// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable CS1591, CS1573, CS0465, CS0649, CS8019, CS1570, CS1584, CS1658
namespace Windows.Win32
{
    using global::System;
    using global::System.Diagnostics;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;
    using win32 = global::Windows.Win32;

    internal static partial class User32
    {
        /// <summary>The ReleaseDC function releases a device context (DC), freeing it for use by other applications. The effect of the ReleaseDC function depends on the type of DC. It frees only common and window DCs. It has no effect on class or private DCs.</summary>
        /// <param name = "hWnd">A handle to the window whose DC is to be released.</param>
        /// <param name = "hDC">A handle to the DC to be released.</param>
        /// <returns>
        /// <para>The return value indicates whether the DC was released. If the DC was released, the return value is 1.</para>
        /// <para>If the DC was not released, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-releasedc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern int ReleaseDC(win32.UI.WindowsAndMessaging.HWND hWnd, win32.Graphics.Gdi.HDC hDC);
        /// <summary>Destroys an icon and frees any memory the icon occupied.</summary>
        /// <param name = "hIcon">
        /// <para>Type: <b>HICON</b></para>
        /// <para>A handle to the icon to be destroyed. The icon must not be in use.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroyicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroyicon">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL DestroyIcon(win32.UI.MenusAndResources.HICON hIcon);
        /// <inheritdoc cref = "LoadString(win32.System.SystemServices.HINSTANCE, uint, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int LoadString(SafeHandle hInstance, uint uID, win32.System.SystemServices.PWSTR lpBuffer, int cchBufferMax)
        {
            bool hInstanceAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hInstanceLocal;
                if (hInstance is object)
                {
                    hInstance.DangerousAddRef(ref hInstanceAddRef);
                    hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                }
                else
                    hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                int __result = User32.LoadString(hInstanceLocal, uID, lpBuffer, cchBufferMax);
                return __result;
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Loads a string resource from the executable file associated with a specified module, copies the string into a buffer, and appends a terminating null character.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to an instance of the module whose executable file contains the string resource. To get the handle to the application itself, call the <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> function with <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uID">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The identifier of the string to be loaded.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The buffer to receive the string (if *cchBufferMax* is non-zero) or a read-only pointer to the string resource itself (if *cchBufferMax* is zero). Must be of sufficient length to hold a pointer (8 bytes).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchBufferMax">
        /// <para>Type: <b>int</b></para>
        /// <para>The size of the buffer, in characters. The string is truncated and null-terminated if it is longer than the number of characters specified. If this parameter is 0, then <i>lpBuffer</i> receives a read-only pointer to the string resource itself.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b> If the function succeeds, the return value is one of the following: - The number of characters copied into the buffer (if *cchBufferMax* is non-zero), not including the terminating null character. - The number of characters in the string resource that *lpBuffer* points to (if *cchBufferMax* is zero). The string resource is not guaranteed to be null-terminated in the module's resource table, and you can use this value to determine where the string resource ends. - Zero if the string resource does not exist. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadstringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "LoadStringW", SetLastError = true)]
        internal static extern int LoadString(win32.System.SystemServices.HINSTANCE hInstance, uint uID, win32.System.SystemServices.PWSTR lpBuffer, int cchBufferMax);
        /// <inheritdoc cref = "wvsprintf(win32.System.SystemServices.PWSTR, win32.System.SystemServices.PCWSTR, sbyte *)"/>
        internal static unsafe int wvsprintf(win32.System.SystemServices.PWSTR param0, string param1, in sbyte arglist)
        {
            fixed (sbyte *arglistLocal = &arglist)
            {
                fixed (char *param1Local = param1)
                {
                    int __result = User32.wvsprintf(param0, param1Local, arglistLocal);
                    return __result;
                }
            }
        }

        /// <summary>Writes formatted data to the specified buffer using a pointer to a list of arguments.</summary>
        /// <param name = "arglist">
        /// <para>Type: <b>va_list</b></para>
        /// <para>Each element of this list specifies an argument for the format-control string. The number, type, and interpretation of the arguments depend on the corresponding format-control specifications in the <i>lpFmt</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-wvsprintfw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the number of characters stored in the buffer, not counting the terminating null character.</para>
        /// <para>If the function fails, the return value is less than the length of the expected output. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-wvsprintfw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "wvsprintfW", SetLastError = true)]
        internal static extern unsafe int wvsprintf(win32.System.SystemServices.PWSTR param0, win32.System.SystemServices.PCWSTR param1, sbyte *arglist);
        /// <inheritdoc cref = "wsprintf(win32.System.SystemServices.PWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe int wsprintf(win32.System.SystemServices.PWSTR param0, string param1)
        {
            fixed (char *param1Local = param1)
            {
                int __result = User32.wsprintf(param0, param1Local);
                return __result;
            }
        }

        /// <summary>Writes formatted data to the specified buffer.</summary>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the number of characters stored in the output buffer, not counting the terminating null character.</para>
        /// <para>If the function fails, the return value is less than the length of the expected output. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-wsprintfw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "wsprintfW", SetLastError = true)]
        internal static extern int wsprintf(win32.System.SystemServices.PWSTR param0, win32.System.SystemServices.PCWSTR param1);
        /// <summary>Determines whether the system considers that a specified application is not responding.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ishungappwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The return value is <b>TRUE</b> if the window stops responding; otherwise, it is <b>FALSE</b>.  Ghost windows always return <b>TRUE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ishungappwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsHungAppWindow(win32.UI.WindowsAndMessaging.HWND hwnd);
        /// <inheritdoc cref = "RegisterWindowMessage(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe uint RegisterWindowMessage(string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                uint __result = User32.RegisterWindowMessage(lpStringLocal);
                return __result;
            }
        }

        /// <summary>Defines a new window message that is guaranteed to be unique throughout the system. The message value can be used when sending or posting messages.</summary>
        /// <param name = "lpString">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The message to be registered.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerwindowmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the message is successfully registered, the return value is a message identifier in the range 0xC000 through 0xFFFF.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerwindowmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "RegisterWindowMessageW", SetLastError = true)]
        internal static extern uint RegisterWindowMessage(win32.System.SystemServices.PCWSTR lpString);
        /// <inheritdoc cref = "GetMessage(win32.UI.WindowsAndMessaging.MSG*, win32.UI.WindowsAndMessaging.HWND, uint, uint)"/>
        internal static unsafe bool GetMessage(out win32.UI.WindowsAndMessaging.MSG lpMsg, win32.UI.WindowsAndMessaging.HWND hWnd, uint wMsgFilterMin, uint wMsgFilterMax)
        {
            fixed (win32.UI.WindowsAndMessaging.MSG*lpMsgLocal = &lpMsg)
            {
                bool __result = User32.GetMessage(lpMsgLocal, hWnd, wMsgFilterMin, wMsgFilterMax);
                return __result;
            }
        }

        /// <summary>Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval.</summary>
        /// <param name = "lpMsg">
        /// <para>Type: <b>LPMSG</b></para>
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that receives message information from the thread's message queue.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</para>
        /// <para>If <i>hWnd</i> is <b>NULL</b>, <b>GetMessage</b> retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b> (see the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure). Therefore if hWnd is <b>NULL</b>, both window messages and thread messages are processed.</para>
        /// <para>If <i>hWnd</i> is -1, <b>GetMessage</b> retrieves only messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b>,  that is, thread messages as posted by  <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a> (when the <i>hWnd</i> parameter is <b>NULL</b>) or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wMsgFilterMin">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The integer value of the lowest message value to be retrieved. Use <b>WM_KEYFIRST</b> (0x0100) to specify the first keyboard message or <b>WM_MOUSEFIRST</b> (0x0200) to specify the first mouse message.</para>
        /// <para>Use <a href = "https://docs.microsoft.com/windows/desktop/inputdev/wm-input">WM_INPUT</a> here and in <i>wMsgFilterMax</i> to specify only the <b>WM_INPUT</b> messages.</para>
        /// <para>If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>GetMessage</b> returns all available messages (that is, no range filtering is performed).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wMsgFilterMax">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The integer value of the highest message value to be retrieved. Use <b>WM_KEYLAST</b> to specify the last keyboard message or <b>WM_MOUSELAST</b> to specify the last mouse message.</para>
        /// <para>Use <a href = "https://docs.microsoft.com/windows/desktop/inputdev/wm-input">WM_INPUT</a> here and in <i>wMsgFilterMin</i> to specify only the <b>WM_INPUT</b> messages.</para>
        /// <para>If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>GetMessage</b> returns all available messages (that is, no range filtering is performed).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function retrieves a message other than <a href = "/windows/desktop/winmsg/wm-quit">WM_QUIT</a>, the return value is nonzero.</para>
        /// <para>If the function retrieves the <a href = "/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message, the return value is zero.</para>
        /// <para>If there is an error, the return value is -1. For example, the function fails if <i>hWnd</i> is an invalid window handle or <i>lpMsg</i> is an invalid pointer. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>Because the return value can be nonzero, zero, or -1, avoid code like this:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetMessageW", SetLastError = true)]
        internal static extern unsafe bool GetMessage(win32.UI.WindowsAndMessaging.MSG*lpMsg, win32.UI.WindowsAndMessaging.HWND hWnd, uint wMsgFilterMin, uint wMsgFilterMax);
        /// <inheritdoc cref = "TranslateMessage(win32.UI.WindowsAndMessaging.MSG*)"/>
        internal static unsafe bool TranslateMessage(in win32.UI.WindowsAndMessaging.MSG lpMsg)
        {
            fixed (win32.UI.WindowsAndMessaging.MSG*lpMsgLocal = &lpMsg)
            {
                bool __result = User32.TranslateMessage(lpMsgLocal);
                return __result;
            }
        }

        /// <summary>Translates virtual-key messages into character messages. The character messages are posted to the calling thread's message queue, to be read the next time the thread calls the GetMessage or PeekMessage function.</summary>
        /// <param name = "lpMsg">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>*</b></para>
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains message information retrieved from the calling thread's message queue by using the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-translatemessage#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the message is translated (that is, a character message is posted to the thread's message queue), the return value is nonzero.</para>
        /// <para>If the message is <a href = "/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a>, <a href = "/windows/desktop/inputdev/wm-keyup">WM_KEYUP</a>, <a href = "/windows/desktop/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a>, or <a href = "/windows/desktop/inputdev/wm-syskeyup">WM_SYSKEYUP</a>, the return value is nonzero, regardless of the translation.</para>
        /// <para>If the message is not translated (that is, a character message is not posted to the thread's message queue), the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-translatemessage">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool TranslateMessage(win32.UI.WindowsAndMessaging.MSG*lpMsg);
        /// <inheritdoc cref = "DispatchMessage(win32.UI.WindowsAndMessaging.MSG*)"/>
        internal static unsafe win32.System.SystemServices.LRESULT DispatchMessage(in win32.UI.WindowsAndMessaging.MSG lpMsg)
        {
            fixed (win32.UI.WindowsAndMessaging.MSG*lpMsgLocal = &lpMsg)
            {
                win32.System.SystemServices.LRESULT __result = User32.DispatchMessage(lpMsgLocal);
                return __result;
            }
        }

        /// <summary>Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function.</summary>
        /// <param name = "lpMsg">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>*</b></para>
        /// <para>A pointer to a structure that contains the message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dispatchmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>The return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dispatchmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DispatchMessageW")]
        internal static extern unsafe win32.System.SystemServices.LRESULT DispatchMessage(win32.UI.WindowsAndMessaging.MSG*lpMsg);
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool SetMessageQueue(int cMessagesMax);
        /// <inheritdoc cref = "PeekMessage(win32.UI.WindowsAndMessaging.MSG*, win32.UI.WindowsAndMessaging.HWND, uint, uint, win32.UI.WindowsAndMessaging.PEEK_MESSAGE_REMOVE_TYPE)"/>
        internal static unsafe bool PeekMessage(out win32.UI.WindowsAndMessaging.MSG lpMsg, win32.UI.WindowsAndMessaging.HWND hWnd, uint wMsgFilterMin, uint wMsgFilterMax, win32.UI.WindowsAndMessaging.PEEK_MESSAGE_REMOVE_TYPE wRemoveMsg)
        {
            fixed (win32.UI.WindowsAndMessaging.MSG*lpMsgLocal = &lpMsg)
            {
                bool __result = User32.PeekMessage(lpMsgLocal, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
                return __result;
            }
        }

        /// <summary>Dispatches incoming sent messages, checks the thread message queue for a posted message, and retrieves the message (if any exist).</summary>
        /// <param name = "lpMsg">
        /// <para>Type: <b>LPMSG</b></para>
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that receives message information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</para>
        /// <para>If <i>hWnd</i> is <b>NULL</b>, <b>PeekMessage</b> retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b> (see the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure). Therefore if hWnd is <b>NULL</b>, both window messages and thread messages are processed.</para>
        /// <para>If <i>hWnd</i> is -1, <b>PeekMessage</b> retrieves only messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b>, that is, thread messages as posted by  <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a> (when the <i>hWnd</i> parameter is <b>NULL</b>) or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wMsgFilterMin">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The value of the first message in the range of messages to be examined. Use <b>WM_KEYFIRST</b> (0x0100) to specify the first keyboard message or <b>WM_MOUSEFIRST</b> (0x0200) to specify the first mouse message.</para>
        /// <para>If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>PeekMessage</b> returns all available messages (that is, no range filtering is performed).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wMsgFilterMax">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The value of the last message in the range of messages to be examined. Use <b>WM_KEYLAST</b> to specify the last keyboard message or <b>WM_MOUSELAST</b> to specify the last mouse message.</para>
        /// <para>If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>PeekMessage</b> returns all available messages (that is, no range filtering is performed).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wRemoveMsg">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If a message is available, the return value is nonzero.</para>
        /// <para>If no messages are available, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-peekmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "PeekMessageW")]
        internal static extern unsafe bool PeekMessage(win32.UI.WindowsAndMessaging.MSG*lpMsg, win32.UI.WindowsAndMessaging.HWND hWnd, uint wMsgFilterMin, uint wMsgFilterMax, win32.UI.WindowsAndMessaging.PEEK_MESSAGE_REMOVE_TYPE wRemoveMsg);
        /// <summary>Retrieves the cursor position for the last message retrieved by the GetMessage function.</summary>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The return value specifies the x- and y-coordinates of the cursor position. The x-coordinate is the low order <b>short</b> and the y-coordinate is the high-order <b>short</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmessagepos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetMessagePos();
        /// <summary>Retrieves the message time for the last message retrieved by the GetMessage function.</summary>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>The return value specifies the message time.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmessagetime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern int GetMessageTime();
        /// <summary>Retrieves the extra message information for the current thread. Extra message information is an application- or driver-defined value associated with the current thread's message queue.</summary>
        /// <returns>
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The return value specifies the extra information. The meaning of the extra information is device specific.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmessageextrainfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.LPARAM GetMessageExtraInfo();
        /// <summary>Sets the extra message information for the current thread.</summary>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The value to be associated with the current thread.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmessageextrainfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The return value is the previous value associated with the current thread.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmessageextrainfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.LPARAM SetMessageExtraInfo(win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.</para>
        /// <para>Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to be sent.</para>
        /// <para>For lists of the system-provided messages, see <a href = "https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SendMessageW", SetLastError = true)]
        internal static extern win32.System.SystemServices.LRESULT SendMessage(win32.UI.WindowsAndMessaging.HWND hWnd, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Sends the specified message to one or more windows.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose window procedure will receive the message.</para>
        /// <para>If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows. The function does not return until each window has timed out. Therefore, the total wait time can be up to the value of <i>uTimeout</i> multiplied by the number of top-level windows.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagetimeoutw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to be sent.</para>
        /// <para>For lists of the system-provided messages, see <a href = "https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagetimeoutw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Any additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagetimeoutw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Any additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagetimeoutw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fuFlags">Type: <b>UINT</b></param>
        /// <param name = "uTimeout">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The duration of the time-out period, in milliseconds. If the message is a broadcast message, each window can use the full time-out period. For example, if you specify a five second time-out period and there are three top-level windows that fail to process the message, you could have up to a 15 second delay.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagetimeoutw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpdwResult">
        /// <para>Type: <b>PDWORD_PTR</b></para>
        /// <para>The result of the message processing. The value of this parameter depends on the message that is specified.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagetimeoutw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>If the function succeeds, the return value is nonzero. <b>SendMessageTimeout</b> does not provide information about individual windows timing out if <b>HWND_BROADCAST</b> is used.</para>
        /// <para>If the function fails or times out, the return value is 0. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If <b>GetLastError</b> returns <b>ERROR_TIMEOUT</b>, then the function timed out.</para>
        /// <para><b>Windows 2000:  </b>If <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 0, then the function timed out.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagetimeoutw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SendMessageTimeoutW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.LRESULT SendMessageTimeout(win32.UI.WindowsAndMessaging.HWND hWnd, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam, win32.UI.WindowsAndMessaging.SEND_MESSAGE_TIMEOUT_FLAGS fuFlags, uint uTimeout, [Optional] nuint*lpdwResult);
        /// <summary>Sends the specified message to a window or windows.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendnotifymessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to be sent.</para>
        /// <para>For lists of the system-provided messages, see <a href = "https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendnotifymessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendnotifymessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendnotifymessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendnotifymessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SendNotifyMessageW", SetLastError = true)]
        internal static extern bool SendNotifyMessage(win32.UI.WindowsAndMessaging.HWND hWnd, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Sends the specified message to a window or windows.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagecallbackw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to be sent.</para>
        /// <para>For lists of the system-provided messages, see <a href = "https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagecallbackw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagecallbackw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagecallbackw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpResultCallBack">
        /// <para>Type: <b>SENDASYNCPROC</b> A pointer to a callback function that the system calls after the window procedure processes the message. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-sendasyncproc">SendAsyncProc</a>.</para>
        /// <para>If <i>hWnd</i> is <b>HWND_BROADCAST</b> ((HWND)0xffff), the system calls the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-sendasyncproc">SendAsyncProc</a> callback function once for each top-level window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagecallbackw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwData">
        /// <para>Type: <b>ULONG_PTR</b></para>
        /// <para>An application-defined value to be sent to the callback function pointed to by the <i>lpCallBack</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagecallbackw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagecallbackw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SendMessageCallbackW", SetLastError = true)]
        internal static extern unsafe bool SendMessageCallback(win32.UI.WindowsAndMessaging.HWND hWnd, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, nuint, win32.System.SystemServices.LRESULT, void>lpResultCallBack, nuint dwData);
        /// <summary>Closes an open handle to a desktop object.</summary>
        /// <param name = "hDesktop">
        /// <para>A handle to the desktop to be closed. This can be a handle returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createdesktopa">CreateDesktop</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-opendesktopa">OpenDesktop</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-openinputdesktop">OpenInputDesktop</a> functions. Do not specify the handle returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getthreaddesktop">GetThreadDesktop</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-closedesktop#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-closedesktop">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL CloseDesktop(win32.System.StationsAndDesktops.HDESK hDesktop);
        /// <summary>Sends a message to the specified recipients.</summary>
        /// <param name = "flags">Type: <b>DWORD</b></param>
        /// <param name = "lpInfo">
        /// <para>Type: <b>LPDWORD</b></para>
        /// <para>A pointer to a variable that contains and receives information about the recipients of the message.</para>
        /// <para>When the function returns, this variable receives a combination of these values identifying which recipients actually received the message.</para>
        /// <para>If this parameter is <b>NULL</b>, the function broadcasts to all components.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-broadcastsystemmessageexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to be sent.</para>
        /// <para>For lists of the system-provided messages, see <a href = "https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-broadcastsystemmessageexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-broadcastsystemmessageexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-broadcastsystemmessageexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pbsmInfo">
        /// <para>Type: <b>PBSMINFO</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-bsminfo">BSMINFO</a> structure that contains additional information if the request is denied and <i>dwFlags</i> is set to <b>BSF_QUERY</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-broadcastsystemmessageexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>long</b></para>
        /// <para>If the function succeeds, the return value is a positive value.</para>
        /// <para>If the function is unable to broadcast the message, the return value is –1.</para>
        /// <para>If the <i>dwFlags</i> parameter is <b>BSF_QUERY</b> and at least one recipient returned <b>BROADCAST_QUERY_DENY</b> to the corresponding message, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-broadcastsystemmessageexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "BroadcastSystemMessageExW", SetLastError = true)]
        internal static extern unsafe int BroadcastSystemMessageEx(win32.UI.WindowsAndMessaging.BROADCAST_SYSTEM_MESSAGE_FLAGS flags, [Optional] win32.UI.WindowsAndMessaging.BROADCAST_SYSTEM_MESSAGE_INFO*lpInfo, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam, [Optional] win32.UI.WindowsAndMessaging.BSMINFO*pbsmInfo);
        /// <summary>Sends a message to the specified recipients.</summary>
        /// <param name = "flags">Type: <b>DWORD</b></param>
        /// <param name = "lpInfo">
        /// <para>Type: <b>LPDWORD</b> A pointer to a variable that contains and receives information about the recipients of the message.</para>
        /// <para>When the function returns, this variable receives a combination of these values identifying which recipients actually received the message. If this parameter is <b>NULL</b>, the function broadcasts to all components.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-broadcastsystemmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to be sent.</para>
        /// <para>For lists of the system-provided messages, see <a href = "https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-broadcastsystemmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-broadcastsystemmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-broadcastsystemmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>long</b></para>
        /// <para>If the function succeeds, the return value is a positive value.</para>
        /// <para>If the function is unable to broadcast the message, the return value is –1.</para>
        /// <para>If the <i>dwFlags</i> parameter is <b>BSF_QUERY</b> and at least one recipient returned <b>BROADCAST_QUERY_DENY</b> to the corresponding message, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-broadcastsystemmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "BroadcastSystemMessageW", SetLastError = true)]
        internal static extern unsafe int BroadcastSystemMessage(win32.UI.WindowsAndMessaging.BROADCAST_SYSTEM_MESSAGE_FLAGS flags, [Optional] win32.UI.WindowsAndMessaging.BROADCAST_SYSTEM_MESSAGE_INFO*lpInfo, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose window procedure is to receive the message. The following values have special meanings.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to be posted.</para>
        /// <para>For lists of the system-provided messages, see <a href = "https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <b>GetLastError</b> returns <b>ERROR_NOT_ENOUGH_QUOTA</b> when the limit is hit.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "PostMessageW", SetLastError = true)]
        internal static extern bool PostMessage(win32.UI.WindowsAndMessaging.HWND hWnd, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message.</summary>
        /// <param name = "idThread">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The identifier of the thread to which the message is to be posted.</para>
        /// <para>The function fails if the specified thread does not have a message queue. The system creates a thread's message queue when the thread makes its first call to one of the User or GDI functions. For more information, see the Remarks section.</para>
        /// <para>Message posting is subject to UIPI. The thread of a process can post messages only to posted-message queues of threads in processes of lesser or equal integrity level.</para>
        /// <para>This thread must have the <b>SE_TCB_NAME</b> privilege to post a message to a thread that belongs to a process with the same locally unique identifier (LUID) but is in a different desktop. Otherwise, the function fails and returns <b>ERROR_INVALID_THREAD_ID</b>.</para>
        /// <para>This thread must either belong to the same desktop as the calling thread or to a process with the same LUID. Otherwise, the function fails and returns <b>ERROR_INVALID_THREAD_ID</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postthreadmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The type of message to be posted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postthreadmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postthreadmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postthreadmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <b>GetLastError</b> returns <b>ERROR_INVALID_THREAD_ID</b> if <i>idThread</i> is not a valid thread identifier, or if the thread specified by <i>idThread</i> does not have a message queue. <b>GetLastError</b> returns <b>ERROR_NOT_ENOUGH_QUOTA</b> when the message limit is hit.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postthreadmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "PostThreadMessageW", SetLastError = true)]
        internal static extern bool PostThreadMessage(uint idThread, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Replies to a message sent from another thread by the SendMessage function.</summary>
        /// <param name = "lResult">
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>The result of the message processing. The possible values are based on the message sent.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-replymessage#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the calling thread was processing a message sent from another thread or process, the return value is nonzero.</para>
        /// <para>If the calling thread was not processing a message sent from another thread or process, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-replymessage">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool ReplyMessage(win32.System.SystemServices.LRESULT lResult);
        /// <summary>Yields control to other threads when a thread has no other messages in its message queue. The WaitMessage function suspends the thread and does not return until a new message is placed in the thread's message queue.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-waitmessage">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool WaitMessage();
        /// <summary>Calls the default window procedure to provide default processing for any window messages that an application does not process.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window procedure that received the message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>The return value is the result of the message processing and depends on the message.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defwindowprocw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DefWindowProcW")]
        internal static extern win32.System.SystemServices.LRESULT DefWindowProc(win32.UI.WindowsAndMessaging.HWND hWnd, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Indicates to the system that a thread has made a request to terminate (quit). It is typically used in response to a WM_DESTROY message.</summary>
        /// <param name = "nExitCode">
        /// <para>Type: <b>int</b></para>
        /// <para>The application exit code. This value is used as the <i>wParam</i> parameter of the <a href = "https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postquitmessage#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>The <b>PostQuitMessage</b> function posts a <a href = "https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message to the thread's message queue and returns immediately; the function simply indicates to the system that the thread is requesting to quit at some time in the future.</para>
        /// <para>When the thread retrieves the <a href = "https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message from its message queue, it should exit its message loop and return control to the system. The exit value returned to the system must be the <i>wParam</i> parameter of the <b>WM_QUIT</b> message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-postquitmessage#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern void PostQuitMessage(int nExitCode);
        /// <summary>Passes message information to the specified window procedure.</summary>
        /// <param name = "lpPrevWndFunc">
        /// <para>Type: <b>WNDPROC</b></para>
        /// <para>The previous window procedure. If this value is obtained by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowlonga">GetWindowLong</a> function with the <i>nIndex</i> parameter set to <b>GWL_WNDPROC</b> or <b>DWL_DLGPROC</b>, it is actually either the address of a window or dialog box procedure, or a special internal value meaningful only to <b>CallWindowProc</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window procedure to receive the message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information. The contents of this parameter depend on the value of the <i>Msg</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information. The contents of this parameter depend on the value of the <i>Msg</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>The return value specifies the result of the message processing and depends on the message sent.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callwindowprocw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CallWindowProcW")]
        internal static extern unsafe win32.System.SystemServices.LRESULT CallWindowProc(delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.LRESULT>lpPrevWndFunc, win32.UI.WindowsAndMessaging.HWND hWnd, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or a different process) by a call to the SendMessage function.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the window procedure is processing a message sent to it from another thread using the <a href = "/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> function, the return value is nonzero.</para>
        /// <para>If the window procedure is not processing a message sent to it from another thread using the <a href = "/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> function, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insendmessage">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool InSendMessage();
        /// <summary>Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or a different process).</summary>
        /// <param name = "lpReserved">
        /// <para>Type: <b>LPVOID</b></para>
        /// <para>Reserved; must be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insendmessageex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>If the message was not sent, the return value is <b>ISMEX_NOSEND</b> (0x00000000). Otherwise, the return value is one or more of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insendmessageex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe uint InSendMessageEx(void *lpReserved);
        /// <summary>Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.</summary>
        /// <param name = "hCursor">
        /// <para>Type: <b>HCURSOR</b></para>
        /// <para>A handle to the cursor to be destroyed. The cursor must not be in use.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroycursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroycursor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL DestroyCursor(win32.UI.MenusAndResources.HCURSOR hCursor);
        /// <inheritdoc cref = "RegisterClass(win32.UI.WindowsAndMessaging.WNDCLASSW*)"/>
        internal static unsafe ushort RegisterClass(in win32.UI.WindowsAndMessaging.WNDCLASSW lpWndClass)
        {
            fixed (win32.UI.WindowsAndMessaging.WNDCLASSW*lpWndClassLocal = &lpWndClass)
            {
                ushort __result = User32.RegisterClass(lpWndClassLocal);
                return __result;
            }
        }

        /// <summary>Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function.</summary>
        /// <param name = "lpWndClass">
        /// <para>Type: <b>const WNDCLASS*</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure. You must fill the structure with the appropriate class attributes before passing it to the function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerclassw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>ATOM</b></para>
        /// <para>If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the <a href = "/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a>, <a href = "/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a>, <a href = "/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a>, <a href = "/windows/desktop/api/winuser/nf-winuser-getclassinfoexa">GetClassInfoEx</a>, <a href = "/windows/desktop/api/winuser/nf-winuser-findwindowa">FindWindow</a>, <a href = "/windows/desktop/api/winuser/nf-winuser-findwindowexa">FindWindowEx</a>, and <a href = "/windows/desktop/api/winuser/nf-winuser-unregisterclassa">UnregisterClass</a> functions and the <b>IActiveIMMap::FilterClientWindows</b> method.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerclassw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "RegisterClassW", SetLastError = true)]
        internal static extern unsafe ushort RegisterClass(win32.UI.WindowsAndMessaging.WNDCLASSW*lpWndClass);
        /// <inheritdoc cref = "UnregisterClass(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.HINSTANCE)"/>
        internal static unsafe bool UnregisterClass(string lpClassName, SafeHandle hInstance)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (char *lpClassNameLocal = lpClassName)
                {
                    win32.System.SystemServices.HINSTANCE hInstanceLocal;
                    if (hInstance is object)
                    {
                        hInstance.DangerousAddRef(ref hInstanceAddRef);
                        hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                    }
                    else
                        hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                    bool __result = User32.UnregisterClass(lpClassNameLocal, hInstanceLocal);
                    return __result;
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Unregisters a window class, freeing the memory required for the class.</summary>
        /// <param name = "lpClassName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>A null-terminated string or a class atom. If <i>lpClassName</i> is a string, it specifies the window class name. This class name must have been registered by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. System classes, such as dialog box controls, cannot be unregistered. If this parameter is an atom, it must be a class atom created by a previous call to the <b>RegisterClass</b> or <b>RegisterClassEx</b> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterclassw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the instance of the module that created the class.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterclassw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the class could not be found or if a window still exists that was created with the class, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterclassw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "UnregisterClassW", SetLastError = true)]
        internal static extern bool UnregisterClass(win32.System.SystemServices.PCWSTR lpClassName, win32.System.SystemServices.HINSTANCE hInstance);
        /// <inheritdoc cref = "GetClassInfo(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.UI.WindowsAndMessaging.WNDCLASSW*)"/>
        internal static unsafe bool GetClassInfo(SafeHandle hInstance, string lpClassName, out win32.UI.WindowsAndMessaging.WNDCLASSW lpWndClass)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.WNDCLASSW*lpWndClassLocal = &lpWndClass)
                {
                    fixed (char *lpClassNameLocal = lpClassName)
                    {
                        win32.System.SystemServices.HINSTANCE hInstanceLocal;
                        if (hInstance is object)
                        {
                            hInstance.DangerousAddRef(ref hInstanceAddRef);
                            hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                        }
                        else
                            hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                        bool __result = User32.GetClassInfo(hInstanceLocal, lpClassNameLocal, lpWndClassLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about a window class.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the instance of the application that created the class. To retrieve information about classes defined by the system (such as buttons or list boxes), set this parameter to <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpClassName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The class name. The name must be that of a preregistered class or a class registered by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function.</para>
        /// <para>Alternatively, this parameter can be an atom. If so, it must be a class atom created by a previous call to <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpWndClass">
        /// <para>Type: <b>LPWNDCLASS</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure that receives the information about the class.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function finds a matching class and successfully copies the data, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetClassInfoW", SetLastError = true)]
        internal static extern unsafe bool GetClassInfo(win32.System.SystemServices.HINSTANCE hInstance, win32.System.SystemServices.PCWSTR lpClassName, win32.UI.WindowsAndMessaging.WNDCLASSW*lpWndClass);
        /// <inheritdoc cref = "RegisterClassEx(win32.UI.WindowsAndMessaging.WNDCLASSEXW*)"/>
        internal static unsafe ushort RegisterClassEx(in win32.UI.WindowsAndMessaging.WNDCLASSEXW param0)
        {
            fixed (win32.UI.WindowsAndMessaging.WNDCLASSEXW*param0Local = &param0)
            {
                ushort __result = User32.RegisterClassEx(param0Local);
                return __result;
            }
        }

        /// <summary>Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function.</summary>
        /// <returns>
        /// <para>Type: <b>ATOM</b></para>
        /// <para>If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the <a href = "/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a>, <a href = "/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a>, <a href = "/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a>, <a href = "/windows/desktop/api/winuser/nf-winuser-getclassinfoexa">GetClassInfoEx</a>, <a href = "/windows/desktop/api/winuser/nf-winuser-findwindowa">FindWindow</a>, <a href = "/windows/desktop/api/winuser/nf-winuser-findwindowexa">FindWindowEx</a>, and <a href = "/windows/desktop/api/winuser/nf-winuser-unregisterclassa">UnregisterClass</a> functions and the <b>IActiveIMMap::FilterClientWindows</b> method.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerclassexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "RegisterClassExW", SetLastError = true)]
        internal static extern unsafe ushort RegisterClassEx(win32.UI.WindowsAndMessaging.WNDCLASSEXW*param0);
        /// <inheritdoc cref = "GetClassInfoEx(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.UI.WindowsAndMessaging.WNDCLASSEXW*)"/>
        internal static unsafe bool GetClassInfoEx(SafeHandle hInstance, string lpszClass, out win32.UI.WindowsAndMessaging.WNDCLASSEXW lpwcx)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.WNDCLASSEXW*lpwcxLocal = &lpwcx)
                {
                    fixed (char *lpszClassLocal = lpszClass)
                    {
                        win32.System.SystemServices.HINSTANCE hInstanceLocal;
                        if (hInstance is object)
                        {
                            hInstance.DangerousAddRef(ref hInstanceAddRef);
                            hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                        }
                        else
                            hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                        bool __result = User32.GetClassInfoEx(hInstanceLocal, lpszClassLocal, lpwcxLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about a window class, including a handle to the small icon associated with the window class. The GetClassInfo function does not retrieve a handle to the small icon.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the instance of the application that created the class. To retrieve information about classes defined by the system (such as buttons or list boxes), set this parameter to <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassinfoexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszClass">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The class name. The name must be that of a preregistered class or a class registered by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. Alternatively, this parameter can be a class atom created by a previous call to <b>RegisterClass</b> or <b>RegisterClassEx</b>. The atom must be in the low-order word of <i>lpszClass</i>; the high-order word must be zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassinfoexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpwcx">
        /// <para>Type: <b>LPWNDCLASSEX</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure that receives the information about the class.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassinfoexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function finds a matching class and successfully copies the data, the return value is nonzero.</para>
        /// <para>If the function does not find a matching class and successfully copy the data, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassinfoexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetClassInfoExW", SetLastError = true)]
        internal static extern unsafe bool GetClassInfoEx(win32.System.SystemServices.HINSTANCE hInstance, win32.System.SystemServices.PCWSTR lpszClass, win32.UI.WindowsAndMessaging.WNDCLASSEXW*lpwcx);
        /// <summary>Destroys the specified menu and frees any memory that the menu occupies.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu to be destroyed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroymenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroymenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL DestroyMenu(win32.UI.MenusAndResources.HMENU hMenu);
        /// <inheritdoc cref = "CreateWindowEx(win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.UI.WindowsAndMessaging.WINDOW_STYLE, int, int, int, int, win32.UI.WindowsAndMessaging.HWND, win32.UI.MenusAndResources.HMENU, win32.System.SystemServices.HINSTANCE, void *)"/>
        internal static unsafe win32.UI.WindowsAndMessaging.HWND CreateWindowEx(win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE dwExStyle, string lpClassName, string lpWindowName, win32.UI.WindowsAndMessaging.WINDOW_STYLE dwStyle, int X, int Y, int nWidth, int nHeight, win32.UI.WindowsAndMessaging.HWND hWndParent, SafeHandle hMenu, SafeHandle hInstance, void *lpParam)
        {
            bool hMenuAddRef = false;
            bool hInstanceAddRef = false;
            try
            {
                fixed (char *lpWindowNameLocal = lpWindowName)
                {
                    fixed (char *lpClassNameLocal = lpClassName)
                    {
                        win32.UI.MenusAndResources.HMENU hMenuLocal;
                        if (hMenu is object)
                        {
                            hMenu.DangerousAddRef(ref hMenuAddRef);
                            hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                        }
                        else
                            hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                        win32.System.SystemServices.HINSTANCE hInstanceLocal;
                        if (hInstance is object)
                        {
                            hInstance.DangerousAddRef(ref hInstanceAddRef);
                            hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                        }
                        else
                            hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                        win32.UI.WindowsAndMessaging.HWND __result = User32.CreateWindowEx(dwExStyle, lpClassNameLocal, lpWindowNameLocal, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenuLocal, hInstanceLocal, lpParam);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the CreateWindow function.</summary>
        /// <param name = "dwExStyle">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The extended window style of the window being created. For a list of possible values, see  <a href = "https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">Extended Window Styles</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpClassName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>A <b>null</b>-terminated string or a class atom created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero. If <i>lpClassName</i> is a string, it specifies the window class name. The class name can be any name registered with <b>RegisterClass</b> or <b>RegisterClassEx</b>, provided that the module that registers the class is also the module that creates the window. The class name can also be any of the predefined <a href = "https://docs.microsoft.com/windows/desktop/winmsg/about-window-classes">system class</a> names.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpWindowName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The window name. If the window style specifies a title bar, the window title pointed to by <i>lpWindowName</i> is displayed in the title bar. When using <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create controls, such as buttons, check boxes, and static controls, use <i>lpWindowName</i> to specify the text of the control. When creating a static control with the <b>SS_ICON</b> style, use <i>lpWindowName</i> to specify the icon name or identifier. To specify an identifier, use the syntax "#<i>num</i>".</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwStyle">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The style of the window being created. This parameter can be a combination of the <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style values</a>, plus the control styles indicated in the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "X">
        /// <para>Type: <b>int</b></para>
        /// <para>The initial horizontal position of the window. For an overlapped or pop-up window, the <i>x</i> parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>x</i> is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. If <i>x</i> is set to <b>CW_USEDEFAULT</b>, the system selects the default position for the window's upper-left corner and ignores the <i>y</i> parameter. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if it is specified for a pop-up or child window, the <i>x</i> and <i>y</i> parameters are set to zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Y">
        /// <para>Type: <b>int</b></para>
        /// <para>The initial vertical position of the window. For an overlapped or pop-up window, the <i>y</i> parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>y</i> is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box <i>y</i> is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's client area.</para>
        /// <para>If an overlapped window is created with the <b>WS_VISIBLE</b> style bit set and the <i>x</i> parameter is set to <b>CW_USEDEFAULT</b>, then the <i>y</i> parameter determines how the window is shown. If the <i>y</i> parameter is <b>CW_USEDEFAULT</b>, then the window manager calls <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with the <b>SW_SHOW</b> flag after the window has been created. If the <i>y</i> parameter is some other value, then the window manager calls <b>ShowWindow</b> with that value as the <i>nCmdShow</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nWidth">
        /// <para>Type: <b>int</b></para>
        /// <para>The width, in device units, of the window. For overlapped windows, <i>nWidth</i> is the window's width, in screen coordinates, or <b>CW_USEDEFAULT</b>. If <i>nWidth</i> is <b>CW_USEDEFAULT</b>, the system selects a default width and height for the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial y-coordinate to the top of the icon area. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if <b>CW_USEDEFAULT</b> is specified for a pop-up or child window, the <i>nWidth</i> and <i>nHeight</i> parameter are set to zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nHeight">
        /// <para>Type: <b>int</b></para>
        /// <para>The height, in device units, of the window. For overlapped windows, <i>nHeight</i> is the window's height, in screen coordinates. If the <i>nWidth</i> parameter is set to <b>CW_USEDEFAULT</b>, the system ignores <i>nHeight</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid window handle. This parameter is optional for pop-up windows.</para>
        /// <para>To create a <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>, supply <b>HWND_MESSAGE</b> or a handle to an existing message-only window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, <i>hMenu</i> identifies the menu to be used with the window; it can be <b>NULL</b> if the class menu is to be used. For a child window, <i>hMenu</i> specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The application determines the child-window identifier; it must be unique for all child windows with the same parent window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the instance of the module to be associated with the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpParam">
        /// <para>Type: <b>LPVOID</b></para>
        /// <para>Pointer to a value to be passed to the window through the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-createstructa">CREATESTRUCT</a> structure (<b>lpCreateParams</b> member) pointed to by the <i>lParam</i> param of the <b>WM_CREATE</b> message.  This message is sent to the created window by this function before it returns.</para>
        /// <para>If an application calls <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create a MDI client window, <i>lpParam</i> should point to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-clientcreatestruct">CLIENTCREATESTRUCT</a> structure. If an MDI client window calls <b>CreateWindow</b> to create an MDI child window, <i>lpParam</i> should point to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mdicreatestructa">MDICREATESTRUCT</a> structure. <i>lpParam</i> may be <b>NULL</b> if no additional data is needed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is a handle to the new window.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>This function typically fails for one of the following reasons:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CreateWindowExW", SetLastError = true)]
        internal static extern unsafe win32.UI.WindowsAndMessaging.HWND CreateWindowEx(win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE dwExStyle, win32.System.SystemServices.PCWSTR lpClassName, win32.System.SystemServices.PCWSTR lpWindowName, win32.UI.WindowsAndMessaging.WINDOW_STYLE dwStyle, int X, int Y, int nWidth, int nHeight, win32.UI.WindowsAndMessaging.HWND hWndParent, win32.UI.MenusAndResources.HMENU hMenu, win32.System.SystemServices.HINSTANCE hInstance, [Optional] void *lpParam);
        /// <summary>Determines whether the specified window handle identifies an existing window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iswindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the window handle identifies an existing window, the return value is nonzero.</para>
        /// <para>If the window handle does not identify an existing window, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iswindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsWindow(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <inheritdoc cref = "IsMenu(win32.UI.MenusAndResources.HMENU)"/>
        internal static unsafe bool IsMenu(SafeHandle hMenu)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                bool __result = User32.IsMenu(hMenuLocal);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Determines whether a handle is a menu handle.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ismenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the handle is a menu handle, the return value is nonzero.</para>
        /// <para>If the handle is not a menu handle, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ismenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsMenu(win32.UI.MenusAndResources.HMENU hMenu);
        /// <summary>Determines whether a window is a child window or descendant window of a specified parent window.</summary>
        /// <param name = "hWndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the parent window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ischild#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ischild#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the window is a child or descendant window of the specified parent window, the return value is nonzero.</para>
        /// <para>If the window is not a child or descendant window of the specified parent window, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ischild">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsChild(win32.UI.WindowsAndMessaging.HWND hWndParent, win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Destroys the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be destroyed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroywindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroywindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DestroyWindow(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Sets the specified window's show state.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nCmdShow">Type: <b>int</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the window was previously visible, the return value is nonzero.</para>
        /// <para>If the window was previously hidden, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool ShowWindow(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.SHOW_WINDOW_CMD nCmdShow);
        /// <summary>Enables you to produce special effects when showing or hiding windows. There are four types of animation:\_roll, slide, collapse or expand, and alpha-blended fade.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to animate. The calling thread must own this window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-animatewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwTime">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The time it takes to play the animation, in milliseconds. Typically, an animation takes 200 milliseconds to play.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-animatewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Type: <b>DWORD</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. The function will fail in the following situations:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-animatewindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool AnimateWindow(win32.UI.WindowsAndMessaging.HWND hWnd, uint dwTime, win32.UI.WindowsAndMessaging.ANIMATE_WINDOW_FLAGS dwFlags);
        /// <inheritdoc cref = "UpdateLayeredWindow(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.POINT*, win32.UI.DisplayDevices.SIZE*, win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.POINT*, uint, win32.Graphics.Gdi.BLENDFUNCTION*, win32.UI.WindowsAndMessaging.UPDATE_LAYERED_WINDOW_FLAGS)"/>
        internal static unsafe bool UpdateLayeredWindow(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hdcDst, win32.UI.DisplayDevices.POINT? pptDst, win32.UI.DisplayDevices.SIZE? psize, SafeHandle hdcSrc, win32.UI.DisplayDevices.POINT? pptSrc, uint crKey, win32.Graphics.Gdi.BLENDFUNCTION? pblend, win32.UI.WindowsAndMessaging.UPDATE_LAYERED_WINDOW_FLAGS dwFlags)
        {
            bool hdcDstAddRef = false;
            bool hdcSrcAddRef = false;
            try
            {
                win32.Graphics.Gdi.HDC hdcDstLocal;
                if (hdcDst is object)
                {
                    hdcDst.DangerousAddRef(ref hdcDstAddRef);
                    hdcDstLocal = (win32.Graphics.Gdi.HDC)hdcDst.DangerousGetHandle();
                }
                else
                    hdcDstLocal = default(win32.Graphics.Gdi.HDC);
                win32.UI.DisplayDevices.POINT pptDstLocal = pptDst.HasValue ? pptDst.Value : default(win32.UI.DisplayDevices.POINT);
                win32.UI.DisplayDevices.SIZE psizeLocal = psize.HasValue ? psize.Value : default(win32.UI.DisplayDevices.SIZE);
                win32.Graphics.Gdi.HDC hdcSrcLocal;
                if (hdcSrc is object)
                {
                    hdcSrc.DangerousAddRef(ref hdcSrcAddRef);
                    hdcSrcLocal = (win32.Graphics.Gdi.HDC)hdcSrc.DangerousGetHandle();
                }
                else
                    hdcSrcLocal = default(win32.Graphics.Gdi.HDC);
                win32.UI.DisplayDevices.POINT pptSrcLocal = pptSrc.HasValue ? pptSrc.Value : default(win32.UI.DisplayDevices.POINT);
                win32.Graphics.Gdi.BLENDFUNCTION pblendLocal = pblend.HasValue ? pblend.Value : default(win32.Graphics.Gdi.BLENDFUNCTION);
                bool __result = User32.UpdateLayeredWindow(hWnd, hdcDstLocal, pptDst.HasValue ? &pptDstLocal : null, psize.HasValue ? &psizeLocal : null, hdcSrcLocal, pptSrc.HasValue ? &pptSrcLocal : null, crKey, pblend.HasValue ? &pblendLocal : null, dwFlags);
                return __result;
            }
            finally
            {
                if (hdcDstAddRef)
                    hdcDst.DangerousRelease();
                if (hdcSrcAddRef)
                    hdcSrc.DangerousRelease();
            }
        }

        /// <summary>Updates the position, size, shape, content, and translucency of a layered window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to a layered window. A layered window is created by specifying <b>WS_EX_LAYERED</b> when creating the window with the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function.</para>
        /// <para><b>Windows 8:  </b>The <b>WS_EX_LAYERED</b> style is supported for top-level windows and child windows. Previous Windows versions support <b>WS_EX_LAYERED</b> only for top-level windows.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-updatelayeredwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hdcDst">
        /// <para>Type: <b>HDC</b></para>
        /// <para>A handle to a DC for the screen. This handle is obtained by specifying <b>NULL</b> when calling the <a href = "https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-getdc">GetDC</a> function. It is used for palette color matching when the window contents are updated. If <i>hdcDst</i> is <b>NULL</b>, the default palette will be used.</para>
        /// <para>If <i>hdcSrc</i> is <b>NULL</b>, <i>hdcDst</i> must be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-updatelayeredwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pptDst">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a>*</b></para>
        /// <para>A pointer to a structure that specifies the new screen position of the layered window. If the current position is not changing, <i>pptDst</i> can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-updatelayeredwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "psize">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/previous-versions/dd145106(v=vs.85)">SIZE</a>*</b></para>
        /// <para>A pointer to a structure that specifies the new size of the layered window. If the size of the window is not changing, <i>psize</i> can be <b>NULL</b>. If <i>hdcSrc</i> is <b>NULL</b>, <i>psize</i> must be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-updatelayeredwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hdcSrc">
        /// <para>Type: <b>HDC</b></para>
        /// <para>A handle to a DC for the surface that defines the layered window. This handle can be obtained by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createcompatibledc">CreateCompatibleDC</a> function. If the shape and visual context of the window are not changing, <i>hdcSrc</i> can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-updatelayeredwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pptSrc">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a>*</b></para>
        /// <para>A pointer to a structure that specifies the location of the layer in the device context. If <i>hdcSrc</i> is <b>NULL</b>, <i>pptSrc</i> should be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-updatelayeredwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "crKey">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a></b></para>
        /// <para>A structure that specifies the color key to be used when composing the layered window. To generate a <a href = "https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a>, use the <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-rgb">RGB</a> macro.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-updatelayeredwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pblend">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-blendfunction">BLENDFUNCTION</a>*</b></para>
        /// <para>A pointer to a structure that specifies the transparency value to be used when composing the layered window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-updatelayeredwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Type: <b>DWORD</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-updatelayeredwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool UpdateLayeredWindow(win32.UI.WindowsAndMessaging.HWND hWnd, win32.Graphics.Gdi.HDC hdcDst, [Optional] win32.UI.DisplayDevices.POINT*pptDst, [Optional] win32.UI.DisplayDevices.SIZE*psize, win32.Graphics.Gdi.HDC hdcSrc, [Optional] win32.UI.DisplayDevices.POINT*pptSrc, uint crKey, [Optional] win32.Graphics.Gdi.BLENDFUNCTION*pblend, win32.UI.WindowsAndMessaging.UPDATE_LAYERED_WINDOW_FLAGS dwFlags);
        /// <inheritdoc cref = "UpdateLayeredWindowIndirect(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.UPDATELAYEREDWINDOWINFO*)"/>
        internal static unsafe bool UpdateLayeredWindowIndirect(win32.UI.WindowsAndMessaging.HWND hWnd, in win32.UI.WindowsAndMessaging.UPDATELAYEREDWINDOWINFO pULWInfo)
        {
            fixed (win32.UI.WindowsAndMessaging.UPDATELAYEREDWINDOWINFO*pULWInfoLocal = &pULWInfo)
            {
                bool __result = User32.UpdateLayeredWindowIndirect(hWnd, pULWInfoLocal);
                return __result;
            }
        }

        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool UpdateLayeredWindowIndirect(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.UPDATELAYEREDWINDOWINFO*pULWInfo);
        /// <summary>Retrieves the opacity and transparency color key of a layered window.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the layered window. A layered window is created by specifying <b>WS_EX_LAYERED</b> when creating the window with the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function or by setting <b>WS_EX_LAYERED</b> using <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> after the window has been created.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getlayeredwindowattributes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcrKey">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a>*</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a> value that receives the transparency color key to be used when composing the layered window. All pixels painted by the window in this color will be transparent. This can be <b>NULL</b> if the argument is not needed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getlayeredwindowattributes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pbAlpha">
        /// <para>Type: <b>BYTE*</b></para>
        /// <para>The Alpha value used to describe the opacity of the layered window. Similar to the <b>SourceConstantAlpha</b> member of the <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-blendfunction">BLENDFUNCTION</a> structure. When the variable referred to by <i>pbAlpha</i> is 0, the window is completely transparent. When the variable referred to by <i>pbAlpha</i> is 255, the window is opaque. This can be <b>NULL</b> if the argument is not needed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getlayeredwindowattributes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pdwFlags">Type: <b>DWORD*</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getlayeredwindowattributes">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetLayeredWindowAttributes(win32.UI.WindowsAndMessaging.HWND hwnd, [Optional] uint *pcrKey, [Optional] byte *pbAlpha, [Optional] win32.UI.WindowsAndMessaging.LAYERED_WINDOW_ATTRIBUTES_FLAGS*pdwFlags);
        /// <summary>Sets the opacity and transparency color key of a layered window.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the layered window. A layered window is created by specifying <b>WS_EX_LAYERED</b> when creating the window with the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function or by setting <b>WS_EX_LAYERED</b> via <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> after the window has been created.</para>
        /// <para><b>Windows 8:  </b>The <b>WS_EX_LAYERED</b> style is supported for top-level windows and child windows. Previous Windows versions support <b>WS_EX_LAYERED</b> only for top-level windows.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setlayeredwindowattributes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "crKey">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a></b></para>
        /// <para>A <a href = "https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a> structure that specifies the transparency color key to be used when composing the layered window. All pixels painted by the window in this color will be transparent. To generate a <b>COLORREF</b>, use the <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-rgb">RGB</a> macro.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setlayeredwindowattributes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bAlpha">
        /// <para>Type: <b>BYTE</b></para>
        /// <para>Alpha value used to describe the opacity of the layered window. Similar to the <b>SourceConstantAlpha</b> member of the <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-blendfunction">BLENDFUNCTION</a> structure. When <i>bAlpha</i> is 0, the window is completely transparent. When <i>bAlpha</i> is 255, the window is opaque.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setlayeredwindowattributes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Type: <b>DWORD</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setlayeredwindowattributes">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetLayeredWindowAttributes(win32.UI.WindowsAndMessaging.HWND hwnd, uint crKey, byte bAlpha, win32.UI.WindowsAndMessaging.LAYERED_WINDOW_ATTRIBUTES_FLAGS dwFlags);
        /// <summary>Sets the show state of a window without waiting for the operation to complete.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showwindowasync#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nCmdShow">
        /// <para>Type: <b>int</b></para>
        /// <para>Controls how the window is to be shown. For a list of possible values, see the description of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showwindowasync#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the operation was successfully started, the return value is nonzero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showwindowasync">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool ShowWindowAsync(win32.UI.WindowsAndMessaging.HWND hWnd, int nCmdShow);
        /// <summary>Shows or hides all pop-up windows owned by the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that owns the pop-up windows to be shown or hidden.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showownedpopups#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fShow">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If this parameter is <b>TRUE</b>, all hidden pop-up windows are shown. If this parameter is <b>FALSE</b>, all visible pop-up windows are hidden.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showownedpopups#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showownedpopups">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ShowOwnedPopups(win32.UI.WindowsAndMessaging.HWND hWnd, bool fShow);
        /// <summary>Restores a minimized (iconic) window to its previous size and position; it then activates the window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be restored and activated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-openicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-openicon">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool OpenIcon(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Minimizes (but does not destroy) the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be minimized.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-closewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-closewindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool CloseWindow(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Changes the position and dimensions of the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "X">
        /// <para>Type: <b>int</b></para>
        /// <para>The new position of the left side of the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Y">
        /// <para>Type: <b>int</b></para>
        /// <para>The new position of the top of the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nWidth">
        /// <para>Type: <b>int</b></para>
        /// <para>The new width of the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nHeight">
        /// <para>Type: <b>int</b></para>
        /// <para>The new height of the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bRepaint">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether the window is to be repainted. If this parameter is <b>TRUE</b>, the window receives a  message. If the parameter is <b>FALSE</b>, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of moving a child window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-movewindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool MoveWindow(win32.UI.WindowsAndMessaging.HWND hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);
        /// <summary>Changes the size, position, and Z order of a child, pop-up, or top-level window. These windows are ordered according to their appearance on the screen. The topmost window receives the highest rank and is the first window in the Z order.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndInsertAfter">Type: <b>HWND</b></param>
        /// <param name = "X">
        /// <para>Type: <b>int</b></para>
        /// <para>The new position of the left side of the window, in client coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Y">
        /// <para>Type: <b>int</b></para>
        /// <para>The new position of the top of the window, in client coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cx">
        /// <para>Type: <b>int</b></para>
        /// <para>The new width of the window, in pixels.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cy">
        /// <para>Type: <b>int</b></para>
        /// <para>The new height of the window, in pixels.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetWindowPos(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.HWND hWndInsertAfter, int X, int Y, int cx, int cy, win32.UI.WindowsAndMessaging.SET_WINDOW_POS_FLAGS uFlags);
        /// <inheritdoc cref = "GetWindowPlacement(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.WINDOWPLACEMENT*)"/>
        internal static unsafe bool GetWindowPlacement(win32.UI.WindowsAndMessaging.HWND hWnd, ref win32.UI.WindowsAndMessaging.WINDOWPLACEMENT lpwndpl)
        {
            fixed (win32.UI.WindowsAndMessaging.WINDOWPLACEMENT*lpwndplLocal = &lpwndpl)
            {
                bool __result = User32.GetWindowPlacement(hWnd, lpwndplLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the show state and the restored, minimized, and maximized positions of the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowplacement#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpwndpl">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a>*</b></para>
        /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a> structure that receives the show state and position information. Before calling <b>GetWindowPlacement</b>, set the <b>length</b> member to <c>sizeof(WINDOWPLACEMENT)</c>. <b>GetWindowPlacement</b> fails if <i>lpwndpl</i>-&gt; <i>length</i> is not set correctly.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowplacement#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowplacement">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetWindowPlacement(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.WINDOWPLACEMENT*lpwndpl);
        /// <inheritdoc cref = "SetWindowPlacement(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.WINDOWPLACEMENT*)"/>
        internal static unsafe bool SetWindowPlacement(win32.UI.WindowsAndMessaging.HWND hWnd, in win32.UI.WindowsAndMessaging.WINDOWPLACEMENT lpwndpl)
        {
            fixed (win32.UI.WindowsAndMessaging.WINDOWPLACEMENT*lpwndplLocal = &lpwndpl)
            {
                bool __result = User32.SetWindowPlacement(hWnd, lpwndplLocal);
                return __result;
            }
        }

        /// <summary>Sets the show state and the restored, minimized, and maximized positions of the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowplacement#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpwndpl">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a>*</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a> structure that specifies the new show state and window positions.</para>
        /// <para>Before calling <b>SetWindowPlacement</b>, set the <b>length</b> member of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a> structure to sizeof(<b>WINDOWPLACEMENT</b>). <b>SetWindowPlacement</b> fails if the <b>length</b> member is not set correctly.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowplacement#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowplacement">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetWindowPlacement(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.WINDOWPLACEMENT*lpwndpl);
        /// <inheritdoc cref = "GetWindowDisplayAffinity(win32.UI.WindowsAndMessaging.HWND, uint *)"/>
        internal static unsafe bool GetWindowDisplayAffinity(win32.UI.WindowsAndMessaging.HWND hWnd, out uint pdwAffinity)
        {
            fixed (uint *pdwAffinityLocal = &pdwAffinity)
            {
                bool __result = User32.GetWindowDisplayAffinity(hWnd, pdwAffinityLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the current display affinity setting, from any process, for a given window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowdisplayaffinity#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pdwAffinity">
        /// <para>Type: <b>DWORD*</b></para>
        /// <para>A pointer to a variable that receives the display affinity setting. See <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowdisplayaffinity">SetWindowDisplayAffinity</a> for a list of affinity settings and their meanings.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowdisplayaffinity#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>This function succeeds only when the window is layered and Desktop Windows Manager is composing the desktop. If this function succeeds, it returns <b>TRUE</b>; otherwise, it returns <b>FALSE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowdisplayaffinity">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetWindowDisplayAffinity(win32.UI.WindowsAndMessaging.HWND hWnd, uint *pdwAffinity);
        /// <summary>Stores the display affinity setting in kernel mode on the hWnd associated with the window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the top-level window. The window must belong to the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowdisplayaffinity#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwAffinity">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The display affinity setting that specifies where the content of the window can be displayed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowdisplayaffinity#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, it returns <b>TRUE</b>; otherwise, it returns <b>FALSE</b> when, for example, the function call is made on a non top-level window. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowdisplayaffinity">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetWindowDisplayAffinity(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.WINDOW_DISPLAY_AFFINITY dwAffinity);
        /// <summary>Allocates memory for a multiple-window- position structure and returns the handle to the structure.</summary>
        /// <param name = "nNumWindows">
        /// <para>Type: <b>int</b></para>
        /// <para>The initial number of windows for which to store position information. The <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-deferwindowpos">DeferWindowPos</a> function increases the size of the structure, if necessary.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-begindeferwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HDWP</b></para>
        /// <para>If the function succeeds, the return value identifies the multiple-window-position structure. If insufficient system resources are available to allocate the structure, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-begindeferwindowpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern nint BeginDeferWindowPos(int nNumWindows);
        /// <summary>Updates the specified multiple-window � position structure for the specified window.</summary>
        /// <param name = "hWinPosInfo">
        /// <para>Type: <b>HDWP</b></para>
        /// <para>A handle to a multiple-window – position structure that contains size and position information for one or more windows. This structure is returned by <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-begindeferwindowpos">BeginDeferWindowPos</a> or by the most recent call to <b>DeferWindowPos</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deferwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window for which update information is stored in the structure. All windows in a multiple-window – position structure must have the same parent.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deferwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndInsertAfter">Type: <b>HWND</b></param>
        /// <param name = "x">
        /// <para>Type: <b>int</b></para>
        /// <para>The x-coordinate of the window's upper-left corner.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deferwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "y">
        /// <para>Type: <b>int</b></para>
        /// <para>The y-coordinate of the window's upper-left corner.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deferwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cx">
        /// <para>Type: <b>int</b></para>
        /// <para>The window's new width, in pixels.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deferwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cy">
        /// <para>Type: <b>int</b></para>
        /// <para>The window's new height, in pixels.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deferwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>HDWP</b></para>
        /// <para>The return value identifies the updated multiple-window – position structure. The handle returned by this function may differ from the handle passed to the function. The new handle that this function returns should be passed during the next call to the <b>DeferWindowPos</b> or <a href = "/windows/desktop/api/winuser/nf-winuser-enddeferwindowpos">EndDeferWindowPos</a> function.</para>
        /// <para>If insufficient system resources are available for the function to succeed, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deferwindowpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern nint DeferWindowPos(nint hWinPosInfo, win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.HWND hWndInsertAfter, int x, int y, int cx, int cy, win32.UI.WindowsAndMessaging.SET_WINDOW_POS_FLAGS uFlags);
        /// <summary>Simultaneously updates the position and size of one or more windows in a single screen-refreshing cycle.</summary>
        /// <param name = "hWinPosInfo">
        /// <para>Type: <b>HDWP</b></para>
        /// <para>A handle to a multiple-window – position structure that contains size and position information for one or more windows. This internal structure is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-begindeferwindowpos">BeginDeferWindowPos</a> function or by the most recent call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-deferwindowpos">DeferWindowPos</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enddeferwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enddeferwindowpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool EndDeferWindowPos(nint hWinPosInfo);
        /// <summary>Determines the visibility state of the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iswindowvisible#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the specified window, its parent window, its parent's parent window, and so forth, have the <b>WS_VISIBLE</b> style, the return value is nonzero. Otherwise, the return value is zero.</para>
        /// <para>Because the return value specifies whether the window has the <b>WS_VISIBLE</b> style, it may be nonzero even if the window is totally obscured by other windows.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iswindowvisible">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsWindowVisible(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Determines whether the specified window is minimized (iconic).</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isiconic#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the window is iconic, the return value is nonzero.</para>
        /// <para>If the window is not iconic, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isiconic">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsIconic(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Indicates whether an owned, visible, top-level pop-up, or overlapped window exists on the screen. The function searches the entire screen, not just the calling application's client area.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If a pop-up window exists, the return value is nonzero, even if the pop-up window is completely covered by other windows.</para>
        /// <para>If a pop-up window does not exist, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-anypopup">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool AnyPopup();
        /// <summary>Brings the specified window to the top of the Z order. If the window is a top-level window, it is activated. If the window is a child window, the top-level parent window associated with the child window is activated.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to bring to the top of the Z order.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-bringwindowtotop#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-bringwindowtotop">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool BringWindowToTop(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Determines whether a window is maximized.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iszoomed#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the window is zoomed, the return value is nonzero.</para>
        /// <para>If the window is not zoomed, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iszoomed">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsZoomed(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <inheritdoc cref = "CreateDialogParam(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.UI.WindowsAndMessaging.HWND, delegate *unmanaged[Stdcall]{win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint}, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe win32.UI.WindowsAndMessaging.HWND CreateDialogParam(SafeHandle hInstance, string lpTemplateName, win32.UI.WindowsAndMessaging.HWND hWndParent, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint>lpDialogFunc, win32.UI.WindowsAndMessaging.LPARAM dwInitParam)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (char *lpTemplateNameLocal = lpTemplateName)
                {
                    win32.System.SystemServices.HINSTANCE hInstanceLocal;
                    if (hInstance is object)
                    {
                        hInstance.DangerousAddRef(ref hInstanceAddRef);
                        hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                    }
                    else
                        hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                    win32.UI.WindowsAndMessaging.HWND __result = User32.CreateDialogParam(hInstanceLocal, lpTemplateNameLocal, hWndParent, lpDialogFunc, dwInitParam);
                    return __result;
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Creates a modeless dialog box from a dialog box template resource.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTemplateName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and low-order word must contain the identifier. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to create this value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that owns the dialog box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDialogFunc">
        /// <para>Type: <b>DLGPROC</b></para>
        /// <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwInitParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The value to be passed to the dialog box procedure in the <i>lParam</i> parameter in the <a href = "https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is the window handle to the dialog box.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogparamw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CreateDialogParamW", SetLastError = true)]
        internal static extern unsafe win32.UI.WindowsAndMessaging.HWND CreateDialogParam(win32.System.SystemServices.HINSTANCE hInstance, win32.System.SystemServices.PCWSTR lpTemplateName, win32.UI.WindowsAndMessaging.HWND hWndParent, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint>lpDialogFunc, win32.UI.WindowsAndMessaging.LPARAM dwInitParam);
        /// <inheritdoc cref = "CreateDialogIndirectParam(win32.System.SystemServices.HINSTANCE, win32.UI.WindowsAndMessaging.DLGTEMPLATE*, win32.UI.WindowsAndMessaging.HWND, delegate *unmanaged[Stdcall]{win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint}, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe win32.UI.WindowsAndMessaging.HWND CreateDialogIndirectParam(SafeHandle hInstance, in win32.UI.WindowsAndMessaging.DLGTEMPLATE lpTemplate, win32.UI.WindowsAndMessaging.HWND hWndParent, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint>lpDialogFunc, win32.UI.WindowsAndMessaging.LPARAM dwInitParam)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.DLGTEMPLATE*lpTemplateLocal = &lpTemplate)
                {
                    win32.System.SystemServices.HINSTANCE hInstanceLocal;
                    if (hInstance is object)
                    {
                        hInstance.DangerousAddRef(ref hInstanceAddRef);
                        hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                    }
                    else
                        hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                    win32.UI.WindowsAndMessaging.HWND __result = User32.CreateDialogIndirectParam(hInstanceLocal, lpTemplateLocal, hWndParent, lpDialogFunc, dwInitParam);
                    return __result;
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Creates a modeless dialog box from a dialog box template in memory.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogindirectparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTemplate">
        /// <para>Type: <b>LPCDLGTEMPLATE</b></para>
        /// <para>The template <b>CreateDialogIndirectParam</b> uses to create the dialog box. A dialog box template consists of a header that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The template can use either the standard format or the extended format.</para>
        /// <para>In a standard template, the header is a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgtemplate">DLGTEMPLATE</a> structure followed by additional variable-length arrays. The data for each control consists of a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgitemtemplate">DLGITEMTEMPLATE</a> structure followed by additional variable-length arrays.</para>
        /// <para>In an extended dialog box template, the header uses the <a href = "https://docs.microsoft.com/windows/desktop/dlgbox/dlgtemplateex">DLGTEMPLATEEX</a> format and the control definitions use the <a href = "https://docs.microsoft.com/windows/desktop/dlgbox/dlgitemtemplateex">DLGITEMTEMPLATEEX</a> format.</para>
        /// <para>After <b>CreateDialogIndirectParam</b> returns, you can free the template, which is only used to get the dialog box started.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogindirectparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that owns the dialog box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogindirectparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDialogFunc">
        /// <para>Type: <b>DLGPROC</b></para>
        /// <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogindirectparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwInitParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The value to pass to the dialog box in the <i>lParam</i> parameter of the <a href = "https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogindirectparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is the window handle to the dialog box.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdialogindirectparamw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CreateDialogIndirectParamW", SetLastError = true)]
        internal static extern unsafe win32.UI.WindowsAndMessaging.HWND CreateDialogIndirectParam(win32.System.SystemServices.HINSTANCE hInstance, win32.UI.WindowsAndMessaging.DLGTEMPLATE*lpTemplate, win32.UI.WindowsAndMessaging.HWND hWndParent, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint>lpDialogFunc, win32.UI.WindowsAndMessaging.LPARAM dwInitParam);
        /// <inheritdoc cref = "DialogBoxParam(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.UI.WindowsAndMessaging.HWND, delegate *unmanaged[Stdcall]{win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint}, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe nint DialogBoxParam(SafeHandle hInstance, string lpTemplateName, win32.UI.WindowsAndMessaging.HWND hWndParent, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint>lpDialogFunc, win32.UI.WindowsAndMessaging.LPARAM dwInitParam)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (char *lpTemplateNameLocal = lpTemplateName)
                {
                    win32.System.SystemServices.HINSTANCE hInstanceLocal;
                    if (hInstance is object)
                    {
                        hInstance.DangerousAddRef(ref hInstanceAddRef);
                        hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                    }
                    else
                        hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                    nint __result = User32.DialogBoxParam(hInstanceLocal, lpTemplateNameLocal, hWndParent, lpDialogFunc, dwInitParam);
                    return __result;
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Creates a modal dialog box from a dialog box template resource.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTemplateName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to create this value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that owns the dialog box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDialogFunc">
        /// <para>Type: <b>DLGPROC</b></para>
        /// <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwInitParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The value to pass to the dialog box in the <i>lParam</i> parameter of the <a href = "https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>INT_PTR</b></para>
        /// <para>If the function succeeds, the return value is the value of the <i>nResult</i> parameter specified in the call to the <a href = "/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> function used to terminate the dialog box.</para>
        /// <para>If the function fails because the <i>hWndParent</i> parameter is invalid, the return value is zero. The function returns zero in this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is –1. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxparamw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DialogBoxParamW", SetLastError = true)]
        internal static extern unsafe nint DialogBoxParam(win32.System.SystemServices.HINSTANCE hInstance, win32.System.SystemServices.PCWSTR lpTemplateName, win32.UI.WindowsAndMessaging.HWND hWndParent, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint>lpDialogFunc, win32.UI.WindowsAndMessaging.LPARAM dwInitParam);
        /// <inheritdoc cref = "DialogBoxIndirectParam(win32.System.SystemServices.HINSTANCE, win32.UI.WindowsAndMessaging.DLGTEMPLATE*, win32.UI.WindowsAndMessaging.HWND, delegate *unmanaged[Stdcall]{win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint}, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe nint DialogBoxIndirectParam(SafeHandle hInstance, in win32.UI.WindowsAndMessaging.DLGTEMPLATE hDialogTemplate, win32.UI.WindowsAndMessaging.HWND hWndParent, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint>lpDialogFunc, win32.UI.WindowsAndMessaging.LPARAM dwInitParam)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.DLGTEMPLATE*hDialogTemplateLocal = &hDialogTemplate)
                {
                    win32.System.SystemServices.HINSTANCE hInstanceLocal;
                    if (hInstance is object)
                    {
                        hInstance.DangerousAddRef(ref hInstanceAddRef);
                        hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                    }
                    else
                        hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                    nint __result = User32.DialogBoxIndirectParam(hInstanceLocal, hDialogTemplateLocal, hWndParent, lpDialogFunc, dwInitParam);
                    return __result;
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Creates a modal dialog box from a dialog box template in memory.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the module that creates the dialog box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxindirectparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hDialogTemplate">
        /// <para>Type: <b>LPCDLGTEMPLATE</b></para>
        /// <para>The template that <b>DialogBoxIndirectParam</b> uses to create the dialog box. A dialog box template consists of a header that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The template can use either the standard format or the extended format.</para>
        /// <para>In a standard template for a dialog box, the header is a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgtemplate">DLGTEMPLATE</a> structure followed by additional variable-length arrays. The data for each control consists of a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgitemtemplate">DLGITEMTEMPLATE</a> structure followed by additional variable-length arrays.</para>
        /// <para>In an extended template for a dialog box, the header uses the <a href = "https://docs.microsoft.com/windows/desktop/dlgbox/dlgtemplateex">DLGTEMPLATEEX</a> format and the control definitions use the <a href = "https://docs.microsoft.com/windows/desktop/dlgbox/dlgitemtemplateex">DLGITEMTEMPLATEEX</a> format.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxindirectparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that owns the dialog box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxindirectparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDialogFunc">
        /// <para>Type: <b>DLGPROC</b></para>
        /// <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxindirectparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwInitParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The value to pass to the dialog box in the <i>lParam</i> parameter of the <a href = "https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxindirectparamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>INT_PTR</b></para>
        /// <para>If the function succeeds, the return value is the <i>nResult</i> parameter specified in the call to the <a href = "/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> function that was used to terminate the dialog box.</para>
        /// <para>If the function fails because the <i>hWndParent</i> parameter is invalid, the return value is zero. The function returns zero in this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is –1. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dialogboxindirectparamw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DialogBoxIndirectParamW", SetLastError = true)]
        internal static extern unsafe nint DialogBoxIndirectParam(win32.System.SystemServices.HINSTANCE hInstance, win32.UI.WindowsAndMessaging.DLGTEMPLATE*hDialogTemplate, win32.UI.WindowsAndMessaging.HWND hWndParent, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, nint>lpDialogFunc, win32.UI.WindowsAndMessaging.LPARAM dwInitParam);
        /// <summary>Destroys a modal dialog box, causing the system to end any processing for the dialog box.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the dialog box to be destroyed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enddialog#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nResult">
        /// <para>Type: <b>INT_PTR</b></para>
        /// <para>The value to be returned to the application from the function that created the dialog box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enddialog#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enddialog">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool EndDialog(win32.UI.WindowsAndMessaging.HWND hDlg, nint nResult);
        /// <summary>Retrieves a handle to a control in the specified dialog box.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the dialog box that contains the control.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDDlgItem">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the control to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is the window handle of the specified control.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>, indicating an invalid dialog box handle or a nonexistent control. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetDlgItem(win32.UI.WindowsAndMessaging.HWND hDlg, int nIDDlgItem);
        /// <summary>Sets the text of a control in a dialog box to the string representation of a specified integer value.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the dialog box that contains the control.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdlgitemint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDDlgItem">
        /// <para>Type: <b>int</b></para>
        /// <para>The control to be changed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdlgitemint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uValue">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The integer value used to generate the item text.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdlgitemint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bSigned">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether the <i>uValue</i> parameter is signed or unsigned. If this parameter is <b>TRUE</b>, <i>uValue</i> is signed. If this parameter is <b>TRUE</b> and <i>uValue</i> is less than zero, a minus sign is placed before the first digit in the string. If this parameter is <b>FALSE</b>, <i>uValue</i> is unsigned.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdlgitemint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdlgitemint">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetDlgItemInt(win32.UI.WindowsAndMessaging.HWND hDlg, int nIDDlgItem, uint uValue, bool bSigned);
        /// <summary>Translates the text of a specified control in a dialog box into an integer value.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the dialog box that contains the control of interest.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitemint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDDlgItem">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the control whose text is to be translated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitemint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTranslated">
        /// <para>Type: <b>BOOL*</b></para>
        /// <para>Indicates success or failure (<b>TRUE</b> indicates success, <b>FALSE</b> indicates failure).</para>
        /// <para>If this parameter is <b>NULL</b>, the function returns no information about success or failure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitemint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bSigned">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether the function should examine the text for a minus sign at the beginning and return a signed integer value if it finds one (<b>TRUE</b> specifies this should be done, <b>FALSE</b> that it should not).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitemint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the variable pointed to by <i>lpTranslated</i> is set to <b>TRUE</b>, and the return value is the translated value of the control text.</para>
        /// <para>If the function fails, the variable pointed to by <i>lpTranslated</i> is set to <b>FALSE</b>, and the return value is zero. Note that, because zero is a possible translated value, a return value of zero does not by itself indicate failure.</para>
        /// <para>If <i>lpTranslated</i> is <b>NULL</b>, the function returns no information about success or failure.</para>
        /// <para>Note that, if the <i>bSigned</i> parameter is <b>TRUE</b> and there is a minus sign (–) at the beginning of the text, <b>GetDlgItemInt</b> translates the text into a signed integer value. Otherwise, the function creates an unsigned integer value. To obtain the proper value in this case, cast the return value to an <b>int</b> type.</para>
        /// <para>To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitemint">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint GetDlgItemInt(win32.UI.WindowsAndMessaging.HWND hDlg, int nIDDlgItem, [Optional] bool *lpTranslated, bool bSigned);
        /// <inheritdoc cref = "SetDlgItemText(win32.UI.WindowsAndMessaging.HWND, int, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetDlgItemText(win32.UI.WindowsAndMessaging.HWND hDlg, int nIDDlgItem, string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                bool __result = User32.SetDlgItemText(hDlg, nIDDlgItem, lpStringLocal);
                return __result;
            }
        }

        /// <summary>Sets the title or text of a control in a dialog box.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the dialog box that contains the control.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdlgitemtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDDlgItem">
        /// <para>Type: <b>int</b></para>
        /// <para>The control with a title or text to be set.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdlgitemtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The text to be copied to the control.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdlgitemtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdlgitemtextw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SetDlgItemTextW", SetLastError = true)]
        internal static extern bool SetDlgItemText(win32.UI.WindowsAndMessaging.HWND hDlg, int nIDDlgItem, win32.System.SystemServices.PCWSTR lpString);
        /// <summary>Retrieves the title or text associated with a control in a dialog box.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the dialog box that contains the control.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitemtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDDlgItem">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the control whose title or text is to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitemtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The buffer to receive the title or text.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitemtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchMax">
        /// <para>Type: <b>int</b></para>
        /// <para>The maximum length, in characters, of the string to be copied to the buffer pointed to by <i>lpString</i>. If the length of the string, including the null character, exceeds the limit, the string is truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitemtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null character.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgitemtextw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetDlgItemTextW", SetLastError = true)]
        internal static extern uint GetDlgItemText(win32.UI.WindowsAndMessaging.HWND hDlg, int nIDDlgItem, win32.System.SystemServices.PWSTR lpString, int cchMax);
        /// <summary>Sends a message to the specified control in a dialog box.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the dialog box that contains the control.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-senddlgitemmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDDlgItem">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the control that receives the message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-senddlgitemmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to be sent.</para>
        /// <para>For lists of the system-provided messages, see <a href = "https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-senddlgitemmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-senddlgitemmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-senddlgitemmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>The return value specifies the result of the message processing and depends on the message sent.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-senddlgitemmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SendDlgItemMessageW")]
        internal static extern win32.System.SystemServices.LRESULT SendDlgItemMessage(win32.UI.WindowsAndMessaging.HWND hDlg, int nIDDlgItem, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Retrieves a handle to the first control in a group of controls that precedes (or follows) the specified control in a dialog box.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the dialog box to be searched.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getnextdlggroupitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hCtl">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the control to be used as the starting point for the search. If this parameter is <b>NULL</b>, the function uses the last (or first) control in the dialog box as the starting point for the search.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getnextdlggroupitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bPrevious">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates how the function is to search the group of controls in the dialog box. If this parameter is <b>TRUE</b>, the function searches for the previous control in the group. If it is <b>FALSE</b>, the function searches for the next control in the group.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getnextdlggroupitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is a handle to the previous (or next) control in the group of controls.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getnextdlggroupitem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetNextDlgGroupItem(win32.UI.WindowsAndMessaging.HWND hDlg, win32.UI.WindowsAndMessaging.HWND hCtl, bool bPrevious);
        /// <summary>Retrieves a handle to the first control that has the WS_TABSTOP style that precedes (or follows) the specified control.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the dialog box to be searched.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getnextdlgtabitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hCtl">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the control to be used as the starting point for the search. If this parameter is <b>NULL</b>, the function fails.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getnextdlgtabitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bPrevious">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates how the function is to search the dialog box. If this parameter is <b>TRUE</b>, the function searches for the previous control in the dialog box. If this parameter is <b>FALSE</b>, the function searches for the next control in the dialog box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getnextdlgtabitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is the window handle of the previous (or next) control that has the <a href = "/windows/desktop/dlgbox/dlgbox-programming-considerations">WS_TABSTOP</a> style set.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getnextdlgtabitem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetNextDlgTabItem(win32.UI.WindowsAndMessaging.HWND hDlg, win32.UI.WindowsAndMessaging.HWND hCtl, bool bPrevious);
        /// <summary>Retrieves the identifier of the specified control.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the control.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgctrlid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the identifier of the control.</para>
        /// <para>If the function fails, the return value is zero. An invalid value for the <i>hwndCtl</i> parameter, for example, will cause the function to fail. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdlgctrlid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetDlgCtrlID(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Retrieves the system's dialog base units, which are the average width and height of characters in the system font.</summary>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>The function returns the dialog base units. The low-order word of the return value contains the horizontal dialog box base unit, and the high-order word contains the vertical dialog box base unit.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdialogbaseunits">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern int GetDialogBaseUnits();
        /// <summary>Calls the default dialog box window procedure to provide default processing for any window messages that a dialog box with a private window class does not process.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the dialog box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defdlgprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defdlgprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defdlgprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defdlgprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>The return value specifies the result of the message processing and depends on the message sent.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defdlgprocw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DefDlgProcW")]
        internal static extern win32.System.SystemServices.LRESULT DefDlgProc(win32.UI.WindowsAndMessaging.HWND hDlg, uint Msg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <inheritdoc cref = "CallMsgFilter(win32.UI.WindowsAndMessaging.MSG*, int)"/>
        internal static unsafe bool CallMsgFilter(in win32.UI.WindowsAndMessaging.MSG lpMsg, int nCode)
        {
            fixed (win32.UI.WindowsAndMessaging.MSG*lpMsgLocal = &lpMsg)
            {
                bool __result = User32.CallMsgFilter(lpMsgLocal, nCode);
                return __result;
            }
        }

        /// <summary>Passes the specified message and hook code to the hook procedures associated with the WH_SYSMSGFILTER and WH_MSGFILTER hooks.</summary>
        /// <param name = "lpMsg">
        /// <para>Type: <b>LPMSG</b></para>
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains the message to be passed to the hook procedures.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callmsgfilterw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nCode">
        /// <para>Type: <b>int</b></para>
        /// <para>An application-defined code used by the hook procedure to determine how to process the message. The code must not have the same value as system-defined hook codes (MSGF_ and HC_) associated with the <a href = "https://docs.microsoft.com/windows/desktop/winmsg/about-hooks">WH_SYSMSGFILTER</a> and <b>WH_MSGFILTER</b> hooks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callmsgfilterw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the application should process the message further, the return value is zero.</para>
        /// <para>If the application should not process the message further, the return value is nonzero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callmsgfilterw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CallMsgFilterW")]
        internal static extern unsafe bool CallMsgFilter(win32.UI.WindowsAndMessaging.MSG*lpMsg, int nCode);
        /// <inheritdoc cref = "CharToOem(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PSTR)"/>
        internal static unsafe bool CharToOem(string pSrc, win32.System.SystemServices.PSTR pDst)
        {
            fixed (char *pSrcLocal = pSrc)
            {
                bool __result = User32.CharToOem(pSrcLocal, pDst);
                return __result;
            }
        }

        /// <summary>Translates a string into the OEM-defined character set.Warning  Do not use.</summary>
        /// <param name = "pSrc">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The null-terminated string to be translated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-chartooemw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pDst">
        /// <para>Type: <b>LPSTR</b></para>
        /// <para>The destination buffer, which receives the translated string. If the <b>CharToOem</b> function is being used as an ANSI function, the string can be translated in place by setting the <i>lpszDst</i> parameter to the same address as the <i>lpszSrc</i> parameter. This cannot be done if <b>CharToOem</b> is being used as a wide-character function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-chartooemw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The return value is always nonzero except when you pass the same address to <i>lpszSrc</i> and <i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-chartooemw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CharToOemW", SetLastError = true)]
        internal static extern bool CharToOem(win32.System.SystemServices.PCWSTR pSrc, win32.System.SystemServices.PSTR pDst);
        /// <summary>Translates a string from the OEM-defined character set into either an ANSI or a wide-character string.Warning  Do not use.</summary>
        /// <param name = "pSrc">
        /// <para>Type: <b>LPCSTR</b></para>
        /// <para>A null-terminated string of characters from the OEM-defined character set.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-oemtocharw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pDst">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The destination buffer, which receives the translated string. If the <b>OemToChar</b> function is being used as an ANSI function, the string can be translated in place by setting the <i>lpszDst</i> parameter to the same address as the <i>lpszSrc</i> parameter. This cannot be done if <b>OemToChar</b> is being used as a wide-character function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-oemtocharw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The return value is always nonzero except when you pass the same address to <i>lpszSrc</i> and <i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-oemtocharw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "OemToCharW", SetLastError = true)]
        internal static extern bool OemToChar(win32.System.SystemServices.PCSTR pSrc, win32.System.SystemServices.PWSTR pDst);
        /// <inheritdoc cref = "CharToOemBuff(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PSTR, uint)"/>
        internal static unsafe bool CharToOemBuff(string lpszSrc, win32.System.SystemServices.PSTR lpszDst, uint cchDstLength)
        {
            fixed (char *lpszSrcLocal = lpszSrc)
            {
                bool __result = User32.CharToOemBuff(lpszSrcLocal, lpszDst, cchDstLength);
                return __result;
            }
        }

        /// <summary>Translates a specified number of characters in a string into the OEM-defined character set.</summary>
        /// <param name = "lpszSrc">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The null-terminated string to be translated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-chartooembuffw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszDst">
        /// <para>Type: <b>LPSTR</b></para>
        /// <para>The buffer for the translated string. If the <b>CharToOemBuff</b> function is being used as an ANSI function, the string can be translated in place by setting the <i>lpszDst</i> parameter to the same address as the <i>lpszSrc</i> parameter. This cannot be done if <b>CharToOemBuff</b> is being used as a wide-character function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-chartooembuffw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchDstLength">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The number of characters to translate in the string identified by the <i>lpszSrc</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-chartooembuffw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The return value is always nonzero except when you pass the same address to <i>lpszSrc</i> and <i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-chartooembuffw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CharToOemBuffW", SetLastError = true)]
        internal static extern bool CharToOemBuff(win32.System.SystemServices.PCWSTR lpszSrc, win32.System.SystemServices.PSTR lpszDst, uint cchDstLength);
        /// <summary>Translates a specified number of characters in a string from the OEM-defined character set into either an ANSI or a wide-character string.</summary>
        /// <param name = "lpszSrc">
        /// <para>Type: <b>LPCSTR</b></para>
        /// <para>One or more characters from the OEM-defined character set.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-oemtocharbuffw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszDst">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The destination buffer, which receives the translated string. If the <b>OemToCharBuff</b> function is being used as an ANSI function, the string can be translated in place by setting the <i>lpszDst</i> parameter to the same address as the <i>lpszSrc</i> parameter. This cannot be done if the <b>OemToCharBuff</b> function is being used as a wide-character function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-oemtocharbuffw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchDstLength">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The number of characters to be translated in the buffer identified by the <i>lpszSrc</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-oemtocharbuffw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The return value is always nonzero except when you pass the same address to <i>lpszSrc</i> and <i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-oemtocharbuffw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "OemToCharBuffW", SetLastError = true)]
        internal static extern bool OemToCharBuff(win32.System.SystemServices.PCSTR lpszSrc, win32.System.SystemServices.PWSTR lpszDst, uint cchDstLength);
        /// <summary>Converts a character string or a single character to uppercase. If the operand is a character string, the function converts the characters in place.</summary>
        /// <param name = "lpsz">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>A null-terminated string, or a single character. If the high-order word of this parameter is zero, the low-order word must contain a single character to be converted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charupperw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>If the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the return value is equal to <i>lpsz</i>.</para>
        /// <para>If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the converted character.</para>
        /// <para>There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charupperw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CharUpperW", SetLastError = true)]
        internal static extern win32.System.SystemServices.PWSTR CharUpper(win32.System.SystemServices.PWSTR lpsz);
        /// <summary>Converts lowercase characters in a buffer to uppercase characters. The function converts the characters in place.</summary>
        /// <param name = "lpsz">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>A buffer containing one or more characters to be processed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charupperbuffw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchLength">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The size, in characters, of the buffer pointed to by <i>lpsz</i>.</para>
        /// <para>The function examines each character, and converts lowercase characters to uppercase characters. The function examines the number of characters indicated by <i>cchLength</i>, even if one or more characters are null characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charupperbuffw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The return value is the number of characters processed.</para>
        /// <para>For example, if <b>CharUpperBuff</b>("Zenith of API Sets", 10) succeeds, the return value is 10.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charupperbuffw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CharUpperBuffW")]
        internal static extern uint CharUpperBuff(win32.System.SystemServices.PWSTR lpsz, uint cchLength);
        /// <summary>Converts a character string or a single character to lowercase. If the operand is a character string, the function converts the characters in place.</summary>
        /// <param name = "lpsz">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>A null-terminated string, or specifies a single character. If the high-order word of this parameter is zero, the low-order word must contain a single character to be converted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charlowerw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>If the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the return value is equal to <i>lpsz</i>.</para>
        /// <para>If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the converted character.</para>
        /// <para>There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charlowerw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CharLowerW", SetLastError = true)]
        internal static extern win32.System.SystemServices.PWSTR CharLower(win32.System.SystemServices.PWSTR lpsz);
        /// <summary>Converts uppercase characters in a buffer to lowercase characters. The function converts the characters in place.</summary>
        /// <param name = "lpsz">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>A buffer containing one or more characters to be processed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charlowerbuffw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchLength">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The size, in characters, of the buffer pointed to by <i>lpsz</i>. The function examines each character, and converts uppercase characters to lowercase characters. The function examines the number of characters indicated by <i>cchLength</i>, even if one or more characters are null characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charlowerbuffw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The return value is the number of characters processed. For example, if <b>CharLowerBuff</b>("Acme of Operating Systems", 10) succeeds, the return value is 10.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charlowerbuffw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CharLowerBuffW")]
        internal static extern uint CharLowerBuff(win32.System.SystemServices.PWSTR lpsz, uint cchLength);
        /// <inheritdoc cref = "CharNext(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.SystemServices.PWSTR CharNext(string lpsz)
        {
            fixed (char *lpszLocal = lpsz)
            {
                win32.System.SystemServices.PWSTR __result = User32.CharNext(lpszLocal);
                return __result;
            }
        }

        /// <summary>Retrieves a pointer to the next character in a string. This function can handle strings consisting of either single- or multi-byte characters.</summary>
        /// <param name = "lpsz">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>A character in a null-terminated string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charnextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The return value is a pointer to the next character in the string, or to the terminating null character if at the end of the string.</para>
        /// <para>If <i>lpsz</i> points to the terminating null character, the return value is equal to <i>lpsz</i>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charnextw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CharNextW")]
        internal static extern win32.System.SystemServices.PWSTR CharNext(win32.System.SystemServices.PCWSTR lpsz);
        /// <inheritdoc cref = "CharPrev(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.SystemServices.PWSTR CharPrev(string lpszStart, string lpszCurrent)
        {
            fixed (char *lpszCurrentLocal = lpszCurrent)
            {
                fixed (char *lpszStartLocal = lpszStart)
                {
                    win32.System.SystemServices.PWSTR __result = User32.CharPrev(lpszStartLocal, lpszCurrentLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves a pointer to the preceding character in a string. This function can handle strings consisting of either single- or multi-byte characters.</summary>
        /// <param name = "lpszStart">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The beginning of the string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charprevw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszCurrent">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>A character in a null-terminated string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charprevw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The return value is a pointer to the preceding character in the string, or to the first character in the string if the <i>lpszCurrent</i> parameter equals the <i>lpszStart</i> parameter.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-charprevw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CharPrevW")]
        internal static extern win32.System.SystemServices.PWSTR CharPrev(win32.System.SystemServices.PCWSTR lpszStart, win32.System.SystemServices.PCWSTR lpszCurrent);
        /// <summary>Determines whether a character is an alphabetical character. This determination is based on the semantics of the language selected by the user during setup or through Control Panel.</summary>
        /// <param name = "ch">
        /// <para>Type: <b>TCHAR</b></para>
        /// <para>The character to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ischaralphaw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the character is alphabetical, the return value is nonzero.</para>
        /// <para>If the character is not alphabetical, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ischaralphaw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "IsCharAlphaW", SetLastError = true)]
        internal static extern bool IsCharAlpha(char ch);
        /// <summary>Determines whether a character is either an alphabetical or a numeric character. This determination is based on the semantics of the language selected by the user during setup or through Control Panel.</summary>
        /// <param name = "ch">
        /// <para>Type: <b>TCHAR</b></para>
        /// <para>The character to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ischaralphanumericw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the character is alphanumeric, the return value is nonzero.</para>
        /// <para>If the character is not alphanumeric, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ischaralphanumericw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "IsCharAlphaNumericW", SetLastError = true)]
        internal static extern bool IsCharAlphaNumeric(char ch);
        /// <summary>Determines whether a character is uppercase. This determination is based on the semantics of the language selected by the user during setup or through Control Panel.</summary>
        /// <param name = "ch">
        /// <para>Type: <b>TCHAR</b></para>
        /// <para>The character to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ischarupperw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the character is uppercase, the return value is nonzero.</para>
        /// <para>If the character is not uppercase, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ischarupperw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "IsCharUpperW", SetLastError = true)]
        internal static extern bool IsCharUpper(char ch);
        /// <summary>Determines whether there are mouse-button or keyboard messages in the calling thread's message queue.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the queue contains one or more new mouse-button or keyboard messages, the return value is nonzero.</para>
        /// <para>If there are no new mouse-button or keyboard messages in the queue, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getinputstate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool GetInputState();
        /// <summary>Retrieves the type of messages found in the calling thread's message queue.</summary>
        /// <param name = "flags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The high-order word of the return value indicates the types of messages currently in the queue. The low-order word indicates the types of messages that have been added to the queue and that are still in the queue since the last call to the <b>GetQueueStatus</b>, <a href = "/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a>, or <a href = "/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getqueuestatus">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetQueueStatus(win32.UI.WindowsAndMessaging.QUEUE_STATUS_FLAGS flags);
        /// <summary>Creates a timer with the specified time-out value.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be associated with the timer. This window must be owned by the calling thread. If a <b>NULL</b> value for <i>hWnd</i> is passed in along with an <i>nIDEvent</i> of an existing timer, that timer will be replaced in the same way that an existing non-NULL <i>hWnd</i> timer will be.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-settimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDEvent">
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>A nonzero timer identifier. If the <i>hWnd</i> parameter is <b>NULL</b>, and the <i>nIDEvent</i> does not match an existing timer then it is ignored and a new timer ID is generated. If the <i>hWnd</i> parameter is not <b>NULL</b> and the window specified by <i>hWnd</i> already has a timer with the value <i>nIDEvent</i>, then the existing timer is replaced by the new timer. When <b>SetTimer</b> replaces a timer, the timer is reset. Therefore, a message will be sent after the current time-out value elapses, but the previously set time-out value is ignored. If the call is not intended to replace an existing timer, <i>nIDEvent</i> should be 0 if the <i>hWnd</i> is <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-settimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uElapse">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The time-out value, in milliseconds.</para>
        /// <para>If <i>uElapse</i> is less than <b>USER_TIMER_MINIMUM</b> (0x0000000A), the timeout is set to <b>USER_TIMER_MINIMUM</b>. If <i>uElapse</i> is greater than <b>USER_TIMER_MAXIMUM</b> (0x7FFFFFFF), the timeout is set to <b>USER_TIMER_MAXIMUM</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-settimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTimerFunc">
        /// <para>Type: <b>TIMERPROC</b></para>
        /// <para>A pointer to the function to be notified when the time-out value elapses. For more information about the function, see <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-timerproc">TimerProc</a>. If <i>lpTimerFunc</i> is <b>NULL</b>, the system posts a <a href = "https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> message to the application queue. The <b>hwnd</b> member of the message's <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure contains the value of the <i>hWnd</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-settimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>If the function succeeds and the <i>hWnd</i> parameter is <b>NULL</b>, the return value is an integer identifying the new timer. An application can pass this value to the <a href = "/windows/desktop/api/winuser/nf-winuser-killtimer">KillTimer</a> function to destroy the timer.</para>
        /// <para>If the function succeeds and the <i>hWnd</i> parameter is not <b>NULL</b>, then the return value is a nonzero integer. An application can pass the value of the <i>nIDEvent</i> parameter to the <a href = "/windows/desktop/api/winuser/nf-winuser-killtimer">KillTimer</a> function to destroy the timer.</para>
        /// <para>If the function fails to create a timer, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-settimer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe nuint SetTimer(win32.UI.WindowsAndMessaging.HWND hWnd, nuint nIDEvent, uint uElapse, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, nuint, uint, void>lpTimerFunc);
        /// <summary>Creates a timer with the specified time-out value and coalescing tolerance delay.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be associated with the timer. This window must be owned by the calling thread. If a <b>NULL</b> value for <i>hWnd</i> is passed in along with an <i>nIDEvent</i> of an existing timer, that timer will be replaced in the same way that an existing non-NULL <i>hWnd</i> timer will be.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcoalescabletimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDEvent">
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>A timer identifier. If the <i>hWnd</i> parameter is <b>NULL</b>, and the <i>nIDEvent</i> does not match an existing timer, then the <i>nIDEvent</i> is ignored and a new timer ID is generated. If the <i>hWnd</i> parameter is not <b>NULL</b> and the window specified by <i>hWnd</i> already has a timer with the value <i>nIDEvent</i>, then the existing timer is replaced by the new timer. When <b>SetCoalescableTimer</b> replaces a timer, the timer is reset. Therefore, a message will be sent after the current time-out value elapses, but the previously set time-out value is ignored. If the call is not intended to replace an existing timer, <i>nIDEvent</i> should be 0 if the <i>hWnd</i> is <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcoalescabletimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uElapse">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The time-out value, in milliseconds.</para>
        /// <para>If <i>uElapse</i> is less than <b>USER_TIMER_MINIMUM</b> (0x0000000A), the timeout is set to <b>USER_TIMER_MINIMUM</b>. If <i>uElapse</i> is greater than <b>USER_TIMER_MAXIMUM</b> (0x7FFFFFFF), the timeout is set to <b>USER_TIMER_MAXIMUM</b>.</para>
        /// <para>If the sum of <i>uElapse</i> and <i>uToleranceDelay</i> exceeds <b>USER_TIMER_MAXIMUM</b>, an ERROR_INVALID_PARAMETER exception occurs.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcoalescabletimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTimerFunc">
        /// <para>Type: <b>TIMERPROC</b></para>
        /// <para>A pointer to the function to be notified when the time-out value elapses. For more information about the function, see <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-timerproc">TimerProc</a>. If <i>lpTimerFunc</i> is <b>NULL</b>, the system posts a <a href = "https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> message to the application queue. The <b>hwnd</b> member of the message's <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure contains the value of the <i>hWnd</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcoalescabletimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uToleranceDelay">Type: <b>ULONG</b></param>
        /// <returns>
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>If the function succeeds and the <i>hWnd</i> parameter is <b>NULL</b>, the return value is an integer identifying the new timer. An application can pass this value to the <a href = "/windows/desktop/api/winuser/nf-winuser-killtimer">KillTimer</a> function to destroy the timer.</para>
        /// <para>If the function succeeds and the <i>hWnd</i> parameter is not <b>NULL</b>, then the return value is a nonzero integer. An application can pass the value of the <i>nIDEvent</i> parameter to the <a href = "/windows/desktop/api/winuser/nf-winuser-killtimer">KillTimer</a> function to destroy the timer.</para>
        /// <para>If the function fails to create a timer, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcoalescabletimer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe nuint SetCoalescableTimer(win32.UI.WindowsAndMessaging.HWND hWnd, nuint nIDEvent, uint uElapse, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, uint, nuint, uint, void>lpTimerFunc, uint uToleranceDelay);
        /// <summary>Destroys the specified timer.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window associated with the specified timer. This value must be the same as the <i>hWnd</i> value passed to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-settimer">SetTimer</a> function that created the timer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-killtimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uIDEvent">
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>The timer to be destroyed. If the window handle passed to <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-settimer">SetTimer</a> is valid, this parameter must be the same as the <i>nIDEvent</i></para>
        /// <para>value passed to <b>SetTimer</b>. If the application calls <b>SetTimer</b> with <i>hWnd</i> set to <b>NULL</b>, this parameter must be the timer identifier returned by <b>SetTimer</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-killtimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-killtimer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool KillTimer(win32.UI.WindowsAndMessaging.HWND hWnd, nuint uIDEvent);
        /// <summary>Determines whether the specified window is a native Unicode window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iswindowunicode#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the window is a native Unicode window, the return value is nonzero.</para>
        /// <para>If the window is not a native Unicode window, the return value is zero. The window is a native ANSI window.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iswindowunicode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsWindowUnicode(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Destroys an accelerator table.</summary>
        /// <param name = "hAccel">
        /// <para>Type: <b>HACCEL</b></para>
        /// <para>A handle to the accelerator table to be destroyed. This handle must have been created by a call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createacceleratortablea">CreateAcceleratorTable</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadacceleratorsa">LoadAccelerators</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroyacceleratortable#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero. However, if the table has been loaded more than one call to <a href = "/windows/desktop/api/winuser/nf-winuser-loadacceleratorsa">LoadAccelerators</a>, the function will return a nonzero value only when <b>DestroyAcceleratorTable</b> has been called an equal number of times.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroyacceleratortable">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.BOOL DestroyAcceleratorTable(win32.UI.MenusAndResources.HACCEL hAccel);
        /// <inheritdoc cref = "LoadAccelerators(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe User32.DestroyAcceleratorTableSafeHandle LoadAccelerators(SafeHandle hInstance, string lpTableName)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (char *lpTableNameLocal = lpTableName)
                {
                    win32.System.SystemServices.HINSTANCE hInstanceLocal;
                    if (hInstance is object)
                    {
                        hInstance.DangerousAddRef(ref hInstanceAddRef);
                        hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                    }
                    else
                        hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                    win32.UI.MenusAndResources.HACCEL __result = User32.LoadAccelerators(hInstanceLocal, lpTableNameLocal);
                    return new User32.DestroyAcceleratorTableSafeHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "User32.DestroyAcceleratorTable"/>.
        /// </summary>
        internal class DestroyAcceleratorTableSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal DestroyAcceleratorTableSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal DestroyAcceleratorTableSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => User32.DestroyAcceleratorTable((win32.UI.MenusAndResources.HACCEL)this.handle);
        }

        /// <summary>Loads the specified accelerator table.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the module whose executable file contains the accelerator table to be loaded.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadacceleratorsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTableName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The name of the accelerator table to be loaded. Alternatively, this parameter can specify the resource identifier of an accelerator-table resource in the low-order word and zero in the high-order word. To create this value, use the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadacceleratorsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HACCEL</b></para>
        /// <para>If the function succeeds, the return value is a handle to the loaded accelerator table.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadacceleratorsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "LoadAcceleratorsW", SetLastError = true)]
        internal static extern win32.UI.MenusAndResources.HACCEL LoadAccelerators(win32.System.SystemServices.HINSTANCE hInstance, win32.System.SystemServices.PCWSTR lpTableName);
        /// <inheritdoc cref = "CreateAcceleratorTable(win32.UI.WindowsAndMessaging.ACCEL*, int)"/>
        internal static unsafe User32.DestroyAcceleratorTableSafeHandle CreateAcceleratorTable(Span<win32.UI.WindowsAndMessaging.ACCEL> paccel)
        {
            fixed (win32.UI.WindowsAndMessaging.ACCEL*paccelLocal = paccel)
            {
                win32.UI.MenusAndResources.HACCEL __result = User32.CreateAcceleratorTable(paccelLocal, paccel.Length);
                return new User32.DestroyAcceleratorTableSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates an accelerator table.</summary>
        /// <param name = "paccel">
        /// <para>Type: <b>LPACCEL</b></para>
        /// <para>An array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures that describes the accelerator table.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createacceleratortablew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cAccel">
        /// <para>Type: <b>int</b></para>
        /// <para>The number of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures in the array. This must be within the range 1 to 32767 or the function will fail.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createacceleratortablew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HACCEL</b></para>
        /// <para>If the function succeeds, the return value is the handle to the created accelerator table; otherwise, it is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createacceleratortablew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CreateAcceleratorTableW", SetLastError = true)]
        internal static extern unsafe win32.UI.MenusAndResources.HACCEL CreateAcceleratorTable(win32.UI.WindowsAndMessaging.ACCEL*paccel, int cAccel);
        /// <inheritdoc cref = "CopyAcceleratorTable(win32.UI.MenusAndResources.HACCEL, win32.UI.WindowsAndMessaging.ACCEL*, int)"/>
        internal static unsafe int CopyAcceleratorTable(SafeHandle hAccelSrc, Span<win32.UI.WindowsAndMessaging.ACCEL> lpAccelDst)
        {
            bool hAccelSrcAddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.ACCEL*lpAccelDstLocal = lpAccelDst)
                {
                    win32.UI.MenusAndResources.HACCEL hAccelSrcLocal;
                    if (hAccelSrc is object)
                    {
                        hAccelSrc.DangerousAddRef(ref hAccelSrcAddRef);
                        hAccelSrcLocal = (win32.UI.MenusAndResources.HACCEL)hAccelSrc.DangerousGetHandle();
                    }
                    else
                        hAccelSrcLocal = default(win32.UI.MenusAndResources.HACCEL);
                    int __result = User32.CopyAcceleratorTable(hAccelSrcLocal, lpAccelDstLocal, lpAccelDst.Length);
                    return __result;
                }
            }
            finally
            {
                if (hAccelSrcAddRef)
                    hAccelSrc.DangerousRelease();
            }
        }

        /// <summary>Copies the specified accelerator table. This function is used to obtain the accelerator-table data that corresponds to an accelerator-table handle, or to determine the size of the accelerator-table data.</summary>
        /// <param name = "hAccelSrc">
        /// <para>Type: <b>HACCEL</b></para>
        /// <para>A handle to the accelerator table to copy.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-copyacceleratortablew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpAccelDst">
        /// <para>Type: <b>LPACCEL</b></para>
        /// <para>An array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures that receives the accelerator-table information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-copyacceleratortablew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cAccelEntries">
        /// <para>Type: <b>int</b></para>
        /// <para>The number of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures to copy to the buffer pointed to by the <i>lpAccelDst</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-copyacceleratortablew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If <i>lpAccelDst</i> is <b>NULL</b>, the return value specifies the number of accelerator-table entries in the original table. Otherwise, it specifies the number of accelerator-table entries that were copied.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-copyacceleratortablew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CopyAcceleratorTableW")]
        internal static extern unsafe int CopyAcceleratorTable(win32.UI.MenusAndResources.HACCEL hAccelSrc, [Optional] win32.UI.WindowsAndMessaging.ACCEL*lpAccelDst, int cAccelEntries);
        /// <inheritdoc cref = "TranslateAccelerator(win32.UI.WindowsAndMessaging.HWND, win32.UI.MenusAndResources.HACCEL, win32.UI.WindowsAndMessaging.MSG*)"/>
        internal static unsafe int TranslateAccelerator(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hAccTable, in win32.UI.WindowsAndMessaging.MSG lpMsg)
        {
            bool hAccTableAddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.MSG*lpMsgLocal = &lpMsg)
                {
                    win32.UI.MenusAndResources.HACCEL hAccTableLocal;
                    if (hAccTable is object)
                    {
                        hAccTable.DangerousAddRef(ref hAccTableAddRef);
                        hAccTableLocal = (win32.UI.MenusAndResources.HACCEL)hAccTable.DangerousGetHandle();
                    }
                    else
                        hAccTableLocal = default(win32.UI.MenusAndResources.HACCEL);
                    int __result = User32.TranslateAccelerator(hWnd, hAccTableLocal, lpMsgLocal);
                    return __result;
                }
            }
            finally
            {
                if (hAccTableAddRef)
                    hAccTable.DangerousRelease();
            }
        }

        /// <summary>Processes accelerator keys for menu commands.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose messages are to be translated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-translateacceleratorw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hAccTable">
        /// <para>Type: <b>HACCEL</b></para>
        /// <para>A handle to the accelerator table. The accelerator table must have been loaded by a call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadacceleratorsa">LoadAccelerators</a> function or created by a call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createacceleratortablea">CreateAcceleratorTable</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-translateacceleratorw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMsg">
        /// <para>Type: <b>LPMSG</b></para>
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains message information retrieved from the calling thread's message queue using the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-translateacceleratorw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-translateacceleratorw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "TranslateAcceleratorW", SetLastError = true)]
        internal static extern unsafe int TranslateAccelerator(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.MenusAndResources.HACCEL hAccTable, win32.UI.WindowsAndMessaging.MSG*lpMsg);
        /// <summary>Retrieves the specified system metric or system configuration setting.</summary>
        /// <param name = "nIndex">Type: <b>int</b></param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the requested system metric or configuration setting.</para>
        /// <para>If the function fails, the return value is 0. <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not provide extended error information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getsystemmetrics">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetSystemMetrics(win32.UI.WindowsAndMessaging.SYSTEM_METRICS_INDEX nIndex);
        /// <inheritdoc cref = "LoadMenu(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe User32.DestroyMenuSafeHandle LoadMenu(SafeHandle hInstance, string lpMenuName)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (char *lpMenuNameLocal = lpMenuName)
                {
                    win32.System.SystemServices.HINSTANCE hInstanceLocal;
                    if (hInstance is object)
                    {
                        hInstance.DangerousAddRef(ref hInstanceAddRef);
                        hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                    }
                    else
                        hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                    win32.UI.MenusAndResources.HMENU __result = User32.LoadMenu(hInstanceLocal, lpMenuNameLocal);
                    return new User32.DestroyMenuSafeHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "User32.DestroyMenu"/>.
        /// </summary>
        internal class DestroyMenuSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal DestroyMenuSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal DestroyMenuSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => User32.DestroyMenu((win32.UI.MenusAndResources.HMENU)this.handle);
        }

        /// <summary>Loads the specified menu resource from the executable (.exe) file associated with an application instance.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the module containing the menu resource to be loaded.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadmenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMenuName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The name of the menu resource. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. To create this value, use the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadmenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HMENU</b></para>
        /// <para>If the function succeeds, the return value is a handle to the menu resource.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadmenuw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "LoadMenuW", SetLastError = true)]
        internal static extern win32.UI.MenusAndResources.HMENU LoadMenu(win32.System.SystemServices.HINSTANCE hInstance, win32.System.SystemServices.PCWSTR lpMenuName);
        /// <inheritdoc cref = "LoadMenuIndirect(void *)"/>
        internal static unsafe User32.DestroyMenuSafeHandle LoadMenuIndirect_SafeHandle(void *lpMenuTemplate)
        {
            win32.UI.MenusAndResources.HMENU __result = User32.LoadMenuIndirect(lpMenuTemplate);
            return new User32.DestroyMenuSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>Loads the specified menu template in memory.</summary>
        /// <param name = "lpMenuTemplate">
        /// <para>Type: <b>const MENUTEMPLATE*</b></para>
        /// <para>A pointer to a menu template or an extended menu template. A menu template consists of a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuitemtemplateheader">MENUITEMTEMPLATEHEADER</a> structure followed by one or more contiguous <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuitemtemplate">MENUITEMTEMPLATE</a> structures. An extended menu template consists of a <a href = "https://docs.microsoft.com/windows/desktop/menurc/menuex-template-header">MENUEX_TEMPLATE_HEADER</a> structure followed by one or more contiguous <a href = "https://docs.microsoft.com/windows/desktop/menurc/menuex-template-item">MENUEX_TEMPLATE_ITEM</a> structures.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadmenuindirectw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HMENU</b></para>
        /// <para>If the function succeeds, the return value is a handle to the menu.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadmenuindirectw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "LoadMenuIndirectW", SetLastError = true)]
        internal static extern unsafe win32.UI.MenusAndResources.HMENU LoadMenuIndirect(void *lpMenuTemplate);
        /// <inheritdoc cref = "GetMenu(win32.UI.WindowsAndMessaging.HWND)"/>
        internal static unsafe User32.DestroyMenuSafeHandle GetMenu_SafeHandle(win32.UI.WindowsAndMessaging.HWND hWnd)
        {
            win32.UI.MenusAndResources.HMENU __result = User32.GetMenu(hWnd);
            return new User32.DestroyMenuSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>Retrieves a handle to the menu assigned to the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose menu handle is to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HMENU</b></para>
        /// <para>The return value is a handle to the menu. If the specified window has no menu, the return value is <b>NULL</b>. If the window is a child window, the return value is undefined.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.MenusAndResources.HMENU GetMenu(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <inheritdoc cref = "SetMenu(win32.UI.WindowsAndMessaging.HWND, win32.UI.MenusAndResources.HMENU)"/>
        internal static unsafe bool SetMenu(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hMenu)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                bool __result = User32.SetMenu(hWnd, hMenuLocal);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Assigns a new menu to the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to which the menu is to be assigned.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the new menu. If this parameter is <b>NULL</b>, the window's current menu is removed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetMenu(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.MenusAndResources.HMENU hMenu);
        /// <inheritdoc cref = "ChangeMenu(win32.UI.MenusAndResources.HMENU, uint, win32.System.SystemServices.PCWSTR, uint, uint)"/>
        internal static unsafe bool ChangeMenu(SafeHandle hMenu, uint cmd, string lpszNewItem, uint cmdInsert, uint flags)
        {
            bool hMenuAddRef = false;
            try
            {
                fixed (char *lpszNewItemLocal = lpszNewItem)
                {
                    win32.UI.MenusAndResources.HMENU hMenuLocal;
                    if (hMenu is object)
                    {
                        hMenu.DangerousAddRef(ref hMenuAddRef);
                        hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                    }
                    else
                        hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                    bool __result = User32.ChangeMenu(hMenuLocal, cmd, lpszNewItemLocal, cmdInsert, flags);
                    return __result;
                }
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        [DllImport("User32", ExactSpelling = true, EntryPoint = "ChangeMenuW")]
        internal static extern bool ChangeMenu(win32.UI.MenusAndResources.HMENU hMenu, uint cmd, win32.System.SystemServices.PCWSTR lpszNewItem, uint cmdInsert, uint flags);
        /// <inheritdoc cref = "HiliteMenuItem(win32.UI.WindowsAndMessaging.HWND, win32.UI.MenusAndResources.HMENU, uint, uint)"/>
        internal static unsafe bool HiliteMenuItem(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hMenu, uint uIDHiliteItem, uint uHilite)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                bool __result = User32.HiliteMenuItem(hWnd, hMenuLocal, uIDHiliteItem, uHilite);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Adds or removes highlighting from an item in a menu bar.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that contains the menu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-hilitemenuitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu bar that contains the item.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-hilitemenuitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uIDHiliteItem">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The menu item. This parameter is either the identifier of the menu item or the offset of the menu item in the menu bar, depending on the value of the <i>uHilite</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-hilitemenuitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uHilite">
        /// <para>Type: <b>UINT</b></para>
        /// <para>Controls the interpretation of the <i>uItemHilite</i> parameter and indicates whether the menu item is highlighted. This parameter must be a combination of either <b>MF_BYCOMMAND</b> or <b>MF_BYPOSITION</b> and <b>MF_HILITE</b> or <b>MF_UNHILITE</b>.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-hilitemenuitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the menu item is set to the specified highlight state, the return value is nonzero.</para>
        /// <para>If the menu item is not set to the specified highlight state, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-hilitemenuitem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool HiliteMenuItem(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.MenusAndResources.HMENU hMenu, uint uIDHiliteItem, uint uHilite);
        /// <inheritdoc cref = "GetMenuString(win32.UI.MenusAndResources.HMENU, uint, win32.System.SystemServices.PWSTR, int, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS)"/>
        internal static unsafe int GetMenuString(SafeHandle hMenu, uint uIDItem, win32.System.SystemServices.PWSTR lpString, int cchMax, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS flags)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                int __result = User32.GetMenuString(hMenuLocal, uIDItem, lpString, cchMax, flags);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Copies the text string of the specified menu item into the specified buffer.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenustringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uIDItem">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The menu item to be changed, as determined by the <i>uFlag</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenustringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The buffer that receives the null-terminated string. If the string is as long or longer than <i>lpString</i>, the string is truncated and the terminating null character is added. If <i>lpString</i> is <b>NULL</b>, the function returns the length of the menu string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenustringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchMax">
        /// <para>Type: <b>int</b></para>
        /// <para>The maximum length, in characters, of the string to be copied. If the string is longer than the maximum specified in the <i>nMaxCount</i> parameter, the extra characters are truncated. If <i>nMaxCount</i> is 0, the function returns the length of the menu string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenustringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null character.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// <para>If the specified item is not of type <b>MIIM_STRING</b> or <b>MFT_STRING</b>, then the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenustringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetMenuStringW")]
        internal static extern int GetMenuString(win32.UI.MenusAndResources.HMENU hMenu, uint uIDItem, win32.System.SystemServices.PWSTR lpString, int cchMax, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS flags);
        /// <inheritdoc cref = "GetMenuState(win32.UI.MenusAndResources.HMENU, uint, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS)"/>
        internal static unsafe uint GetMenuState(SafeHandle hMenu, uint uId, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                uint __result = User32.GetMenuState(hMenuLocal, uId, uFlags);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Retrieves the menu flags associated with the specified menu item.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu that contains the menu item whose flags are to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenustate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uId">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The menu item for which the menu flags are to be retrieved, as determined by the <i>uFlags</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenustate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the specified item does not exist, the return value is -1.</para>
        /// <para>If the menu item opens a submenu, the low-order byte of the return value contains the menu flags associated with the item, and the high-order byte contains the number of items in the submenu opened by the item.</para>
        /// <para>Otherwise, the return value is a mask (Bitwise OR) of the menu flags. Following are the menu flags associated with the menu item.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenustate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetMenuState(win32.UI.MenusAndResources.HMENU hMenu, uint uId, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags);
        /// <summary>Redraws the menu bar of the specified window. If the menu bar changes after the system has created the window, this function must be called to draw the changed menu bar.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose menu bar is to be redrawn.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawmenubar#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawmenubar">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DrawMenuBar(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <inheritdoc cref = "GetSystemMenu(win32.UI.WindowsAndMessaging.HWND, bool)"/>
        internal static unsafe User32.DestroyMenuSafeHandle GetSystemMenu_SafeHandle(win32.UI.WindowsAndMessaging.HWND hWnd, bool bRevert)
        {
            win32.UI.MenusAndResources.HMENU __result = User32.GetSystemMenu(hWnd, bRevert);
            return new User32.DestroyMenuSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>Enables the application to access the window menu (also known as the system menu or the control menu) for copying and modifying.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that will own a copy of the window menu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getsystemmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bRevert">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The action to be taken. If this parameter is <b>FALSE</b>, <b>GetSystemMenu</b> returns a handle to the copy of the window menu currently in use. The copy is initially identical to the window menu, but it can be modified. If this parameter is <b>TRUE</b>, <b>GetSystemMenu</b> resets the window menu back to the default state. The previous window menu, if any, is destroyed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getsystemmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HMENU</b></para>
        /// <para>If the <i>bRevert</i> parameter is <b>FALSE</b>, the return value is a handle to a copy of the window menu. If the <i>bRevert</i> parameter is <b>TRUE</b>, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getsystemmenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.MenusAndResources.HMENU GetSystemMenu(win32.UI.WindowsAndMessaging.HWND hWnd, bool bRevert);
        /// <inheritdoc cref = "CreateMenu()"/>
        internal static unsafe User32.DestroyMenuSafeHandle CreateMenu_SafeHandle()
        {
            win32.UI.MenusAndResources.HMENU __result = User32.CreateMenu();
            return new User32.DestroyMenuSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>Creates a menu. The menu is initially empty, but it can be filled with menu items by using the InsertMenuItem, AppendMenu, and InsertMenu functions.</summary>
        /// <returns>
        /// <para>Type: <b>HMENU</b></para>
        /// <para>If the function succeeds, the return value is a handle to the newly created menu.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createmenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.MenusAndResources.HMENU CreateMenu();
        /// <inheritdoc cref = "CreatePopupMenu()"/>
        internal static unsafe User32.DestroyMenuSafeHandle CreatePopupMenu_SafeHandle()
        {
            win32.UI.MenusAndResources.HMENU __result = User32.CreatePopupMenu();
            return new User32.DestroyMenuSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>Creates a drop-down menu, submenu, or shortcut menu.</summary>
        /// <returns>
        /// <para>Type: <b>HMENU</b></para>
        /// <para>If the function succeeds, the return value is a handle to the newly created menu.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createpopupmenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.MenusAndResources.HMENU CreatePopupMenu();
        /// <inheritdoc cref = "CheckMenuItem(win32.UI.MenusAndResources.HMENU, uint, uint)"/>
        internal static unsafe uint CheckMenuItem(SafeHandle hMenu, uint uIDCheckItem, uint uCheck)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                uint __result = User32.CheckMenuItem(hMenuLocal, uIDCheckItem, uCheck);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Sets the state of the specified menu item's check-mark attribute to either selected or clear.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu of interest.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkmenuitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uIDCheckItem">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The menu item whose check-mark attribute is to be set, as determined by the <i>uCheck</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkmenuitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uCheck">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The flags that control the interpretation of the <i>uIDCheckItem</i> parameter and the state of the menu item's check-mark attribute. This parameter can be a combination of either <b>MF_BYCOMMAND</b>, or <b>MF_BYPOSITION</b> and <b>MF_CHECKED</b> or <b>MF_UNCHECKED</b>.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkmenuitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The return value specifies the previous state of the menu item (either <b>MF_CHECKED</b> or <b>MF_UNCHECKED</b>). If the menu item does not exist, the return value is –1.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkmenuitem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint CheckMenuItem(win32.UI.MenusAndResources.HMENU hMenu, uint uIDCheckItem, uint uCheck);
        /// <inheritdoc cref = "EnableMenuItem(win32.UI.MenusAndResources.HMENU, uint, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS)"/>
        internal static unsafe bool EnableMenuItem(SafeHandle hMenu, uint uIDEnableItem, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uEnable)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                bool __result = User32.EnableMenuItem(hMenuLocal, uIDEnableItem, uEnable);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Enables, disables, or grays the specified menu item.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enablemenuitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uIDEnableItem">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The menu item to be enabled, disabled, or grayed, as determined by the <i>uEnable</i> parameter. This parameter specifies an item in a menu bar, menu, or submenu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enablemenuitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uEnable">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The return value specifies the previous state of the menu item (it is either <b>MF_DISABLED</b>, <b>MF_ENABLED</b>, or <b>MF_GRAYED</b>). If the menu item does not exist, the return value is -1.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enablemenuitem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool EnableMenuItem(win32.UI.MenusAndResources.HMENU hMenu, uint uIDEnableItem, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uEnable);
        /// <inheritdoc cref = "GetSubMenu(win32.UI.MenusAndResources.HMENU, int)"/>
        internal static unsafe User32.DestroyMenuSafeHandle GetSubMenu(SafeHandle hMenu, int nPos)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                win32.UI.MenusAndResources.HMENU __result = User32.GetSubMenu(hMenuLocal, nPos);
                return new User32.DestroyMenuSafeHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Retrieves a handle to the drop-down menu or submenu activated by the specified menu item.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getsubmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nPos">
        /// <para>Type: <b>int</b></para>
        /// <para>The zero-based relative position in the specified menu of an item that activates a drop-down menu or submenu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getsubmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HMENU</b></para>
        /// <para>If the function succeeds, the return value is a handle to the drop-down menu or submenu activated by the menu item. If the menu item does not activate a drop-down menu or submenu, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getsubmenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.MenusAndResources.HMENU GetSubMenu(win32.UI.MenusAndResources.HMENU hMenu, int nPos);
        /// <inheritdoc cref = "GetMenuItemID(win32.UI.MenusAndResources.HMENU, int)"/>
        internal static unsafe uint GetMenuItemID(SafeHandle hMenu, int nPos)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                uint __result = User32.GetMenuItemID(hMenuLocal, nPos);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Retrieves the menu item identifier of a menu item located at the specified position in a menu.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu that contains the item whose identifier is to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuitemid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nPos">
        /// <para>Type: <b>int</b></para>
        /// <para>The zero-based relative position of the menu item whose identifier is to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuitemid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>The return value is the identifier of the specified menu item. If the menu item identifier is <b>NULL</b> or if the specified item opens a submenu, the return value is -1.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuitemid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetMenuItemID(win32.UI.MenusAndResources.HMENU hMenu, int nPos);
        /// <inheritdoc cref = "GetMenuItemCount(win32.UI.MenusAndResources.HMENU)"/>
        internal static unsafe int GetMenuItemCount(SafeHandle hMenu)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                int __result = User32.GetMenuItemCount(hMenuLocal);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Determines the number of items in the specified menu.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu to be examined.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuitemcount#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value specifies the number of items in the menu.</para>
        /// <para>If the function fails, the return value is -1. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuitemcount">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetMenuItemCount(win32.UI.MenusAndResources.HMENU hMenu);
        /// <inheritdoc cref = "InsertMenu(win32.UI.MenusAndResources.HMENU, uint, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS, nuint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool InsertMenu(SafeHandle hMenu, uint uPosition, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags, nuint uIDNewItem, string lpNewItem)
        {
            bool hMenuAddRef = false;
            try
            {
                fixed (char *lpNewItemLocal = lpNewItem)
                {
                    win32.UI.MenusAndResources.HMENU hMenuLocal;
                    if (hMenu is object)
                    {
                        hMenu.DangerousAddRef(ref hMenuAddRef);
                        hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                    }
                    else
                        hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                    bool __result = User32.InsertMenu(hMenuLocal, uPosition, uFlags, uIDNewItem, lpNewItemLocal);
                    return __result;
                }
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Inserts a new menu item into a menu, moving other items down the menu.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu to be changed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insertmenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uPosition">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The menu item before which the new menu item is to be inserted, as determined by the <i>uFlags</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insertmenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>Controls the interpretation of the <i>uPosition</i> parameter and the content, appearance, and behavior of the new menu item. This parameter must include one of the following required values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insertmenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uIDNewItem">
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>The identifier of the new menu item or, if the <i>uFlags</i> parameter has the <b>MF_POPUP</b> flag set, a handle to the drop-down menu or submenu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insertmenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewItem">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The content of the new menu item. The interpretation of <i>lpNewItem</i> depends on whether the <i>uFlags</i> parameter includes the <b>MF_BITMAP</b>, <b>MF_OWNERDRAW</b>, or <b>MF_STRING</b> flag, as follows.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insertmenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insertmenuw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "InsertMenuW", SetLastError = true)]
        internal static extern bool InsertMenu(win32.UI.MenusAndResources.HMENU hMenu, uint uPosition, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags, nuint uIDNewItem, win32.System.SystemServices.PCWSTR lpNewItem);
        /// <inheritdoc cref = "AppendMenu(win32.UI.MenusAndResources.HMENU, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS, nuint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool AppendMenu(SafeHandle hMenu, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags, nuint uIDNewItem, string lpNewItem)
        {
            bool hMenuAddRef = false;
            try
            {
                fixed (char *lpNewItemLocal = lpNewItem)
                {
                    win32.UI.MenusAndResources.HMENU hMenuLocal;
                    if (hMenu is object)
                    {
                        hMenu.DangerousAddRef(ref hMenuAddRef);
                        hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                    }
                    else
                        hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                    bool __result = User32.AppendMenu(hMenuLocal, uFlags, uIDNewItem, lpNewItemLocal);
                    return __result;
                }
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Appends a new item to the end of the specified menu bar, drop-down menu, submenu, or shortcut menu. You can use this function to specify the content, appearance, and behavior of the menu item.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu bar, drop-down menu, submenu, or shortcut menu to be changed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-appendmenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">Type: <b>UINT</b></param>
        /// <param name = "uIDNewItem">
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>The identifier of the new menu item or, if the <i>uFlags</i> parameter is set to <b>MF_POPUP</b>, a handle to the drop-down menu or submenu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-appendmenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewItem">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The content of the new menu item. The interpretation of <i>lpNewItem</i> depends on whether the <i>uFlags</i> parameter includes the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-appendmenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-appendmenuw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "AppendMenuW", SetLastError = true)]
        internal static extern bool AppendMenu(win32.UI.MenusAndResources.HMENU hMenu, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags, nuint uIDNewItem, win32.System.SystemServices.PCWSTR lpNewItem);
        /// <inheritdoc cref = "ModifyMenu(win32.UI.MenusAndResources.HMENU, uint, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS, nuint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool ModifyMenu(SafeHandle hMnu, uint uPosition, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags, nuint uIDNewItem, string lpNewItem)
        {
            bool hMnuAddRef = false;
            try
            {
                fixed (char *lpNewItemLocal = lpNewItem)
                {
                    win32.UI.MenusAndResources.HMENU hMnuLocal;
                    if (hMnu is object)
                    {
                        hMnu.DangerousAddRef(ref hMnuAddRef);
                        hMnuLocal = (win32.UI.MenusAndResources.HMENU)hMnu.DangerousGetHandle();
                    }
                    else
                        hMnuLocal = default(win32.UI.MenusAndResources.HMENU);
                    bool __result = User32.ModifyMenu(hMnuLocal, uPosition, uFlags, uIDNewItem, lpNewItemLocal);
                    return __result;
                }
            }
            finally
            {
                if (hMnuAddRef)
                    hMnu.DangerousRelease();
            }
        }

        /// <summary>Changes an existing menu item.</summary>
        /// <param name = "hMnu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu to be changed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-modifymenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uPosition">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The menu item to be changed, as determined by the <i>uFlags</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-modifymenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>Controls the interpretation of the <i>uPosition</i> parameter and the content, appearance, and behavior of the menu item. This parameter must include one of the following required values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-modifymenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uIDNewItem">
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>The identifier of the modified menu item or, if the <i>uFlags</i> parameter has the <b>MF_POPUP</b> flag set, a handle to the drop-down menu or submenu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-modifymenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewItem">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The contents of the changed menu item. The interpretation of this parameter depends on whether the <i>uFlags</i> parameter includes the <b>MF_BITMAP</b>, <b>MF_OWNERDRAW</b>, or <b>MF_STRING</b> flag.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-modifymenuw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-modifymenuw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "ModifyMenuW", SetLastError = true)]
        internal static extern bool ModifyMenu(win32.UI.MenusAndResources.HMENU hMnu, uint uPosition, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags, nuint uIDNewItem, win32.System.SystemServices.PCWSTR lpNewItem);
        /// <inheritdoc cref = "RemoveMenu(win32.UI.MenusAndResources.HMENU, uint, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS)"/>
        internal static unsafe bool RemoveMenu(SafeHandle hMenu, uint uPosition, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                bool __result = User32.RemoveMenu(hMenuLocal, uPosition, uFlags);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Deletes a menu item or detaches a submenu from the specified menu.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu to be changed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-removemenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uPosition">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The menu item to be deleted, as determined by the <i>uFlags</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-removemenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-removemenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool RemoveMenu(win32.UI.MenusAndResources.HMENU hMenu, uint uPosition, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags);
        /// <inheritdoc cref = "DeleteMenu(win32.UI.MenusAndResources.HMENU, uint, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS)"/>
        internal static unsafe bool DeleteMenu(SafeHandle hMenu, uint uPosition, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                bool __result = User32.DeleteMenu(hMenuLocal, uPosition, uFlags);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Deletes an item from the specified menu. If the menu item opens a menu or submenu, this function destroys the handle to the menu or submenu and frees the memory used by the menu or submenu.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu to be changed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deletemenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uPosition">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The menu item to be deleted, as determined by the <i>uFlags</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deletemenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deletemenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DeleteMenu(win32.UI.MenusAndResources.HMENU hMenu, uint uPosition, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags);
        /// <inheritdoc cref = "SetMenuItemBitmaps(win32.UI.MenusAndResources.HMENU, uint, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS, win32.Graphics.Gdi.HBITMAP, win32.Graphics.Gdi.HBITMAP)"/>
        internal static unsafe bool SetMenuItemBitmaps(SafeHandle hMenu, uint uPosition, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags, SafeHandle hBitmapUnchecked, SafeHandle hBitmapChecked)
        {
            bool hMenuAddRef = false;
            bool hBitmapUncheckedAddRef = false;
            bool hBitmapCheckedAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                win32.Graphics.Gdi.HBITMAP hBitmapUncheckedLocal;
                if (hBitmapUnchecked is object)
                {
                    hBitmapUnchecked.DangerousAddRef(ref hBitmapUncheckedAddRef);
                    hBitmapUncheckedLocal = (win32.Graphics.Gdi.HBITMAP)hBitmapUnchecked.DangerousGetHandle();
                }
                else
                    hBitmapUncheckedLocal = default(win32.Graphics.Gdi.HBITMAP);
                win32.Graphics.Gdi.HBITMAP hBitmapCheckedLocal;
                if (hBitmapChecked is object)
                {
                    hBitmapChecked.DangerousAddRef(ref hBitmapCheckedAddRef);
                    hBitmapCheckedLocal = (win32.Graphics.Gdi.HBITMAP)hBitmapChecked.DangerousGetHandle();
                }
                else
                    hBitmapCheckedLocal = default(win32.Graphics.Gdi.HBITMAP);
                bool __result = User32.SetMenuItemBitmaps(hMenuLocal, uPosition, uFlags, hBitmapUncheckedLocal, hBitmapCheckedLocal);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
                if (hBitmapUncheckedAddRef)
                    hBitmapUnchecked.DangerousRelease();
                if (hBitmapCheckedAddRef)
                    hBitmapChecked.DangerousRelease();
            }
        }

        /// <summary>Associates the specified bitmap with a menu item. Whether the menu item is selected or clear, the system displays the appropriate bitmap next to the menu item.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu containing the item to receive new check-mark bitmaps.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenuitembitmaps#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uPosition">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The menu item to be changed, as determined by the <i>uFlags</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenuitembitmaps#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">Type: <b>UINT</b></param>
        /// <param name = "hBitmapUnchecked">
        /// <para>Type: <b>HBITMAP</b></para>
        /// <para>A handle to the bitmap displayed when the menu item is not selected.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenuitembitmaps#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hBitmapChecked">
        /// <para>Type: <b>HBITMAP</b></para>
        /// <para>A handle to the bitmap displayed when the menu item is selected.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenuitembitmaps#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenuitembitmaps">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetMenuItemBitmaps(win32.UI.MenusAndResources.HMENU hMenu, uint uPosition, win32.UI.WindowsAndMessaging.MENU_ITEM_FLAGS uFlags, win32.Graphics.Gdi.HBITMAP hBitmapUnchecked, win32.Graphics.Gdi.HBITMAP hBitmapChecked);
        /// <summary>Retrieves the dimensions of the default check-mark bitmap.</summary>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>The return value specifies the height and width, in pixels, of the default check-mark bitmap. The high-order word contains the height; the low-order word contains the width.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenucheckmarkdimensions">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern int GetMenuCheckMarkDimensions();
        /// <inheritdoc cref = "TrackPopupMenu(win32.UI.MenusAndResources.HMENU, win32.UI.WindowsAndMessaging.TRACK_POPUP_MENU_FLAGS, int, int, int, win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool TrackPopupMenu(SafeHandle hMenu, win32.UI.WindowsAndMessaging.TRACK_POPUP_MENU_FLAGS uFlags, int x, int y, int nReserved, win32.UI.WindowsAndMessaging.HWND hWnd, in win32.UI.DisplayDevices.RECT prcRect)
        {
            bool hMenuAddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*prcRectLocal = &prcRect)
                {
                    win32.UI.MenusAndResources.HMENU hMenuLocal;
                    if (hMenu is object)
                    {
                        hMenu.DangerousAddRef(ref hMenuAddRef);
                        hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                    }
                    else
                        hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                    bool __result = User32.TrackPopupMenu(hMenuLocal, uFlags, x, y, nReserved, hWnd, prcRectLocal);
                    return __result;
                }
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Displays a shortcut menu at the specified location and tracks the selection of items on the menu. The shortcut menu can appear anywhere on the screen.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the shortcut menu to be displayed. The handle can be obtained by calling <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createpopupmenu">CreatePopupMenu</a> to create a new shortcut menu, or by calling <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsubmenu">GetSubMenu</a> to retrieve a handle to a submenu associated with an existing menu item.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>Use zero of more of these flags to specify function options.</para>
        /// <para>Use one of the following flags to specify how the function positions the shortcut menu horizontally.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "x">
        /// <para>Type: <b>int</b></para>
        /// <para>The horizontal location of the shortcut menu, in screen coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "y">
        /// <para>Type: <b>int</b></para>
        /// <para>The vertical location of the shortcut menu, in screen coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nReserved">
        /// <para>Type: <b>int</b></para>
        /// <para>Reserved; must be zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that owns the shortcut menu. This window receives all messages from the menu. The window does not receive a <a href = "https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> message from the menu until the function returns. If you specify TPM_NONOTIFY in the <i>uFlags</i> parameter, the function does not send messages to the window identified by <i>hWnd</i>. However, you must still pass a window handle in <i>hWnd</i>. It can be any window handle from your application.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "prcRect">
        /// <para>Type: <b>const RECT*</b></para>
        /// <para>Ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenu#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If you specify <b>TPM_RETURNCMD</b> in the <i>uFlags</i> parameter, the return value is the menu-item identifier of the item that the user selected. If the user cancels the menu without making a selection, or if an error occurs, the return value is zero.</para>
        /// <para>If you do not specify <b>TPM_RETURNCMD</b> in the <i>uFlags</i> parameter, the return value is nonzero if the function succeeds and zero if it fails. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool TrackPopupMenu(win32.UI.MenusAndResources.HMENU hMenu, win32.UI.WindowsAndMessaging.TRACK_POPUP_MENU_FLAGS uFlags, int x, int y, int nReserved, win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.RECT*prcRect);
        /// <inheritdoc cref = "TrackPopupMenuEx(win32.UI.MenusAndResources.HMENU, uint, int, int, win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.TPMPARAMS*)"/>
        internal static unsafe bool TrackPopupMenuEx(SafeHandle hMenu, uint uFlags, int x, int y, win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.WindowsAndMessaging.TPMPARAMS? lptpm)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                win32.UI.WindowsAndMessaging.TPMPARAMS lptpmLocal = lptpm.HasValue ? lptpm.Value : default(win32.UI.WindowsAndMessaging.TPMPARAMS);
                bool __result = User32.TrackPopupMenuEx(hMenuLocal, uFlags, x, y, hwnd, lptpm.HasValue ? &lptpmLocal : null);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Displays a shortcut menu at the specified location and tracks the selection of items on the shortcut menu. The shortcut menu can appear anywhere on the screen.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the shortcut menu to be displayed. This handle can be obtained by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createpopupmenu">CreatePopupMenu</a> function to create a new shortcut menu or by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsubmenu">GetSubMenu</a> function to retrieve a handle to a submenu associated with an existing menu item.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenuex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>Specifies function options.</para>
        /// <para>Use one of the following flags to specify how the function positions the shortcut menu horizontally.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenuex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "x">
        /// <para>Type: <b>int</b></para>
        /// <para>The horizontal location of the shortcut menu, in screen coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenuex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "y">
        /// <para>Type: <b>int</b></para>
        /// <para>The vertical location of the shortcut menu, in screen coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenuex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that owns the shortcut menu. This window receives all messages from the menu. The window does not receive a <a href = "https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> message from the menu until the function returns. If you specify TPM_NONOTIFY in the <i>fuFlags</i> parameter, the function does not send messages to the window identified by <i>hwnd</i>. However, you must still pass a window handle in <i>hwnd</i>. It can be any window handle from your application.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenuex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lptpm">
        /// <para>Type: <b>LPTPMPARAMS</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-tpmparams">TPMPARAMS</a> structure that specifies an area of the screen the menu should not overlap. This parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenuex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If you specify <b>TPM_RETURNCMD</b> in the <i>fuFlags</i> parameter, the return value is the menu-item identifier of the item that the user selected. If the user cancels the menu without making a selection, or if an error occurs, the return value is zero.</para>
        /// <para>If you do not specify <b>TPM_RETURNCMD</b> in the <i>fuFlags</i> parameter, the return value is nonzero if the function succeeds and zero if it fails. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackpopupmenuex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool TrackPopupMenuEx(win32.UI.MenusAndResources.HMENU hMenu, uint uFlags, int x, int y, win32.UI.WindowsAndMessaging.HWND hwnd, [Optional] win32.UI.WindowsAndMessaging.TPMPARAMS*lptpm);
        /// <inheritdoc cref = "CalculatePopupWindowPosition(win32.UI.DisplayDevices.POINT*, win32.UI.DisplayDevices.SIZE*, uint, win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool CalculatePopupWindowPosition(in win32.UI.DisplayDevices.POINT anchorPoint, in win32.UI.DisplayDevices.SIZE windowSize, uint flags, win32.UI.DisplayDevices.RECT? excludeRect, out win32.UI.DisplayDevices.RECT popupWindowPosition)
        {
            fixed (win32.UI.DisplayDevices.RECT*popupWindowPositionLocal = &popupWindowPosition)
            {
                fixed (win32.UI.DisplayDevices.SIZE*windowSizeLocal = &windowSize)
                {
                    fixed (win32.UI.DisplayDevices.POINT*anchorPointLocal = &anchorPoint)
                    {
                        win32.UI.DisplayDevices.RECT excludeRectLocal = excludeRect.HasValue ? excludeRect.Value : default(win32.UI.DisplayDevices.RECT);
                        bool __result = User32.CalculatePopupWindowPosition(anchorPointLocal, windowSizeLocal, flags, excludeRect.HasValue ? &excludeRectLocal : null, popupWindowPositionLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Calculates an appropriate pop-up window position using the specified anchor point, pop-up window size, flags, and the optional exclude rectangle.</summary>
        /// <param name = "anchorPoint">
        /// <para>Type: <b>const POINT*</b></para>
        /// <para>The specified anchor point.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-calculatepopupwindowposition#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "windowSize">
        /// <para>Type: <b>const SIZE*</b></para>
        /// <para>The specified window size.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-calculatepopupwindowposition#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>Use one of the following flags to specify how the function positions the pop-up window horizontally and vertically. The flags are the same as the vertical and horizontal positioning flags of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackpopupmenuex">TrackPopupMenuEx</a> function.</para>
        /// <para>Use one of the following flags to specify how the function positions the pop-up window horizontally.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-calculatepopupwindowposition#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "excludeRect">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b></para>
        /// <para>A pointer to a structure that specifies the exclude rectangle. It can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-calculatepopupwindowposition#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "popupWindowPosition">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b></para>
        /// <para>A pointer to a structure that specifies the pop-up window position.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-calculatepopupwindowposition#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, it returns <b>TRUE</b>; otherwise, it returns <b>FALSE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-calculatepopupwindowposition">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool CalculatePopupWindowPosition(win32.UI.DisplayDevices.POINT*anchorPoint, win32.UI.DisplayDevices.SIZE*windowSize, uint flags, [Optional] win32.UI.DisplayDevices.RECT*excludeRect, win32.UI.DisplayDevices.RECT*popupWindowPosition);
        /// <inheritdoc cref = "GetMenuInfo(win32.UI.MenusAndResources.HMENU, win32.UI.WindowsAndMessaging.MENUINFO*)"/>
        internal static unsafe bool GetMenuInfo(SafeHandle param0, ref win32.UI.WindowsAndMessaging.MENUINFO param1)
        {
            bool param0AddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.MENUINFO*param1Local = &param1)
                {
                    win32.UI.MenusAndResources.HMENU param0Local;
                    if (param0 is object)
                    {
                        param0.DangerousAddRef(ref param0AddRef);
                        param0Local = (win32.UI.MenusAndResources.HMENU)param0.DangerousGetHandle();
                    }
                    else
                        param0Local = default(win32.UI.MenusAndResources.HMENU);
                    bool __result = User32.GetMenuInfo(param0Local, param1Local);
                    return __result;
                }
            }
            finally
            {
                if (param0AddRef)
                    param0.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about a specified menu.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetMenuInfo(win32.UI.MenusAndResources.HMENU param0, win32.UI.WindowsAndMessaging.MENUINFO*param1);
        /// <inheritdoc cref = "SetMenuInfo(win32.UI.MenusAndResources.HMENU, win32.UI.WindowsAndMessaging.MENUINFO*)"/>
        internal static unsafe bool SetMenuInfo(SafeHandle param0, in win32.UI.WindowsAndMessaging.MENUINFO param1)
        {
            bool param0AddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.MENUINFO*param1Local = &param1)
                {
                    win32.UI.MenusAndResources.HMENU param0Local;
                    if (param0 is object)
                    {
                        param0.DangerousAddRef(ref param0AddRef);
                        param0Local = (win32.UI.MenusAndResources.HMENU)param0.DangerousGetHandle();
                    }
                    else
                        param0Local = default(win32.UI.MenusAndResources.HMENU);
                    bool __result = User32.SetMenuInfo(param0Local, param1Local);
                    return __result;
                }
            }
            finally
            {
                if (param0AddRef)
                    param0.DangerousRelease();
            }
        }

        /// <summary>Sets information for a specified menu.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenuinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetMenuInfo(win32.UI.MenusAndResources.HMENU param0, win32.UI.WindowsAndMessaging.MENUINFO*param1);
        /// <summary>Ends the calling thread's active menu.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-endmenu">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool EndMenu();
        /// <inheritdoc cref = "InsertMenuItem(win32.UI.MenusAndResources.HMENU, uint, bool, win32.UI.WindowsAndMessaging.MENUITEMINFOW*)"/>
        internal static unsafe bool InsertMenuItem(SafeHandle hmenu, uint item, bool fByPosition, in win32.UI.WindowsAndMessaging.MENUITEMINFOW lpmi)
        {
            bool hmenuAddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.MENUITEMINFOW*lpmiLocal = &lpmi)
                {
                    win32.UI.MenusAndResources.HMENU hmenuLocal;
                    if (hmenu is object)
                    {
                        hmenu.DangerousAddRef(ref hmenuAddRef);
                        hmenuLocal = (win32.UI.MenusAndResources.HMENU)hmenu.DangerousGetHandle();
                    }
                    else
                        hmenuLocal = default(win32.UI.MenusAndResources.HMENU);
                    bool __result = User32.InsertMenuItem(hmenuLocal, item, fByPosition, lpmiLocal);
                    return __result;
                }
            }
            finally
            {
                if (hmenuAddRef)
                    hmenu.DangerousRelease();
            }
        }

        /// <summary>Inserts a new menu item at the specified position in a menu.</summary>
        /// <param name = "hmenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu in which the new menu item is inserted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insertmenuitemw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "item">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The identifier or position of the menu item before which to insert the new item. The meaning of this parameter depends on the value of <i>fByPosition</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insertmenuitemw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fByPosition">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Controls the meaning of <i>item</i>. If this parameter is <b>FALSE</b>, <i>item</i> is a menu item identifier. Otherwise, it is a menu item position. See <a href = "https://docs.microsoft.com/windows/desktop/menurc/about-menus">Accessing Menu Items Programmatically</a> for more information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insertmenuitemw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpmi">
        /// <para>Type: <b>LPCMENUITEMINFO</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> structure that contains information about the new menu item.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insertmenuitemw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-insertmenuitemw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "InsertMenuItemW", SetLastError = true)]
        internal static extern unsafe bool InsertMenuItem(win32.UI.MenusAndResources.HMENU hmenu, uint item, bool fByPosition, win32.UI.WindowsAndMessaging.MENUITEMINFOW*lpmi);
        /// <inheritdoc cref = "GetMenuItemInfo(win32.UI.MenusAndResources.HMENU, uint, bool, win32.UI.WindowsAndMessaging.MENUITEMINFOW*)"/>
        internal static unsafe bool GetMenuItemInfo(SafeHandle hmenu, uint item, bool fByPosition, ref win32.UI.WindowsAndMessaging.MENUITEMINFOW lpmii)
        {
            bool hmenuAddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.MENUITEMINFOW*lpmiiLocal = &lpmii)
                {
                    win32.UI.MenusAndResources.HMENU hmenuLocal;
                    if (hmenu is object)
                    {
                        hmenu.DangerousAddRef(ref hmenuAddRef);
                        hmenuLocal = (win32.UI.MenusAndResources.HMENU)hmenu.DangerousGetHandle();
                    }
                    else
                        hmenuLocal = default(win32.UI.MenusAndResources.HMENU);
                    bool __result = User32.GetMenuItemInfo(hmenuLocal, item, fByPosition, lpmiiLocal);
                    return __result;
                }
            }
            finally
            {
                if (hmenuAddRef)
                    hmenu.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about a menu item.</summary>
        /// <param name = "hmenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu that contains the menu item.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuiteminfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "item">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The identifier or position of the menu item to get information about. The meaning of this parameter depends on the value of <i>fByPosition</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuiteminfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fByPosition">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The meaning of <i>uItem</i>. If this parameter is <b>FALSE</b>, <i>uItem</i> is a menu item identifier. Otherwise, it is a menu item position. See <a href = "https://docs.microsoft.com/windows/desktop/menurc/about-menus">Accessing Menu Items Programmatically</a> for more information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuiteminfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpmii">
        /// <para>Type: <b>LPMENUITEMINFO</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> structure that specifies the information to retrieve and receives information about the menu item. Note that you must set the <b>cbSize</b> member to <c>sizeof(MENUITEMINFO)</c> before calling this function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuiteminfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuiteminfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetMenuItemInfoW", SetLastError = true)]
        internal static extern unsafe bool GetMenuItemInfo(win32.UI.MenusAndResources.HMENU hmenu, uint item, bool fByPosition, win32.UI.WindowsAndMessaging.MENUITEMINFOW*lpmii);
        /// <inheritdoc cref = "SetMenuItemInfo(win32.UI.MenusAndResources.HMENU, uint, bool, win32.UI.WindowsAndMessaging.MENUITEMINFOW*)"/>
        internal static unsafe bool SetMenuItemInfo(SafeHandle hmenu, uint item, bool fByPositon, in win32.UI.WindowsAndMessaging.MENUITEMINFOW lpmii)
        {
            bool hmenuAddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.MENUITEMINFOW*lpmiiLocal = &lpmii)
                {
                    win32.UI.MenusAndResources.HMENU hmenuLocal;
                    if (hmenu is object)
                    {
                        hmenu.DangerousAddRef(ref hmenuAddRef);
                        hmenuLocal = (win32.UI.MenusAndResources.HMENU)hmenu.DangerousGetHandle();
                    }
                    else
                        hmenuLocal = default(win32.UI.MenusAndResources.HMENU);
                    bool __result = User32.SetMenuItemInfo(hmenuLocal, item, fByPositon, lpmiiLocal);
                    return __result;
                }
            }
            finally
            {
                if (hmenuAddRef)
                    hmenu.DangerousRelease();
            }
        }

        /// <summary>Changes information about a menu item.</summary>
        /// <param name = "hmenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu that contains the menu item.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenuiteminfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "item">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The identifier or position of the menu item to change. The meaning of this parameter depends on the value of <i>fByPosition</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenuiteminfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fByPositon">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The meaning of <i>uItem</i>. If this parameter is <b>FALSE</b>, <i>uItem</i> is a menu item identifier. Otherwise, it is a menu item position. See <a href = "https://docs.microsoft.com/windows/desktop/menurc/about-menus">About Menus</a> for more information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenuiteminfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpmii">
        /// <para>Type: <b>LPMENUITEMINFO</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> structure that contains information about the menu item and specifies which menu item attributes to change.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenuiteminfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenuiteminfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SetMenuItemInfoW", SetLastError = true)]
        internal static extern unsafe bool SetMenuItemInfo(win32.UI.MenusAndResources.HMENU hmenu, uint item, bool fByPositon, win32.UI.WindowsAndMessaging.MENUITEMINFOW*lpmii);
        /// <inheritdoc cref = "GetMenuDefaultItem(win32.UI.MenusAndResources.HMENU, uint, win32.UI.WindowsAndMessaging.GET_MENU_DEFAULT_ITEM_FLAGS)"/>
        internal static unsafe uint GetMenuDefaultItem(SafeHandle hMenu, uint fByPos, win32.UI.WindowsAndMessaging.GET_MENU_DEFAULT_ITEM_FLAGS gmdiFlags)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                uint __result = User32.GetMenuDefaultItem(hMenuLocal, fByPos, gmdiFlags);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Determines the default menu item on the specified menu.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu for which to retrieve the default menu item.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenudefaultitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fByPos">
        /// <para>Type: <b>UINT</b></para>
        /// <para>Indicates whether to retrieve the menu item's identifier or its position. If this parameter is <b>FALSE</b>, the identifier is returned. Otherwise, the position is returned.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenudefaultitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "gmdiFlags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the return value is the identifier or position of the menu item.</para>
        /// <para>If the function fails, the return value is -1. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenudefaultitem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetMenuDefaultItem(win32.UI.MenusAndResources.HMENU hMenu, uint fByPos, win32.UI.WindowsAndMessaging.GET_MENU_DEFAULT_ITEM_FLAGS gmdiFlags);
        /// <inheritdoc cref = "SetMenuDefaultItem(win32.UI.MenusAndResources.HMENU, uint, uint)"/>
        internal static unsafe bool SetMenuDefaultItem(SafeHandle hMenu, uint uItem, uint fByPos)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                bool __result = User32.SetMenuDefaultItem(hMenuLocal, uItem, fByPos);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Sets the default menu item for the specified menu.</summary>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu to set the default item for.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenudefaultitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uItem">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The identifier or position of the new default menu item or -1 for no default item. The meaning of this parameter depends on the value of <i>fByPos</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenudefaultitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fByPos">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The meaning of <i>uItem</i>. If this parameter is <b>FALSE</b>, <i>uItem</i> is a menu item identifier. Otherwise, it is a menu item position. See <a href = "https://docs.microsoft.com/windows/desktop/menurc/about-menus">About Menus</a> for more information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenudefaultitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenudefaultitem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetMenuDefaultItem(win32.UI.MenusAndResources.HMENU hMenu, uint uItem, uint fByPos);
        /// <inheritdoc cref = "GetMenuItemRect(win32.UI.WindowsAndMessaging.HWND, win32.UI.MenusAndResources.HMENU, uint, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool GetMenuItemRect(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hMenu, uint uItem, out win32.UI.DisplayDevices.RECT lprcItem)
        {
            bool hMenuAddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcItemLocal = &lprcItem)
                {
                    win32.UI.MenusAndResources.HMENU hMenuLocal;
                    if (hMenu is object)
                    {
                        hMenu.DangerousAddRef(ref hMenuAddRef);
                        hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                    }
                    else
                        hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                    bool __result = User32.GetMenuItemRect(hWnd, hMenuLocal, uItem, lprcItemLocal);
                    return __result;
                }
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Retrieves the bounding rectangle for the specified menu item.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window containing the menu.</para>
        /// <para>If this value is <b>NULL</b> and the <i>hMenu</i> parameter represents a popup menu, the function will find the menu window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuitemrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to a menu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuitemrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uItem">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The zero-based position of the menu item.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuitemrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lprcItem">
        /// <para>Type: <b>LPRECT</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the bounding rectangle of the specified menu item expressed in screen coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuitemrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenuitemrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetMenuItemRect(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.MenusAndResources.HMENU hMenu, uint uItem, win32.UI.DisplayDevices.RECT*lprcItem);
        /// <inheritdoc cref = "MenuItemFromPoint(win32.UI.WindowsAndMessaging.HWND, win32.UI.MenusAndResources.HMENU, win32.UI.DisplayDevices.POINT)"/>
        internal static unsafe int MenuItemFromPoint(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hMenu, win32.UI.DisplayDevices.POINT ptScreen)
        {
            bool hMenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hMenuLocal;
                if (hMenu is object)
                {
                    hMenu.DangerousAddRef(ref hMenuAddRef);
                    hMenuLocal = (win32.UI.MenusAndResources.HMENU)hMenu.DangerousGetHandle();
                }
                else
                    hMenuLocal = default(win32.UI.MenusAndResources.HMENU);
                int __result = User32.MenuItemFromPoint(hWnd, hMenuLocal, ptScreen);
                return __result;
            }
            finally
            {
                if (hMenuAddRef)
                    hMenu.DangerousRelease();
            }
        }

        /// <summary>Determines which menu item, if any, is at the specified location.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window containing the menu. If this value is <b>NULL</b> and the <i>hMenu</i> parameter represents a popup menu, the function will find the menu window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-menuitemfrompoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hMenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu containing the menu items to hit test.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-menuitemfrompoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ptScreen">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a></b></para>
        /// <para>A structure that specifies the location to test. If <i>hMenu</i> specifies a menu bar, this parameter is in window coordinates. Otherwise, it is in client coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-menuitemfrompoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>Returns the zero-based position of the menu item at the specified location or -1 if no menu item is at the specified location.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-menuitemfrompoint">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern int MenuItemFromPoint(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.MenusAndResources.HMENU hMenu, win32.UI.DisplayDevices.POINT ptScreen);
        /// <inheritdoc cref = "DragObject(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.HWND, uint, nuint, win32.UI.MenusAndResources.HCURSOR)"/>
        internal static unsafe uint DragObject(win32.UI.WindowsAndMessaging.HWND hwndParent, win32.UI.WindowsAndMessaging.HWND hwndFrom, uint fmt, nuint data, SafeHandle hcur)
        {
            bool hcurAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HCURSOR hcurLocal;
                if (hcur is object)
                {
                    hcur.DangerousAddRef(ref hcurAddRef);
                    hcurLocal = (win32.UI.MenusAndResources.HCURSOR)hcur.DangerousGetHandle();
                }
                else
                    hcurLocal = default(win32.UI.MenusAndResources.HCURSOR);
                uint __result = User32.DragObject(hwndParent, hwndFrom, fmt, data, hcurLocal);
                return __result;
            }
            finally
            {
                if (hcurAddRef)
                    hcur.DangerousRelease();
            }
        }

        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint DragObject(win32.UI.WindowsAndMessaging.HWND hwndParent, win32.UI.WindowsAndMessaging.HWND hwndFrom, uint fmt, nuint data, win32.UI.MenusAndResources.HCURSOR hcur);
        /// <inheritdoc cref = "DrawIcon(win32.Graphics.Gdi.HDC, int, int, win32.UI.MenusAndResources.HICON)"/>
        internal static unsafe bool DrawIcon(SafeHandle hDC, int X, int Y, SafeHandle hIcon)
        {
            bool hDCAddRef = false;
            bool hIconAddRef = false;
            try
            {
                win32.Graphics.Gdi.HDC hDCLocal;
                if (hDC is object)
                {
                    hDC.DangerousAddRef(ref hDCAddRef);
                    hDCLocal = (win32.Graphics.Gdi.HDC)hDC.DangerousGetHandle();
                }
                else
                    hDCLocal = default(win32.Graphics.Gdi.HDC);
                win32.UI.MenusAndResources.HICON hIconLocal;
                if (hIcon is object)
                {
                    hIcon.DangerousAddRef(ref hIconAddRef);
                    hIconLocal = (win32.UI.MenusAndResources.HICON)hIcon.DangerousGetHandle();
                }
                else
                    hIconLocal = default(win32.UI.MenusAndResources.HICON);
                bool __result = User32.DrawIcon(hDCLocal, X, Y, hIconLocal);
                return __result;
            }
            finally
            {
                if (hDCAddRef)
                    hDC.DangerousRelease();
                if (hIconAddRef)
                    hIcon.DangerousRelease();
            }
        }

        /// <summary>Draws an icon or cursor into the specified device context.</summary>
        /// <param name = "hDC">
        /// <para>Type: <b>HDC</b></para>
        /// <para>A handle to the device context into which the icon or cursor will be drawn.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "X">
        /// <para>Type: <b>int</b></para>
        /// <para>The logical x-coordinate of the upper-left corner of the icon.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Y">
        /// <para>Type: <b>int</b></para>
        /// <para>The logical y-coordinate of the upper-left corner of the icon.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hIcon">
        /// <para>Type: <b>HICON</b></para>
        /// <para>A handle to the icon to be drawn.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawicon">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DrawIcon(win32.Graphics.Gdi.HDC hDC, int X, int Y, win32.UI.MenusAndResources.HICON hIcon);
        /// <summary>Retrieves a handle to the foreground window (the window with which the user is currently working). The system assigns a slightly higher priority to the thread that creates the foreground window than it does to other threads.</summary>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is a handle to the foreground window. The foreground window can be <b>NULL</b> in certain circumstances, such as when a window is losing activation.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getforegroundwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetForegroundWindow();
        /// <summary>Switches focus to the specified window and brings it to the foreground.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-switchtothiswindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fUnknown">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>A <b>TRUE</b> for this parameter indicates that the window is being switched to using the Alt/Ctl+Tab key sequence.  This parameter should be <b>FALSE</b> otherwise.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-switchtothiswindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>This function is typically called to maintain window z-ordering.</para>
        /// <para>This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server 2003. If you do not have a header file and import library for this function, you can call the function using <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-switchtothiswindow#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern void SwitchToThisWindow(win32.UI.WindowsAndMessaging.HWND hwnd, bool fUnknown);
        /// <summary>Brings the thread that created the specified window into the foreground and activates the window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that should be activated and brought to the foreground.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setforegroundwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b> If the window was brought to the foreground, the return value is nonzero.</para>
        /// <para>If the window was not brought to the foreground, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setforegroundwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool SetForegroundWindow(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Enables the specified process to set the foreground window using the SetForegroundWindow function. The calling process must already be able to set the foreground window. For more information, see Remarks later in this topic.</summary>
        /// <param name = "dwProcessId">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The identifier of the process that will be enabled to set the foreground window. If this parameter is <b>ASFW_ANY</b>, all processes will be enabled to set the foreground window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-allowsetforegroundwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. The function will fail if the calling process cannot set the foreground window. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-allowsetforegroundwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool AllowSetForegroundWindow(uint dwProcessId);
        /// <summary>The foreground process can call the LockSetForegroundWindow function to disable calls to the SetForegroundWindow function.</summary>
        /// <param name = "uLockCode">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-locksetforegroundwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool LockSetForegroundWindow(win32.UI.WindowsAndMessaging.FOREGROUND_WINDOW_LOCK_CODE uLockCode);
        /// <inheritdoc cref = "SetProp(win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool SetProp(win32.UI.WindowsAndMessaging.HWND hWnd, string lpString, SafeHandle hData)
        {
            bool hDataAddRef = false;
            try
            {
                fixed (char *lpStringLocal = lpString)
                {
                    win32.System.SystemServices.HANDLE hDataLocal;
                    if (hData is object)
                    {
                        hData.DangerousAddRef(ref hDataAddRef);
                        hDataLocal = (win32.System.SystemServices.HANDLE)hData.DangerousGetHandle();
                    }
                    else
                        hDataLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = User32.SetProp(hWnd, lpStringLocal, hDataLocal);
                    return __result;
                }
            }
            finally
            {
                if (hDataAddRef)
                    hData.DangerousRelease();
            }
        }

        /// <summary>Adds a new entry or changes an existing entry in the property list of the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose property list receives the new entry.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setpropw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>A null-terminated string or an atom that identifies a string. If this parameter is an atom, it must be a global atom created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globaladdatoma">GlobalAddAtom</a> function. The atom must be placed in the low-order word of <i>lpString</i>; the high-order word must be zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setpropw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hData">
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>A handle to the data to be copied to the property list. The data handle can identify any value useful to the application.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setpropw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the data handle and string are added to the property list, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setpropw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SetPropW", SetLastError = true)]
        internal static extern bool SetProp(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PCWSTR lpString, win32.System.SystemServices.HANDLE hData);
        /// <inheritdoc cref = "GetProp(win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle GetProp(win32.UI.WindowsAndMessaging.HWND hWnd, string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                win32.System.SystemServices.HANDLE __result = User32.GetProp(hWnd, lpStringLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Retrieves a data handle from the property list of the specified window. The character string identifies the handle to be retrieved. The string and handle must have been added to the property list by a previous call to the SetProp function.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose property list is to be searched.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpropw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>An atom that identifies a string. If this parameter is an atom, it must have been created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globaladdatoma">GlobalAddAtom</a> function. The atom, a 16-bit value, must be placed in the low-order word of the <i>lpString</i> parameter; the high-order word must be zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpropw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>If the property list contains the string, the return value is the associated data handle. Otherwise, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpropw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetPropW")]
        internal static extern win32.System.SystemServices.HANDLE GetProp(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PCWSTR lpString);
        /// <inheritdoc cref = "RemoveProp(win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle RemoveProp(win32.UI.WindowsAndMessaging.HWND hWnd, string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                win32.System.SystemServices.HANDLE __result = User32.RemoveProp(hWnd, lpStringLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Removes an entry from the property list of the specified window. The specified character string identifies the entry to be removed.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose property list is to be changed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-removepropw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>A null-terminated character string or an atom that identifies a string. If this parameter is an atom, it must have been created using the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globaladdatoma">GlobalAddAtom</a> function. The atom, a 16-bit value, must be placed in the low-order word of <i>lpString</i>; the high-order word must be zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-removepropw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>The return value identifies the specified data. If the data cannot be found in the specified property list, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-removepropw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "RemovePropW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE RemoveProp(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PCWSTR lpString);
        /// <summary>Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function. EnumPropsEx continues until the last entry is enumerated or the callback function returns FALSE.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose property list is to be enumerated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumpropsexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEnumFunc">
        /// <para>Type: <b>PROPENUMPROCEX</b></para>
        /// <para>A pointer to the callback function. For more information about the callback function, see the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-propenumprocexa">PropEnumProcEx</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumpropsexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Application-defined data to be passed to the callback function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumpropsexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>The return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumpropsexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "EnumPropsExW")]
        internal static extern unsafe int EnumPropsEx(win32.UI.WindowsAndMessaging.HWND hWnd, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PWSTR, win32.System.SystemServices.HANDLE, nuint, win32.System.SystemServices.BOOL>lpEnumFunc, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function. EnumProps continues until the last entry is enumerated or the callback function returns FALSE.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose property list is to be enumerated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumpropsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEnumFunc">
        /// <para>Type: <b>PROPENUMPROC</b></para>
        /// <para>A pointer to the callback function. For more information about the callback function, see the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-propenumproca">PropEnumProc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumpropsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>The return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumpropsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "EnumPropsW")]
        internal static extern unsafe int EnumProps(win32.UI.WindowsAndMessaging.HWND hWnd, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.HANDLE, win32.System.SystemServices.BOOL>lpEnumFunc);
        /// <inheritdoc cref = "SetWindowText(win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetWindowText(win32.UI.WindowsAndMessaging.HWND hWnd, string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                bool __result = User32.SetWindowText(hWnd, lpStringLocal);
                return __result;
            }
        }

        /// <summary>Changes the text of the specified window's title bar (if it has one). If the specified window is a control, the text of the control is changed. However, SetWindowText cannot change the text of a control in another application.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window or control whose text is to be changed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The new title or control text.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowtextw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SetWindowTextW", SetLastError = true)]
        internal static extern bool SetWindowText(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PCWSTR lpString);
        /// <summary>Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another application.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window or control containing the text.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The buffer that will receive the text. If the string is as long or longer than the buffer, the string is truncated and terminated with a null character.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nMaxCount">
        /// <para>Type: <b>int</b></para>
        /// <para>The maximum number of characters to copy to the buffer, including the null character. If the text exceeds this limit, it is truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null character. If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>This function cannot retrieve the text of an edit control in another application.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowtextw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetWindowTextW", SetLastError = true)]
        internal static extern int GetWindowText(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PWSTR lpString, int nMaxCount);
        /// <summary>Retrieves the length, in characters, of the specified window's title bar text (if the window has a title bar).</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window or control.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowtextlengthw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the length, in characters, of the text. Under certain conditions, this value might be greater than the length of the text (see Remarks).</para>
        /// <para>If the window has no text, the return value is zero.</para>
        /// <para>Function failure is indicated by a return value of zero and a <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero.</para>
        /// <para>> [!NOTE] > This function does not clear the most recent error information. To determine success or failure, clear the most recent error information by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0, then call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowtextlengthw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetWindowTextLengthW", SetLastError = true)]
        internal static extern int GetWindowTextLength(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <inheritdoc cref = "GetClientRect(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool GetClientRect(win32.UI.WindowsAndMessaging.HWND hWnd, out win32.UI.DisplayDevices.RECT lpRect)
        {
            fixed (win32.UI.DisplayDevices.RECT*lpRectLocal = &lpRect)
            {
                bool __result = User32.GetClientRect(hWnd, lpRectLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the coordinates of a window's client area.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose client coordinates are to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclientrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpRect">
        /// <para>Type: <b>LPRECT</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the client coordinates. The <b>left</b> and <b>top</b> members are zero. The <b>right</b> and <b>bottom</b> members contain the width and height of the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclientrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclientrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetClientRect(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.RECT*lpRect);
        /// <inheritdoc cref = "GetWindowRect(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool GetWindowRect(win32.UI.WindowsAndMessaging.HWND hWnd, out win32.UI.DisplayDevices.RECT lpRect)
        {
            fixed (win32.UI.DisplayDevices.RECT*lpRectLocal = &lpRect)
            {
                bool __result = User32.GetWindowRect(hWnd, lpRectLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the dimensions of the bounding rectangle of the specified window. The dimensions are given in screen coordinates that are relative to the upper-left corner of the screen.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpRect">
        /// <para>Type: <b>LPRECT</b></para>
        /// <para>A pointer to a  <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the screen coordinates of the upper-left and lower-right corners of the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetWindowRect(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.RECT*lpRect);
        /// <inheritdoc cref = "AdjustWindowRect(win32.UI.DisplayDevices.RECT*, uint, bool)"/>
        internal static unsafe bool AdjustWindowRect(ref win32.UI.DisplayDevices.RECT lpRect, uint dwStyle, bool bMenu)
        {
            fixed (win32.UI.DisplayDevices.RECT*lpRectLocal = &lpRect)
            {
                bool __result = User32.AdjustWindowRect(lpRectLocal, dwStyle, bMenu);
                return __result;
            }
        }

        /// <summary>Calculates the required size of the window rectangle, based on the desired client-rectangle size. The window rectangle can then be passed to the CreateWindow function to create a window whose client area is the desired size.</summary>
        /// <param name = "lpRect">
        /// <para>Type: <b>LPRECT</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-adjustwindowrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwStyle">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style</a> of the window whose required size is to be calculated. Note that you cannot specify the <b>WS_OVERLAPPED</b> style.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-adjustwindowrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bMenu">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether the window has a menu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-adjustwindowrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-adjustwindowrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool AdjustWindowRect(win32.UI.DisplayDevices.RECT*lpRect, uint dwStyle, bool bMenu);
        /// <inheritdoc cref = "AdjustWindowRectEx(win32.UI.DisplayDevices.RECT*, uint, bool, uint)"/>
        internal static unsafe bool AdjustWindowRectEx(ref win32.UI.DisplayDevices.RECT lpRect, uint dwStyle, bool bMenu, uint dwExStyle)
        {
            fixed (win32.UI.DisplayDevices.RECT*lpRectLocal = &lpRect)
            {
                bool __result = User32.AdjustWindowRectEx(lpRectLocal, dwStyle, bMenu, dwExStyle);
                return __result;
            }
        }

        /// <summary>Calculates the required size of the window rectangle, based on the desired size of the client rectangle. The window rectangle can then be passed to the CreateWindowEx function to create a window whose client area is the desired size.</summary>
        /// <param name = "lpRect">
        /// <para>Type: <b>LPRECT</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-adjustwindowrectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwStyle">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style</a> of the window whose required size is to be calculated. Note that you cannot specify the <b>WS_OVERLAPPED</b> style.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-adjustwindowrectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bMenu">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether the window has a menu.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-adjustwindowrectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwExStyle">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">extended window style</a> of the window whose required size is to be calculated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-adjustwindowrectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-adjustwindowrectex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool AdjustWindowRectEx(win32.UI.DisplayDevices.RECT*lpRect, uint dwStyle, bool bMenu, uint dwExStyle);
        /// <inheritdoc cref = "MessageBox(win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.UI.WindowsAndMessaging.MESSAGEBOX_STYLE)"/>
        internal static unsafe win32.UI.WindowsAndMessaging.MESSAGEBOX_RESULT MessageBox(win32.UI.WindowsAndMessaging.HWND hWnd, string lpText, string lpCaption, win32.UI.WindowsAndMessaging.MESSAGEBOX_STYLE uType)
        {
            fixed (char *lpCaptionLocal = lpCaption)
            {
                fixed (char *lpTextLocal = lpText)
                {
                    win32.UI.WindowsAndMessaging.MESSAGEBOX_RESULT __result = User32.MessageBox(hWnd, lpTextLocal, lpCaptionLocal, uType);
                    return __result;
                }
            }
        }

        /// <summary>Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as status or error information. The message box returns an integer value that indicates which button the user clicked.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the owner window of the message box to be created. If this parameter is <b>NULL</b>, the message box has no owner window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpText">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The message to be displayed. If the string consists of more than one line, you can separate the lines using a carriage return and/or linefeed character between each line.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCaption">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The dialog box title. If this parameter is <b>NULL</b>, the default title is <b>Error</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uType">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups of flags.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If a message box has a <b>Cancel</b> button, the function returns the <b>IDCANCEL</b> value if either the ESC key is pressed or the <b>Cancel</b> button is selected. If the message box has no <b>Cancel</b> button, pressing ESC will no effect - unless an MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be <b>IDOK</b>.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the function succeeds, the return value is one of the following menu-item values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "MessageBoxW", SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.MESSAGEBOX_RESULT MessageBox(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PCWSTR lpText, win32.System.SystemServices.PCWSTR lpCaption, win32.UI.WindowsAndMessaging.MESSAGEBOX_STYLE uType);
        /// <inheritdoc cref = "MessageBoxEx(win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.UI.WindowsAndMessaging.MESSAGEBOX_STYLE, ushort)"/>
        internal static unsafe win32.UI.WindowsAndMessaging.MESSAGEBOX_RESULT MessageBoxEx(win32.UI.WindowsAndMessaging.HWND hWnd, string lpText, string lpCaption, win32.UI.WindowsAndMessaging.MESSAGEBOX_STYLE uType, ushort wLanguageId)
        {
            fixed (char *lpCaptionLocal = lpCaption)
            {
                fixed (char *lpTextLocal = lpText)
                {
                    win32.UI.WindowsAndMessaging.MESSAGEBOX_RESULT __result = User32.MessageBoxEx(hWnd, lpTextLocal, lpCaptionLocal, uType, wLanguageId);
                    return __result;
                }
            }
        }

        /// <summary>Creates, displays, and operates a message box.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the owner window of the message box to be created. If this parameter is <b>NULL</b>, the message box has no owner window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpText">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The message to be displayed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCaption">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The dialog box title. If this parameter is <b>NULL</b>, the default title <b>Error</b> is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uType">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The contents and behavior of the dialog box. For information on the supported flags, see <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wLanguageId">
        /// <para>Type: <b>WORD</b> The language for the text displayed in the message box button(s). Specifying a value of zero (0) indicates to display the button text in the default system language. If this parameter is <c>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</c>, the current language associated with the calling thread is used.</para>
        /// <para>To specify a language other than the current language, use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelangid">MAKELANGID</a> macro to create this parameter. For more information, see <b>MAKELANGID</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If a message box has a <b>Cancel</b> button, the function returns the <b>IDCANCEL</b> value if either the ESC key is pressed or the <b>Cancel</b> button is selected. If the message box has no <b>Cancel</b> button, pressing ESC will no effect - unless an MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be <b>IDOK</b>.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the function succeeds, the return value is one of the following menu-item values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "MessageBoxExW", SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.MESSAGEBOX_RESULT MessageBoxEx(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PCWSTR lpText, win32.System.SystemServices.PCWSTR lpCaption, win32.UI.WindowsAndMessaging.MESSAGEBOX_STYLE uType, ushort wLanguageId);
        /// <inheritdoc cref = "MessageBoxIndirect(win32.UI.WindowsAndMessaging.MSGBOXPARAMSW*)"/>
        internal static unsafe win32.UI.WindowsAndMessaging.MESSAGEBOX_RESULT MessageBoxIndirect(in win32.UI.WindowsAndMessaging.MSGBOXPARAMSW lpmbp)
        {
            fixed (win32.UI.WindowsAndMessaging.MSGBOXPARAMSW*lpmbpLocal = &lpmbp)
            {
                win32.UI.WindowsAndMessaging.MESSAGEBOX_RESULT __result = User32.MessageBoxIndirect(lpmbpLocal);
                return __result;
            }
        }

        /// <summary>Creates, displays, and operates a message box. The message box contains application-defined message text and title, any icon, and any combination of predefined push buttons.</summary>
        /// <param name = "lpmbp">
        /// <para>Type: <b>const LPMSGBOXPARAMS</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msgboxparamsa">MSGBOXPARAMS</a> structure that contains information used to display the message box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxindirectw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is one of the following menu-item values.</para>
        /// <para>If a message box has a <b>Cancel</b> button, the function returns the <b>IDCANCEL</b> value if either the ESC key is pressed or the <b>Cancel</b> button is selected. If the message box has no <b>Cancel</b> button, pressing ESC has no effect.</para>
        /// <para>If there is not enough memory to create the message box, the return value is zero.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messageboxindirectw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "MessageBoxIndirectW")]
        internal static extern unsafe win32.UI.WindowsAndMessaging.MESSAGEBOX_RESULT MessageBoxIndirect(win32.UI.WindowsAndMessaging.MSGBOXPARAMSW*lpmbp);
        /// <summary>Displays or hides the cursor.</summary>
        /// <param name = "bShow">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If <i>bShow</i> is <b>TRUE</b>, the display count is incremented by one. If <i>bShow</i> is <b>FALSE</b>, the display count is decremented by one.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>The return value specifies the new display counter.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showcursor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern int ShowCursor(bool bShow);
        /// <summary>Moves the cursor to the specified screen coordinates.</summary>
        /// <param name = "X">
        /// <para>Type: <b>int</b></para>
        /// <para>The new x-coordinate of the cursor, in screen coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcursorpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Y">
        /// <para>Type: <b>int</b></para>
        /// <para>The new y-coordinate of the cursor, in screen coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcursorpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns nonzero if successful or zero otherwise. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcursorpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetCursorPos(int X, int Y);
        /// <summary>Sets the position of the cursor in physical coordinates.</summary>
        /// <param name = "X">
        /// <para>Type: <b>int</b></para>
        /// <para>The new x-coordinate of the cursor, in physical coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setphysicalcursorpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Y">
        /// <para>Type: <b>int</b></para>
        /// <para>The new y-coordinate of the cursor, in physical coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setphysicalcursorpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para><b>TRUE</b> if successful; otherwise <b>FALSE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setphysicalcursorpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetPhysicalCursorPos(int X, int Y);
        /// <inheritdoc cref = "SetCursor(win32.UI.MenusAndResources.HCURSOR)"/>
        internal static unsafe User32.DestroyCursorSafeHandle SetCursor(SafeHandle hCursor)
        {
            bool hCursorAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HCURSOR hCursorLocal;
                if (hCursor is object)
                {
                    hCursor.DangerousAddRef(ref hCursorAddRef);
                    hCursorLocal = (win32.UI.MenusAndResources.HCURSOR)hCursor.DangerousGetHandle();
                }
                else
                    hCursorLocal = default(win32.UI.MenusAndResources.HCURSOR);
                win32.UI.MenusAndResources.HCURSOR __result = User32.SetCursor(hCursorLocal);
                return new User32.DestroyCursorSafeHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hCursorAddRef)
                    hCursor.DangerousRelease();
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "User32.DestroyCursor"/>.
        /// </summary>
        internal class DestroyCursorSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal DestroyCursorSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal DestroyCursorSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => User32.DestroyCursor((win32.UI.MenusAndResources.HCURSOR)this.handle);
        }

        /// <summary>Sets the cursor shape.</summary>
        /// <param name = "hCursor">
        /// <para>Type: <b>HCURSOR</b></para>
        /// <para>A handle to the cursor. The cursor must have been created by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createcursor">CreateCursor</a> function or loaded by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadcursora">LoadCursor</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> function. If this parameter is <b>NULL</b>, the cursor is removed from the screen.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HCURSOR</b></para>
        /// <para>The return value is the handle to the previous cursor, if there was one.</para>
        /// <para>If there was no previous cursor, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcursor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.MenusAndResources.HCURSOR SetCursor(win32.UI.MenusAndResources.HCURSOR hCursor);
        /// <inheritdoc cref = "GetCursorPos(win32.UI.DisplayDevices.POINT*)"/>
        internal static unsafe bool GetCursorPos(out win32.UI.DisplayDevices.POINT lpPoint)
        {
            fixed (win32.UI.DisplayDevices.POINT*lpPointLocal = &lpPoint)
            {
                bool __result = User32.GetCursorPos(lpPointLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the position of the mouse cursor, in screen coordinates.</summary>
        /// <param name = "lpPoint">
        /// <para>Type: <b>LPPOINT</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that receives the screen coordinates of the cursor.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcursorpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns nonzero if successful or zero otherwise. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcursorpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCursorPos(win32.UI.DisplayDevices.POINT*lpPoint);
        /// <inheritdoc cref = "GetPhysicalCursorPos(win32.UI.DisplayDevices.POINT*)"/>
        internal static unsafe bool GetPhysicalCursorPos(out win32.UI.DisplayDevices.POINT lpPoint)
        {
            fixed (win32.UI.DisplayDevices.POINT*lpPointLocal = &lpPoint)
            {
                bool __result = User32.GetPhysicalCursorPos(lpPointLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the position of the cursor in physical coordinates.</summary>
        /// <param name = "lpPoint">
        /// <para>Type: <b>LPPOINT</b></para>
        /// <para>The position of the cursor, in physical coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getphysicalcursorpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para><b>TRUE</b> if successful; otherwise <b>FALSE</b>.</para>
        /// <para><a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> can be called to get more information about any error that is generated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getphysicalcursorpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPhysicalCursorPos(win32.UI.DisplayDevices.POINT*lpPoint);
        /// <inheritdoc cref = "GetClipCursor(win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool GetClipCursor(out win32.UI.DisplayDevices.RECT lpRect)
        {
            fixed (win32.UI.DisplayDevices.RECT*lpRectLocal = &lpRect)
            {
                bool __result = User32.GetClipCursor(lpRectLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the screen coordinates of the rectangular area to which the cursor is confined.</summary>
        /// <param name = "lpRect">
        /// <para>Type: <b>LPRECT</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the screen coordinates of the confining rectangle. The structure receives the dimensions of the screen if the cursor is not confined to a rectangle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclipcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclipcursor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetClipCursor(win32.UI.DisplayDevices.RECT*lpRect);
        /// <inheritdoc cref = "GetCursor()"/>
        internal static unsafe User32.DestroyCursorSafeHandle GetCursor_SafeHandle()
        {
            win32.UI.MenusAndResources.HCURSOR __result = User32.GetCursor();
            return new User32.DestroyCursorSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>Retrieves a handle to the current cursor.</summary>
        /// <returns>
        /// <para>Type: <b>HCURSOR</b></para>
        /// <para>The return value is the handle to the current cursor. If there is no cursor, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcursor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.MenusAndResources.HCURSOR GetCursor();
        /// <inheritdoc cref = "CreateCaret(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.HBITMAP, int, int)"/>
        internal static unsafe bool CreateCaret(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hBitmap, int nWidth, int nHeight)
        {
            bool hBitmapAddRef = false;
            try
            {
                win32.Graphics.Gdi.HBITMAP hBitmapLocal;
                if (hBitmap is object)
                {
                    hBitmap.DangerousAddRef(ref hBitmapAddRef);
                    hBitmapLocal = (win32.Graphics.Gdi.HBITMAP)hBitmap.DangerousGetHandle();
                }
                else
                    hBitmapLocal = default(win32.Graphics.Gdi.HBITMAP);
                bool __result = User32.CreateCaret(hWnd, hBitmapLocal, nWidth, nHeight);
                return __result;
            }
            finally
            {
                if (hBitmapAddRef)
                    hBitmap.DangerousRelease();
            }
        }

        /// <summary>Creates a new shape for the system caret and assigns ownership of the caret to the specified window. The caret shape can be a line, a block, or a bitmap.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that owns the caret.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcaret#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hBitmap">
        /// <para>Type: <b>HBITMAP</b></para>
        /// <para>A handle to the bitmap that defines the caret shape. If this parameter is <b>NULL</b>, the caret is solid. If this parameter is <c>(HBITMAP) 1</c>, the caret is gray. If this parameter is a bitmap handle, the caret is the specified bitmap. The bitmap handle must have been created by the <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createbitmap">CreateBitmap</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createdibitmap">CreateDIBitmap</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadbitmapa">LoadBitmap</a> function.</para>
        /// <para>If <i>hBitmap</i> is a bitmap handle, <b>CreateCaret</b> ignores the <i>nWidth</i> and <i>nHeight</i> parameters; the bitmap defines its own width and height.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcaret#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nWidth">
        /// <para>Type: <b>int</b></para>
        /// <para>The width of the caret, in logical units. If this parameter is zero, the width is set to the system-defined window border width. If <i>hBitmap</i> is a bitmap handle, <b>CreateCaret</b> ignores this parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcaret#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nHeight">
        /// <para>Type: <b>int</b></para>
        /// <para>The height of the caret, in logical units. If this parameter is zero, the height is set to the system-defined window border height. If <i>hBitmap</i> is a bitmap handle, <b>CreateCaret</b> ignores this parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcaret#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcaret">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool CreateCaret(win32.UI.WindowsAndMessaging.HWND hWnd, win32.Graphics.Gdi.HBITMAP hBitmap, int nWidth, int nHeight);
        /// <summary>Retrieves the time required to invert the caret's pixels. The user can set this value.</summary>
        /// <returns>
        /// <para>Type: <b>UINT</b> If the function succeeds, the return value is the blink time, in milliseconds.</para>
        /// <para>A return value of <b>INFINITE</b> indicates that the caret does not blink. A return value is zero indicates that the function has failed. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcaretblinktime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetCaretBlinkTime();
        /// <summary>Sets the caret blink time to the specified number of milliseconds. The blink time is the elapsed time, in milliseconds, required to invert the caret's pixels.</summary>
        /// <param name = "uMSeconds">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The new blink time, in milliseconds.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcaretblinktime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcaretblinktime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetCaretBlinkTime(uint uMSeconds);
        /// <summary>Destroys the caret's current shape, frees the caret from the window, and removes the caret from the screen.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroycaret">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DestroyCaret();
        /// <summary>Removes the caret from the screen. Hiding a caret does not destroy its current shape or invalidate the insertion point.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that owns the caret. If this parameter is <b>NULL</b>, <b>HideCaret</b> searches the current task for the window that owns the caret.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-hidecaret#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-hidecaret">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool HideCaret(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Makes the caret visible on the screen at the caret's current position. When the caret becomes visible, it begins flashing automatically.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that owns the caret. If this parameter is <b>NULL</b>, <b>ShowCaret</b> searches the current task for the window that owns the caret.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showcaret#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showcaret">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ShowCaret(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Moves the caret to the specified coordinates. If the window that owns the caret was created with the CS_OWNDC class style, then the specified coordinates are subject to the mapping mode of the device context associated with that window.</summary>
        /// <param name = "X">
        /// <para>Type: <b>int</b></para>
        /// <para>The new x-coordinate of the caret.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcaretpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Y">
        /// <para>Type: <b>int</b></para>
        /// <para>The new y-coordinate of the caret.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcaretpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcaretpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetCaretPos(int X, int Y);
        /// <inheritdoc cref = "GetCaretPos(win32.UI.DisplayDevices.POINT*)"/>
        internal static unsafe bool GetCaretPos(out win32.UI.DisplayDevices.POINT lpPoint)
        {
            fixed (win32.UI.DisplayDevices.POINT*lpPointLocal = &lpPoint)
            {
                bool __result = User32.GetCaretPos(lpPointLocal);
                return __result;
            }
        }

        /// <summary>Copies the caret's position to the specified POINT structure.</summary>
        /// <param name = "lpPoint">
        /// <para>Type: <b>LPPOINT</b></para>
        /// <para>A pointer to the <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that is to receive the client coordinates of the caret.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcaretpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcaretpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCaretPos(win32.UI.DisplayDevices.POINT*lpPoint);
        /// <inheritdoc cref = "LogicalToPhysicalPoint(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.POINT*)"/>
        internal static unsafe bool LogicalToPhysicalPoint(win32.UI.WindowsAndMessaging.HWND hWnd, ref win32.UI.DisplayDevices.POINT lpPoint)
        {
            fixed (win32.UI.DisplayDevices.POINT*lpPointLocal = &lpPoint)
            {
                bool __result = User32.LogicalToPhysicalPoint(hWnd, lpPointLocal);
                return __result;
            }
        }

        /// <summary>Converts the logical coordinates of a point in a window to physical coordinates.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose transform is used for the conversion. Top level windows are fully supported. In the case of child windows, only the area of overlap between the parent and the child window is converted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-logicaltophysicalpoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpPoint">
        /// <para>Type: <b>LPPOINT</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that specifies the logical coordinates to be converted. The new physical coordinates are copied into this structure if the function succeeds.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-logicaltophysicalpoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>Windows Vista introduces the concept of physical coordinates. Desktop Window Manager (DWM) scales non-dots per inch (dpi) aware windows when the display is high dpi. The window seen on the screen corresponds to the physical coordinates. The application continues to work in logical space. Therefore, the application's view of the window is different from that which appears on the screen. For scaled windows, logical and physical coordinates are different.</para>
        /// <para><b>LogicalToPhysicalPoint</b> is a transformation API that can be called by a process that declares itself as dpi aware. The function uses the window identified by the <i>hWnd</i> parameter and the logical coordinates given in the <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure to compute the physical coordinates.</para>
        /// <para>The <b>LogicalToPhysicalPoint</b> function replaces the logical coordinates in the <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure with the physical coordinates. The physical coordinates are relative to the upper-left corner of the screen. The coordinates have to be inside the client area of <i>hWnd</i>.</para>
        /// <para>On all platforms, <b>LogicalToPhysicalPoint</b> will fail on a window that has either 0 width or height; an application must first establish a non-0 width and height by calling, for example, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-movewindow">MoveWindow</a>.  On some versions of Windows (including Windows 7), <b>LogicalToPhysicalPoint</b> will still fail if <b>MoveWindow</b> has been called after a call to <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with <b>SH_HIDE</b> has hidden the window.</para>
        /// <para>In Windows 8, system–DPI aware applications translate between physical and logical space using PhysicalToLogicalPoint and LogicalToPhysicalPoint. In Windows 8.1, the additional virtualization of the system and inter-process communications means that for the majority of applications, you do not need these APIs. As a result, in Windows 8.1, PhysicalToLogicalPoint and LogicalToPhysicalPoint no longer transform points. The system returns all points to an application in its own coordinate space. This behavior preserves functionality for the majority of applications, but there are some exceptions in which you must make changes to ensure that the application works as expected. In those cases, use <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-physicaltologicalpointforpermonitordpi">PhysicalToLogicalPointForPerMonitorDPI</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-logicaltophysicalpointforpermonitordpi">LogicalToPhysicalPointForPerMonitorDPI.</a></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-logicaltophysicalpoint#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool LogicalToPhysicalPoint(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.POINT*lpPoint);
        /// <inheritdoc cref = "PhysicalToLogicalPoint(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.POINT*)"/>
        internal static unsafe bool PhysicalToLogicalPoint(win32.UI.WindowsAndMessaging.HWND hWnd, ref win32.UI.DisplayDevices.POINT lpPoint)
        {
            fixed (win32.UI.DisplayDevices.POINT*lpPointLocal = &lpPoint)
            {
                bool __result = User32.PhysicalToLogicalPoint(hWnd, lpPointLocal);
                return __result;
            }
        }

        /// <summary>Converts the physical coordinates of a point in a window to logical coordinates.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose transform is used for the conversion. Top level windows are fully supported. In the case of child windows, only the area of overlap between the parent and the child window is converted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-physicaltologicalpoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpPoint">
        /// <para>Type: <b>LPPOINT</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that specifies the physical/screen coordinates to be converted. The new logical coordinates are copied into this structure if the function succeeds.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-physicaltologicalpoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>Windows Vista introduces the concept of physical coordinates. Desktop Window Manager (DWM) scales non-dots per inch (dpi) aware windows when the display is high dpi. The window seen on the screen corresponds to the physical coordinates. The application continues to work in logical space. Therefore, the application's view of the window is different from that which appears on the screen. For scaled windows, logical and physical coordinates are different.</para>
        /// <para>The function uses the window identified by the <i>hWnd</i> parameter and the physical coordinates given in the <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure to compute the logical coordinates. The logical coordinates are the <i>unscaled</i> coordinates that appear to the application in a programmatic way. In other words, the logical coordinates are the coordinates the application recognizes, which can be different from the physical coordinates. The API then replaces the physical coordinates with the logical coordinates. The new coordinates are in the <i>world</i> coordinates whose origin is (0, 0) on the desktop. The coordinates passed to the API have to be on the <i>hWnd</i>.</para>
        /// <para>The source coordinates are in device units.</para>
        /// <para>On all platforms, <b>PhysicalToLogicalPoint</b> will fail on a window that has either 0 width or height; an application must first establish a non-0 width and height by calling, for example, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-movewindow">MoveWindow</a>.  On some versions of Windows (including Windows 7), <b>PhysicalToLogicalPoint</b> will still fail if <b>MoveWindow</b> has been called after a call to <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with <b>SH_HIDE</b> has hidden the window.</para>
        /// <para>In Windows 8, system–DPI aware applications translate between physical and logical space using PhysicalToLogicalPoint and LogicalToPhysicalPoint. In Windows 8.1, the additional virtualization of the system and inter-process communications means that for the majority of applications, you do not need these APIs. As a result, in Windows 8.1, PhysicalToLogicalPoint and LogicalToPhysicalPoint no longer transform points. The system returns all points to an application in its own coordinate space. This behavior preserves functionality for the majority of applications, but there are some exceptions in which you must make changes to ensure that the application works as expected. In those cases, use <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-physicaltologicalpointforpermonitordpi">PhysicalToLogicalPointForPerMonitorDPI</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-logicaltophysicalpointforpermonitordpi">LogicalToPhysicalPointForPerMonitorDPI.</a></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-physicaltologicalpoint#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool PhysicalToLogicalPoint(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.POINT*lpPoint);
        /// <summary>Retrieves a handle to the window that contains the specified point.</summary>
        /// <param name = "Point">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a></b></para>
        /// <para>The point to be checked.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-windowfrompoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is a handle to the window that contains the point. If no window exists at the given point, the return value is <b>NULL</b>. If the point is over a static text control, the return value is a handle to the window under the static text control.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-windowfrompoint">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND WindowFromPoint(win32.UI.DisplayDevices.POINT Point);
        /// <summary>Retrieves a handle to the window that contains the specified physical point.</summary>
        /// <param name = "Point">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a></b></para>
        /// <para>The physical coordinates of the point.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-windowfromphysicalpoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that contains the given physical point. If no window exists at the point, this value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-windowfromphysicalpoint">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND WindowFromPhysicalPoint(win32.UI.DisplayDevices.POINT Point);
        /// <summary>Determines which, if any, of the child windows belonging to a parent window contains the specified point. The search is restricted to immediate child windows. Grandchildren, and deeper descendant windows are not searched.</summary>
        /// <param name = "hWndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the parent window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-childwindowfrompoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Point">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a></b></para>
        /// <para>A structure that defines the client coordinates, relative to <i>hWndParent</i>, of the point to be checked.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-childwindowfrompoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is a handle to the child window that contains the point, even if the child window is hidden or disabled. If the point lies outside the parent window, the return value is <b>NULL</b>. If the point is within the parent window but not within any child window, the return value is a handle to the parent window.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-childwindowfrompoint">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND ChildWindowFromPoint(win32.UI.WindowsAndMessaging.HWND hWndParent, win32.UI.DisplayDevices.POINT Point);
        /// <inheritdoc cref = "ClipCursor(win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool ClipCursor(win32.UI.DisplayDevices.RECT? lpRect)
        {
            win32.UI.DisplayDevices.RECT lpRectLocal = lpRect.HasValue ? lpRect.Value : default(win32.UI.DisplayDevices.RECT);
            bool __result = User32.ClipCursor(lpRect.HasValue ? &lpRectLocal : null);
            return __result;
        }

        /// <summary>Confines the cursor to a rectangular area on the screen.</summary>
        /// <param name = "lpRect">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b></para>
        /// <para>A pointer to the structure that contains the screen coordinates of the upper-left and lower-right corners of the confining rectangle. If this parameter is <b>NULL</b>, the cursor is free to move anywhere on the screen.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-clipcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-clipcursor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ClipCursor([Optional] win32.UI.DisplayDevices.RECT*lpRect);
        /// <summary>Determines which, if any, of the child windows belonging to the specified parent window contains the specified point.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the parent window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-childwindowfrompointex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pt">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a></b></para>
        /// <para>A structure that defines the client coordinates (relative to <i>hwndParent</i>) of the point to be checked.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-childwindowfrompointex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The child windows to be skipped. This parameter can be one or more of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-childwindowfrompointex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is a handle to the first child window that contains the point and meets the criteria specified by <i>uFlags</i>. If the point is within the parent window but not within any child window that meets the criteria, the return value is a handle to the parent window. If the point lies outside the parent window or if the function fails, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-childwindowfrompointex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND ChildWindowFromPointEx(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.DisplayDevices.POINT pt, win32.UI.WindowsAndMessaging.CWP_FLAGS flags);
        /// <summary>Retrieves the current color of the specified display element.</summary>
        /// <param name = "nIndex">Type: <b>int</b></param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The function returns the red, green, blue (RGB) color value of the given element.</para>
        /// <para>If the <i>nIndex</i> parameter is out of range, the return value is zero. Because zero is also a valid RGB value, you cannot use <b>GetSysColor</b> to determine whether a system color is supported by the current platform. Instead, use the <a href = "/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush">GetSysColorBrush</a> function, which returns <b>NULL</b> if the color is not supported.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getsyscolor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetSysColor(win32.UI.WindowsAndMessaging.SYS_COLOR_INDEX nIndex);
        /// <inheritdoc cref = "SetSysColors(int, int *, uint *)"/>
        internal static unsafe bool SetSysColors(ReadOnlySpan<int> lpaElements, ReadOnlySpan<uint> lpaRgbValues)
        {
            fixed (uint *lpaRgbValuesLocal = lpaRgbValues)
            {
                fixed (int *lpaElementsLocal = lpaElements)
                {
                    if (lpaElements.Length != lpaRgbValues.Length)
                        throw new ArgumentException();
                    bool __result = User32.SetSysColors(lpaRgbValues.Length, lpaElementsLocal, lpaRgbValuesLocal);
                    return __result;
                }
            }
        }

        /// <summary>Sets the colors for the specified display elements.</summary>
        /// <param name = "cElements">
        /// <para>Type: <b>int</b></para>
        /// <para>The number of display elements in the <i>lpaElements</i> array.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setsyscolors#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpaElements">
        /// <para>Type: <b>const INT*</b></para>
        /// <para>An array of integers that specify the display elements to be changed. For a list of display elements, see <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsyscolor">GetSysColor</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setsyscolors#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpaRgbValues">
        /// <para>Type: <b>const COLORREF*</b></para>
        /// <para>An array of <a href = "https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a> values that contain the new red, green, blue (RGB) color values for the display elements in the array pointed to by the <i>lpaElements</i> parameter.</para>
        /// <para>To generate a <a href = "https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a>, use the <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-rgb">RGB</a> macro.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setsyscolors#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setsyscolors">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetSysColors(int cElements, int *lpaElements, uint *lpaRgbValues);
        [DllImport("User32", ExactSpelling = true)]
        internal static extern ushort GetWindowWord(win32.UI.WindowsAndMessaging.HWND hWnd, int nIndex);
        [DllImport("User32", ExactSpelling = true)]
        internal static extern ushort SetWindowWord(win32.UI.WindowsAndMessaging.HWND hWnd, int nIndex, ushort wNewWord);
        /// <summary>Retrieves information about the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowlongw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIndex">Type: <b>int</b></param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds, the return value is the requested value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If <a href = "/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> has not been called previously, <b>GetWindowLong</b> returns zero for values in the extra window or class memory.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowlongw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetWindowLongW", SetLastError = true)]
        internal static extern int GetWindowLong(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.WINDOW_LONG_PTR_INDEX nIndex);
        /// <summary>Changes an attribute of the specified window. The function also sets the 32-bit (long) value at the specified offset into the extra window memory.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowlongw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIndex">Type: <b>int</b></param>
        /// <param name = "dwNewLong">
        /// <para>Type: <b>LONG</b></para>
        /// <para>The replacement value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowlongw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds, the return value is the previous value of the specified 32-bit integer.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the previous value of the specified 32-bit integer is zero, and the function succeeds, the return value is zero, but the function does not clear the last error information. This makes it difficult to determine success or failure. To deal with this, you should clear the last error information by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0 before calling <b>SetWindowLong</b>. Then, function failure will be indicated by a return value of zero and a <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowlongw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SetWindowLongW", SetLastError = true)]
        internal static extern int SetWindowLong(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.WINDOW_LONG_PTR_INDEX nIndex, int dwNewLong);
        /// <summary>Retrieves the 16-bit (WORD) value at the specified offset into the extra class memory for the window class to which the specified window belongs.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassword#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIndex">
        /// <para>Type: <b>int</b></para>
        /// <para>The zero-based byte offset of the value to be retrieved. Valid values are in the range zero through the number of bytes of class memory, minus two; for example, if you specified 10 or more bytes of extra class memory, a value of eight would be an index to the fifth 16-bit integer. There is an additional valid value as shown in the following table.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassword#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>WORD</b></para>
        /// <para>If the function succeeds, the return value is the requested 16-bit value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassword">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern ushort GetClassWord(win32.UI.WindowsAndMessaging.HWND hWnd, int nIndex);
        /// <summary>Replaces the 16-bit (WORD) value at the specified offset into the extra class memory for the window class to which the specified window belongs.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclassword#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIndex">
        /// <para>Type: <b>int</b></para>
        /// <para>The zero-based byte offset of the value to be replaced. Valid values are in the range zero through the number of bytes of class memory minus two; for example, if you specified 10 or more bytes of extra class memory, a value of 8 would be an index to the fifth 16-bit integer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclassword#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wNewWord">
        /// <para>Type: <b>WORD</b></para>
        /// <para>The replacement value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclassword#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>WORD</b></para>
        /// <para>If the function succeeds, the return value is the previous value of the specified 16-bit integer. If the value was not previously set, the return value is zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclassword">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern ushort SetClassWord(win32.UI.WindowsAndMessaging.HWND hWnd, int nIndex, ushort wNewWord);
        /// <summary>Retrieves the specified 32-bit (DWORD) value from the WNDCLASSEX structure associated with the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclasslongw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIndex">Type: <b>int</b></param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>If the function succeeds, the return value is the requested value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclasslongw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetClassLongW", SetLastError = true)]
        internal static extern uint GetClassLong(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.GET_CLASS_LONG_INDEX nIndex);
        /// <summary>Replaces the specified 32-bit (long) value at the specified offset into the extra class memory or the WNDCLASSEX structure for the class to which the specified window belongs.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclasslongw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIndex">Type: <b>int</b></param>
        /// <param name = "dwNewLong">
        /// <para>Type: <b>LONG</b></para>
        /// <para>The replacement value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclasslongw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>If the function succeeds, the return value is the previous value of the specified 32-bit integer. If the value was not previously set, the return value is zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclasslongw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SetClassLongW", SetLastError = true)]
        internal static extern uint SetClassLong(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.GET_CLASS_LONG_INDEX nIndex, int dwNewLong);
        /// <inheritdoc cref = "GetProcessDefaultLayout(uint *)"/>
        internal static unsafe bool GetProcessDefaultLayout(out uint pdwDefaultLayout)
        {
            fixed (uint *pdwDefaultLayoutLocal = &pdwDefaultLayout)
            {
                bool __result = User32.GetProcessDefaultLayout(pdwDefaultLayoutLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the default layout that is used when windows are created with no parent or owner.</summary>
        /// <param name = "pdwDefaultLayout">
        /// <para>Type: <b>DWORD*</b></para>
        /// <para>The current default process layout. For a list of values, see <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setprocessdefaultlayout">SetProcessDefaultLayout</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getprocessdefaultlayout#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getprocessdefaultlayout">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessDefaultLayout(uint *pdwDefaultLayout);
        /// <summary>Changes the default layout when windows are created with no parent or owner only for the currently running process.</summary>
        /// <param name = "dwDefaultLayout">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The default process layout. This parameter can be 0 or the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setprocessdefaultlayout#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setprocessdefaultlayout">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetProcessDefaultLayout(uint dwDefaultLayout);
        /// <summary>Retrieves a handle to the desktop window. The desktop window covers the entire screen. The desktop window is the area on top of which other windows are painted.</summary>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is a handle to the desktop window.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdesktopwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetDesktopWindow();
        /// <summary>Retrieves a handle to the specified window's parent or owner.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose parent window handle is to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getparent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the window is a child window, the return value is a handle to the parent window. If the window is a top-level window with the <b>WS_POPUP</b> style, the return value is a handle to the owner window.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>This function typically fails for one of the following reasons:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getparent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetParent(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Changes the parent window of the specified child window.</summary>
        /// <param name = "hWndChild">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the child window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setparent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndNewParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the new parent window. If this parameter is <b>NULL</b>, the desktop window becomes the new parent window. If this parameter is <b>HWND_MESSAGE</b>, the child window becomes a <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setparent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is a handle to the previous parent window.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setparent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND SetParent(win32.UI.WindowsAndMessaging.HWND hWndChild, win32.UI.WindowsAndMessaging.HWND hWndNewParent);
        /// <summary>Enumerates the child windows that belong to the specified parent window by passing the handle to each child window, in turn, to an application-defined callback function.</summary>
        /// <param name = "hWndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the parent window whose child windows are to be enumerated. If this parameter is <b>NULL</b>, this function is equivalent to <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumwindows">EnumWindows</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumchildwindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEnumFunc">
        /// <para>Type: <b>WNDENUMPROC</b></para>
        /// <para>A pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633493(v=vs.85)">EnumChildProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumchildwindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>An application-defined value to be passed to the callback function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumchildwindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The return value is not used.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumchildwindows">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool EnumChildWindows(win32.UI.WindowsAndMessaging.HWND hWndParent, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpEnumFunc, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <inheritdoc cref = "FindWindow(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.UI.WindowsAndMessaging.HWND FindWindow(string lpClassName, string lpWindowName)
        {
            fixed (char *lpWindowNameLocal = lpWindowName)
            {
                fixed (char *lpClassNameLocal = lpClassName)
                {
                    win32.UI.WindowsAndMessaging.HWND __result = User32.FindWindow(lpClassNameLocal, lpWindowNameLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not search child windows. This function does not perform a case-sensitive search.</summary>
        /// <param name = "lpClassName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The class name or a class atom created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero.</para>
        /// <para>If <i>lpClassName</i> points to a string, it specifies the window class name. The class name can be any name registered with <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>, or any of the predefined control-class names.</para>
        /// <para>If <i>lpClassName</i> is <b>NULL</b>, it finds any window whose title matches the <i>lpWindowName</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-findwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpWindowName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The window name (the window's title). If this parameter is <b>NULL</b>, all window names match.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-findwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is a handle to the window that has the specified class name and window name.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-findwindoww">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "FindWindowW", SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND FindWindow(win32.System.SystemServices.PCWSTR lpClassName, win32.System.SystemServices.PCWSTR lpWindowName);
        /// <inheritdoc cref = "FindWindowEx(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.UI.WindowsAndMessaging.HWND FindWindowEx(win32.UI.WindowsAndMessaging.HWND hWndParent, win32.UI.WindowsAndMessaging.HWND hWndChildAfter, string lpszClass, string lpszWindow)
        {
            fixed (char *lpszWindowLocal = lpszWindow)
            {
                fixed (char *lpszClassLocal = lpszClass)
                {
                    win32.UI.WindowsAndMessaging.HWND __result = User32.FindWindowEx(hWndParent, hWndChildAfter, lpszClassLocal, lpszWindowLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves a handle to a window whose class name and window name match the specified strings. The function searches child windows, beginning with the one following the specified child window. This function does not perform a case-sensitive search.</summary>
        /// <param name = "hWndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the parent window whose child windows are to be searched.</para>
        /// <para>If <i>hwndParent</i> is <b>NULL</b>, the function uses the desktop window as the parent window. The function searches among windows that are child windows of the desktop.</para>
        /// <para>If <i>hwndParent</i> is <b>HWND_MESSAGE</b>, the function searches all <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only windows</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-findwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndChildAfter">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to a child window. The search begins with the next child window in the Z order. The child window must be a direct child window of <i>hwndParent</i>, not just a descendant window.</para>
        /// <para>If <i>hwndChildAfter</i> is <b>NULL</b>, the search begins with the first child window of <i>hwndParent</i>.</para>
        /// <para>Note that if both <i>hwndParent</i> and <i>hwndChildAfter</i> are <b>NULL</b>, the function searches all top-level and message-only windows.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-findwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszClass">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The class name or a class atom created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be placed in the low-order word of <i>lpszClass</i>; the high-order word must be zero.</para>
        /// <para>If <i>lpszClass</i> is a string, it specifies the window class name. The class name can be any name registered with <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>, or any of the predefined control-class names, or it can be <c>MAKEINTATOM(0x8000)</c>. In this latter case, 0x8000 is the atom for a menu class. For more information, see the Remarks section of this topic.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-findwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszWindow">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The window name (the window's title). If this parameter is <b>NULL</b>, all window names match.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-findwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is a handle to the window that has the specified class and window names.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-findwindowexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "FindWindowExW", SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND FindWindowEx(win32.UI.WindowsAndMessaging.HWND hWndParent, win32.UI.WindowsAndMessaging.HWND hWndChildAfter, win32.System.SystemServices.PCWSTR lpszClass, win32.System.SystemServices.PCWSTR lpszWindow);
        /// <summary>Retrieves a handle to the Shell's desktop window.</summary>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is the handle of the Shell's desktop window. If no Shell process is present, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getshellwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetShellWindow();
        /// <summary>Registers a specified Shell window to receive certain messages for events or notifications that are useful to Shell applications.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to register for Shell hook messages.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registershellhookwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para><b>TRUE</b> if the function succeeds; otherwise, <b>FALSE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registershellhookwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool RegisterShellHookWindow(win32.UI.WindowsAndMessaging.HWND hwnd);
        /// <summary>Unregisters a specified Shell window that is registered to receive Shell hook messages.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be unregistered. The window was registered with a call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registershellhookwindow">RegisterShellHookWindow</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deregistershellhookwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para><b>TRUE</b> if the function succeeds; <b>FALSE</b> if the function fails.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-deregistershellhookwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DeregisterShellHookWindow(win32.UI.WindowsAndMessaging.HWND hwnd);
        /// <summary>Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE.</summary>
        /// <param name = "lpEnumFunc">
        /// <para>Type: <b>WNDENUMPROC</b></para>
        /// <para>A pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633498(v=vs.85)">EnumWindowsProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumwindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>An application-defined value to be passed to the callback function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumwindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If <a href = "/previous-versions/windows/desktop/legacy/ms633498(v=vs.85)">EnumWindowsProc</a> returns zero, the return value is also zero. In this case, the callback function should call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> to obtain a meaningful error code to be returned to the caller of <b>EnumWindows</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumwindows">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool EnumWindows(delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpEnumFunc, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Enumerates all nonchild windows associated with a thread by passing the handle to each window, in turn, to an application-defined callback function.</summary>
        /// <param name = "dwThreadId">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The identifier of the thread whose windows are to be enumerated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumthreadwindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpfn">
        /// <para>Type: <b>WNDENUMPROC</b></para>
        /// <para>A pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633496(v=vs.85)">EnumThreadWndProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumthreadwindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>An application-defined value to be passed to the callback function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumthreadwindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the callback function returns <b>TRUE</b> for all windows in the thread specified by <i>dwThreadId</i>, the return value is <b>TRUE</b>. If the callback function returns <b>FALSE</b> on any enumerated window, or if there are no windows found in the thread specified by <i>dwThreadId</i>, the return value is <b>FALSE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumthreadwindows">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool EnumThreadWindows(uint dwThreadId, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpfn, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Retrieves the name of the class to which the specified window belongs.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpClassName">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The class name string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nMaxCount">
        /// <para>Type: <b>int</b></para>
        /// <para>The length of the *lpClassName* buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the class name string is truncated to `nMaxCount-1` characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the number of characters copied to the buffer, not including the terminating null character.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclassnamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetClassNameW", SetLastError = true)]
        internal static extern int GetClassName(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PWSTR lpClassName, int nMaxCount);
        /// <summary>Examines the Z order of the child windows associated with the specified parent window and retrieves a handle to the child window at the top of the Z order.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the parent window whose child windows are to be examined. If this parameter is <b>NULL</b>, the function returns a handle to the window at the top of the Z order.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-gettopwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is a handle to the child window at the top of the Z order. If the specified window has no child windows, the return value is <b>NULL</b>. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-gettopwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetTopWindow(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Retrieves the identifier of the thread that created the specified window and, optionally, the identifier of the process that created the window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowthreadprocessid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpdwProcessId">
        /// <para>Type: <b>LPDWORD</b></para>
        /// <para>A pointer to a variable that receives the process identifier. If this parameter is not <b>NULL</b>, <b>GetWindowThreadProcessId</b> copies the identifier of the process to the variable; otherwise, it does not.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowthreadprocessid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The return value is the identifier of the thread that created the window.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowthreadprocessid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe uint GetWindowThreadProcessId(win32.UI.WindowsAndMessaging.HWND hWnd, [Optional] uint *lpdwProcessId);
        /// <summary>Determines whether the calling thread is already a GUI thread. It can also optionally convert the thread to a GUI thread.</summary>
        /// <param name = "bConvert">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If <b>TRUE</b> and the thread is not a GUI thread, convert the thread to a GUI thread.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isguithread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The function returns a nonzero value in the following situations:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isguithread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsGUIThread(bool bConvert);
        /// <summary>Determines which pop-up window owned by the specified window was most recently active.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the owner window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getlastactivepopup#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value identifies the most recently active pop-up window. The return value is the same as the <i>hWnd</i> parameter, if any of the following conditions are met:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getlastactivepopup">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetLastActivePopup(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to a window. The window handle retrieved is relative to this window, based on the value of the <i>uCmd</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uCmd">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is a window handle. If no window exists with the specified relationship to the specified window, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetWindow(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.GET_WINDOW_CMD uCmd);
        /// <summary>Removes a hook procedure installed in a hook chain by the SetWindowsHookEx function.</summary>
        /// <param name = "hhk">
        /// <para>Type: <b>HHOOK</b></para>
        /// <para>A handle to the hook to be removed. This parameter is a hook handle obtained by a previous call to <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookEx</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unhookwindowshookex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unhookwindowshookex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL UnhookWindowsHookEx(win32.UI.WindowsAndMessaging.HHOOK hhk);
        /// <inheritdoc cref = "SetWindowsHook(int, delegate *unmanaged[Stdcall]{int, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.LRESULT})"/>
        internal static unsafe User32.UnhookWindowsHookExSafeHandle SetWindowsHook_SafeHandle(int nFilterType, delegate *unmanaged[Stdcall]<int, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.LRESULT>pfnFilterProc)
        {
            win32.UI.WindowsAndMessaging.HHOOK __result = User32.SetWindowsHook(nFilterType, pfnFilterProc);
            return new User32.UnhookWindowsHookExSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "User32.UnhookWindowsHookEx"/>.
        /// </summary>
        internal class UnhookWindowsHookExSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal UnhookWindowsHookExSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal UnhookWindowsHookExSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => User32.UnhookWindowsHookEx((win32.UI.WindowsAndMessaging.HHOOK)this.handle);
        }

        [DllImport("User32", ExactSpelling = true, EntryPoint = "SetWindowsHookW")]
        internal static extern unsafe win32.UI.WindowsAndMessaging.HHOOK SetWindowsHook(int nFilterType, delegate *unmanaged[Stdcall]<int, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.LRESULT>pfnFilterProc);
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool UnhookWindowsHook(int nCode, delegate *unmanaged[Stdcall]<int, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.LRESULT>pfnFilterProc);
        /// <inheritdoc cref = "SetWindowsHookEx(win32.UI.WindowsAndMessaging.WINDOWS_HOOK_ID, delegate *unmanaged[Stdcall]{int, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.LRESULT}, win32.System.SystemServices.HINSTANCE, uint)"/>
        internal static unsafe User32.UnhookWindowsHookExSafeHandle SetWindowsHookEx(win32.UI.WindowsAndMessaging.WINDOWS_HOOK_ID idHook, delegate *unmanaged[Stdcall]<int, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.LRESULT>lpfn, SafeHandle hmod, uint dwThreadId)
        {
            bool hmodAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hmodLocal;
                if (hmod is object)
                {
                    hmod.DangerousAddRef(ref hmodAddRef);
                    hmodLocal = (win32.System.SystemServices.HINSTANCE)hmod.DangerousGetHandle();
                }
                else
                    hmodLocal = default(win32.System.SystemServices.HINSTANCE);
                win32.UI.WindowsAndMessaging.HHOOK __result = User32.SetWindowsHookEx(idHook, lpfn, hmodLocal, dwThreadId);
                return new User32.UnhookWindowsHookExSafeHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hmodAddRef)
                    hmod.DangerousRelease();
            }
        }

        /// <summary>Installs an application-defined hook procedure into a hook chain.</summary>
        /// <param name = "idHook">Type: <b>int</b></param>
        /// <param name = "lpfn">
        /// <para>Type: <b>HOOKPROC</b></para>
        /// <para>A pointer to the hook procedure. If the <i>dwThreadId</i> parameter is zero or specifies the identifier of a thread created by a different process, the <i>lpfn</i> parameter must point to a hook procedure in a DLL. Otherwise, <i>lpfn</i> can point to a hook procedure in the code associated with the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowshookexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hmod">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the DLL containing the hook procedure pointed to by the <i>lpfn</i> parameter. The <i>hMod</i> parameter must be set to <b>NULL</b> if the <i>dwThreadId</i> parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowshookexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwThreadId">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread. For Windows Store apps, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowshookexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HHOOK</b></para>
        /// <para>If the function succeeds, the return value is the handle to the hook procedure.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowshookexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SetWindowsHookExW", SetLastError = true)]
        internal static extern unsafe win32.UI.WindowsAndMessaging.HHOOK SetWindowsHookEx(win32.UI.WindowsAndMessaging.WINDOWS_HOOK_ID idHook, delegate *unmanaged[Stdcall]<int, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.LRESULT>lpfn, win32.System.SystemServices.HINSTANCE hmod, uint dwThreadId);
        /// <inheritdoc cref = "CallNextHookEx(win32.UI.WindowsAndMessaging.HHOOK, int, win32.UI.WindowsAndMessaging.WPARAM, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe win32.System.SystemServices.LRESULT CallNextHookEx(SafeHandle hhk, int nCode, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam)
        {
            bool hhkAddRef = false;
            try
            {
                win32.UI.WindowsAndMessaging.HHOOK hhkLocal;
                if (hhk is object)
                {
                    hhk.DangerousAddRef(ref hhkAddRef);
                    hhkLocal = (win32.UI.WindowsAndMessaging.HHOOK)hhk.DangerousGetHandle();
                }
                else
                    hhkLocal = default(win32.UI.WindowsAndMessaging.HHOOK);
                win32.System.SystemServices.LRESULT __result = User32.CallNextHookEx(hhkLocal, nCode, wParam, lParam);
                return __result;
            }
            finally
            {
                if (hhkAddRef)
                    hhk.DangerousRelease();
            }
        }

        /// <summary>Passes the hook information to the next hook procedure in the current hook chain. A hook procedure can call this function either before or after processing the hook information.</summary>
        /// <param name = "hhk">
        /// <para>Type: <b>HHOOK</b></para>
        /// <para>This parameter is ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callnexthookex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nCode">
        /// <para>Type: <b>int</b></para>
        /// <para>The hook code passed to the current hook procedure. The next hook procedure uses this code to determine how to process the hook information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callnexthookex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>The <i>wParam</i> value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with the current hook chain.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callnexthookex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The <i>lParam</i> value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with the current hook chain.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callnexthookex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>This value is returned by the next hook procedure in the chain. The current hook procedure must also return this value. The meaning of the return value depends on the hook type. For more information, see the descriptions of the individual hook procedures.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-callnexthookex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.LRESULT CallNextHookEx(win32.UI.WindowsAndMessaging.HHOOK hhk, int nCode, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <inheritdoc cref = "CheckMenuRadioItem(win32.UI.MenusAndResources.HMENU, uint, uint, uint, uint)"/>
        internal static unsafe bool CheckMenuRadioItem(SafeHandle hmenu, uint first, uint last, uint check, uint flags)
        {
            bool hmenuAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU hmenuLocal;
                if (hmenu is object)
                {
                    hmenu.DangerousAddRef(ref hmenuAddRef);
                    hmenuLocal = (win32.UI.MenusAndResources.HMENU)hmenu.DangerousGetHandle();
                }
                else
                    hmenuLocal = default(win32.UI.MenusAndResources.HMENU);
                bool __result = User32.CheckMenuRadioItem(hmenuLocal, first, last, check, flags);
                return __result;
            }
            finally
            {
                if (hmenuAddRef)
                    hmenu.DangerousRelease();
            }
        }

        /// <summary>Checks a specified menu item and makes it a radio item. At the same time, the function clears all other menu items in the associated group and clears the radio-item type flag for those items.</summary>
        /// <param name = "hmenu">
        /// <para>Type: <b>HMENU</b></para>
        /// <para>A handle to the menu that contains the group of menu items.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkmenuradioitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "first">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The identifier or position of the first menu item in the group.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkmenuradioitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "last">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The identifier or position of the last menu item in the group.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkmenuradioitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "check">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The identifier or position of the menu item to check.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkmenuradioitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>Indicates the meaning of <i>idFirst</i>, <i>idLast</i>, and <i>idCheck</i>. If this parameter is <b>MF_BYCOMMAND</b>, the other parameters specify menu item identifiers. If it is <b>MF_BYPOSITION</b>, the other parameters specify the menu item positions.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkmenuradioitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkmenuradioitem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool CheckMenuRadioItem(win32.UI.MenusAndResources.HMENU hmenu, uint first, uint last, uint check, uint flags);
        /// <inheritdoc cref = "LoadCursor(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe User32.DestroyCursorSafeHandle LoadCursor(SafeHandle hInstance, string lpCursorName)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (char *lpCursorNameLocal = lpCursorName)
                {
                    win32.System.SystemServices.HINSTANCE hInstanceLocal;
                    if (hInstance is object)
                    {
                        hInstance.DangerousAddRef(ref hInstanceAddRef);
                        hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                    }
                    else
                        hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                    win32.UI.MenusAndResources.HCURSOR __result = User32.LoadCursor(hInstanceLocal, lpCursorNameLocal);
                    return new User32.DestroyCursorSafeHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Loads the specified cursor resource from the executable (.EXE) file associated with an application instance.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to an instance of the module whose executable file contains the cursor to be loaded.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadcursorw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCursorName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro can also be used to create this value. To use one of the predefined cursors, the application must set the <i>hInstance</i> parameter to <b>NULL</b> and the <i>lpCursorName</i> parameter to one the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadcursorw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HCURSOR</b></para>
        /// <para>If the function succeeds, the return value is the handle to the newly loaded cursor.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadcursorw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "LoadCursorW", SetLastError = true)]
        internal static extern win32.UI.MenusAndResources.HCURSOR LoadCursor(win32.System.SystemServices.HINSTANCE hInstance, win32.System.SystemServices.PCWSTR lpCursorName);
        /// <inheritdoc cref = "LoadCursorFromFile(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe User32.DestroyCursorSafeHandle LoadCursorFromFile(string lpFileName)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                win32.UI.MenusAndResources.HCURSOR __result = User32.LoadCursorFromFile(lpFileNameLocal);
                return new User32.DestroyCursorSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates a cursor based on data contained in a file.</summary>
        /// <param name = "lpFileName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The source of the file data to be used to create the cursor. The data in the file must be in either .CUR or .ANI format.</para>
        /// <para>If the high-order word of <i>lpFileName</i> is nonzero, it is a pointer to a string that is a fully qualified name of a file containing cursor data.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadcursorfromfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HCURSOR</b></para>
        /// <para>If the function is successful, the return value is a handle to the new cursor.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <b>GetLastError</b> may return the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadcursorfromfilew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "LoadCursorFromFileW", SetLastError = true)]
        internal static extern win32.UI.MenusAndResources.HCURSOR LoadCursorFromFile(win32.System.SystemServices.PCWSTR lpFileName);
        /// <inheritdoc cref = "CreateCursor(win32.System.SystemServices.HINSTANCE, int, int, int, int, void *, void *)"/>
        internal static unsafe User32.DestroyCursorSafeHandle CreateCursor(SafeHandle hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, void *pvANDPlane, void *pvXORPlane)
        {
            bool hInstAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hInstLocal;
                if (hInst is object)
                {
                    hInst.DangerousAddRef(ref hInstAddRef);
                    hInstLocal = (win32.System.SystemServices.HINSTANCE)hInst.DangerousGetHandle();
                }
                else
                    hInstLocal = default(win32.System.SystemServices.HINSTANCE);
                win32.UI.MenusAndResources.HCURSOR __result = User32.CreateCursor(hInstLocal, xHotSpot, yHotSpot, nWidth, nHeight, pvANDPlane, pvXORPlane);
                return new User32.DestroyCursorSafeHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hInstAddRef)
                    hInst.DangerousRelease();
            }
        }

        /// <summary>Creates a cursor having the specified size, bit patterns, and hot spot.</summary>
        /// <param name = "hInst">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the current instance of the application creating the cursor.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "xHotSpot">
        /// <para>Type: <b>int</b></para>
        /// <para>The horizontal position of the cursor's hot spot.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "yHotSpot">
        /// <para>Type: <b>int</b></para>
        /// <para>The vertical position of the cursor's hot spot.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nWidth">
        /// <para>Type: <b>int</b></para>
        /// <para>The width of the cursor, in pixels.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nHeight">
        /// <para>Type: <b>int</b></para>
        /// <para>The height of the cursor, in pixels.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pvANDPlane">
        /// <para>Type: <b>const VOID*</b></para>
        /// <para>An array of bytes that contains the bit values for the AND mask of the cursor, as in a device-dependent monochrome bitmap.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pvXORPlane">
        /// <para>Type: <b>const VOID*</b></para>
        /// <para>An array of bytes that contains the bit values for the XOR mask of the cursor, as in a device-dependent monochrome bitmap.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HCURSOR</b></para>
        /// <para>If the function succeeds, the return value is a handle to the cursor.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createcursor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.UI.MenusAndResources.HCURSOR CreateCursor(win32.System.SystemServices.HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, void *pvANDPlane, void *pvXORPlane);
        /// <inheritdoc cref = "SetSystemCursor(win32.UI.MenusAndResources.HCURSOR, win32.UI.WindowsAndMessaging.SYSTEM_CURSOR_ID)"/>
        internal static unsafe bool SetSystemCursor(SafeHandle hcur, win32.UI.WindowsAndMessaging.SYSTEM_CURSOR_ID id)
        {
            bool hcurAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HCURSOR hcurLocal;
                if (hcur is object)
                {
                    hcur.DangerousAddRef(ref hcurAddRef);
                    hcurLocal = (win32.UI.MenusAndResources.HCURSOR)hcur.DangerousGetHandle();
                }
                else
                    hcurLocal = default(win32.UI.MenusAndResources.HCURSOR);
                bool __result = User32.SetSystemCursor(hcurLocal, id);
                return __result;
            }
            finally
            {
                if (hcurAddRef)
                    hcur.DangerousRelease();
            }
        }

        /// <summary>Enables an application to customize the system cursors. It replaces the contents of the system cursor specified by the id parameter with the contents of the cursor specified by the hcur parameter and then destroys hcur.</summary>
        /// <param name = "hcur">
        /// <para>Type: <b>HCURSOR</b></para>
        /// <para>A handle to the cursor. The function replaces the contents of the system cursor specified by <i>id</i> with the contents of the cursor handled by <i>hcur</i>.</para>
        /// <para>The system destroys <i>hcur</i> by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroycursor">DestroyCursor</a> function. Therefore, <i>hcur</i> cannot be a cursor loaded using the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadcursora">LoadCursor</a> function. To specify a cursor loaded from a resource, copy the cursor using the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copycursor">CopyCursor</a> function, then pass the copy to <b>SetSystemCursor</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setsystemcursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "id">Type: <b>DWORD</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setsystemcursor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetSystemCursor(win32.UI.MenusAndResources.HCURSOR hcur, win32.UI.WindowsAndMessaging.SYSTEM_CURSOR_ID id);
        /// <inheritdoc cref = "LoadIcon(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe User32.DestroyIconSafeHandle LoadIcon(SafeHandle hInstance, string lpIconName)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (char *lpIconNameLocal = lpIconName)
                {
                    win32.System.SystemServices.HINSTANCE hInstanceLocal;
                    if (hInstance is object)
                    {
                        hInstance.DangerousAddRef(ref hInstanceAddRef);
                        hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                    }
                    else
                        hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                    win32.UI.MenusAndResources.HICON __result = User32.LoadIcon(hInstanceLocal, lpIconNameLocal);
                    return new User32.DestroyIconSafeHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "User32.DestroyIcon"/>.
        /// </summary>
        internal class DestroyIconSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal DestroyIconSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal DestroyIconSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => User32.DestroyIcon((win32.UI.MenusAndResources.HICON)this.handle);
        }

        /// <summary>Loads the specified icon resource from the executable (.exe) file associated with an application instance.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to an instance of the module whose executable file contains the icon to be loaded. This parameter must be <b>NULL</b> when a standard icon is being loaded.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadiconw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpIconName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The name of the icon resource to be loaded. Alternatively, this parameter can contain the resource identifier in the low-order word and zero in the high-order word. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to create this value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadiconw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HICON</b></para>
        /// <para>If the function succeeds, the return value is a handle to the newly loaded icon.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadiconw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "LoadIconW", SetLastError = true)]
        internal static extern win32.UI.MenusAndResources.HICON LoadIcon(win32.System.SystemServices.HINSTANCE hInstance, win32.System.SystemServices.PCWSTR lpIconName);
        /// <inheritdoc cref = "PrivateExtractIcons(win32.System.SystemServices.PCWSTR, int, int, int, win32.UI.MenusAndResources.HICON*, uint *, uint, uint)"/>
        internal static unsafe uint PrivateExtractIcons(string szFileName, int nIconIndex, int cxIcon, int cyIcon, out User32.DestroyIconSafeHandle phicon, Span<uint> piconid, uint flags)
        {
            fixed (uint *piconidLocal = piconid)
            {
                fixed (char *szFileNameLocal = szFileName)
                {
                    win32.UI.MenusAndResources.HICON phiconLocal;
                    uint __result = User32.PrivateExtractIcons(szFileNameLocal, nIconIndex, cxIcon, cyIcon, &phiconLocal, piconidLocal, (uint)piconid.Length, flags);
                    phicon = new User32.DestroyIconSafeHandle(phiconLocal, ownsHandle: true);
                    return __result;
                }
            }
        }

        /// <summary>Creates an array of handles to icons that are extracted from a specified file.</summary>
        /// <param name = "szFileName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The path and name of the file from which the icon(s) are to be extracted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-privateextracticonsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIconIndex">
        /// <para>Type: <b>int</b></para>
        /// <para>The zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-privateextracticonsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cxIcon">
        /// <para>Type: <b>int</b></para>
        /// <para>The horizontal icon size wanted. See Remarks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-privateextracticonsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cyIcon">
        /// <para>Type: <b>int</b></para>
        /// <para>The vertical icon size wanted. See Remarks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-privateextracticonsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "phicon">
        /// <para>Type: <b>HICON*</b></para>
        /// <para>A pointer to the returned array of icon handles.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-privateextracticonsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "piconid">
        /// <para>Type: <b>UINT*</b></para>
        /// <para>A pointer to a returned resource identifier for the icon that best fits the current display device.  The returned identifier is 0xFFFFFFFF if the identifier is not available for this format.  The returned identifier is 0 if the identifier cannot otherwise be obtained.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-privateextracticonsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIcons">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The number of icons to extract from the file. This parameter is only valid when extracting from .exe and .dll files.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-privateextracticonsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>Specifies flags that control this function.  These flags are the LR_* flags used by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-privateextracticonsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the <i>phicon</i>parameter is <b>NULL</b> and this function succeeds, then the return value is the number of icons in the file.  If the function fails then the return value is 0.</para>
        /// <para>If the <i>phicon</i> parameter is not <b>NULL</b> and the function succeeds, then the return value is the number of icons extracted.  Otherwise, the return value is 0xFFFFFFFF if the file is not found.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-privateextracticonsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "PrivateExtractIconsW")]
        internal static extern unsafe uint PrivateExtractIcons(win32.System.SystemServices.PCWSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, [Optional] win32.UI.MenusAndResources.HICON*phicon, [Optional] uint *piconid, uint nIcons, uint flags);
        /// <inheritdoc cref = "CreateIcon(win32.System.SystemServices.HINSTANCE, int, int, byte, byte, byte *, byte *)"/>
        internal static unsafe User32.DestroyIconSafeHandle CreateIcon(SafeHandle hInstance, int nWidth, int nHeight, byte cPlanes, byte cBitsPixel, byte *lpbANDbits, byte *lpbXORbits)
        {
            bool hInstanceAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hInstanceLocal;
                if (hInstance is object)
                {
                    hInstance.DangerousAddRef(ref hInstanceAddRef);
                    hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                }
                else
                    hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                win32.UI.MenusAndResources.HICON __result = User32.CreateIcon(hInstanceLocal, nWidth, nHeight, cPlanes, cBitsPixel, lpbANDbits, lpbXORbits);
                return new User32.DestroyIconSafeHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Creates an icon that has the specified size, colors, and bit patterns.</summary>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the instance of the module creating the icon.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nWidth">
        /// <para>Type: <b>int</b></para>
        /// <para>The width, in pixels, of the icon.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nHeight">
        /// <para>Type: <b>int</b></para>
        /// <para>The height, in pixels, of the icon.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cPlanes">
        /// <para>Type: <b>BYTE</b></para>
        /// <para>The number of planes in the XOR bitmask of the icon.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cBitsPixel">
        /// <para>Type: <b>BYTE</b></para>
        /// <para>The number of bits-per-pixel in the XOR bitmask of the icon.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpbANDbits">
        /// <para>Type: <b>const BYTE*</b></para>
        /// <para>An array of bytes that contains the bit values for the AND bitmask of the icon. This bitmask describes a monochrome bitmap.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpbXORbits">
        /// <para>Type: <b>const BYTE*</b></para>
        /// <para>An array of bytes that contains the bit values for the XOR bitmask of the icon. This bitmask describes a monochrome or device-dependent color bitmap.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HICON</b></para>
        /// <para>If the function succeeds, the return value is a handle to an icon.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createicon">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.UI.MenusAndResources.HICON CreateIcon(win32.System.SystemServices.HINSTANCE hInstance, int nWidth, int nHeight, byte cPlanes, byte cBitsPixel, byte *lpbANDbits, byte *lpbXORbits);
        /// <inheritdoc cref = "LookupIconIdFromDirectory(byte *, bool)"/>
        internal static unsafe int LookupIconIdFromDirectory(in byte presbits, bool fIcon)
        {
            fixed (byte *presbitsLocal = &presbits)
            {
                int __result = User32.LookupIconIdFromDirectory(presbitsLocal, fIcon);
                return __result;
            }
        }

        /// <summary>Searches through icon or cursor data for the icon or cursor that best fits the current display device.</summary>
        /// <param name = "presbits">
        /// <para>Type: <b>PBYTE</b></para>
        /// <para>The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if <i>presbits</i> is not pointing to valid resource data.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-lookupiconidfromdirectory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fIcon">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether an icon or a cursor is sought. If this parameter is <b>TRUE</b>, the function is searching for an icon; if the parameter is <b>FALSE</b>, the function is searching for a cursor.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-lookupiconidfromdirectory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display device.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-lookupiconidfromdirectory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int LookupIconIdFromDirectory(byte *presbits, bool fIcon);
        /// <inheritdoc cref = "LookupIconIdFromDirectoryEx(byte *, bool, int, int, win32.UI.Controls.IMAGE_FLAGS)"/>
        internal static unsafe int LookupIconIdFromDirectoryEx(in byte presbits, bool fIcon, int cxDesired, int cyDesired, win32.UI.Controls.IMAGE_FLAGS Flags)
        {
            fixed (byte *presbitsLocal = &presbits)
            {
                int __result = User32.LookupIconIdFromDirectoryEx(presbitsLocal, fIcon, cxDesired, cyDesired, Flags);
                return __result;
            }
        }

        /// <summary>Searches through icon or cursor data for the icon or cursor that best fits the current display device.</summary>
        /// <param name = "presbits">
        /// <para>Type: <b>PBYTE</b></para>
        /// <para>The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if <i>presbits</i> is not pointing to valid resource data.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-lookupiconidfromdirectoryex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fIcon">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether an icon or a cursor is sought. If this parameter is <b>TRUE</b>, the function is searching for an icon; if the parameter is <b>FALSE</b>, the function is searching for a cursor.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-lookupiconidfromdirectoryex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cxDesired">
        /// <para>Type: <b>int</b></para>
        /// <para>The desired width, in pixels, of the icon. If this parameter is zero, the function uses the <b>SM_CXICON</b> or <b>SM_CXCURSOR</b> system metric value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-lookupiconidfromdirectoryex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cyDesired">
        /// <para>Type: <b>int</b></para>
        /// <para>The desired height, in pixels, of the icon. If this parameter is zero, the function uses the <b>SM_CYICON</b> or <b>SM_CYCURSOR</b> system metric value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-lookupiconidfromdirectoryex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display device.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-lookupiconidfromdirectoryex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int LookupIconIdFromDirectoryEx(byte *presbits, bool fIcon, int cxDesired, int cyDesired, win32.UI.Controls.IMAGE_FLAGS Flags);
        /// <inheritdoc cref = "CreateIconFromResource(byte *, uint, bool, uint)"/>
        internal static unsafe User32.DestroyIconSafeHandle CreateIconFromResource(in byte presbits, uint dwResSize, bool fIcon, uint dwVer)
        {
            fixed (byte *presbitsLocal = &presbits)
            {
                win32.UI.MenusAndResources.HICON __result = User32.CreateIconFromResource(presbitsLocal, dwResSize, fIcon, dwVer);
                return new User32.DestroyIconSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates an icon or cursor from resource bits describing the icon.</summary>
        /// <param name = "presbits">
        /// <para>Type: <b>PBYTE</b></para>
        /// <para>The buffer containing the icon or cursor resource bits. These bits are typically loaded by calls to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-lookupiconidfromdirectory">LookupIconIdFromDirectory</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-lookupiconidfromdirectoryex">LookupIconIdFromDirectoryEx</a>, and <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a> functions.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresource#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwResSize">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The size, in bytes, of the set of bits pointed to by the <i>presbits</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresource#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fIcon">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether an icon or a cursor is to be created. If this parameter is <b>TRUE</b>, an icon is to be created. If it is <b>FALSE</b>, a cursor is to be created.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresource#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwVer">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The version number of the icon or cursor format for the resource bits pointed to by the <i>presbits</i> parameter. The value must be greater than or equal to 0x00020000 and less than or equal to 0x00030000. This parameter is generally set to 0x00030000.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresource#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HICON</b></para>
        /// <para>If the function succeeds, the return value is a handle to the icon or cursor.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresource">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.UI.MenusAndResources.HICON CreateIconFromResource(byte *presbits, uint dwResSize, bool fIcon, uint dwVer);
        /// <inheritdoc cref = "CreateIconFromResourceEx(byte *, uint, bool, uint, int, int, win32.UI.Controls.IMAGE_FLAGS)"/>
        internal static unsafe User32.DestroyIconSafeHandle CreateIconFromResourceEx(in byte presbits, uint dwResSize, bool fIcon, uint dwVer, int cxDesired, int cyDesired, win32.UI.Controls.IMAGE_FLAGS Flags)
        {
            fixed (byte *presbitsLocal = &presbits)
            {
                win32.UI.MenusAndResources.HICON __result = User32.CreateIconFromResourceEx(presbitsLocal, dwResSize, fIcon, dwVer, cxDesired, cyDesired, Flags);
                return new User32.DestroyIconSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates an icon or cursor from resource bits describing the icon.</summary>
        /// <param name = "presbits">
        /// <para>Type: <b>PBYTE</b></para>
        /// <para>The icon or cursor resource bits. These bits are typically loaded by calls to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-lookupiconidfromdirectoryex">LookupIconIdFromDirectoryEx</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a> functions.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresourceex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwResSize">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The size, in bytes, of the set of bits pointed to by the <i>pbIconBits</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresourceex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fIcon">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether an icon or a cursor is to be created. If this parameter is <b>TRUE</b>, an icon is to be created. If it is <b>FALSE</b>, a cursor is to be created.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresourceex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwVer">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The version number of the icon or cursor format for the resource bits pointed to by the <i>pbIconBits</i> parameter. The value must be greater than or equal to 0x00020000 and less than or equal to 0x00030000. This parameter is generally set to 0x00030000.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresourceex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cxDesired">
        /// <para>Type: <b>int</b></para>
        /// <para>The desired width, in pixels, of the icon or cursor. If this parameter is zero, the function uses the <b>SM_CXICON</b> or <b>SM_CXCURSOR</b> system metric value to set the width.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresourceex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cyDesired">
        /// <para>Type: <b>int</b></para>
        /// <para>The desired height, in pixels, of the icon or cursor. If this parameter is zero, the function uses the <b>SM_CYICON</b> or <b>SM_CYCURSOR</b> system metric value to set the height.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresourceex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>HICON</b></para>
        /// <para>If the function succeeds, the return value is a handle to the icon or cursor.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconfromresourceex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.UI.MenusAndResources.HICON CreateIconFromResourceEx(byte *presbits, uint dwResSize, bool fIcon, uint dwVer, int cxDesired, int cyDesired, win32.UI.Controls.IMAGE_FLAGS Flags);
        /// <inheritdoc cref = "LoadImage(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE, int, int, win32.UI.Controls.IMAGE_FLAGS)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle LoadImage(SafeHandle hInst, string name, win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE type, int cx, int cy, win32.UI.Controls.IMAGE_FLAGS fuLoad)
        {
            bool hInstAddRef = false;
            try
            {
                fixed (char *nameLocal = name)
                {
                    win32.System.SystemServices.HINSTANCE hInstLocal;
                    if (hInst is object)
                    {
                        hInst.DangerousAddRef(ref hInstAddRef);
                        hInstLocal = (win32.System.SystemServices.HINSTANCE)hInst.DangerousGetHandle();
                    }
                    else
                        hInstLocal = default(win32.System.SystemServices.HINSTANCE);
                    win32.System.SystemServices.HANDLE __result = User32.LoadImage(hInstLocal, nameLocal, type, cx, cy, fuLoad);
                    return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hInstAddRef)
                    hInst.DangerousRelease();
            }
        }

        /// <summary>Loads an icon, cursor, animated cursor, or bitmap.</summary>
        /// <param name = "hInst">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>. Note that as of  32-bit Windows, an instance handle (<b>HINSTANCE</b>), such as the application instance handle exposed by system function call of <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-winmain">WinMain</a>, and a module handle (<b>HMODULE</b>) are the same thing.</para>
        /// <para>To load an OEM image, set this parameter to <b>NULL</b>.</para>
        /// <para>To load a stand-alone resource (icon, cursor, or bitmap file)—for example, c:\myimage.bmp—set this parameter to <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadimagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "name">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The image to be loaded. If the <i>hinst</i> parameter is non-<b>NULL</b> and the <i>fuLoad</i> parameter omits <b>LR_LOADFROMFILE</b>, <i>lpszName</i> specifies the image resource in the <i>hinst</i> module. If the image resource is to be loaded by name from the module, the <i>lpszName</i> parameter is a pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by ordinal from the module, use the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to convert the image ordinal into a form that can be passed to the <b>LoadImage</b> function.</para>
        /// <para>For more information, see the Remarks section below.</para>
        /// <para>If the <i>hinst</i> parameter is <b>NULL</b> and the <i>fuLoad</i> parameter omits the <b>LR_LOADFROMFILE</b> value, the <i>lpszName</i> specifies the OEM image to load. The OEM image identifiers are defined in Winuser.h and have the following prefixes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadimagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "type">Type: <b>UINT</b></param>
        /// <param name = "cx">
        /// <para>Type: <b>int</b></para>
        /// <para>The width, in pixels, of the icon or cursor. If this parameter is zero and the <i>fuLoad</i> parameter is <b>LR_DEFAULTSIZE</b>, the function uses the <b>SM_CXICON</b> or <b>SM_CXCURSOR</b> system metric value to set the width. If this parameter is zero and <b>LR_DEFAULTSIZE</b> is not used, the function uses the actual resource width.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadimagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cy">
        /// <para>Type: <b>int</b></para>
        /// <para>The height, in pixels, of the icon or cursor. If this parameter is zero and the <i>fuLoad</i> parameter is <b>LR_DEFAULTSIZE</b>, the function uses the <b>SM_CYICON</b> or <b>SM_CYCURSOR</b> system metric value to set the height. If this parameter is zero and <b>LR_DEFAULTSIZE</b> is not used, the function uses the actual resource height.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadimagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fuLoad">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>If the function succeeds, the return value is the handle of the newly loaded image.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadimagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "LoadImageW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE LoadImage(win32.System.SystemServices.HINSTANCE hInst, win32.System.SystemServices.PCWSTR name, win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE type, int cx, int cy, win32.UI.Controls.IMAGE_FLAGS fuLoad);
        /// <inheritdoc cref = "CopyImage(win32.System.SystemServices.HANDLE, win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE, int, int, win32.UI.Controls.IMAGE_FLAGS)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CopyImage(SafeHandle h, win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE type, int cx, int cy, win32.UI.Controls.IMAGE_FLAGS flags)
        {
            bool hAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hLocal;
                if (h is object)
                {
                    h.DangerousAddRef(ref hAddRef);
                    hLocal = (win32.System.SystemServices.HANDLE)h.DangerousGetHandle();
                }
                else
                    hLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE __result = User32.CopyImage(hLocal, type, cx, cy, flags);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hAddRef)
                    h.DangerousRelease();
            }
        }

        /// <summary>Creates a new image (icon, cursor, or bitmap) and copies the attributes of the specified image to the new one. If necessary, the function stretches the bits to fit the desired size of the new image.</summary>
        /// <param name = "h">
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>A handle to the image to be copied.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-copyimage#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "type">Type: <b>UINT</b></param>
        /// <param name = "cx">
        /// <para>Type: <b>int</b></para>
        /// <para>The desired width, in pixels, of the image. If this is zero, then the returned image will have the same width as the original <i>hImage</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-copyimage#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cy">
        /// <para>Type: <b>int</b></para>
        /// <para>The desired height, in pixels, of the image. If this is zero, then the returned image will have the same height as the original <i>hImage</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-copyimage#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>If the function succeeds, the return value is the handle to the newly created image.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-copyimage">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE CopyImage(win32.System.SystemServices.HANDLE h, win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE type, int cx, int cy, win32.UI.Controls.IMAGE_FLAGS flags);
        /// <inheritdoc cref = "DrawIconEx(win32.Graphics.Gdi.HDC, int, int, win32.UI.MenusAndResources.HICON, int, int, uint, win32.Graphics.Gdi.HBRUSH, win32.UI.WindowsAndMessaging.DI_FLAGS)"/>
        internal static unsafe bool DrawIconEx(SafeHandle hdc, int xLeft, int yTop, SafeHandle hIcon, int cxWidth, int cyWidth, uint istepIfAniCur, SafeHandle hbrFlickerFreeDraw, win32.UI.WindowsAndMessaging.DI_FLAGS diFlags)
        {
            bool hdcAddRef = false;
            bool hIconAddRef = false;
            bool hbrFlickerFreeDrawAddRef = false;
            try
            {
                win32.Graphics.Gdi.HDC hdcLocal;
                if (hdc is object)
                {
                    hdc.DangerousAddRef(ref hdcAddRef);
                    hdcLocal = (win32.Graphics.Gdi.HDC)hdc.DangerousGetHandle();
                }
                else
                    hdcLocal = default(win32.Graphics.Gdi.HDC);
                win32.UI.MenusAndResources.HICON hIconLocal;
                if (hIcon is object)
                {
                    hIcon.DangerousAddRef(ref hIconAddRef);
                    hIconLocal = (win32.UI.MenusAndResources.HICON)hIcon.DangerousGetHandle();
                }
                else
                    hIconLocal = default(win32.UI.MenusAndResources.HICON);
                win32.Graphics.Gdi.HBRUSH hbrFlickerFreeDrawLocal;
                if (hbrFlickerFreeDraw is object)
                {
                    hbrFlickerFreeDraw.DangerousAddRef(ref hbrFlickerFreeDrawAddRef);
                    hbrFlickerFreeDrawLocal = (win32.Graphics.Gdi.HBRUSH)hbrFlickerFreeDraw.DangerousGetHandle();
                }
                else
                    hbrFlickerFreeDrawLocal = default(win32.Graphics.Gdi.HBRUSH);
                bool __result = User32.DrawIconEx(hdcLocal, xLeft, yTop, hIconLocal, cxWidth, cyWidth, istepIfAniCur, hbrFlickerFreeDrawLocal, diFlags);
                return __result;
            }
            finally
            {
                if (hdcAddRef)
                    hdc.DangerousRelease();
                if (hIconAddRef)
                    hIcon.DangerousRelease();
                if (hbrFlickerFreeDrawAddRef)
                    hbrFlickerFreeDraw.DangerousRelease();
            }
        }

        /// <summary>Draws an icon or cursor into the specified device context, performing the specified raster operations, and stretching or compressing the icon or cursor as specified.</summary>
        /// <param name = "hdc">
        /// <para>Type: <b>HDC</b></para>
        /// <para>A handle to the device context into which the icon or cursor will be drawn.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "xLeft">
        /// <para>Type: <b>int</b></para>
        /// <para>The logical x-coordinate of the upper-left corner of the icon or cursor.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "yTop">
        /// <para>Type: <b>int</b></para>
        /// <para>The logical y-coordinate of the upper-left corner of the icon or cursor.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hIcon">
        /// <para>Type: <b>HICON</b></para>
        /// <para>A handle to the icon or cursor to be drawn. This parameter can identify an animated cursor.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cxWidth">
        /// <para>Type: <b>int</b></para>
        /// <para>The logical width of the icon or cursor. If this parameter is zero and the <i>diFlags</i> parameter is <b>DI_DEFAULTSIZE</b>, the function uses the <b>SM_CXICON</b> system metric value to set the width. If this parameter is zero and <b>DI_DEFAULTSIZE</b> is not used, the function uses the actual resource width.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cyWidth">
        /// <para>Type: <b>int</b></para>
        /// <para>The logical height of the icon or cursor. If this parameter is zero and the <i>diFlags</i> parameter is <b>DI_DEFAULTSIZE</b>, the function uses the <b>SM_CYICON</b> system metric value to set the width. If this parameter is zero and <b>DI_DEFAULTSIZE</b> is not used, the function uses the actual resource height.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "istepIfAniCur">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The index of the frame to draw, if <i>hIcon</i> identifies an animated cursor. This parameter is ignored if <i>hIcon</i> does not identify an animated cursor.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hbrFlickerFreeDraw">
        /// <para>Type: <b>HBRUSH</b></para>
        /// <para>A handle to a brush that the system uses for flicker-free drawing. If <i>hbrFlickerFreeDraw</i> is a valid brush handle, the system creates an offscreen bitmap using the specified brush for the background color, draws the icon or cursor into the bitmap, and then copies the bitmap into the device context identified by <i>hdc</i>. If <i>hbrFlickerFreeDraw</i> is <b>NULL</b>, the system draws the icon or cursor directly into the device context.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "diFlags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawiconex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DrawIconEx(win32.Graphics.Gdi.HDC hdc, int xLeft, int yTop, win32.UI.MenusAndResources.HICON hIcon, int cxWidth, int cyWidth, uint istepIfAniCur, win32.Graphics.Gdi.HBRUSH hbrFlickerFreeDraw, win32.UI.WindowsAndMessaging.DI_FLAGS diFlags);
        /// <inheritdoc cref = "CreateIconIndirect(win32.UI.WindowsAndMessaging.ICONINFO*)"/>
        internal static unsafe User32.DestroyIconSafeHandle CreateIconIndirect(in win32.UI.WindowsAndMessaging.ICONINFO piconinfo)
        {
            fixed (win32.UI.WindowsAndMessaging.ICONINFO*piconinfoLocal = &piconinfo)
            {
                win32.UI.MenusAndResources.HICON __result = User32.CreateIconIndirect(piconinfoLocal);
                return new User32.DestroyIconSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates an icon or cursor from an ICONINFO structure.</summary>
        /// <param name = "piconinfo">
        /// <para>Type: <b>PICONINFO</b></para>
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfo">ICONINFO</a> structure the function uses to create the icon or cursor.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconindirect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HICON</b></para>
        /// <para>If the function succeeds, the return value is a handle to the icon or cursor that is created.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createiconindirect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.UI.MenusAndResources.HICON CreateIconIndirect(win32.UI.WindowsAndMessaging.ICONINFO*piconinfo);
        /// <inheritdoc cref = "CopyIcon(win32.UI.MenusAndResources.HICON)"/>
        internal static unsafe User32.DestroyIconSafeHandle CopyIcon(SafeHandle hIcon)
        {
            bool hIconAddRef = false;
            try
            {
                win32.UI.MenusAndResources.HICON hIconLocal;
                if (hIcon is object)
                {
                    hIcon.DangerousAddRef(ref hIconAddRef);
                    hIconLocal = (win32.UI.MenusAndResources.HICON)hIcon.DangerousGetHandle();
                }
                else
                    hIconLocal = default(win32.UI.MenusAndResources.HICON);
                win32.UI.MenusAndResources.HICON __result = User32.CopyIcon(hIconLocal);
                return new User32.DestroyIconSafeHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hIconAddRef)
                    hIcon.DangerousRelease();
            }
        }

        /// <summary>Copies the specified icon from another module to the current module.</summary>
        /// <param name = "hIcon">
        /// <para>Type: <b>HICON</b></para>
        /// <para>A handle to the icon to be copied.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-copyicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HICON</b></para>
        /// <para>If the function succeeds, the return value is a handle to the duplicate icon.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-copyicon">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.MenusAndResources.HICON CopyIcon(win32.UI.MenusAndResources.HICON hIcon);
        /// <inheritdoc cref = "GetIconInfo(win32.UI.MenusAndResources.HICON, win32.UI.WindowsAndMessaging.ICONINFO*)"/>
        internal static unsafe bool GetIconInfo(SafeHandle hIcon, out win32.UI.WindowsAndMessaging.ICONINFO piconinfo)
        {
            bool hIconAddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.ICONINFO*piconinfoLocal = &piconinfo)
                {
                    win32.UI.MenusAndResources.HICON hIconLocal;
                    if (hIcon is object)
                    {
                        hIcon.DangerousAddRef(ref hIconAddRef);
                        hIconLocal = (win32.UI.MenusAndResources.HICON)hIcon.DangerousGetHandle();
                    }
                    else
                        hIconLocal = default(win32.UI.MenusAndResources.HICON);
                    bool __result = User32.GetIconInfo(hIconLocal, piconinfoLocal);
                    return __result;
                }
            }
            finally
            {
                if (hIconAddRef)
                    hIcon.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the specified icon or cursor.</summary>
        /// <param name = "hIcon">Type: <b>HICON</b></param>
        /// <param name = "piconinfo">
        /// <para>Type: <b>PICONINFO</b></para>
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfo">ICONINFO</a> structure. The function fills in the structure's members.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-geticoninfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero and the function fills in the members of the specified <a href = "/windows/desktop/api/winuser/ns-winuser-iconinfo">ICONINFO</a> structure.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-geticoninfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetIconInfo(win32.UI.MenusAndResources.HICON hIcon, win32.UI.WindowsAndMessaging.ICONINFO*piconinfo);
        /// <inheritdoc cref = "GetIconInfoEx(win32.UI.MenusAndResources.HICON, win32.UI.WindowsAndMessaging.ICONINFOEXW*)"/>
        internal static unsafe bool GetIconInfoEx(SafeHandle hicon, ref win32.UI.WindowsAndMessaging.ICONINFOEXW piconinfo)
        {
            bool hiconAddRef = false;
            try
            {
                fixed (win32.UI.WindowsAndMessaging.ICONINFOEXW*piconinfoLocal = &piconinfo)
                {
                    win32.UI.MenusAndResources.HICON hiconLocal;
                    if (hicon is object)
                    {
                        hicon.DangerousAddRef(ref hiconAddRef);
                        hiconLocal = (win32.UI.MenusAndResources.HICON)hicon.DangerousGetHandle();
                    }
                    else
                        hiconLocal = default(win32.UI.MenusAndResources.HICON);
                    bool __result = User32.GetIconInfoEx(hiconLocal, piconinfoLocal);
                    return __result;
                }
            }
            finally
            {
                if (hiconAddRef)
                    hicon.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the specified icon or cursor. GetIconInfoEx extends GetIconInfo by using the newer ICONINFOEX structure.</summary>
        /// <param name = "hicon">Type: <b>HICON</b></param>
        /// <param name = "piconinfo">
        /// <para>Type: <b>PICONINFOEX</b></para>
        /// <para>When this method returns, contains a pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfoexa">ICONINFOEX</a> structure. The function fills in the structure's members.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-geticoninfoexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para><b>TRUE</b> indicates success, <b>FALSE</b> indicates failure.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-geticoninfoexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetIconInfoExW")]
        internal static extern unsafe bool GetIconInfoEx(win32.UI.MenusAndResources.HICON hicon, win32.UI.WindowsAndMessaging.ICONINFOEXW*piconinfo);
        /// <inheritdoc cref = "IsDialogMessage(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.MSG*)"/>
        internal static unsafe bool IsDialogMessage(win32.UI.WindowsAndMessaging.HWND hDlg, in win32.UI.WindowsAndMessaging.MSG lpMsg)
        {
            fixed (win32.UI.WindowsAndMessaging.MSG*lpMsgLocal = &lpMsg)
            {
                bool __result = User32.IsDialogMessage(hDlg, lpMsgLocal);
                return __result;
            }
        }

        /// <summary>Determines whether a message is intended for the specified dialog box and, if it is, processes the message.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the dialog box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isdialogmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMsg">
        /// <para>Type: <b>LPMSG</b></para>
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains the message to be checked.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isdialogmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the message has been processed, the return value is nonzero.</para>
        /// <para>If the message has not been processed, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isdialogmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "IsDialogMessageW")]
        internal static extern unsafe bool IsDialogMessage(win32.UI.WindowsAndMessaging.HWND hDlg, win32.UI.WindowsAndMessaging.MSG*lpMsg);
        /// <inheritdoc cref = "MapDialogRect(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool MapDialogRect(win32.UI.WindowsAndMessaging.HWND hDlg, ref win32.UI.DisplayDevices.RECT lpRect)
        {
            fixed (win32.UI.DisplayDevices.RECT*lpRectLocal = &lpRect)
            {
                bool __result = User32.MapDialogRect(hDlg, lpRectLocal);
                return __result;
            }
        }

        /// <summary>Converts the specified dialog box units to screen units (pixels).</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to a dialog box. This function accepts only handles returned by one of the dialog box creation functions; handles for other windows are not valid.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mapdialogrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpRect">
        /// <para>Type: <b>LPRECT</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the dialog box coordinates to be converted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mapdialogrect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mapdialogrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool MapDialogRect(win32.UI.WindowsAndMessaging.HWND hDlg, win32.UI.DisplayDevices.RECT*lpRect);
        /// <summary>Provides default processing for any window messages that the window procedure of a multiple-document interface (MDI) frame window does not process.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the MDI frame window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defframeprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndMDIClient">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the MDI client window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defframeprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uMsg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to be processed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defframeprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defframeprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defframeprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>The return value specifies the result of the message processing and depends on the message. If the <i>hWndMDIClient</i> parameter is <b>NULL</b>, the return value is the same as for the <a href = "/windows/desktop/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defframeprocw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DefFrameProcW")]
        internal static extern win32.System.SystemServices.LRESULT DefFrameProc(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.WindowsAndMessaging.HWND hWndMDIClient, uint uMsg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Provides default processing for any window message that the window procedure of a multiple-document interface (MDI) child window does not process.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the MDI child window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defmdichildprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uMsg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to be processed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defmdichildprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defmdichildprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defmdichildprocw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>The return value specifies the result of the message processing and depends on the message.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defmdichildprocw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DefMDIChildProcW")]
        internal static extern win32.System.SystemServices.LRESULT DefMDIChildProc(win32.UI.WindowsAndMessaging.HWND hWnd, uint uMsg, win32.UI.WindowsAndMessaging.WPARAM wParam, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <inheritdoc cref = "TranslateMDISysAccel(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.MSG*)"/>
        internal static unsafe bool TranslateMDISysAccel(win32.UI.WindowsAndMessaging.HWND hWndClient, in win32.UI.WindowsAndMessaging.MSG lpMsg)
        {
            fixed (win32.UI.WindowsAndMessaging.MSG*lpMsgLocal = &lpMsg)
            {
                bool __result = User32.TranslateMDISysAccel(hWndClient, lpMsgLocal);
                return __result;
            }
        }

        /// <summary>Processes accelerator keystrokes for window menu commands of the multiple-document interface (MDI) child windows associated with the specified MDI client window.</summary>
        /// <param name = "hWndClient">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the MDI client window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-translatemdisysaccel#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMsg">
        /// <para>Type: <b>LPMSG</b></para>
        /// <para>A pointer to a message retrieved by using the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function. The message must be an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure and contain message information from the application's message queue.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-translatemdisysaccel#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the message is translated into a system command, the return value is nonzero.</para>
        /// <para>If the message is not translated into a system command, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-translatemdisysaccel">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool TranslateMDISysAccel(win32.UI.WindowsAndMessaging.HWND hWndClient, win32.UI.WindowsAndMessaging.MSG*lpMsg);
        /// <summary>Arranges all the minimized (iconic) child windows of the specified parent window.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the parent window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-arrangeiconicwindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the return value is the height of one row of icons.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-arrangeiconicwindows">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint ArrangeIconicWindows(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <inheritdoc cref = "CreateMDIWindow(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.UI.WindowsAndMessaging.WINDOW_STYLE, int, int, int, int, win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.HINSTANCE, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe win32.UI.WindowsAndMessaging.HWND CreateMDIWindow(string lpClassName, string lpWindowName, win32.UI.WindowsAndMessaging.WINDOW_STYLE dwStyle, int X, int Y, int nWidth, int nHeight, win32.UI.WindowsAndMessaging.HWND hWndParent, SafeHandle hInstance, win32.UI.WindowsAndMessaging.LPARAM lParam)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (char *lpWindowNameLocal = lpWindowName)
                {
                    fixed (char *lpClassNameLocal = lpClassName)
                    {
                        win32.System.SystemServices.HINSTANCE hInstanceLocal;
                        if (hInstance is object)
                        {
                            hInstance.DangerousAddRef(ref hInstanceAddRef);
                            hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                        }
                        else
                            hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                        win32.UI.WindowsAndMessaging.HWND __result = User32.CreateMDIWindow(lpClassNameLocal, lpWindowNameLocal, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstanceLocal, lParam);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>Creates a multiple-document interface (MDI) child window.</summary>
        /// <param name = "lpClassName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The window class of the MDI child window. The class name must have been registered by a call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createmdiwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpWindowName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The window name. The system displays the name in the title bar of the child window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createmdiwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwStyle">Type: <b>DWORD</b></param>
        /// <param name = "X">
        /// <para>Type: <b>int</b></para>
        /// <para>The initial horizontal position, in client coordinates, of the MDI child window. If this parameter is <b>CW_USEDEFAULT</b> ((int)0x80000000), the MDI child window is assigned the default horizontal position.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createmdiwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Y">
        /// <para>Type: <b>int</b></para>
        /// <para>The initial vertical position, in client coordinates, of the MDI child window. If this parameter is <b>CW_USEDEFAULT</b>, the MDI child window is assigned the default vertical position.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createmdiwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nWidth">
        /// <para>Type: <b>int</b></para>
        /// <para>The initial width, in device units, of the MDI child window. If this parameter is <b>CW_USEDEFAULT</b>, the MDI child window is assigned the default width.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createmdiwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nHeight">
        /// <para>Type: <b>int</b></para>
        /// <para>The initial height, in device units, of the MDI child window. If this parameter is set to <b>CW_USEDEFAULT</b>, the MDI child window is assigned the default height.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createmdiwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the MDI client window that will be the parent of the new MDI child window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createmdiwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hInstance">
        /// <para>Type: <b>HINSTANCE</b></para>
        /// <para>A handle to the instance of the application creating the MDI child window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createmdiwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>An application-defined value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createmdiwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is the handle to the created window.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createmdiwindoww">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CreateMDIWindowW", SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND CreateMDIWindow(win32.System.SystemServices.PCWSTR lpClassName, win32.System.SystemServices.PCWSTR lpWindowName, win32.UI.WindowsAndMessaging.WINDOW_STYLE dwStyle, int X, int Y, int nWidth, int nHeight, win32.UI.WindowsAndMessaging.HWND hWndParent, win32.System.SystemServices.HINSTANCE hInstance, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <inheritdoc cref = "TileWindows(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.TILE_WINDOWS_HOW, win32.UI.DisplayDevices.RECT*, uint, win32.UI.WindowsAndMessaging.HWND*)"/>
        internal static unsafe ushort TileWindows(win32.UI.WindowsAndMessaging.HWND hwndParent, win32.UI.WindowsAndMessaging.TILE_WINDOWS_HOW wHow, win32.UI.DisplayDevices.RECT? lpRect, ReadOnlySpan<win32.UI.WindowsAndMessaging.HWND> lpKids)
        {
            fixed (win32.UI.WindowsAndMessaging.HWND*lpKidsLocal = lpKids)
            {
                win32.UI.DisplayDevices.RECT lpRectLocal = lpRect.HasValue ? lpRect.Value : default(win32.UI.DisplayDevices.RECT);
                ushort __result = User32.TileWindows(hwndParent, wHow, lpRect.HasValue ? &lpRectLocal : null, (uint)lpKids.Length, lpKidsLocal);
                return __result;
            }
        }

        /// <summary>Tiles the specified child windows of the specified parent window.</summary>
        /// <param name = "hwndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the parent window. If this parameter is <b>NULL</b>, the desktop window is assumed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tilewindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wHow">Type: <b>UINT</b></param>
        /// <param name = "lpRect">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b></para>
        /// <para>A pointer to a structure that specifies the rectangular area, in client coordinates, within which the windows are arranged. If this parameter is <b>NULL</b>, the client area of the parent window is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tilewindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cKids">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The number of elements in the array specified by the <i>lpKids</i> parameter. This parameter is ignored if <i>lpKids</i> is <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tilewindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpKids">
        /// <para>Type: <b>const HWND*</b></para>
        /// <para>An array of handles to the child windows to arrange. If a specified child window is a top-level window with the style <b>WS_EX_TOPMOST</b> or <b>WS_EX_TOOLWINDOW</b>, the child window is not arranged. If this parameter is <b>NULL</b>, all child windows of the specified parent window (or of the desktop window) are arranged.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tilewindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>WORD</b></para>
        /// <para>If the function succeeds, the return value is the number of windows arranged.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tilewindows">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe ushort TileWindows(win32.UI.WindowsAndMessaging.HWND hwndParent, win32.UI.WindowsAndMessaging.TILE_WINDOWS_HOW wHow, [Optional] win32.UI.DisplayDevices.RECT*lpRect, uint cKids, [Optional] win32.UI.WindowsAndMessaging.HWND*lpKids);
        /// <inheritdoc cref = "CascadeWindows(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.CASCADE_WINDOWS_HOW, win32.UI.DisplayDevices.RECT*, uint, win32.UI.WindowsAndMessaging.HWND*)"/>
        internal static unsafe ushort CascadeWindows(win32.UI.WindowsAndMessaging.HWND hwndParent, win32.UI.WindowsAndMessaging.CASCADE_WINDOWS_HOW wHow, win32.UI.DisplayDevices.RECT? lpRect, ReadOnlySpan<win32.UI.WindowsAndMessaging.HWND> lpKids)
        {
            fixed (win32.UI.WindowsAndMessaging.HWND*lpKidsLocal = lpKids)
            {
                win32.UI.DisplayDevices.RECT lpRectLocal = lpRect.HasValue ? lpRect.Value : default(win32.UI.DisplayDevices.RECT);
                ushort __result = User32.CascadeWindows(hwndParent, wHow, lpRect.HasValue ? &lpRectLocal : null, (uint)lpKids.Length, lpKidsLocal);
                return __result;
            }
        }

        /// <summary>Cascades the specified child windows of the specified parent window.</summary>
        /// <param name = "hwndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the parent window. If this parameter is <b>NULL</b>, the desktop window is assumed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-cascadewindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wHow">Type: <b>UINT</b></param>
        /// <param name = "lpRect">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b></para>
        /// <para>A pointer to a structure that specifies the rectangular area, in client coordinates, within which the windows are arranged. This parameter can be <b>NULL</b>, in which case the client area of the parent window is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-cascadewindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cKids">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The number of elements in the array specified by the <i>lpKids</i> parameter. This parameter is ignored if <i>lpKids</i> is <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-cascadewindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpKids">
        /// <para>Type: <b>const HWND*</b></para>
        /// <para>An array of handles to the child windows to arrange. If a specified child window is a top-level window with the style <b>WS_EX_TOPMOST</b> or <b>WS_EX_TOOLWINDOW</b>, the child window is not arranged. If this parameter is <b>NULL</b>, all child windows of the specified parent window (or of the desktop window) are arranged.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-cascadewindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>WORD</b></para>
        /// <para>If the function succeeds, the return value is the number of windows arranged.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-cascadewindows">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe ushort CascadeWindows(win32.UI.WindowsAndMessaging.HWND hwndParent, win32.UI.WindowsAndMessaging.CASCADE_WINDOWS_HOW wHow, [Optional] win32.UI.DisplayDevices.RECT*lpRect, uint cKids, [Optional] win32.UI.WindowsAndMessaging.HWND*lpKids);
        /// <summary>Retrieves or sets the value of one of the system-wide parameters.</summary>
        /// <param name = "uiAction">
        /// <para>Type: <b>UINT</b> The system-wide parameter to be retrieved or set. The possible values are organized in the following tables of related parameters: </para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-systemparametersinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uiParam">
        /// <para>Type: <b>UINT</b></para>
        /// <para>A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify zero for this parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-systemparametersinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pvParam">
        /// <para>Type: <b>PVOID</b></para>
        /// <para>A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify <b>NULL</b> for this parameter. For information on the <b>PVOID</b> datatype, see <a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">Windows Data Types</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-systemparametersinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fWinIni">
        /// <para>Type: <b>UINT</b></para>
        /// <para>If a system parameter is being set, specifies whether the user profile is to be updated, and if so, whether the <a href = "https://docs.microsoft.com/windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message is to be broadcast to all top-level windows to notify them of the change.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-systemparametersinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-systemparametersinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SystemParametersInfoW", SetLastError = true)]
        internal static extern unsafe bool SystemParametersInfo(win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION uiAction, uint uiParam, [Optional] void *pvParam, win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_UPDATE_FLAGS fWinIni);
        /// <summary>Triggers a visual signal to indicate that a sound is playing.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>This function returns one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-soundsentry">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool SoundSentry();
        [DllImport("User32", ExactSpelling = true)]
        internal static extern void SetDebugErrorLevel(uint dwLevel);
        /// <summary>Copies the text of the specified window's title bar (if it has one) into a buffer.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window or control containing the text.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-internalgetwindowtext#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pString">
        /// <para>Type: <b>LPWSTR</b></para>
        /// <para>The buffer that is to receive the text.</para>
        /// <para>If the string is as long or longer than the buffer, the string is truncated and terminated with a null character.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-internalgetwindowtext#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchMaxCount">
        /// <para>Type: <b>int</b></para>
        /// <para>The maximum number of characters to be copied to the buffer, including the null character. If the text exceeds this limit, it is truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-internalgetwindowtext#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null character.</para>
        /// <para>If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-internalgetwindowtext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern int InternalGetWindowText(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PWSTR pString, int cchMaxCount);
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool CancelShutdown();
        /// <inheritdoc cref = "GetGUIThreadInfo(uint, win32.UI.WindowsAndMessaging.GUITHREADINFO*)"/>
        internal static unsafe bool GetGUIThreadInfo(uint idThread, ref win32.UI.WindowsAndMessaging.GUITHREADINFO pgui)
        {
            fixed (win32.UI.WindowsAndMessaging.GUITHREADINFO*pguiLocal = &pgui)
            {
                bool __result = User32.GetGUIThreadInfo(idThread, pguiLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about the active window or a specified GUI thread.</summary>
        /// <param name = "idThread">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The identifier for the thread for which information is to be retrieved. To retrieve this value, use the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowthreadprocessid">GetWindowThreadProcessId</a> function. If this parameter is <b>NULL</b>, the function returns information for the foreground thread.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getguithreadinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pgui">
        /// <para>Type: <b>LPGUITHREADINFO</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-guithreadinfo">GUITHREADINFO</a> structure that receives information describing the thread. Note that you must set the <b>cbSize</b> member to <c>sizeof(GUITHREADINFO)</c> before calling this function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getguithreadinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getguithreadinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetGUIThreadInfo(uint idThread, win32.UI.WindowsAndMessaging.GUITHREADINFO*pgui);
        /// <summary>SetProcessDPIAware may be altered or unavailable. Instead, use SetProcessDPIAwareness.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero. Otherwise, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setprocessdpiaware">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool SetProcessDPIAware();
        /// <summary>IsProcessDPIAware may be altered or unavailable. Instead, use GetProcessDPIAwareness.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para><b>TRUE</b> if the process is dpi aware; otherwise, <b>FALSE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isprocessdpiaware">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsProcessDPIAware();
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool InheritWindowMonitor(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.WindowsAndMessaging.HWND hwndInherit);
        /// <inheritdoc cref = "GetDpiAwarenessContextForProcess(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe win32.System.SystemServices.DPI_AWARENESS_CONTEXT GetDpiAwarenessContextForProcess(SafeHandle hProcess)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.DPI_AWARENESS_CONTEXT __result = User32.GetDpiAwarenessContextForProcess(hProcessLocal);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.DPI_AWARENESS_CONTEXT GetDpiAwarenessContextForProcess(win32.System.SystemServices.HANDLE hProcess);
        /// <summary>Retrieves the full path and file name of the module associated with the specified window handle.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose module file name is to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowmodulefilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pszFileName">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The path and file name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowmodulefilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchFileNameMax">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The maximum number of characters that can be copied into the <i>lpszFileName</i> buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowmodulefilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>The return value is the total number of characters copied into the buffer.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowmodulefilenamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetWindowModuleFileNameW")]
        internal static extern uint GetWindowModuleFileName(win32.UI.WindowsAndMessaging.HWND hwnd, win32.System.SystemServices.PWSTR pszFileName, uint cchFileNameMax);
        /// <inheritdoc cref = "GetCursorInfo(win32.UI.WindowsAndMessaging.CURSORINFO*)"/>
        internal static unsafe bool GetCursorInfo(ref win32.UI.WindowsAndMessaging.CURSORINFO pci)
        {
            fixed (win32.UI.WindowsAndMessaging.CURSORINFO*pciLocal = &pci)
            {
                bool __result = User32.GetCursorInfo(pciLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about the global cursor.</summary>
        /// <param name = "pci">
        /// <para>Type: <b>PCURSORINFO</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ns-winuser-cursorinfo">CURSORINFO</a> structure that receives the information. Note that you must set the <b>cbSize</b> member to <c>sizeof(CURSORINFO)</c> before calling this function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcursorinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcursorinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCursorInfo(win32.UI.WindowsAndMessaging.CURSORINFO*pci);
        /// <inheritdoc cref = "GetWindowInfo(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.WINDOWINFO*)"/>
        internal static unsafe bool GetWindowInfo(win32.UI.WindowsAndMessaging.HWND hwnd, ref win32.UI.WindowsAndMessaging.WINDOWINFO pwi)
        {
            fixed (win32.UI.WindowsAndMessaging.WINDOWINFO*pwiLocal = &pwi)
            {
                bool __result = User32.GetWindowInfo(hwnd, pwiLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about the specified window.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose information is to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pwi">
        /// <para>Type: <b>PWINDOWINFO</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowinfo">WINDOWINFO</a> structure to receive the information. Note that you must set the <b>cbSize</b> member to <c>sizeof(WINDOWINFO)</c> before calling this function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// <para>To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetWindowInfo(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.WindowsAndMessaging.WINDOWINFO*pwi);
        /// <inheritdoc cref = "GetTitleBarInfo(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.TITLEBARINFO*)"/>
        internal static unsafe bool GetTitleBarInfo(win32.UI.WindowsAndMessaging.HWND hwnd, ref win32.UI.WindowsAndMessaging.TITLEBARINFO pti)
        {
            fixed (win32.UI.WindowsAndMessaging.TITLEBARINFO*ptiLocal = &pti)
            {
                bool __result = User32.GetTitleBarInfo(hwnd, ptiLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about the specified title bar.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the title bar whose information is to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-gettitlebarinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pti">
        /// <para>Type: <b>PTITLEBARINFO</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-titlebarinfo">TITLEBARINFO</a> structure to receive the information. Note that you must set the <b>cbSize</b> member to <c>sizeof(TITLEBARINFO)</c> before calling this function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-gettitlebarinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-gettitlebarinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetTitleBarInfo(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.WindowsAndMessaging.TITLEBARINFO*pti);
        /// <inheritdoc cref = "GetMenuBarInfo(win32.UI.WindowsAndMessaging.HWND, win32.UI.Controls.SCROLLBAR_OBJID, int, win32.UI.WindowsAndMessaging.MENUBARINFO*)"/>
        internal static unsafe bool GetMenuBarInfo(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.Controls.SCROLLBAR_OBJID idObject, int idItem, ref win32.UI.WindowsAndMessaging.MENUBARINFO pmbi)
        {
            fixed (win32.UI.WindowsAndMessaging.MENUBARINFO*pmbiLocal = &pmbi)
            {
                bool __result = User32.GetMenuBarInfo(hwnd, idObject, idItem, pmbiLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about the specified menu bar.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window (menu bar) whose information is to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenubarinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "idObject">Type: <b>LONG</b></param>
        /// <param name = "idItem">
        /// <para>Type: <b>LONG</b></para>
        /// <para>The item for which to retrieve information. If this parameter is zero, the function retrieves information about the menu itself. If this parameter is 1, the function retrieves information about the first item on the menu, and so on.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenubarinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pmbi">
        /// <para>Type: <b>PMENUBARINFO</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menubarinfo">MENUBARINFO</a> structure that receives the information. Note that you must set the <b>cbSize</b> member to <c>sizeof(MENUBARINFO)</c> before calling this function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenubarinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenubarinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetMenuBarInfo(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.Controls.SCROLLBAR_OBJID idObject, int idItem, win32.UI.WindowsAndMessaging.MENUBARINFO*pmbi);
        /// <summary>Retrieves the handle to the ancestor of the specified window.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose ancestor is to be retrieved. If this parameter is the desktop window, the function returns <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getancestor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "gaFlags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is the handle to the ancestor window.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getancestor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetAncestor(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.WindowsAndMessaging.GET_ANCESTOR_FLAGS gaFlags);
        /// <summary>Retrieves a handle to the child window at the specified point. The search is restricted to immediate child windows; grandchildren and deeper descendant windows are not searched.</summary>
        /// <param name = "hwndParent">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose child is to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-realchildwindowfrompoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ptParentClientCoords">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a></b></para>
        /// <para>A <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that defines the client coordinates of the point to be checked.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-realchildwindowfrompoint#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is a handle to the child window that contains the specified point.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-realchildwindowfrompoint">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND RealChildWindowFromPoint(win32.UI.WindowsAndMessaging.HWND hwndParent, win32.UI.DisplayDevices.POINT ptParentClientCoords);
        /// <summary>Retrieves a string that specifies the window type.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose type will be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-realgetwindowclassw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ptszClassName">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>A pointer to a string that receives the window type.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-realgetwindowclassw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchClassNameMax">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The length, in characters, of the buffer pointed to by the <i>pszType</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-realgetwindowclassw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the return value is the number of characters copied to the specified buffer.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-realgetwindowclassw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "RealGetWindowClassW", SetLastError = true)]
        internal static extern uint RealGetWindowClass(win32.UI.WindowsAndMessaging.HWND hwnd, win32.System.SystemServices.PWSTR ptszClassName, uint cchClassNameMax);
        /// <inheritdoc cref = "GetAltTabInfo(win32.UI.WindowsAndMessaging.HWND, int, win32.UI.WindowsAndMessaging.ALTTABINFO*, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe bool GetAltTabInfo(win32.UI.WindowsAndMessaging.HWND hwnd, int iItem, ref win32.UI.WindowsAndMessaging.ALTTABINFO pati, win32.System.SystemServices.PWSTR pszItemText, uint cchItemText)
        {
            fixed (win32.UI.WindowsAndMessaging.ALTTABINFO*patiLocal = &pati)
            {
                bool __result = User32.GetAltTabInfo(hwnd, iItem, patiLocal, pszItemText, cchItemText);
                return __result;
            }
        }

        /// <summary>Retrieves status information for the specified window if it is the application-switching (ALT+TAB) window.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window for which status information will be retrieved. This window must be the application-switching window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getalttabinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "iItem">
        /// <para>Type: <b>int</b></para>
        /// <para>The index of the icon in the application-switching window. If the <i>pszItemText</i> parameter is not <b>NULL</b>, the name of the item is copied to the <i>pszItemText</i> string. If this parameter is –1, the name of the item is not copied.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getalttabinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pati">
        /// <para>Type: <b>PALTTABINFO</b></para>
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-alttabinfo">ALTTABINFO</a> structure to receive the status information. Note that you must set the <b>csSize</b> member to <c>sizeof(ALTTABINFO)</c> before calling this function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getalttabinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pszItemText">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The name of the item. If this parameter is <b>NULL</b>, the name of the item is not copied.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getalttabinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchItemText">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The size, in characters, of the <i>pszItemText</i> buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getalttabinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getalttabinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetAltTabInfoW", SetLastError = true)]
        internal static extern unsafe bool GetAltTabInfo(win32.UI.WindowsAndMessaging.HWND hwnd, int iItem, win32.UI.WindowsAndMessaging.ALTTABINFO*pati, win32.System.SystemServices.PWSTR pszItemText, uint cchItemText);
        /// <summary>Adds or removes a message from the User Interface Privilege Isolation (UIPI) message filter.</summary>
        /// <param name = "message">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to add to or remove from the filter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changewindowmessagefilter#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlag">Type: <b>DWORD</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para><div class = "alert"><b>Note</b>  A message can be successfully removed from the filter, but that is not a guarantee that the message will be blocked. See the Remarks section for more details.</div> <div> </div></para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changewindowmessagefilter">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ChangeWindowMessageFilter(uint message, win32.UI.WindowsAndMessaging.CHANGE_WINDOW_MESSAGE_FILTER_FLAGS dwFlag);
        /// <summary>Modifies the User Interface Privilege Isolation (UIPI) message filter for a specified window.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose UIPI message filter is to be modified.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changewindowmessagefilterex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "message">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message that the message filter allows through or blocks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changewindowmessagefilterex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "action">Type: <b>DWORD</b></param>
        /// <param name = "pChangeFilterStruct">
        /// <para>Type: <b>PCHANGEFILTERSTRUCT</b></para>
        /// <para>Optional pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-changefilterstruct">CHANGEFILTERSTRUCT</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changewindowmessagefilterex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, it returns <b>TRUE</b>; otherwise, it returns <b>FALSE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changewindowmessagefilterex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ChangeWindowMessageFilterEx(win32.UI.WindowsAndMessaging.HWND hwnd, uint message, win32.UI.WindowsAndMessaging.WINDOW_MESSAGE_FILTER_ACTION action, [Optional] win32.UI.WindowsAndMessaging.CHANGEFILTERSTRUCT*pChangeFilterStruct);
        /// <summary>Determines whether the last message read from the current thread's queue originated from a WOW64 process.</summary>
        /// <returns>The function returns TRUE if the last message read from the current thread's queue originated from a WOW64 process, and FALSE otherwise.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iswow64message">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsWow64Message();
        /// <inheritdoc cref = "RegisterDeviceNotification(win32.System.SystemServices.HANDLE, void *, win32.System.Power.POWER_SETTING_REGISTER_NOTIFICATION_FLAGS)"/>
        internal static unsafe void *RegisterDeviceNotification(SafeHandle hRecipient, void *NotificationFilter, win32.System.Power.POWER_SETTING_REGISTER_NOTIFICATION_FLAGS Flags)
        {
            bool hRecipientAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hRecipientLocal;
                if (hRecipient is object)
                {
                    hRecipient.DangerousAddRef(ref hRecipientAddRef);
                    hRecipientLocal = (win32.System.SystemServices.HANDLE)hRecipient.DangerousGetHandle();
                }
                else
                    hRecipientLocal = default(win32.System.SystemServices.HANDLE);
                void *__result = User32.RegisterDeviceNotification(hRecipientLocal, NotificationFilter, Flags);
                return __result;
            }
            finally
            {
                if (hRecipientAddRef)
                    hRecipient.DangerousRelease();
            }
        }

        /// <summary>Registers the device or type of device for which a window will receive notifications.</summary>
        /// <param name = "hRecipient">
        /// <para>A handle to the window or service that will receive device events for the devices specified in the <i>NotificationFilter</i> parameter. The same window handle can be used in multiple calls to <b>RegisterDeviceNotification</b>.</para>
        /// <para>Services can specify either a window handle or service status handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerdevicenotificationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "NotificationFilter">
        /// <para>A pointer to a block of data that specifies the type of device for which notifications should be sent. This block always begins with the <a href = "https://docs.microsoft.com/windows/desktop/api/dbt/ns-dbt-dev_broadcast_hdr">DEV_BROADCAST_HDR</a> structure. The data following this header is dependent on the value of the <b>dbch_devicetype</b> member, which can be <b>DBT_DEVTYP_DEVICEINTERFACE</b> or <b>DBT_DEVTYP_HANDLE</b>. For more information, see Remarks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerdevicenotificationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a device notification handle.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerdevicenotificationw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "RegisterDeviceNotificationW", SetLastError = true)]
        internal static extern unsafe void *RegisterDeviceNotification(win32.System.SystemServices.HANDLE hRecipient, void *NotificationFilter, win32.System.Power.POWER_SETTING_REGISTER_NOTIFICATION_FLAGS Flags);
        /// <summary>Closes the specified device notification handle.</summary>
        /// <param name = "Handle">
        /// <para>Device notification handle returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerdevicenotificationa">RegisterDeviceNotification</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterdevicenotification#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterdevicenotification">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool UnregisterDeviceNotification(void *Handle);
        /// <summary>Unregisters the power setting notification.</summary>
        /// <param name = "Handle">The handle returned from the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerpowersettingnotification">RegisterPowerSettingNotification</a> function.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterpowersettingnotification">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL UnregisterPowerSettingNotification(win32.System.SystemServices.HPOWERNOTIFY Handle);
        /// <inheritdoc cref = "RegisterPowerSettingNotification(win32.System.SystemServices.HANDLE, global::System.Guid*, uint)"/>
        internal static unsafe User32.UnregisterPowerSettingNotificationSafeHandle RegisterPowerSettingNotification(SafeHandle hRecipient, in global::System.Guid PowerSettingGuid, uint Flags)
        {
            bool hRecipientAddRef = false;
            try
            {
                fixed (global::System.Guid*PowerSettingGuidLocal = &PowerSettingGuid)
                {
                    win32.System.SystemServices.HANDLE hRecipientLocal;
                    if (hRecipient is object)
                    {
                        hRecipient.DangerousAddRef(ref hRecipientAddRef);
                        hRecipientLocal = (win32.System.SystemServices.HANDLE)hRecipient.DangerousGetHandle();
                    }
                    else
                        hRecipientLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.HPOWERNOTIFY __result = User32.RegisterPowerSettingNotification(hRecipientLocal, PowerSettingGuidLocal, Flags);
                    return new User32.UnregisterPowerSettingNotificationSafeHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hRecipientAddRef)
                    hRecipient.DangerousRelease();
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "User32.UnregisterPowerSettingNotification"/>.
        /// </summary>
        internal class UnregisterPowerSettingNotificationSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal UnregisterPowerSettingNotificationSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal UnregisterPowerSettingNotificationSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => User32.UnregisterPowerSettingNotification((win32.System.SystemServices.HPOWERNOTIFY)this.handle);
        }

        /// <summary>Registers the application to receive power setting notifications for the specific power setting event.</summary>
        /// <param name = "hRecipient">
        /// <para>Handle indicating where the power setting notifications are to be sent. For interactive applications, the <i>Flags</i> parameter should be zero, and the <i>hRecipient</i> parameter should be a window handle. For services, the <i>Flags</i> parameter should be one, and the <i>hRecipient</i> parameter should be a <b>SERVICE_STATUS_HANDLE</b> as returned from <a href = "https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-registerservicectrlhandlerexa">RegisterServiceCtrlHandlerEx</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerpowersettingnotification#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "PowerSettingGuid">
        /// <para>The <b>GUID</b> of the power setting for which notifications are to be sent. For more information see <a href = "https://docs.microsoft.com/windows/desktop/Power/registering-for-power-events">Registering for Power Events</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerpowersettingnotification#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags">
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerpowersettingnotification#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns a notification handle for unregistering for power notifications. If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerpowersettingnotification">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HPOWERNOTIFY RegisterPowerSettingNotification(win32.System.SystemServices.HANDLE hRecipient, global::System.Guid*PowerSettingGuid, uint Flags);
        /// <inheritdoc cref = "RegisterSuspendResumeNotification(win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe User32.UnregisterPowerSettingNotificationSafeHandle RegisterSuspendResumeNotification(SafeHandle hRecipient, uint Flags)
        {
            bool hRecipientAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hRecipientLocal;
                if (hRecipient is object)
                {
                    hRecipient.DangerousAddRef(ref hRecipientAddRef);
                    hRecipientLocal = (win32.System.SystemServices.HANDLE)hRecipient.DangerousGetHandle();
                }
                else
                    hRecipientLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HPOWERNOTIFY __result = User32.RegisterSuspendResumeNotification(hRecipientLocal, Flags);
                return new User32.UnregisterPowerSettingNotificationSafeHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hRecipientAddRef)
                    hRecipient.DangerousRelease();
            }
        }

        /// <summary>Registers to receive notification when the system is suspended or resumed. Similar to PowerRegisterSuspendResumeNotification, but operates in user mode and can take a window handle.</summary>
        /// <param name = "hRecipient">
        /// <para>This parameter contains parameters for subscribing to a power notification or a window handle representing the subscribing process.</para>
        /// <para>If <i>Flags</i> is <b>DEVICE_NOTIFY_CALLBACK</b>, <i>hRecipient</i> is interpreted as a pointer to a <a href = "https://docs.microsoft.com/windows/win32/api/powrprof/ns-powrprof-device_notify_subscribe_parameters">DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS</a> structure. In this case, the callback function is <a href = "https://docs.microsoft.com/windows/desktop/api/powrprof/nc-powrprof-device_notify_callback_routine">DeviceNotifyCallbackRoutine</a>. When the <b>Callback</b> function executes, the  <i>Type</i> parameter is set indicating the type of event that occurred. Possible values include <b>PBT_APMSUSPEND</b>, <b>PBT_APMRESUMESUSPEND</b>, and <b>PBT_APMRESUMEAUTOMATIC</b> - see  <a href = "https://docs.microsoft.com/windows/desktop/Power/power-management-events">Power Management Events</a> for more info. The <i>Setting</i> parameter is not used with suspend/resume notifications.</para>
        /// <para>If <i>Flags</i> is <b>DEVICE_NOTIFY_WINDOW_HANDLE</b>, <i>hRecipient</i> is a handle to the window to deliver events to.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registersuspendresumenotification#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags">This parameter can be <b>DEVICE_NOTIFY_WINDOW_HANDLE</b> or <b>DEVICE_NOTIFY_CALLBACK</b>.</param>
        /// <returns>
        /// <para>A handle to the registration. Use this handle to unregister for notifications.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registersuspendresumenotification">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HPOWERNOTIFY RegisterSuspendResumeNotification(win32.System.SystemServices.HANDLE hRecipient, uint Flags);
        /// <inheritdoc cref = "UnregisterSuspendResumeNotification(win32.System.SystemServices.HPOWERNOTIFY)"/>
        internal static unsafe bool UnregisterSuspendResumeNotification(SafeHandle Handle)
        {
            bool HandleAddRef = false;
            try
            {
                win32.System.SystemServices.HPOWERNOTIFY HandleLocal;
                if (Handle is object)
                {
                    Handle.DangerousAddRef(ref HandleAddRef);
                    HandleLocal = (win32.System.SystemServices.HPOWERNOTIFY)Handle.DangerousGetHandle();
                }
                else
                    HandleLocal = default(win32.System.SystemServices.HPOWERNOTIFY);
                bool __result = User32.UnregisterSuspendResumeNotification(HandleLocal);
                return __result;
            }
            finally
            {
                if (HandleAddRef)
                    Handle.DangerousRelease();
            }
        }

        /// <summary>Cancels a registration to receive notification when the system is suspended or resumed. Similar to PowerUnregisterSuspendResumeNotification but operates in user mode.</summary>
        /// <param name = "Handle">A handle to a registration obtained by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registersuspendresumenotification">RegisterSuspendResumeNotification</a> function.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregistersuspendresumenotification">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool UnregisterSuspendResumeNotification(win32.System.SystemServices.HPOWERNOTIFY Handle);
        /// <summary>Attaches or detaches the input processing mechanism of one thread to that of another thread.</summary>
        /// <param name = "idAttach">The identifier of the thread to be attached to another thread. The thread to be attached cannot be a system thread.</param>
        /// <param name = "idAttachTo">
        /// <para>The identifier of the thread to which <i>idAttach</i> will be attached. This thread cannot be a system thread.</para>
        /// <para>A thread cannot attach to itself. Therefore, <i>idAttachTo</i> cannot equal <i>idAttach</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-attachthreadinput#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fAttach">If this parameter is <b>TRUE</b>, the two threads are attached. If the parameter is <b>FALSE</b>, the threads are detached.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>There is no extended error information; do not call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. This behavior changed as of Windows Vista.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-attachthreadinput">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool AttachThreadInput(uint idAttach, uint idAttachTo, bool fAttach);
        /// <inheritdoc cref = "WaitForInputIdle(win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe uint WaitForInputIdle(SafeHandle hProcess, uint dwMilliseconds)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = User32.WaitForInputIdle(hProcessLocal, dwMilliseconds);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Waits until the specified process has finished processing its initial input and is waiting for user input with no input pending, or until the time-out interval has elapsed.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process. If this process is a console application or does not have a message queue, <b>WaitForInputIdle</b> returns immediately.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-waitforinputidle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMilliseconds">The time-out interval, in milliseconds. If <i>dwMilliseconds</i> is INFINITE, the function does not return until the process is idle.</param>
        /// <returns>
        /// <para>The following table shows the possible return values for this function.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-waitforinputidle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint WaitForInputIdle(win32.System.SystemServices.HANDLE hProcess, uint dwMilliseconds);
        /// <inheritdoc cref = "MsgWaitForMultipleObjects(uint, win32.System.SystemServices.HANDLE*, bool, uint, win32.UI.WindowsAndMessaging.QUEUE_STATUS_FLAGS)"/>
        internal static unsafe uint MsgWaitForMultipleObjects(ReadOnlySpan<win32.System.SystemServices.HANDLE> pHandles, bool fWaitAll, uint dwMilliseconds, win32.UI.WindowsAndMessaging.QUEUE_STATUS_FLAGS dwWakeMask)
        {
            fixed (win32.System.SystemServices.HANDLE*pHandlesLocal = pHandles)
            {
                uint __result = User32.MsgWaitForMultipleObjects((uint)pHandles.Length, pHandlesLocal, fWaitAll, dwMilliseconds, dwWakeMask);
                return __result;
            }
        }

        /// <summary>Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. The objects can include input event objects.</summary>
        /// <param name = "nCount">The number of object handles in the array pointed to by <i>pHandles</i>. The maximum number of object handles is <b>MAXIMUM_WAIT_OBJECTS</b> minus one. If this parameter has the value zero, then the function waits only for an input event.</param>
        /// <param name = "pHandles">
        /// <para>An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle.</para>
        /// <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
        /// <para>The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-msgwaitformultipleobjects#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fWaitAll">If this parameter is <b>TRUE</b>, the function returns when the states of all objects in the <i>pHandles</i> array have been set to signaled and an input event has been received. If this parameter is <b>FALSE</b>, the function returns when the state of any one of the objects is set to signaled or an input event has been received. In this case, the return value indicates the object whose state caused the function to return.</param>
        /// <param name = "dwMilliseconds">
        /// <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the specified objects are not signaled; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the specified objects are signaled.</para>
        /// <para><b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
        /// <para><b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-msgwaitformultipleobjects#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwWakeMask"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined as 0x00000080L.)</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-msgwaitformultipleobjects">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint MsgWaitForMultipleObjects(uint nCount, [Optional] win32.System.SystemServices.HANDLE*pHandles, bool fWaitAll, uint dwMilliseconds, win32.UI.WindowsAndMessaging.QUEUE_STATUS_FLAGS dwWakeMask);
        /// <inheritdoc cref = "MsgWaitForMultipleObjectsEx(uint, win32.System.SystemServices.HANDLE*, uint, win32.UI.WindowsAndMessaging.QUEUE_STATUS_FLAGS, win32.System.SystemServices.MSG_WAIT_FOR_MULTIPLE_OBJECTS_EX_FLAGS)"/>
        internal static unsafe uint MsgWaitForMultipleObjectsEx(ReadOnlySpan<win32.System.SystemServices.HANDLE> pHandles, uint dwMilliseconds, win32.UI.WindowsAndMessaging.QUEUE_STATUS_FLAGS dwWakeMask, win32.System.SystemServices.MSG_WAIT_FOR_MULTIPLE_OBJECTS_EX_FLAGS dwFlags)
        {
            fixed (win32.System.SystemServices.HANDLE*pHandlesLocal = pHandles)
            {
                uint __result = User32.MsgWaitForMultipleObjectsEx((uint)pHandles.Length, pHandlesLocal, dwMilliseconds, dwWakeMask, dwFlags);
                return __result;
            }
        }

        /// <summary>Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses. The array of objects can include input event objects.</summary>
        /// <param name = "nCount">The number of object handles in the array pointed to by <i>pHandles</i>. The maximum number of object handles is <b>MAXIMUM_WAIT_OBJECTS</b> minus one. If this parameter has the value zero, then the function waits only for an input event.</param>
        /// <param name = "pHandles">
        /// <para>An array of object handles. For a list of the object types whose handles you can specify, see the Remarks section later in this topic. The array can contain handles to multiple types of objects. It may not contain multiple copies of the same handle.</para>
        /// <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
        /// <para>The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-msgwaitformultipleobjectsex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMilliseconds">
        /// <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled, an I/O completion routine or APC is queued, or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the specified objects are signaled or an I/O completion routine or APC is queued.</para>
        /// <para><b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
        /// <para><b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-msgwaitformultipleobjectsex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwWakeMask"></param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined as 0x00000080L.)</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-msgwaitformultipleobjectsex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint MsgWaitForMultipleObjectsEx(uint nCount, [Optional] win32.System.SystemServices.HANDLE*pHandles, uint dwMilliseconds, win32.UI.WindowsAndMessaging.QUEUE_STATUS_FLAGS dwWakeMask, win32.System.SystemServices.MSG_WAIT_FOR_MULTIPLE_OBJECTS_EX_FLAGS dwFlags);
        /// <inheritdoc cref = "GetGuiResources(win32.System.SystemServices.HANDLE, win32.System.SystemServices.GET_GUI_RESOURCES_FLAGS)"/>
        internal static unsafe uint GetGuiResources(SafeHandle hProcess, win32.System.SystemServices.GET_GUI_RESOURCES_FLAGS uiFlags)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = User32.GetGuiResources(hProcessLocal, uiFlags);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the count of handles to graphical user interface (GUI) objects in use by the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process. The handle must refer to a process in the current session, and must have the **PROCESS_QUERY_INFORMATION** access right (see [Process security and access rights](/windows/win32/procthread/process-security-and-access-rights)).</para>
        /// <para>If this parameter is the special value **GR_GLOBAL**, then the resource usage is reported across all processes in the current session.</para>
        /// <para>**Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP:** The **GR_GLOBAL** value is not supported until Windows 7 and Windows Server 2008 R2.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getguiresources#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uiFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the count of handles to GUI objects in use by the process. If no GUI objects are in use, the return value is zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getguiresources">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetGuiResources(win32.System.SystemServices.HANDLE hProcess, win32.System.SystemServices.GET_GUI_RESOURCES_FLAGS uiFlags);
        /// <inheritdoc cref = "UserHandleGrantAccess(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, bool)"/>
        internal static unsafe bool UserHandleGrantAccess(SafeHandle hUserHandle, SafeHandle hJob, bool bGrant)
        {
            bool hUserHandleAddRef = false;
            bool hJobAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hUserHandleLocal;
                if (hUserHandle is object)
                {
                    hUserHandle.DangerousAddRef(ref hUserHandleAddRef);
                    hUserHandleLocal = (win32.System.SystemServices.HANDLE)hUserHandle.DangerousGetHandle();
                }
                else
                    hUserHandleLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE hJobLocal;
                if (hJob is object)
                {
                    hJob.DangerousAddRef(ref hJobAddRef);
                    hJobLocal = (win32.System.SystemServices.HANDLE)hJob.DangerousGetHandle();
                }
                else
                    hJobLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = User32.UserHandleGrantAccess(hUserHandleLocal, hJobLocal, bGrant);
                return __result;
            }
            finally
            {
                if (hUserHandleAddRef)
                    hUserHandle.DangerousRelease();
                if (hJobAddRef)
                    hJob.DangerousRelease();
            }
        }

        /// <summary>Grants or denies access to a handle to a User object to a job that has a user-interface restriction.</summary>
        /// <param name = "hUserHandle">A handle to the User object.</param>
        /// <param name = "hJob">
        /// <para>A handle to the job to be granted access to the User handle. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createjobobjecta">CreateJobObject</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openjobobjecta">OpenJobObject</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-userhandlegrantaccess#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bGrant">If this parameter is TRUE, all processes associated with the job can recognize and use the handle. If the parameter is FALSE, the processes cannot use the handle.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-userhandlegrantaccess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool UserHandleGrantAccess(win32.System.SystemServices.HANDLE hUserHandle, win32.System.SystemServices.HANDLE hJob, bool bGrant);
        /// <inheritdoc cref = "GetAutoRotationState(win32.System.SystemServices.AR_STATE*)"/>
        internal static unsafe bool GetAutoRotationState(out win32.System.SystemServices.AR_STATE pState)
        {
            fixed (win32.System.SystemServices.AR_STATE*pStateLocal = &pState)
            {
                bool __result = User32.GetAutoRotationState(pStateLocal);
                return __result;
            }
        }

        /// <summary>Retrieves an AR_STATE value containing the state of screen auto-rotation for the system, for example whether auto-rotation is supported, and whether it is enabled by the user.</summary>
        /// <param name = "pState">Pointer to a location in memory that will receive the current state of auto-rotation for the system.</param>
        /// <returns>
        /// <para>TRUE if the method succeeds, otherwise FALSE.</para>
        /// <para>See <a href = "/windows/desktop/api/winuser/nf-winuser-getdisplayautorotationpreferences">GetDisplayAutoRotationPreferences</a> for an example of using this function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getautorotationstate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool GetAutoRotationState(win32.System.SystemServices.AR_STATE*pState);
        /// <inheritdoc cref = "GetDisplayAutoRotationPreferences(win32.System.SystemServices.ORIENTATION_PREFERENCE*)"/>
        internal static unsafe bool GetDisplayAutoRotationPreferences(out win32.System.SystemServices.ORIENTATION_PREFERENCE pOrientation)
        {
            fixed (win32.System.SystemServices.ORIENTATION_PREFERENCE*pOrientationLocal = &pOrientation)
            {
                bool __result = User32.GetDisplayAutoRotationPreferences(pOrientationLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the screen auto-rotation preferences for the current process.</summary>
        /// <param name = "pOrientation">Pointer to a location in memory that will receive the current orientation preference setting for the calling process.</param>
        /// <returns>TRUE if the method succeeds, otherwise FALSE.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdisplayautorotationpreferences">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool GetDisplayAutoRotationPreferences(win32.System.SystemServices.ORIENTATION_PREFERENCE*pOrientation);
        /// <summary>Sets the screen auto-rotation preferences for the current process.</summary>
        /// <param name = "orientation">Pointer to a location in memory with the screen orientation preferences to set for the calling process.</param>
        /// <returns>
        /// <para>TRUE if the method succeeds, otherwise FALSE.</para>
        /// <para>See <a href = "/windows/desktop/api/winuser/nf-winuser-getdisplayautorotationpreferences">GetDisplayAutoRotationPreferences</a> for an example of using this function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdisplayautorotationpreferences">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool SetDisplayAutoRotationPreferences(win32.System.SystemServices.ORIENTATION_PREFERENCE orientation);
        /// <inheritdoc cref = "IsImmersiveProcess(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool IsImmersiveProcess(SafeHandle hProcess)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = User32.IsImmersiveProcess(hProcessLocal);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Determines whether the process belongs to a Windows Store app.</summary>
        /// <param name = "hProcess">Target process handle.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isimmersiveprocess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool IsImmersiveProcess(win32.System.SystemServices.HANDLE hProcess);
        /// <summary>Exempts the calling process from restrictions preventing desktop processes from interacting with the Windows Store app environment. This function is used by development and debugging tools.</summary>
        /// <param name = "fEnableExemption">When set to TRUE, indicates a request to disable exemption for the calling process.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setprocessrestrictionexemption">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetProcessRestrictionExemption(bool fEnableExemption);
        /// <summary>Disables the window ghosting feature for the calling GUI process. Window ghosting is a Windows Manager feature that lets the user minimize, move, or close the main window of an application that is not responding.</summary>
        /// <remarks>
        /// <para>After calling <b>DisableProcessWindowsGhosting</b>, the ghosting feature is disabled for the duration of the process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-disableprocesswindowsghosting#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern void DisableProcessWindowsGhosting();
        /// <summary>Specifies an action or processing for the Input Method Editor (IME) through a specified subfunction.</summary>
        /// <returns>
        /// <para>The result of processing of the subfunction. If the result is not success, one of the following error codes is stored into the <b>wParam</b> of the <a href = "/windows/desktop/api/ime/ns-ime-imestruct">IMESTRUCT</a> structure.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ime/nf-ime-sendimemessageexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SendIMEMessageExW")]
        internal static extern win32.System.SystemServices.LRESULT SendIMEMessageEx(win32.UI.WindowsAndMessaging.HWND param0, win32.UI.WindowsAndMessaging.LPARAM param1);
        /// <inheritdoc cref = "IMPGetIMEA(win32.UI.WindowsAndMessaging.HWND, win32.System.WindowsProgramming.IMEPROA*)"/>
        internal static unsafe bool IMPGetIMEA(win32.UI.WindowsAndMessaging.HWND param0, ref win32.System.WindowsProgramming.IMEPROA param1)
        {
            fixed (win32.System.WindowsProgramming.IMEPROA*param1Local = &param1)
            {
                bool __result = User32.IMPGetIMEA(param0, param1Local);
                return __result;
            }
        }

        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool IMPGetIMEA(win32.UI.WindowsAndMessaging.HWND param0, win32.System.WindowsProgramming.IMEPROA*param1);
        /// <inheritdoc cref = "IMPGetIMEW(win32.UI.WindowsAndMessaging.HWND, win32.System.WindowsProgramming.IMEPROW*)"/>
        internal static unsafe bool IMPGetIMEW(win32.UI.WindowsAndMessaging.HWND param0, ref win32.System.WindowsProgramming.IMEPROW param1)
        {
            fixed (win32.System.WindowsProgramming.IMEPROW*param1Local = &param1)
            {
                bool __result = User32.IMPGetIMEW(param0, param1Local);
                return __result;
            }
        }

        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool IMPGetIMEW(win32.UI.WindowsAndMessaging.HWND param0, win32.System.WindowsProgramming.IMEPROW*param1);
        /// <inheritdoc cref = "IMPQueryIMEA(win32.System.WindowsProgramming.IMEPROA*)"/>
        internal static unsafe bool IMPQueryIMEA(ref win32.System.WindowsProgramming.IMEPROA param0)
        {
            fixed (win32.System.WindowsProgramming.IMEPROA*param0Local = &param0)
            {
                bool __result = User32.IMPQueryIMEA(param0Local);
                return __result;
            }
        }

        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool IMPQueryIMEA(win32.System.WindowsProgramming.IMEPROA*param0);
        /// <inheritdoc cref = "IMPQueryIMEW(win32.System.WindowsProgramming.IMEPROW*)"/>
        internal static unsafe bool IMPQueryIMEW(ref win32.System.WindowsProgramming.IMEPROW param0)
        {
            fixed (win32.System.WindowsProgramming.IMEPROW*param0Local = &param0)
            {
                bool __result = User32.IMPQueryIMEW(param0Local);
                return __result;
            }
        }

        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool IMPQueryIMEW(win32.System.WindowsProgramming.IMEPROW*param0);
        /// <inheritdoc cref = "IMPSetIMEA(win32.UI.WindowsAndMessaging.HWND, win32.System.WindowsProgramming.IMEPROA*)"/>
        internal static unsafe bool IMPSetIMEA(win32.UI.WindowsAndMessaging.HWND param0, ref win32.System.WindowsProgramming.IMEPROA param1)
        {
            fixed (win32.System.WindowsProgramming.IMEPROA*param1Local = &param1)
            {
                bool __result = User32.IMPSetIMEA(param0, param1Local);
                return __result;
            }
        }

        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool IMPSetIMEA(win32.UI.WindowsAndMessaging.HWND param0, win32.System.WindowsProgramming.IMEPROA*param1);
        /// <inheritdoc cref = "IMPSetIMEW(win32.UI.WindowsAndMessaging.HWND, win32.System.WindowsProgramming.IMEPROW*)"/>
        internal static unsafe bool IMPSetIMEW(win32.UI.WindowsAndMessaging.HWND param0, ref win32.System.WindowsProgramming.IMEPROW param1)
        {
            fixed (win32.System.WindowsProgramming.IMEPROW*param1Local = &param1)
            {
                bool __result = User32.IMPSetIMEW(param0, param1Local);
                return __result;
            }
        }

        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool IMPSetIMEW(win32.UI.WindowsAndMessaging.HWND param0, win32.System.WindowsProgramming.IMEPROW*param1);
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint WINNLSGetIMEHotkey(win32.UI.WindowsAndMessaging.HWND param0);
        /// <summary>Temporarily enables or disables an Input Method Editor (IME) and, at the same time, turns on or off the display of all windows owned by the IME.</summary>
        /// <returns>The previous state of the IME. <b>TRUE</b> if it was enabled before this call, otherwise, <b>FALSE</b>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls32/nf-winnls32-winnlsenableime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool WINNLSEnableIME(win32.UI.WindowsAndMessaging.HWND param0, bool param1);
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool WINNLSGetEnableStatus(win32.UI.WindowsAndMessaging.HWND param0);
        /// <summary>Flashes the specified window one time. It does not change the active state of the window.</summary>
        /// <param name = "hWnd">A handle to the window to be flashed. The window can be either open or minimized.</param>
        /// <param name = "bInvert">
        /// <para>If this parameter is <b>TRUE</b>, the window is flashed from one state to the other. If it is <b>FALSE</b>, the window is returned to its original state (either active or inactive).</para>
        /// <para>When an application is minimized and this parameter is <b>TRUE</b>, the taskbar window button flashes active/inactive. If it is <b>FALSE</b>, the taskbar window button flashes inactive, meaning that it does not change colors. It flashes, as if it were being redrawn, but it does not provide the visual invert clue to the user.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-flashwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>The return value specifies the window's state before the call to the <b>FlashWindow</b> function. If the window caption was drawn as active before the call, the return value is nonzero. Otherwise, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-flashwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool FlashWindow(win32.UI.WindowsAndMessaging.HWND hWnd, bool bInvert);
        /// <inheritdoc cref = "FlashWindowEx(win32.System.Diagnostics.Debug.FLASHWINFO*)"/>
        internal static unsafe bool FlashWindowEx(in win32.System.Diagnostics.Debug.FLASHWINFO pfwi)
        {
            fixed (win32.System.Diagnostics.Debug.FLASHWINFO*pfwiLocal = &pfwi)
            {
                bool __result = User32.FlashWindowEx(pfwiLocal);
                return __result;
            }
        }

        /// <summary>Flashes the specified window. It does not change the active state of the window.</summary>
        /// <param name = "pfwi">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-flashwinfo">FLASHWINFO</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-flashwindowex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>The return value specifies the window's state before the call to the <b>FlashWindowEx</b> function. If the window caption was drawn as active before the call, the return value is nonzero. Otherwise, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-flashwindowex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool FlashWindowEx(win32.System.Diagnostics.Debug.FLASHWINFO*pfwi);
        /// <summary>Plays a waveform sound. The waveform sound for each sound type is identified by an entry in the registry.</summary>
        /// <param name = "uType">
        /// <para>The sound to be played. The sounds are set by the user through the Sound control panel application, and then stored in the registry.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messagebeep#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-messagebeep">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool MessageBeep(uint uType);
        /// <summary>Sets the last-error code.</summary>
        /// <param name = "dwErrCode">The last-error code for the thread.</param>
        /// <param name = "dwType">This parameter is ignored.</param>
        /// <remarks>
        /// <para>The last-error code is kept in thread local storage so that multiple threads do not overwrite each other's values.</para>
        /// <para>Most functions call <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> or <b>SetLastErrorEx</b> only when they fail. However, some system functions call <b>SetLastError</b> or <b>SetLastErrorEx</b> under conditions of success; those cases are noted in each function's documentation.</para>
        /// <para>Applications can optionally retrieve the value set by this function by using the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function immediately after a function fails.</para>
        /// <para>Error codes are 32-bit values (bit 31 is the most significant bit). Bit 29 is reserved for application-defined error codes; no system error code has this bit set. If you are defining an error code for your application, set this bit to indicate that the error code has been defined by the application and to ensure that your error code does not conflict with any system-defined error codes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setlasterrorex#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern void SetLastErrorEx(uint dwErrCode, uint dwType);
        /// <inheritdoc cref = "DdeSetQualityOfService(win32.UI.WindowsAndMessaging.HWND, win32.Security.SECURITY_QUALITY_OF_SERVICE*, win32.Security.SECURITY_QUALITY_OF_SERVICE*)"/>
        internal static unsafe bool DdeSetQualityOfService(win32.UI.WindowsAndMessaging.HWND hwndClient, in win32.Security.SECURITY_QUALITY_OF_SERVICE pqosNew, ref win32.Security.SECURITY_QUALITY_OF_SERVICE pqosPrev)
        {
            fixed (win32.Security.SECURITY_QUALITY_OF_SERVICE*pqosPrevLocal = &pqosPrev)
            {
                fixed (win32.Security.SECURITY_QUALITY_OF_SERVICE*pqosNewLocal = &pqosNew)
                {
                    bool __result = User32.DdeSetQualityOfService(hwndClient, pqosNewLocal, pqosPrevLocal);
                    return __result;
                }
            }
        }

        /// <summary>Specifies the quality of service (QOS) a raw Dynamic Data Exchange (DDE) application desires for future DDE conversations it initiates.</summary>
        /// <param name = "hwndClient">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the DDE client window that specifies the source of <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/wm-dde-initiate">WM_DDE_INITIATE</a> messages a client will send to start DDE conversations.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-ddesetqualityofservice#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pqosNew">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_quality_of_service">SECURITY_QUALITY_OF_SERVICE</a>*</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_quality_of_service">SECURITY_QUALITY_OF_SERVICE</a> structure for the desired quality of service values.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-ddesetqualityofservice#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pqosPrev">
        /// <para>Type: <b>PSECURITY_QUALITY_OF_SERVICE</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_quality_of_service">SECURITY_QUALITY_OF_SERVICE</a> structure that receives the previous quality of service values associated with the window identified by <i>hwndClient</i>.</para>
        /// <para>This parameter is optional. If an application has no interest in <i>hwndClient</i>'s previous QOS values, it should set <i>pqosPrev</i> to <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-ddesetqualityofservice#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-ddesetqualityofservice">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool DdeSetQualityOfService(win32.UI.WindowsAndMessaging.HWND hwndClient, win32.Security.SECURITY_QUALITY_OF_SERVICE*pqosNew, win32.Security.SECURITY_QUALITY_OF_SERVICE*pqosPrev);
        /// <summary>Enables a Dynamic Data Exchange (DDE) server application to impersonate a DDE client application's security context. This protects secure server data from unauthorized DDE clients.</summary>
        /// <param name = "hWndClient">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the DDE client window to be impersonated. The client window must have established a DDE conversation with the server window identified by the <i>hWndServer</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-impersonateddeclientwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndServer">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the DDE server window. An application must create the server window before calling this function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-impersonateddeclientwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-impersonateddeclientwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ImpersonateDdeClientWindow(win32.UI.WindowsAndMessaging.HWND hWndClient, win32.UI.WindowsAndMessaging.HWND hWndServer);
        /// <summary>Packs a Dynamic Data Exchange (DDE) lParam value into an internal structure used for sharing DDE data between processes.</summary>
        /// <param name = "msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The DDE message to be posted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-packddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uiLo">
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>A value that corresponds to the 16-bit Windows low-order word of an <i>lParam</i> parameter for the DDE message being posted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-packddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uiHi">
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>A value that corresponds to the 16-bit Windows high-order word of an <i>lParam</i> parameter for the DDE message being posted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-packddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The return value is the <i>lParam</i> value.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-packddelparam">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.LPARAM PackDDElParam(uint msg, nuint uiLo, nuint uiHi);
        /// <inheritdoc cref = "UnpackDDElParam(uint, win32.UI.WindowsAndMessaging.LPARAM, nuint*, nuint*)"/>
        internal static unsafe bool UnpackDDElParam(uint msg, win32.UI.WindowsAndMessaging.LPARAM lParam, out nuint puiLo, out nuint puiHi)
        {
            fixed (nuint*puiHiLocal = &puiHi)
            {
                fixed (nuint*puiLoLocal = &puiLo)
                {
                    bool __result = User32.UnpackDDElParam(msg, lParam, puiLoLocal, puiHiLocal);
                    return __result;
                }
            }
        }

        /// <summary>Unpacks a Dynamic Data Exchange (DDE)lParam value received from a posted DDE message.</summary>
        /// <param name = "msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The posted DDE message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-unpackddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The <i>lParam</i> parameter of the posted DDE message that was received. The application must free the memory object specified by the <i>lParam</i> parameter by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/dde/nf-dde-freeddelparam">FreeDDElParam</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-unpackddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "puiLo">
        /// <para>Type: <b>PUINT_PTR</b></para>
        /// <para>A pointer to a variable that receives the low-order word of <i>lParam</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-unpackddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "puiHi">
        /// <para>Type: <b>PUINT_PTR</b></para>
        /// <para>A pointer to a variable that receives the high-order word of <i>lParam</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-unpackddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-unpackddelparam">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool UnpackDDElParam(uint msg, win32.UI.WindowsAndMessaging.LPARAM lParam, nuint*puiLo, nuint*puiHi);
        /// <summary>Frees the memory specified by the lParam parameter of a posted Dynamic Data Exchange (DDE) message. An application receiving a posted DDE message should call this function after it has used the UnpackDDElParam function to unpack the lParam value.</summary>
        /// <param name = "msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The posted DDE message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-freeddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The <i>lParam</i> parameter of the posted DDE message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-freeddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-freeddelparam">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool FreeDDElParam(uint msg, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Enables an application to reuse a packed Dynamic Data Exchange (DDE) lParam parameter, rather than allocating a new packed lParam. Using this function reduces reallocations for applications that pass packed DDE messages.</summary>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The <i>lParam</i> parameter of the posted DDE message being reused.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-reuseddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "msgIn">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The identifier of the received DDE message.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-reuseddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "msgOut">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The identifier of the DDE message to be posted. The DDE message will reuse the packed <i>lParam</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-reuseddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uiLo">
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>The value to be packed into the low-order word of the reused <i>lParam</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-reuseddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uiHi">
        /// <para>Type: <b>UINT_PTR</b></para>
        /// <para>The value to be packed into the high-order word of the reused <i>lParam</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-reuseddelparam#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>The return value is the new <i>lParam</i> value.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//dde/nf-dde-reuseddelparam">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.LPARAM ReuseDDElParam(win32.UI.WindowsAndMessaging.LPARAM lParam, uint msgIn, uint msgOut, nuint uiLo, nuint uiHi);
        /// <inheritdoc cref = "DdeInitialize(uint *, delegate *unmanaged[Stdcall]{uint, uint, win32.System.DataExchange.HCONV, win32.System.DataExchange.HSZ, win32.System.DataExchange.HSZ, win32.System.DataExchange.HDDEDATA, nuint, nuint, win32.System.DataExchange.HDDEDATA}, win32.System.DataExchange.DDE_INITIALIZE_COMMAND, uint)"/>
        internal static unsafe uint DdeInitialize(ref uint pidInst, delegate *unmanaged[Stdcall]<uint, uint, win32.System.DataExchange.HCONV, win32.System.DataExchange.HSZ, win32.System.DataExchange.HSZ, win32.System.DataExchange.HDDEDATA, nuint, nuint, win32.System.DataExchange.HDDEDATA>pfnCallback, win32.System.DataExchange.DDE_INITIALIZE_COMMAND afCmd, uint ulRes)
        {
            fixed (uint *pidInstLocal = &pidInst)
            {
                uint __result = User32.DdeInitialize(pidInstLocal, pfnCallback, afCmd, ulRes);
                return __result;
            }
        }

        /// <summary>Registers an application with the Dynamic Data Exchange Management Library (DDEML). An application must call this function before calling any other Dynamic Data Exchange Management Library (DDEML) function.</summary>
        /// <param name = "pidInst">
        /// <para>Type: <b>LPDWORD</b></para>
        /// <para>The application instance identifier. At initialization, this parameter should point to 0. If the function succeeds, this parameter points to the instance identifier for the application. This value should be passed as the <i>idInst</i> parameter in all other DDEML functions that require it. If an application uses multiple instances of the DDEML dynamic-link library (DLL), the application should provide a different callback function for each instance.</para>
        /// <para>If <i>pidInst</i> points to a nonzero value, reinitialization of the DDEML is implied. In this case, <i>pidInst</i> must point to a valid application-instance identifier.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeinitializew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pfnCallback">
        /// <para>Type: <b>PFNCALLBACK</b></para>
        /// <para>A pointer to the application-defined DDE callback function. This function processes DDE transactions sent by the system. For more information, see the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nc-ddeml-pfncallback">DdeCallback</a> callback function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeinitializew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "afCmd">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>A set of <b>APPCMD_</b>, <b>CBF_</b>, and <b>MF_</b> flags. The <b>APPCMD_</b> flags provide special instructions to <b>DdeInitialize</b>. The <b>CBF_</b> flags specify filters that prevent specific types of transactions from reaching the callback function. The <b>MF_</b> flags specify the types of DDE activity that a DDE monitoring application monitors. Using these flags enhances the performance of a DDE application by eliminating unnecessary calls to the callback function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeinitializew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ulRes">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>Reserved; must be set to zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeinitializew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the return value is <b>DMLERR_NO_ERROR</b>.</para>
        /// <para>If the function fails, the return value is one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeinitializew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DdeInitializeW")]
        internal static extern unsafe uint DdeInitialize(uint *pidInst, delegate *unmanaged[Stdcall]<uint, uint, win32.System.DataExchange.HCONV, win32.System.DataExchange.HSZ, win32.System.DataExchange.HSZ, win32.System.DataExchange.HDDEDATA, nuint, nuint, win32.System.DataExchange.HDDEDATA>pfnCallback, win32.System.DataExchange.DDE_INITIALIZE_COMMAND afCmd, uint ulRes);
        /// <summary>Frees all Dynamic Data Exchange Management Library (DDEML) resources associated with the calling application.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeuninitialize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeuninitialize">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DdeUninitialize(uint idInst);
        /// <inheritdoc cref = "DdeConnectList(uint, win32.System.DataExchange.HSZ, win32.System.DataExchange.HSZ, win32.System.DataExchange.HCONVLIST, win32.System.DataExchange.CONVCONTEXT*)"/>
        internal static unsafe win32.System.DataExchange.HCONVLIST DdeConnectList(uint idInst, win32.System.DataExchange.HSZ hszService, win32.System.DataExchange.HSZ hszTopic, win32.System.DataExchange.HCONVLIST hConvList, win32.System.DataExchange.CONVCONTEXT? pCC)
        {
            win32.System.DataExchange.CONVCONTEXT pCCLocal = pCC.HasValue ? pCC.Value : default(win32.System.DataExchange.CONVCONTEXT);
            win32.System.DataExchange.HCONVLIST __result = User32.DdeConnectList(idInst, hszService, hszTopic, hConvList, pCC.HasValue ? &pCCLocal : null);
            return __result;
        }

        /// <summary>Establishes a conversation with all server applications that support the specified service name and topic name pair.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeconnectlist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hszService">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the string that specifies the service name of the server application with which a conversation is to be established. If this parameter is 0L, the system attempts to establish conversations with all available servers that support the specified topic name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeconnectlist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hszTopic">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the string that specifies the name of the topic on which a conversation is to be established. This handle must have been created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddecreatestringhandlea">DdeCreateStringHandle</a> function. If this parameter is 0L, the system will attempt to establish conversations on all topics supported by the selected server (or servers).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeconnectlist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hConvList">
        /// <para>Type: <b>HCONVLIST</b></para>
        /// <para>A handle to the conversation list to be enumerated. This parameter should be 0L if a new conversation list is to be established.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeconnectlist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pCC">
        /// <para>Type: <b>PCONVCONTEXT</b></para>
        /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/ns-ddeml-convcontext">CONVCONTEXT</a> structure that contains conversation-context information. If this parameter is <b>NULL</b>, the server receives the default <b>CONVCONTEXT</b> structure during the <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-connect">XTYP_CONNECT</a> or <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-wildconnect">XTYP_WILDCONNECT</a> transaction.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeconnectlist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HCONVLIST</b></para>
        /// <para>If the function succeeds, the return value is the handle to a new conversation list.</para>
        /// <para>If the function fails, the return value is 0L. The handle to the old conversation list is no longer valid.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeconnectlist">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe win32.System.DataExchange.HCONVLIST DdeConnectList(uint idInst, win32.System.DataExchange.HSZ hszService, win32.System.DataExchange.HSZ hszTopic, win32.System.DataExchange.HCONVLIST hConvList, [Optional] win32.System.DataExchange.CONVCONTEXT*pCC);
        /// <summary>Retrieves the next conversation handle in the specified conversation list.</summary>
        /// <param name = "hConvList">
        /// <para>Type: <b>HCONVLIST</b></para>
        /// <para>A handle to the conversation list. This handle must have been created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeconnectlist">DdeConnectList</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequerynextserver#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hConvPrev">
        /// <para>Type: <b>HCONV</b></para>
        /// <para>A handle to the conversation handle previously returned by this function. If this parameter is 0L, the function returns the first conversation handle in the list.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequerynextserver#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HCONV</b></para>
        /// <para>If the list contains any more conversation handles, the return value is the next conversation handle in the list; otherwise, it is 0L.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequerynextserver">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.System.DataExchange.HCONV DdeQueryNextServer(win32.System.DataExchange.HCONVLIST hConvList, win32.System.DataExchange.HCONV hConvPrev);
        /// <summary>Destroys the specified conversation list and terminates all conversations associated with the list.</summary>
        /// <param name = "hConvList">
        /// <para>Type: <b>HCONVLIST</b></para>
        /// <para>A handle to the conversation list. This handle must have been created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeconnectlist">DdeConnectList</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddedisconnectlist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddedisconnectlist">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DdeDisconnectList(win32.System.DataExchange.HCONVLIST hConvList);
        /// <inheritdoc cref = "DdeConnect(uint, win32.System.DataExchange.HSZ, win32.System.DataExchange.HSZ, win32.System.DataExchange.CONVCONTEXT*)"/>
        internal static unsafe win32.System.DataExchange.HCONV DdeConnect(uint idInst, win32.System.DataExchange.HSZ hszService, win32.System.DataExchange.HSZ hszTopic, win32.System.DataExchange.CONVCONTEXT? pCC)
        {
            win32.System.DataExchange.CONVCONTEXT pCCLocal = pCC.HasValue ? pCC.Value : default(win32.System.DataExchange.CONVCONTEXT);
            win32.System.DataExchange.HCONV __result = User32.DdeConnect(idInst, hszService, hszTopic, pCC.HasValue ? &pCCLocal : null);
            return __result;
        }

        /// <summary>Establishes a conversation with a server application that supports the specified service name and topic name pair. If more than one such server exists, the system selects only one.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeconnect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hszService">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the string that specifies the service name of the server application with which a conversation is to be established. This handle must have been created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddecreatestringhandlea">DdeCreateStringHandle</a> function. If this parameter is 0L, a conversation is established with any available server.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeconnect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hszTopic">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the string that specifies the name of the topic on which a conversation is to be established. This handle must have been created by a previous call to <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddecreatestringhandlea">DdeCreateStringHandle</a>. If this parameter is 0L, a conversation on any topic supported by the selected server is established.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeconnect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pCC">
        /// <para>Type: <b>PCONVCONTEXT</b></para>
        /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/ns-ddeml-convcontext">CONVCONTEXT</a> structure that contains conversation context information. If this parameter is <b>NULL</b>, the server receives the default <b>CONVCONTEXT</b> structure during the <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-connect">XTYP_CONNECT</a> or <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-wildconnect">XTYP_WILDCONNECT</a> transaction.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeconnect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HCONV</b></para>
        /// <para>If the function succeeds, the return value is the handle to the established conversation.</para>
        /// <para>If the function fails, the return value is 0L.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeconnect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe win32.System.DataExchange.HCONV DdeConnect(uint idInst, win32.System.DataExchange.HSZ hszService, win32.System.DataExchange.HSZ hszTopic, [Optional] win32.System.DataExchange.CONVCONTEXT*pCC);
        /// <summary>Terminates a conversation started by either the DdeConnect or DdeConnectList function and invalidates the specified conversation handle.</summary>
        /// <param name = "hConv">
        /// <para>Type: <b>HCONV</b></para>
        /// <para>A handle to the active conversation to be terminated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddedisconnect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddedisconnect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DdeDisconnect(win32.System.DataExchange.HCONV hConv);
        /// <summary>Enables a client Dynamic Data Exchange Management Library (DDEML) application to attempt to reestablish a conversation with a service that has terminated a conversation with the client.</summary>
        /// <param name = "hConv">
        /// <para>Type: <b>HCONV</b></para>
        /// <para>A handle to the conversation to be reestablished. A client must have obtained the conversation handle by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeconnect">DdeConnect</a> function or from an <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-disconnect">XTYP_DISCONNECT</a> transaction.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddereconnect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HCONV</b></para>
        /// <para>If the function succeeds, the return value is the handle to the reestablished conversation.</para>
        /// <para>If the function fails, the return value is 0L.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddereconnect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.System.DataExchange.HCONV DdeReconnect(win32.System.DataExchange.HCONV hConv);
        /// <inheritdoc cref = "DdeQueryConvInfo(win32.System.DataExchange.HCONV, uint, win32.System.DataExchange.CONVINFO*)"/>
        internal static unsafe uint DdeQueryConvInfo(win32.System.DataExchange.HCONV hConv, uint idTransaction, ref win32.System.DataExchange.CONVINFO pConvInfo)
        {
            fixed (win32.System.DataExchange.CONVINFO*pConvInfoLocal = &pConvInfo)
            {
                uint __result = User32.DdeQueryConvInfo(hConv, idTransaction, pConvInfoLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about a Dynamic Data Exchange (DDE) transaction and about the conversation in which the transaction takes place.</summary>
        /// <param name = "hConv">
        /// <para>Type: <b>HCONV</b></para>
        /// <para>A handle to the conversation.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequeryconvinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "idTransaction">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The transaction. For asynchronous transactions, this parameter should be a transaction identifier returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeclienttransaction">DdeClientTransaction</a> function. For synchronous transactions, this parameter should be QID_SYNC.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequeryconvinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pConvInfo">
        /// <para>Type: <b>PCONVINFO</b></para>
        /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/ns-ddeml-convinfo">CONVINFO</a> structure that receives information about the transaction and conversation. The <i>cb</i> member of the <b>CONVINFO</b> structure must specify the length of the buffer allocated for the structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequeryconvinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the return value is the number of bytes copied into the <a href = "/windows/desktop/api/ddeml/ns-ddeml-convinfo">CONVINFO</a> structure.</para>
        /// <para>If the function fails, the return value is <b>FALSE</b>.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequeryconvinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe uint DdeQueryConvInfo(win32.System.DataExchange.HCONV hConv, uint idTransaction, win32.System.DataExchange.CONVINFO*pConvInfo);
        /// <summary>Associates an application-defined value with a conversation handle or a transaction identifier. This is useful for simplifying the processing of asynchronous transactions. An application can use the DdeQueryConvInfo function to retrieve this value.</summary>
        /// <param name = "hConv">
        /// <para>Type: <b>HCONV</b></para>
        /// <para>A handle to the conversation.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddesetuserhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "id">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The transaction identifier to associate with the value specified by the <i>hUser</i> parameter. An application should set this parameter to QID_SYNC to associate <i>hUser</i> with the conversation identified by the <i>hConv</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddesetuserhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hUser">
        /// <para>Type: <b>DWORD_PTR</b></para>
        /// <para>The value to be associated with the conversation handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddesetuserhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddesetuserhandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DdeSetUserHandle(win32.System.DataExchange.HCONV hConv, uint id, nuint hUser);
        /// <summary>Abandons the specified asynchronous transaction and releases all resources associated with the transaction.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeabandontransaction#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hConv">
        /// <para>Type: <b>HCONV</b></para>
        /// <para>A handle to the conversation in which the transaction was initiated. If this parameter is 0L, all transactions are abandoned (that is, the <i>idTransaction</i> parameter is ignored).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeabandontransaction#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "idTransaction">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The identifier of the transaction to be abandoned. If this parameter is 0L, all active transactions in the specified conversation are abandoned.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeabandontransaction#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeabandontransaction">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DdeAbandonTransaction(uint idInst, win32.System.DataExchange.HCONV hConv, uint idTransaction);
        /// <summary>Causes the system to send an XTYP_ADVREQ transaction to the calling (server) application's Dynamic Data Exchange (DDE) callback function for each client with an active advise loop on the specified topic and item.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddepostadvise#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hszTopic">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to a string that specifies the topic name. To send notifications for all topics with active advise loops, an application can set this parameter to 0L.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddepostadvise#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hszItem">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to a string that specifies the item name. To send notifications for all items with active advise loops, an application can set this parameter to 0L.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddepostadvise#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddepostadvise">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DdePostAdvise(uint idInst, win32.System.DataExchange.HSZ hszTopic, win32.System.DataExchange.HSZ hszItem);
        /// <summary>Enables or disables transactions for a specific conversation or for all conversations currently established by the calling application.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application-instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeenablecallback#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hConv">
        /// <para>Type: <b>HCONV</b></para>
        /// <para>A handle to the conversation to enable or disable. If this parameter is <b>NULL</b>, the function affects all conversations.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeenablecallback#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wCmd">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// <para>If the <i>wCmd</i> parameter is <b>EC_QUERYWAITING</b>, and the application transaction queue contains one or more unprocessed transactions that are not being processed, the return value is <b>TRUE</b>; otherwise, it is <b>FALSE</b>.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeenablecallback">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DdeEnableCallback(uint idInst, win32.System.DataExchange.HCONV hConv, win32.System.DataExchange.DDE_ENABLE_CALLBACK_CMD wCmd);
        /// <summary>Impersonates a Dynamic Data Exchange (DDE) client application in a DDE client conversation.</summary>
        /// <param name = "hConv">
        /// <para>Type: <b>HCONV</b></para>
        /// <para>A handle to the DDE client conversation to be impersonated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeimpersonateclient#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeimpersonateclient">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DdeImpersonateClient(win32.System.DataExchange.HCONV hConv);
        /// <summary>Registers or unregisters the service names a Dynamic Data Exchange (DDE) server supports.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddenameservice#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hsz1">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the string that specifies the service name the server is registering or unregistering. An application that is unregistering all of its service names should set this parameter to 0L.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddenameservice#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hsz2">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>Reserved; should be set to 0L.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddenameservice#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "afCmd">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>HDDEDATA</b></para>
        /// <para>If the function succeeds, it returns a nonzero value. That value is not a true <b>HDDEDATA</b> value, merely a Boolean indicator of success. The function is typed <b>HDDEDATA</b> to allow for possible future expansion of the function and a more sophisticated return value.</para>
        /// <para>If the function fails, the return value is 0L.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddenameservice">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.System.DataExchange.HDDEDATA DdeNameService(uint idInst, win32.System.DataExchange.HSZ hsz1, win32.System.DataExchange.HSZ hsz2, win32.System.DataExchange.DDE_NAME_SERVICE_CMD afCmd);
        /// <inheritdoc cref = "DdeClientTransaction(byte *, uint, win32.System.DataExchange.HCONV, win32.System.DataExchange.HSZ, uint, win32.System.DataExchange.DDE_CLIENT_TRANSACTION_TYPE, uint, uint *)"/>
        internal static unsafe win32.System.DataExchange.HDDEDATA DdeClientTransaction(byte? pData, uint cbData, win32.System.DataExchange.HCONV hConv, win32.System.DataExchange.HSZ hszItem, uint wFmt, win32.System.DataExchange.DDE_CLIENT_TRANSACTION_TYPE wType, uint dwTimeout, uint *pdwResult)
        {
            byte pDataLocal = pData.HasValue ? pData.Value : default(byte);
            win32.System.DataExchange.HDDEDATA __result = User32.DdeClientTransaction(pData.HasValue ? &pDataLocal : null, cbData, hConv, hszItem, wFmt, wType, dwTimeout, pdwResult);
            return __result;
        }

        /// <summary>Begins a data transaction between a client and a server. Only a Dynamic Data Exchange (DDE) client application can call this function, and the application can use it only after establishing a conversation with the server.</summary>
        /// <param name = "pData">
        /// <para>Type: <b>LPBYTE</b></para>
        /// <para>The beginning of the data the client must pass to the server.</para>
        /// <para>Optionally, an application can specify the data handle (<b>HDDEDATA</b>) to pass to the server and in that case the <i>cbData</i> parameter should be set to -1. This parameter is required only if the <i>wType</i> parameter is <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-execute">XTYP_EXECUTE</a> or <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-poke">XTYP_POKE</a>. Otherwise, this parameter should be <b>NULL</b>.</para>
        /// <para>For the optional usage of this parameter, <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-poke">XTYP_POKE</a> transactions where <i>pData</i> is a data handle, the handle must have been created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddecreatedatahandle">DdeCreateDataHandle</a> function, employing the same data format specified in the <i>wFmt</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeclienttransaction#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbData">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The length, in bytes, of the data pointed to by the <i>pData</i> parameter, including the terminating <b>NULL</b>, if the data is a string. A value of -1 indicates that <i>pData</i> is a data handle that identifies the data being sent.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeclienttransaction#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hConv">
        /// <para>Type: <b>HCONV</b></para>
        /// <para>A handle to the conversation in which the transaction is to take place.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeclienttransaction#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hszItem">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the data item for which data is being exchanged during the transaction. This handle must have been created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddecreatestringhandlea">DdeCreateStringHandle</a> function. This parameter is ignored (and should be set to 0L) if the <i>wType</i> parameter is <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-execute">XTYP_EXECUTE</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeclienttransaction#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wFmt">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The standard clipboard format in which the data item is being submitted or requested.</para>
        /// <para>If the transaction specified by the <i>wType</i> parameter does not pass data or is <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-execute">XTYP_EXECUTE</a>, this parameter should be zero.</para>
        /// <para>If the transaction specified by the <i>wType</i> parameter references non-execute DDE data ( <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-poke">XTYP_POKE</a>, <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-advstart">XTYP_ADVSTART</a>, <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-advstop">XTYP_ADVSTOP</a>, <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-request">XTYP_REQUEST</a>), the <i>wFmt</i> value must be either a valid predefined (CF_) DDE format or a valid registered clipboard format.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeclienttransaction#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wType">Type: <b>UINT</b></param>
        /// <param name = "dwTimeout">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The maximum amount of time, in milliseconds, that the client will wait for a response from the server application in a synchronous transaction. This parameter should be <b>TIMEOUT_ASYNC</b> for asynchronous transactions.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeclienttransaction#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pdwResult">
        /// <para>Type: <b>LPDWORD</b></para>
        /// <para>A pointer to a variable that receives the result of the transaction. An application that does not check the result can use <b>NULL</b> for this value. For synchronous transactions, the low-order word of this variable contains any applicable DDE_ flags resulting from the transaction. This provides support for applications dependent on <b>DDE_APPSTATUS</b> bits. It is, however, recommended that applications no longer use these bits because they may not be supported in future versions of the <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/dynamic-data-exchange-management-library">Dynamic Data Exchange Management Library</a> (DDEML). For asynchronous transactions, this variable is filled with a unique transaction identifier for use with the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeabandontransaction">DdeAbandonTransaction</a> function and the <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-xact-complete">XTYP_XACT_COMPLETE</a> transaction.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeclienttransaction#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HDDEDATA</b></para>
        /// <para>If the function succeeds, the return value is a data handle that identifies the data for successful synchronous transactions in which the client expects data from the server. The return value is nonzero for successful asynchronous transactions and for synchronous transactions in which the client does not expect data. The return value is zero for all unsuccessful transactions.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeclienttransaction">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe win32.System.DataExchange.HDDEDATA DdeClientTransaction([Optional] byte *pData, uint cbData, win32.System.DataExchange.HCONV hConv, win32.System.DataExchange.HSZ hszItem, uint wFmt, win32.System.DataExchange.DDE_CLIENT_TRANSACTION_TYPE wType, uint dwTimeout, [Optional] uint *pdwResult);
        /// <inheritdoc cref = "DdeCreateDataHandle(uint, byte *, uint, uint, win32.System.DataExchange.HSZ, uint, uint)"/>
        internal static unsafe win32.System.DataExchange.HDDEDATA DdeCreateDataHandle(uint idInst, byte? pSrc, uint cb, uint cbOff, win32.System.DataExchange.HSZ hszItem, uint wFmt, uint afCmd)
        {
            byte pSrcLocal = pSrc.HasValue ? pSrc.Value : default(byte);
            win32.System.DataExchange.HDDEDATA __result = User32.DdeCreateDataHandle(idInst, pSrc.HasValue ? &pSrcLocal : null, cb, cbOff, hszItem, wFmt, afCmd);
            return __result;
        }

        /// <summary>Creates a Dynamic Data Exchange (DDE) object and fills the object with data from the specified buffer. A DDE application uses this function during transactions that involve passing data to the partner application.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatedatahandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pSrc">
        /// <para>Type: <b>LPBYTE</b></para>
        /// <para>The data to be copied to the DDE object. If this parameter is <b>NULL</b>, no data is copied to the object.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatedatahandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cb">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The amount of memory, in bytes, to copy from the buffer pointed to by <i>pSrc</i>. (include the terminating NULL, if the data is a string). If this parameter is zero, the <i>pSrc</i> parameter is ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatedatahandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbOff">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>An offset, in bytes, from the beginning of the buffer pointed to by the <i>pSrc</i> parameter. The data beginning at this offset is copied from the buffer to the DDE object.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatedatahandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hszItem">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the string that specifies the data item corresponding to the DDE object. This handle must have been created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddecreatestringhandlea">DdeCreateStringHandle</a> function. If the data handle is to be used in an <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/xtyp-execute">XTYP_EXECUTE</a> transaction, this parameter must be 0L.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatedatahandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wFmt">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The standard clipboard format of the data.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatedatahandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "afCmd">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The creation flags. This parameter can be <b>HDATA_APPOWNED</b>, which specifies that the server application calling the <b>DdeCreateDataHandle</b> function owns the data handle this function creates. This flag enables the application to share the data handle with other DDEML applications rather than creating a separate handle to pass to each application. If this flag is specified, the application must eventually free the shared memory object associated with the handle by using the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddefreedatahandle">DdeFreeDataHandle</a> function. If this flag is not specified, the handle becomes invalid in the application that created the handle after the data handle is returned by the application's DDE callback function or is used as a parameter in another DDEML function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatedatahandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HDDEDATA</b></para>
        /// <para>If the function succeeds, the return value is a data handle.</para>
        /// <para>If the function fails, the return value is 0L.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatedatahandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe win32.System.DataExchange.HDDEDATA DdeCreateDataHandle(uint idInst, [Optional] byte *pSrc, uint cb, uint cbOff, win32.System.DataExchange.HSZ hszItem, uint wFmt, uint afCmd);
        /// <inheritdoc cref = "DdeAddData(win32.System.DataExchange.HDDEDATA, byte *, uint, uint)"/>
        internal static unsafe win32.System.DataExchange.HDDEDATA DdeAddData(win32.System.DataExchange.HDDEDATA hData, in byte pSrc, uint cb, uint cbOff)
        {
            fixed (byte *pSrcLocal = &pSrc)
            {
                win32.System.DataExchange.HDDEDATA __result = User32.DdeAddData(hData, pSrcLocal, cb, cbOff);
                return __result;
            }
        }

        /// <summary>Adds data to the specified Dynamic Data Exchange (DDE) object.</summary>
        /// <param name = "hData">
        /// <para>Type: <b>HDDEDATA</b></para>
        /// <para>A handle to the DDE object that receives additional data.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeadddata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pSrc">
        /// <para>Type: <b>LPBYTE</b></para>
        /// <para>The data to be added to the DDE object.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeadddata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cb">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The length, in bytes, of the data to be added to the DDE object, including the terminating <b>NULL</b>, if the data is a string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeadddata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbOff">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>An offset, in bytes, from the beginning of the DDE object. The additional data is copied to the object beginning at this offset.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeadddata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HDDEDATA</b></para>
        /// <para>If the function succeeds, the return value is a new handle to the DDE object. The new handle is used in all references to the object.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeadddata">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe win32.System.DataExchange.HDDEDATA DdeAddData(win32.System.DataExchange.HDDEDATA hData, byte *pSrc, uint cb, uint cbOff);
        /// <summary>Copies data from the specified Dynamic Data Exchange (DDE) object to the specified local buffer.</summary>
        /// <param name = "hData">
        /// <para>Type: <b>HDDEDATA</b></para>
        /// <para>A handle to the DDE object that contains the data to copy.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddegetdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pDst">
        /// <para>Type: <b>LPBYTE</b></para>
        /// <para>A pointer to the buffer that receives the data. If this parameter is <b>NULL</b>, the <b>DdeGetData</b> function returns the amount of data, in bytes, that would be copied to the buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddegetdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbMax">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The maximum amount of data, in bytes, to copy to the buffer pointed to by the <i>pDst</i> parameter. Typically, this parameter specifies the length of the buffer pointed to by <i>pDst</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddegetdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbOff">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>An offset within the DDE object. Data is copied from the object beginning at this offset.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddegetdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>If the <i>pDst</i> parameter points to a buffer, the return value is the size, in bytes, of the memory object associated with the data handle or the size specified in the <i>cbMax</i> parameter, whichever is lower.</para>
        /// <para>If the <i>pDst</i> parameter is <b>NULL</b>, the return value is the size, in bytes, of the memory object associated with the data handle.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddegetdata">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe uint DdeGetData(win32.System.DataExchange.HDDEDATA hData, [Optional] byte *pDst, uint cbMax, uint cbOff);
        /// <summary>Provides access to the data in the specified Dynamic Data Exchange (DDE) object. An application must call the DdeUnaccessData function when it has finished accessing the data in the object.</summary>
        /// <param name = "hData">
        /// <para>Type: <b>HDDEDATA</b></para>
        /// <para>A handle to the DDE object to be accessed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeaccessdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcbDataSize">
        /// <para>Type: <b>LPDWORD</b></para>
        /// <para>A pointer to a variable that receives the size, in bytes, of the DDE object identified by the <i>hData</i> parameter. If this parameter is <b>NULL</b>, no size information is returned.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeaccessdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LPBYTE</b></para>
        /// <para>If the function succeeds, the return value is a pointer to the first byte of data in the DDE object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeaccessdata">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe byte *DdeAccessData(win32.System.DataExchange.HDDEDATA hData, [Optional] uint *pcbDataSize);
        /// <summary>Unaccesses a Dynamic Data Exchange (DDE) object. An application must call this function after it has finished accessing the object.</summary>
        /// <param name = "hData">
        /// <para>Type: <b>HDDEDATA</b></para>
        /// <para>A handle to the DDE object.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeunaccessdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddeunaccessdata">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DdeUnaccessData(win32.System.DataExchange.HDDEDATA hData);
        /// <summary>Frees a Dynamic Data Exchange (DDE) object and deletes the data handle associated with the object.</summary>
        /// <param name = "hData">
        /// <para>Type: <b>HDDEDATA</b></para>
        /// <para>A handle to the DDE object to be freed. This handle must have been created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddecreatedatahandle">DdeCreateDataHandle</a> function or returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeclienttransaction">DdeClientTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddefreedatahandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddefreedatahandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DdeFreeDataHandle(win32.System.DataExchange.HDDEDATA hData);
        /// <summary>Retrieves the most recent error code set by the failure of a Dynamic Data Exchange Management Library (DDEML) function and resets the error code to DMLERR_NO_ERROR.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddegetlasterror#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the return value is the last error code, which can be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddegetlasterror">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint DdeGetLastError(uint idInst);
        /// <inheritdoc cref = "DdeCreateStringHandle(uint, win32.System.SystemServices.PCWSTR, int)"/>
        internal static unsafe win32.System.DataExchange.HSZ DdeCreateStringHandle(uint idInst, string psz, int iCodePage)
        {
            fixed (char *pszLocal = psz)
            {
                win32.System.DataExchange.HSZ __result = User32.DdeCreateStringHandle(idInst, pszLocal, iCodePage);
                return __result;
            }
        }

        /// <summary>Creates a handle that identifies the specified string. A Dynamic Data Exchange (DDE) client or server application can pass the string handle as a parameter to other Dynamic Data Exchange Management Library (DDEML) functions.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatestringhandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "psz">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The null-terminated string for which a handle is to be created. This string can be up to 255 characters. The reason for this limit is that DDEML string management functions are implemented using atoms.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatestringhandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "iCodePage">
        /// <para>Type: <b>int</b></para>
        /// <para>The code page to be used to render the string. This value should be either <b>CP_WINANSI</b> (the default code page) or CP_WINUNICODE, depending on whether the ANSI or Unicode version of <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> was called by the client application.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatestringhandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HSZ</b></para>
        /// <para>If the function succeeds, the return value is a string handle.</para>
        /// <para>If the function fails, the return value is 0L.</para>
        /// <para>The <a href = "/windows/desktop/api/ddeml/nf-ddeml-ddegetlasterror">DdeGetLastError</a> function can be used to get the error code, which can be one of the following values:</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecreatestringhandlew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DdeCreateStringHandleW")]
        internal static extern win32.System.DataExchange.HSZ DdeCreateStringHandle(uint idInst, win32.System.SystemServices.PCWSTR psz, int iCodePage);
        /// <summary>Copies text associated with a string handle into a buffer.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequerystringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hsz">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the string to copy. This handle must have been created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddecreatestringhandlea">DdeCreateStringHandle</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequerystringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "psz">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>A pointer to a buffer that receives the string. To obtain the length of the string, this parameter should be set to <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequerystringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchMax">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The length, in characters, of the buffer pointed to by the <i>psz</i> parameter. For the ANSI version of the function, this is the number of bytes; for the Unicode version, this is the number of characters. If the string is longer than ( <i>cchMax</i>– 1), it will be truncated. If the <i>psz</i> parameter is set to <b>NULL</b>, this parameter is ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequerystringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "iCodePage">
        /// <para>Type: <b>int</b></para>
        /// <para>The code page used to render the string. This value should be either <b>CP_WINANSI</b> or <b>CP_WINUNICODE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequerystringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>If the <i>psz</i> parameter specified a valid pointer, the return value is the length, in characters, of the returned text (not including the terminating null character). If the <i>psz</i> parameter specified a <b>NULL</b> pointer, the return value is the length of the text associated with the <i>hsz</i> parameter (not including the terminating null character). If an error occurs, the return value is 0L.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddequerystringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DdeQueryStringW")]
        internal static extern uint DdeQueryString(uint idInst, win32.System.DataExchange.HSZ hsz, win32.System.SystemServices.PWSTR psz, uint cchMax, int iCodePage);
        /// <summary>Frees a string handle in the calling application.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddefreestringhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hsz">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the string handle to be freed. This handle must have been created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddecreatestringhandlea">DdeCreateStringHandle</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddefreestringhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddefreestringhandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DdeFreeStringHandle(uint idInst, win32.System.DataExchange.HSZ hsz);
        /// <summary>Increments the usage count associated with the specified handle.</summary>
        /// <param name = "idInst">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The application instance identifier obtained by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/ddeml/nf-ddeml-ddeinitializea">DdeInitialize</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddekeepstringhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hsz">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the string handle to be saved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddekeepstringhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddekeepstringhandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DdeKeepStringHandle(uint idInst, win32.System.DataExchange.HSZ hsz);
        /// <summary>Compares the values of two string handles. The value of a string handle is not related to the case of the associated string.</summary>
        /// <param name = "hsz1">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the first string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecmpstringhandles#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hsz2">
        /// <para>Type: <b>HSZ</b></para>
        /// <para>A handle to the second string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecmpstringhandles#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>The return value can be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ddeml/nf-ddeml-ddecmpstringhandles">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern int DdeCmpStringHandles(win32.System.DataExchange.HSZ hsz1, win32.System.DataExchange.HSZ hsz2);
        /// <summary>Opens the clipboard for examination and prevents other applications from modifying the clipboard content.</summary>
        /// <param name = "hWndNewOwner">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be associated with the open clipboard. If this parameter is <b>NULL</b>, the open clipboard is associated with the current task.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-openclipboard#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-openclipboard">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool OpenClipboard(win32.UI.WindowsAndMessaging.HWND hWndNewOwner);
        /// <summary>Closes the clipboard.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-closeclipboard">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool CloseClipboard();
        /// <summary>Retrieves the clipboard sequence number for the current window station.</summary>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The return value is the clipboard sequence number. If you do not have <b>WINSTA_ACCESSCLIPBOARD</b> access to the window station, the function returns zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclipboardsequencenumber">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetClipboardSequenceNumber();
        /// <summary>Retrieves the window handle of the current owner of the clipboard.</summary>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is the handle to the window that owns the clipboard.</para>
        /// <para>If the clipboard is not owned, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclipboardowner">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetClipboardOwner();
        /// <summary>Adds the specified window to the chain of clipboard viewers. Clipboard viewer windows receive a WM_DRAWCLIPBOARD message whenever the content of the clipboard changes. This function is used for backward compatibility with earlier versions of Windows.</summary>
        /// <param name = "hWndNewViewer">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be added to the clipboard chain.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclipboardviewer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value identifies the next window in the clipboard viewer chain. If an error occurs or there are no other windows in the clipboard viewer chain, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclipboardviewer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND SetClipboardViewer(win32.UI.WindowsAndMessaging.HWND hWndNewViewer);
        /// <summary>Retrieves the handle to the first window in the clipboard viewer chain.</summary>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is the handle to the first window in the clipboard viewer chain.</para>
        /// <para>If there is no clipboard viewer, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclipboardviewer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetClipboardViewer();
        /// <summary>Removes a specified window from the chain of clipboard viewers.</summary>
        /// <param name = "hWndRemove">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be removed from the chain. The handle must have been passed to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setclipboardviewer">SetClipboardViewer</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changeclipboardchain#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hWndNewNext">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that follows the <i>hWndRemove</i> window in the clipboard viewer chain. (This is the handle returned by <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setclipboardviewer">SetClipboardViewer</a>, unless the sequence was changed in response to a <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/wm-changecbchain">WM_CHANGECBCHAIN</a> message.)</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changeclipboardchain#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The return value indicates the result of passing the <a href = "/windows/desktop/dataxchg/wm-changecbchain">WM_CHANGECBCHAIN</a> message to the windows in the clipboard viewer chain. Because a window in the chain typically returns <b>FALSE</b> when it processes <b>WM_CHANGECBCHAIN</b>, the return value from <b>ChangeClipboardChain</b> is typically <b>FALSE</b>. If there is only one window in the chain, the return value is typically <b>TRUE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changeclipboardchain">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool ChangeClipboardChain(win32.UI.WindowsAndMessaging.HWND hWndRemove, win32.UI.WindowsAndMessaging.HWND hWndNewNext);
        /// <inheritdoc cref = "SetClipboardData(uint, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle SetClipboardData(uint uFormat, SafeHandle hMem)
        {
            bool hMemAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hMemLocal;
                if (hMem is object)
                {
                    hMem.DangerousAddRef(ref hMemAddRef);
                    hMemLocal = (win32.System.SystemServices.HANDLE)hMem.DangerousGetHandle();
                }
                else
                    hMemLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE __result = User32.SetClipboardData(uFormat, hMemLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hMemAddRef)
                    hMem.DangerousRelease();
            }
        }

        /// <summary>Places data on the clipboard in a specified clipboard format.</summary>
        /// <param name = "uFormat">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The clipboard format. This parameter can be a registered format or any of the standard clipboard formats. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/standard-clipboard-formats">Standard Clipboard Formats</a> and <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/clipboard-formats">Registered Clipboard Formats</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclipboarddata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hMem">
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>A handle to the data in the specified format. This parameter can be <b>NULL</b>, indicating that the window provides data in the specified clipboard format (renders the format) upon request; this is known as [delayed rendering](/windows/win32/dataxchg/clipboard-operations#delayed-rendering). If a window delays rendering, it must process the [WM_RENDERFORMAT](/windows/win32/dataxchg/wm-renderformat) and [WM_RENDERALLFORMATS](/windows/win32/dataxchg/wm-renderallformats) messages.</para>
        /// <para>If <b>SetClipboardData</b> succeeds, the system owns the object identified by the <i>hMem</i> parameter. The application may not write to or free the data once ownership has been transferred to the system, but it can lock and read from the data until the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-closeclipboard">CloseClipboard</a> function is called. (The memory must be unlocked before the Clipboard is closed.) If the <i>hMem</i> parameter identifies a memory object, the object must have been allocated using the function with the <b>GMEM_MOVEABLE</b> flag.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclipboarddata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>If the function succeeds, the return value is the handle to the data.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setclipboarddata">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE SetClipboardData(uint uFormat, win32.System.SystemServices.HANDLE hMem);
        /// <inheritdoc cref = "GetClipboardData(uint)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle GetClipboardData_SafeHandle(uint uFormat)
        {
            win32.System.SystemServices.HANDLE __result = User32.GetClipboardData(uFormat);
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        /// <summary>Retrieves data from the clipboard in a specified format. The clipboard must have been opened previously.</summary>
        /// <param name = "uFormat">
        /// <para>Type: <b>UINT</b></para>
        /// <para>A clipboard format. For a description of the standard clipboard formats, see <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/clipboard-formats">Standard Clipboard Formats</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclipboarddata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>If the function succeeds, the return value is the handle to a clipboard object in the specified format.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclipboarddata">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE GetClipboardData(uint uFormat);
        /// <inheritdoc cref = "RegisterClipboardFormat(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe uint RegisterClipboardFormat(string lpszFormat)
        {
            fixed (char *lpszFormatLocal = lpszFormat)
            {
                uint __result = User32.RegisterClipboardFormat(lpszFormatLocal);
                return __result;
            }
        }

        /// <summary>Registers a new clipboard format. This format can then be used as a valid clipboard format.</summary>
        /// <param name = "lpszFormat">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The name of the new format.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerclipboardformatw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the return value identifies the registered clipboard format.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerclipboardformatw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "RegisterClipboardFormatW", SetLastError = true)]
        internal static extern uint RegisterClipboardFormat(win32.System.SystemServices.PCWSTR lpszFormat);
        /// <summary>Retrieves the number of different data formats currently on the clipboard.</summary>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the number of different data formats currently on the clipboard.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-countclipboardformats">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern int CountClipboardFormats();
        /// <summary>Enumerates the data formats currently available on the clipboard.</summary>
        /// <param name = "format">
        /// <para>Type: <b>UINT</b></para>
        /// <para>A clipboard format that is known to be available.</para>
        /// <para>To start an enumeration of clipboard formats, set <i>format</i> to zero. When <i>format</i> is zero, the function retrieves the first available clipboard format. For subsequent calls during an enumeration, set <i>format</i> to the result of the previous <b>EnumClipboardFormats</b> call.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumclipboardformats#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the return value is the clipboard format that follows the specified format, namely the next available clipboard format.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the clipboard is not open, the function fails.</para>
        /// <para>If there are no more clipboard formats to enumerate, the return value is zero. In this case, the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the value <b>ERROR_SUCCESS</b>. This lets you distinguish between function failure and the end of enumeration.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumclipboardformats">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint EnumClipboardFormats(uint format);
        /// <summary>Retrieves from the clipboard the name of the specified registered format. The function copies the name to the specified buffer.</summary>
        /// <param name = "format">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The type of format to be retrieved. This parameter must not specify any of the predefined clipboard formats.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclipboardformatnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszFormatName">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The buffer that is to receive the format name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclipboardformatnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchMaxCount">
        /// <para>Type: <b>int</b></para>
        /// <para>The maximum length, in characters, of the string to be copied to the buffer. If the name exceeds this limit, it is truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclipboardformatnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the length, in characters, of the string copied to the buffer.</para>
        /// <para>If the function fails, the return value is zero, indicating that the requested format does not exist or is predefined. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getclipboardformatnamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetClipboardFormatNameW", SetLastError = true)]
        internal static extern int GetClipboardFormatName(uint format, win32.System.SystemServices.PWSTR lpszFormatName, int cchMaxCount);
        /// <summary>Empties the clipboard and frees handles to data in the clipboard. The function then assigns ownership of the clipboard to the window that currently has the clipboard open.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-emptyclipboard">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool EmptyClipboard();
        /// <summary>Determines whether the clipboard contains data in the specified format.</summary>
        /// <param name = "format">
        /// <para>Type: <b>UINT</b></para>
        /// <para>A standard or registered clipboard format. For a description of the standard clipboard formats, see <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/standard-clipboard-formats">Standard Clipboard Formats</a> .</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isclipboardformatavailable#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the clipboard format is available, the return value is nonzero.</para>
        /// <para>If the clipboard format is not available, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isclipboardformatavailable">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool IsClipboardFormatAvailable(uint format);
        /// <inheritdoc cref = "GetPriorityClipboardFormat(uint *, int)"/>
        internal static unsafe int GetPriorityClipboardFormat(Span<uint> paFormatPriorityList)
        {
            fixed (uint *paFormatPriorityListLocal = paFormatPriorityList)
            {
                int __result = User32.GetPriorityClipboardFormat(paFormatPriorityListLocal, paFormatPriorityList.Length);
                return __result;
            }
        }

        /// <summary>Retrieves the first available clipboard format in the specified list.</summary>
        /// <param name = "paFormatPriorityList">
        /// <para>Type: <b>UINT*</b></para>
        /// <para>The clipboard formats, in priority order. For a description of the standard clipboard formats, see <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/standard-clipboard-formats">Standard Clipboard Formats</a> .</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpriorityclipboardformat#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cFormats">
        /// <para>Type: <b>int</b></para>
        /// <para>The number of entries in the <i>paFormatPriorityList</i> array. This value must not be greater than the number of entries in the list.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpriorityclipboardformat#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the first clipboard format in the list for which data is available. If the clipboard is empty, the return value is NULL. If the clipboard contains data, but not in any of the specified formats, the return value is –1. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpriorityclipboardformat">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int GetPriorityClipboardFormat(uint *paFormatPriorityList, int cFormats);
        /// <summary>Retrieves the handle to the window that currently has the clipboard open.</summary>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is the handle to the window that has the clipboard open. If no window has the clipboard open, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getopenclipboardwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetOpenClipboardWindow();
        /// <summary>Places the given window in the system-maintained clipboard format listener list.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be placed in the clipboard format listener list.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-addclipboardformatlistener#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise. Call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for additional details.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-addclipboardformatlistener">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool AddClipboardFormatListener(win32.UI.WindowsAndMessaging.HWND hwnd);
        /// <summary>Removes the given window from the system-maintained clipboard format listener list.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to remove from the clipboard format listener list.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-removeclipboardformatlistener#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise. Call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for additional details.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-removeclipboardformatlistener">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool RemoveClipboardFormatListener(win32.UI.WindowsAndMessaging.HWND hwnd);
        /// <inheritdoc cref = "GetUpdatedClipboardFormats(uint *, uint, uint *)"/>
        internal static unsafe bool GetUpdatedClipboardFormats(Span<uint> lpuiFormats, out uint pcFormatsOut)
        {
            fixed (uint *pcFormatsOutLocal = &pcFormatsOut)
            {
                fixed (uint *lpuiFormatsLocal = lpuiFormats)
                {
                    bool __result = User32.GetUpdatedClipboardFormats(lpuiFormatsLocal, (uint)lpuiFormats.Length, pcFormatsOutLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves the currently supported clipboard formats.</summary>
        /// <param name = "lpuiFormats">
        /// <para>Type: <b>PUINT</b></para>
        /// <para>An array of clipboard formats. For a description of the standard clipboard formats, see <a href = "https://docs.microsoft.com/windows/desktop/dataxchg/standard-clipboard-formats">Standard Clipboard Formats</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getupdatedclipboardformats#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cFormats">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The number of entries in the array pointed to by <i>lpuiFormats</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getupdatedclipboardformats#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcFormatsOut">
        /// <para>Type: <b>PUINT</b></para>
        /// <para>The actual number of clipboard formats in the array pointed to by <i>lpuiFormats</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getupdatedclipboardformats#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The function returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for additional details.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getupdatedclipboardformats">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetUpdatedClipboardFormats(uint *lpuiFormats, uint cFormats, uint *pcFormatsOut);
        /// <summary>Logs off the interactive user, shuts down the system, or shuts down and restarts the system.</summary>
        /// <param name = "uFlags"></param>
        /// <param name = "dwReason">
        /// <para>The reason for initiating the shutdown. This parameter must be one of the <a href = "https://docs.microsoft.com/windows/desktop/Shutdown/system-shutdown-reason-codes">system shutdown reason codes</a>.</para>
        /// <para>If this parameter is zero, the SHTDN_REASON_FLAG_PLANNED reason code  will not be set and therefore the default action is an undefined shutdown that is logged as "No title for this reason could be found". By default, it is also an unplanned shutdown. Depending on how the system is configured, an unplanned shutdown triggers the creation of a file that contains the system state information, which can delay shutdown. Therefore, do not use zero for this parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-exitwindowsex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. Because the function executes asynchronously, a nonzero return value indicates that the shutdown has been initiated. It does not indicate whether the shutdown will succeed. It is possible that the system, the user, or another application will abort the shutdown.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-exitwindowsex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ExitWindowsEx(win32.System.Shutdown.EXIT_WINDOWS_FLAGS uFlags, uint dwReason);
        /// <summary>Locks the workstation's display.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. Because the function executes asynchronously, a nonzero return value indicates that the operation has been initiated. It does not indicate whether the workstation has been successfully locked.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-lockworkstation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool LockWorkStation();
        /// <inheritdoc cref = "ShutdownBlockReasonCreate(win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool ShutdownBlockReasonCreate(win32.UI.WindowsAndMessaging.HWND hWnd, string pwszReason)
        {
            fixed (char *pwszReasonLocal = pwszReason)
            {
                bool __result = User32.ShutdownBlockReasonCreate(hWnd, pwszReasonLocal);
                return __result;
            }
        }

        /// <summary>Indicates that the system cannot be shut down and sets a reason string to be displayed to the user if system shutdown is initiated.</summary>
        /// <param name = "hWnd">A handle to the main window of the application.</param>
        /// <param name = "pwszReason">The reason the application must block system shutdown. This string will be truncated for display purposes after MAX_STR_BLOCKREASON characters.</param>
        /// <returns>
        /// <para>If the call succeeds, the return value is nonzero.</para>
        /// <para>If the call fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-shutdownblockreasoncreate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ShutdownBlockReasonCreate(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PCWSTR pwszReason);
        /// <inheritdoc cref = "ShutdownBlockReasonQuery(win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe bool ShutdownBlockReasonQuery(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PWSTR pwszBuff, ref uint pcchBuff)
        {
            fixed (uint *pcchBuffLocal = &pcchBuff)
            {
                bool __result = User32.ShutdownBlockReasonQuery(hWnd, pwszBuff, pcchBuffLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the reason string set by the ShutdownBlockReasonCreate function.</summary>
        /// <param name = "hWnd">A handle to the main window of the application.</param>
        /// <param name = "pwszBuff">A pointer to a buffer that receives the reason string. If this parameter is <b>NULL</b>, the function retrieves the number of characters in the reason string.</param>
        /// <param name = "pcchBuff">A pointer to a variable that specifies the size of the <i>pwszBuff</i> buffer, in characters. If the function succeeds, this variable receives the number of characters copied into the buffer, including the <b>null</b>-terminating character. If the buffer is too small, the variable receives the required buffer size, in characters, not including the <b>null</b>-terminating character.</param>
        /// <returns>
        /// <para>If the call succeeds, the return value is nonzero.</para>
        /// <para>If the call fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-shutdownblockreasonquery">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ShutdownBlockReasonQuery(win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.PWSTR pwszBuff, uint *pcchBuff);
        /// <summary>Indicates that the system can be shut down and frees the reason string.</summary>
        /// <param name = "hWnd">A handle to the main window of the application.</param>
        /// <returns>
        /// <para>If the call succeeds, the return value is nonzero.</para>
        /// <para>If the call fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-shutdownblockreasondestroy">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ShutdownBlockReasonDestroy(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <inheritdoc cref = "CreateDesktop(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.UI.DisplayDevices.DEVMODEW*, uint, uint, win32.System.SystemServices.SECURITY_ATTRIBUTES*)"/>
        internal static unsafe User32.CloseDesktopSafeHandle CreateDesktop(string lpszDesktop, string lpszDevice, ref win32.UI.DisplayDevices.DEVMODEW pDevmode, uint dwFlags, uint dwDesiredAccess, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpsa)
        {
            fixed (win32.UI.DisplayDevices.DEVMODEW*pDevmodeLocal = &pDevmode)
            {
                fixed (char *lpszDeviceLocal = lpszDevice)
                {
                    fixed (char *lpszDesktopLocal = lpszDesktop)
                    {
                        win32.System.SystemServices.SECURITY_ATTRIBUTES lpsaLocal = lpsa.HasValue ? lpsa.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                        win32.System.StationsAndDesktops.HDESK __result = User32.CreateDesktop(lpszDesktopLocal, lpszDeviceLocal, pDevmodeLocal, dwFlags, dwDesiredAccess, lpsa.HasValue ? &lpsaLocal : null);
                        return new User32.CloseDesktopSafeHandle(__result, ownsHandle: true);
                    }
                }
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "User32.CloseDesktop"/>.
        /// </summary>
        internal class CloseDesktopSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal CloseDesktopSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal CloseDesktopSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => User32.CloseDesktop((win32.System.StationsAndDesktops.HDESK)this.handle);
        }

        /// <summary>Creates a new desktop, associates it with the current window station of the calling process, and assigns it to the calling thread.</summary>
        /// <param name = "lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\\).</param>
        /// <param name = "lpszDevice">Reserved; must be <b>NULL</b>.</param>
        /// <param name = "pDevmode">Reserved; must be <b>NULL</b>.</param>
        /// <param name = "dwFlags">
        /// <para>This parameter can be zero or the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdesktopw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the desktop. For a list of values, see <a href = "https://docs.microsoft.com/windows/desktop/winstation/desktop-security-and-access-rights">Desktop Security and Access Rights</a>.</para>
        /// <para>This parameter must include the <b>DESKTOP_CREATEWINDOW</b> access right, because internally <b>CreateDesktop</b> uses the handle to create a window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdesktopw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpsa">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle can be inherited by child processes. If <i>lpsa</i> is NULL, the handle cannot be inherited.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new desktop. If this parameter is NULL, the desktop inherits its security descriptor from the parent window station.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdesktopw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the newly created desktop. If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop. When you are finished using the handle, call the <a href = "/windows/desktop/api/winuser/nf-winuser-closedesktop">CloseDesktop</a> function to close it.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdesktopw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CreateDesktopW", SetLastError = true)]
        internal static extern unsafe win32.System.StationsAndDesktops.HDESK CreateDesktop(win32.System.SystemServices.PCWSTR lpszDesktop, win32.System.SystemServices.PCWSTR lpszDevice, win32.UI.DisplayDevices.DEVMODEW*pDevmode, uint dwFlags, uint dwDesiredAccess, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpsa);
        /// <inheritdoc cref = "CreateDesktopEx(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.UI.DisplayDevices.DEVMODEW*, uint, uint, win32.System.SystemServices.SECURITY_ATTRIBUTES*, uint, void *)"/>
        internal static unsafe User32.CloseDesktopSafeHandle CreateDesktopEx(string lpszDesktop, string lpszDevice, ref win32.UI.DisplayDevices.DEVMODEW pDevmode, uint dwFlags, uint dwDesiredAccess, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpsa, uint ulHeapSize, void *pvoid)
        {
            fixed (win32.UI.DisplayDevices.DEVMODEW*pDevmodeLocal = &pDevmode)
            {
                fixed (char *lpszDeviceLocal = lpszDevice)
                {
                    fixed (char *lpszDesktopLocal = lpszDesktop)
                    {
                        win32.System.SystemServices.SECURITY_ATTRIBUTES lpsaLocal = lpsa.HasValue ? lpsa.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                        win32.System.StationsAndDesktops.HDESK __result = User32.CreateDesktopEx(lpszDesktopLocal, lpszDeviceLocal, pDevmodeLocal, dwFlags, dwDesiredAccess, lpsa.HasValue ? &lpsaLocal : null, ulHeapSize, pvoid);
                        return new User32.CloseDesktopSafeHandle(__result, ownsHandle: true);
                    }
                }
            }
        }

        /// <summary>Creates a new desktop with the specified heap, associates it with the current window station of the calling process, and assigns it to the calling thread.</summary>
        /// <param name = "lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\\).</param>
        /// <param name = "lpszDevice">This parameter is reserved and must be NULL.</param>
        /// <param name = "pDevmode">This parameter is reserved and must be NULL.</param>
        /// <param name = "dwFlags">
        /// <para>This parameter can be zero or the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdesktopexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">
        /// <para>The requested access to the desktop. For a list of values, see <a href = "https://docs.microsoft.com/windows/desktop/winstation/desktop-security-and-access-rights">Desktop Security and Access Rights</a>.</para>
        /// <para>This parameter must include the DESKTOP_CREATEWINDOW access right, because internally <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createdesktopa">CreateDesktop</a> uses the handle to create a window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdesktopexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpsa">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle can be inherited by child processes. If <i>lpsa</i> is NULL, the handle cannot be inherited.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new desktop. If this parameter is NULL, the desktop inherits its security descriptor from the parent window station.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdesktopexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ulHeapSize">The size of the desktop heap, in kilobytes.</param>
        /// <param name = "pvoid">This parameter is reserved and must be NULL.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the newly created desktop. If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop. When you are finished using the handle, call the <a href = "/windows/desktop/api/winuser/nf-winuser-closedesktop">CloseDesktop</a> function to close it.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createdesktopexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CreateDesktopExW", SetLastError = true)]
        internal static extern unsafe win32.System.StationsAndDesktops.HDESK CreateDesktopEx(win32.System.SystemServices.PCWSTR lpszDesktop, win32.System.SystemServices.PCWSTR lpszDevice, win32.UI.DisplayDevices.DEVMODEW*pDevmode, uint dwFlags, uint dwDesiredAccess, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpsa, uint ulHeapSize, void *pvoid);
        /// <inheritdoc cref = "OpenDesktop(win32.System.SystemServices.PCWSTR, uint, bool, uint)"/>
        internal static unsafe User32.CloseDesktopSafeHandle OpenDesktop(string lpszDesktop, uint dwFlags, bool fInherit, uint dwDesiredAccess)
        {
            fixed (char *lpszDesktopLocal = lpszDesktop)
            {
                win32.System.StationsAndDesktops.HDESK __result = User32.OpenDesktop(lpszDesktopLocal, dwFlags, fInherit, dwDesiredAccess);
                return new User32.CloseDesktopSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Opens the specified desktop object.</summary>
        /// <param name = "lpszDesktop">
        /// <para>The name of the desktop to be opened. Desktop names are case-insensitive.</para>
        /// <para>This desktop must belong to the current window station.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-opendesktopw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>This parameter can be zero or the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-opendesktopw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fInherit">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the desktop. For a list of access rights, see <a href = "https://docs.microsoft.com/windows/desktop/winstation/desktop-security-and-access-rights">Desktop Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-opendesktopw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the opened desktop. When you are finished using the handle, call the <a href = "/windows/desktop/api/winuser/nf-winuser-closedesktop">CloseDesktop</a> function to close it.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-opendesktopw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "OpenDesktopW", SetLastError = true)]
        internal static extern win32.System.StationsAndDesktops.HDESK OpenDesktop(win32.System.SystemServices.PCWSTR lpszDesktop, uint dwFlags, bool fInherit, uint dwDesiredAccess);
        /// <inheritdoc cref = "OpenInputDesktop(uint, bool, uint)"/>
        internal static unsafe User32.CloseDesktopSafeHandle OpenInputDesktop_SafeHandle(uint dwFlags, bool fInherit, uint dwDesiredAccess)
        {
            win32.System.StationsAndDesktops.HDESK __result = User32.OpenInputDesktop(dwFlags, fInherit, dwDesiredAccess);
            return new User32.CloseDesktopSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>Opens the desktop that receives user input.</summary>
        /// <param name = "dwFlags">
        /// <para>This parameter can be zero or the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-openinputdesktop#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fInherit">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the desktop. For a list of access rights, see <a href = "https://docs.microsoft.com/windows/desktop/winstation/desktop-security-and-access-rights">Desktop Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-openinputdesktop#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the desktop that receives user input. When you are finished using the handle, call the <a href = "/windows/desktop/api/winuser/nf-winuser-closedesktop">CloseDesktop</a> function to close it.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-openinputdesktop">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.StationsAndDesktops.HDESK OpenInputDesktop(uint dwFlags, bool fInherit, uint dwDesiredAccess);
        /// <summary>Closes an open window station handle.</summary>
        /// <param name = "hWinSta">
        /// <para>A handle to the window station to be closed. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowstationa">CreateWindowStation</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-openwindowstationa">OpenWindowStation</a> function. Do not specify the handle returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getprocesswindowstation">GetProcessWindowStation</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-closewindowstation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP/2000:  </b>This function does not set the last error code on failure.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-closewindowstation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL CloseWindowStation(win32.System.StationsAndDesktops.HWINSTA hWinSta);
        /// <inheritdoc cref = "EnumDesktops(win32.System.StationsAndDesktops.HWINSTA, delegate *unmanaged[Stdcall]{win32.System.SystemServices.PWSTR, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL}, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe bool EnumDesktops(SafeHandle hwinsta, delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpEnumFunc, win32.UI.WindowsAndMessaging.LPARAM lParam)
        {
            bool hwinstaAddRef = false;
            try
            {
                win32.System.StationsAndDesktops.HWINSTA hwinstaLocal;
                if (hwinsta is object)
                {
                    hwinsta.DangerousAddRef(ref hwinstaAddRef);
                    hwinstaLocal = (win32.System.StationsAndDesktops.HWINSTA)hwinsta.DangerousGetHandle();
                }
                else
                    hwinstaLocal = default(win32.System.StationsAndDesktops.HWINSTA);
                bool __result = User32.EnumDesktops(hwinstaLocal, lpEnumFunc, lParam);
                return __result;
            }
            finally
            {
                if (hwinstaAddRef)
                    hwinsta.DangerousRelease();
            }
        }

        /// <summary>Enumerates all desktops associated with the specified window station of the calling process. The function passes the name of each desktop, in turn, to an application-defined callback function.</summary>
        /// <param name = "hwinsta">
        /// <para>A handle to the window station whose desktops are to be enumerated. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowstationa">CreateWindowStation</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getprocesswindowstation">GetProcessWindowStation</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-openwindowstationa">OpenWindowStation</a> function, and must have the WINSTA_ENUMDESKTOPS access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/winstation/window-station-security-and-access-rights">Window Station Security and Access Rights</a>.</para>
        /// <para>If this parameter is NULL, the current window station is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdesktopsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEnumFunc">
        /// <para>A pointer to an application-defined <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms682612(v=vs.85)">EnumDesktopProc</a> callback function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdesktopsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">An application-defined value to be passed to the callback function.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns the  nonzero value returned by the callback function that was pointed to by <i>lpEnumFunc</i>.</para>
        /// <para>If the function is unable to perform the enumeration, the return value is zero. Call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information.</para>
        /// <para>If the callback function fails, the return value is zero. The callback function can  call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> to set an error code for the caller to retrieve by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdesktopsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "EnumDesktopsW", SetLastError = true)]
        internal static extern unsafe bool EnumDesktops(win32.System.StationsAndDesktops.HWINSTA hwinsta, delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpEnumFunc, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <inheritdoc cref = "EnumDesktopWindows(win32.System.StationsAndDesktops.HDESK, delegate *unmanaged[Stdcall]{win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL}, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe bool EnumDesktopWindows(SafeHandle hDesktop, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpfn, win32.UI.WindowsAndMessaging.LPARAM lParam)
        {
            bool hDesktopAddRef = false;
            try
            {
                win32.System.StationsAndDesktops.HDESK hDesktopLocal;
                if (hDesktop is object)
                {
                    hDesktop.DangerousAddRef(ref hDesktopAddRef);
                    hDesktopLocal = (win32.System.StationsAndDesktops.HDESK)hDesktop.DangerousGetHandle();
                }
                else
                    hDesktopLocal = default(win32.System.StationsAndDesktops.HDESK);
                bool __result = User32.EnumDesktopWindows(hDesktopLocal, lpfn, lParam);
                return __result;
            }
            finally
            {
                if (hDesktopAddRef)
                    hDesktop.DangerousRelease();
            }
        }

        /// <summary>Enumerates all top-level windows associated with the specified desktop. It passes the handle to each window, in turn, to an application-defined callback function.</summary>
        /// <param name = "hDesktop">
        /// <para>A handle to the desktop whose top-level windows are to be enumerated. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createdesktopa">CreateDesktop</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getthreaddesktop">GetThreadDesktop</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-opendesktopa">OpenDesktop</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-openinputdesktop">OpenInputDesktop</a> function, and must have the <b>DESKTOP_READOBJECTS</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/winstation/desktop-security-and-access-rights">Desktop Security and Access Rights</a>.</para>
        /// <para>If this parameter is NULL, the current desktop is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdesktopwindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpfn">
        /// <para>A pointer to an application-defined <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633498(v=vs.85)">EnumWindowsProc</a> callback function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdesktopwindows#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">An application-defined value to be passed to the callback function.</param>
        /// <returns>
        /// <para>If the function fails or is unable to perform the enumeration, the return value is zero.</para>
        /// <para>To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>You must ensure that the callback function sets <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> if it fails.</para>
        /// <para><b>Windows Server 2003 and Windows XP/2000:  </b>If there are no windows on the desktop, <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_HANDLE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdesktopwindows">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool EnumDesktopWindows(win32.System.StationsAndDesktops.HDESK hDesktop, delegate *unmanaged[Stdcall]<win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpfn, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <inheritdoc cref = "SwitchDesktop(win32.System.StationsAndDesktops.HDESK)"/>
        internal static unsafe bool SwitchDesktop(SafeHandle hDesktop)
        {
            bool hDesktopAddRef = false;
            try
            {
                win32.System.StationsAndDesktops.HDESK hDesktopLocal;
                if (hDesktop is object)
                {
                    hDesktop.DangerousAddRef(ref hDesktopAddRef);
                    hDesktopLocal = (win32.System.StationsAndDesktops.HDESK)hDesktop.DangerousGetHandle();
                }
                else
                    hDesktopLocal = default(win32.System.StationsAndDesktops.HDESK);
                bool __result = User32.SwitchDesktop(hDesktopLocal);
                return __result;
            }
            finally
            {
                if (hDesktopAddRef)
                    hDesktop.DangerousRelease();
            }
        }

        /// <summary>Makes the specified desktop visible and activates it. This enables the desktop to receive input from the user.</summary>
        /// <param name = "hDesktop">
        /// <para>A handle to the desktop. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createdesktopa">CreateDesktop</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-opendesktopa">OpenDesktop</a> functions.</para>
        /// <para>This desktop must be associated with the current window station for the process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-switchdesktop#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. However, <b>SwitchDesktop</b> only sets the last error for the following cases:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-switchdesktop">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SwitchDesktop(win32.System.StationsAndDesktops.HDESK hDesktop);
        /// <inheritdoc cref = "SetThreadDesktop(win32.System.StationsAndDesktops.HDESK)"/>
        internal static unsafe bool SetThreadDesktop(SafeHandle hDesktop)
        {
            bool hDesktopAddRef = false;
            try
            {
                win32.System.StationsAndDesktops.HDESK hDesktopLocal;
                if (hDesktop is object)
                {
                    hDesktop.DangerousAddRef(ref hDesktopAddRef);
                    hDesktopLocal = (win32.System.StationsAndDesktops.HDESK)hDesktop.DangerousGetHandle();
                }
                else
                    hDesktopLocal = default(win32.System.StationsAndDesktops.HDESK);
                bool __result = User32.SetThreadDesktop(hDesktopLocal);
                return __result;
            }
            finally
            {
                if (hDesktopAddRef)
                    hDesktop.DangerousRelease();
            }
        }

        /// <summary>Assigns the specified desktop to the calling thread. All subsequent operations on the desktop use the access rights granted to the desktop.</summary>
        /// <param name = "hDesktop">
        /// <para>A handle to the desktop to be assigned to the calling thread. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createdesktopa">CreateDesktop</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getthreaddesktop">GetThreadDesktop</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-opendesktopa">OpenDesktop</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-openinputdesktop">OpenInputDesktop</a> function.</para>
        /// <para>This desktop must be associated with the current window station for the process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setthreaddesktop#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setthreaddesktop">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetThreadDesktop(win32.System.StationsAndDesktops.HDESK hDesktop);
        /// <inheritdoc cref = "GetThreadDesktop(uint)"/>
        internal static unsafe User32.CloseDesktopSafeHandle GetThreadDesktop_SafeHandle(uint dwThreadId)
        {
            win32.System.StationsAndDesktops.HDESK __result = User32.GetThreadDesktop(dwThreadId);
            return new User32.CloseDesktopSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>Retrieves a handle to the desktop assigned to the specified thread.</summary>
        /// <param name = "dwThreadId">
        /// <para>The thread identifier. The <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentthreadid">GetCurrentThreadId</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> functions return thread identifiers.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getthreaddesktop#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the desktop associated with the specified thread. You do not need to call the <a href = "/windows/desktop/api/winuser/nf-winuser-closedesktop">CloseDesktop</a> function to close the returned handle.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getthreaddesktop">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.StationsAndDesktops.HDESK GetThreadDesktop(uint dwThreadId);
        /// <inheritdoc cref = "CreateWindowStation(win32.System.SystemServices.PCWSTR, uint, uint, win32.System.SystemServices.SECURITY_ATTRIBUTES*)"/>
        internal static unsafe User32.CloseWindowStationSafeHandle CreateWindowStation(string lpwinsta, uint dwFlags, uint dwDesiredAccess, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpsa)
        {
            fixed (char *lpwinstaLocal = lpwinsta)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpsaLocal = lpsa.HasValue ? lpsa.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.StationsAndDesktops.HWINSTA __result = User32.CreateWindowStation(lpwinstaLocal, dwFlags, dwDesiredAccess, lpsa.HasValue ? &lpsaLocal : null);
                return new User32.CloseWindowStationSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "User32.CloseWindowStation"/>.
        /// </summary>
        internal class CloseWindowStationSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal CloseWindowStationSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal CloseWindowStationSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => User32.CloseWindowStation((win32.System.StationsAndDesktops.HWINSTA)this.handle);
        }

        /// <summary>Creates a window station object, associates it with the calling process, and assigns it to the current session.</summary>
        /// <param name = "lpwinsta">
        /// <para>The name of the window station to be created. Window station names are case-insensitive and cannot contain backslash characters (\\). Only members of the Administrators group are allowed to specify a name. If <i>lpwinsta</i> is <b>NULL</b> or an empty string, the system forms a window station name using the logon session identifier for the calling process. To get this name, call the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getuserobjectinformationa">GetUserObjectInformation</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowstationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>If this parameter is <b>CWF_CREATE_ONLY</b> and the window station already exists, the call fails. If this flag is not specified and the window station already exists, the function succeeds and returns a new handle to the existing window station.</para>
        /// <para><b>Windows XP/2000:  </b>This parameter is reserved and must be zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowstationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">The type of access the returned handle has to the window station. In addition, you can specify any of the standard access rights, such as <b>READ_CONTROL</b> or <b>WRITE_DAC</b>, and a combination of the window station-specific access rights. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/winstation/window-station-security-and-access-rights">Window Station Security and Access Rights</a>.</param>
        /// <param name = "lpsa">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle can be inherited by child processes. If <i>lpsa</i> is <b>NULL</b>, the handle cannot be inherited.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new window station. If <i>lpsa</i> is <b>NULL</b>, the window station (and any desktops created within the window) gets a security descriptor that grants <b>GENERIC_ALL</b> access to all users.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowstationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the newly created window station. If the specified window station already exists, the function succeeds and returns a handle to the existing window station.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createwindowstationw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "CreateWindowStationW", SetLastError = true)]
        internal static extern unsafe win32.System.StationsAndDesktops.HWINSTA CreateWindowStation(win32.System.SystemServices.PCWSTR lpwinsta, uint dwFlags, uint dwDesiredAccess, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpsa);
        /// <inheritdoc cref = "OpenWindowStation(win32.System.SystemServices.PCWSTR, bool, uint)"/>
        internal static unsafe User32.CloseWindowStationSafeHandle OpenWindowStation(string lpszWinSta, bool fInherit, uint dwDesiredAccess)
        {
            fixed (char *lpszWinStaLocal = lpszWinSta)
            {
                win32.System.StationsAndDesktops.HWINSTA __result = User32.OpenWindowStation(lpszWinStaLocal, fInherit, dwDesiredAccess);
                return new User32.CloseWindowStationSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Opens the specified window station.</summary>
        /// <param name = "lpszWinSta">
        /// <para>The name of the window station to be opened. Window station names are case-insensitive.</para>
        /// <para>This window station must belong to the current session.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-openwindowstationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fInherit">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the window station. For a list of access rights, see <a href = "https://docs.microsoft.com/windows/desktop/winstation/window-station-security-and-access-rights">Window Station Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-openwindowstationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the handle to the specified window station.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-openwindowstationw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "OpenWindowStationW", SetLastError = true)]
        internal static extern win32.System.StationsAndDesktops.HWINSTA OpenWindowStation(win32.System.SystemServices.PCWSTR lpszWinSta, bool fInherit, uint dwDesiredAccess);
        /// <summary>Enumerates all window stations in the current session. The function passes the name of each window station, in turn, to an application-defined callback function.</summary>
        /// <param name = "lpEnumFunc">
        /// <para>A pointer to an application-defined <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms682643(v=vs.85)">EnumWindowStationProc</a> callback function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumwindowstationsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">An application-defined value to be passed to the callback function.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns the  nonzero value returned by the callback function that was pointed to by <i>lpEnumFunc</i>.</para>
        /// <para>If the function is unable to perform the enumeration, the return value is zero. Call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information.</para>
        /// <para>If the callback function fails, the return value is zero. The callback function can  call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> to set an error code for the caller to retrieve by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumwindowstationsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "EnumWindowStationsW", SetLastError = true)]
        internal static extern unsafe bool EnumWindowStations(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpEnumFunc, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <inheritdoc cref = "SetProcessWindowStation(win32.System.StationsAndDesktops.HWINSTA)"/>
        internal static unsafe bool SetProcessWindowStation(SafeHandle hWinSta)
        {
            bool hWinStaAddRef = false;
            try
            {
                win32.System.StationsAndDesktops.HWINSTA hWinStaLocal;
                if (hWinSta is object)
                {
                    hWinSta.DangerousAddRef(ref hWinStaAddRef);
                    hWinStaLocal = (win32.System.StationsAndDesktops.HWINSTA)hWinSta.DangerousGetHandle();
                }
                else
                    hWinStaLocal = default(win32.System.StationsAndDesktops.HWINSTA);
                bool __result = User32.SetProcessWindowStation(hWinStaLocal);
                return __result;
            }
            finally
            {
                if (hWinStaAddRef)
                    hWinSta.DangerousRelease();
            }
        }

        /// <summary>Assigns the specified window station to the calling process.</summary>
        /// <param name = "hWinSta">
        /// <para>A handle to the window station. This can be a handle returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowstationa">CreateWindowStation</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-openwindowstationa">OpenWindowStation</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getprocesswindowstation">GetProcessWindowStation</a> function.</para>
        /// <para>This window station must be associated with the current session.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setprocesswindowstation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setprocesswindowstation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetProcessWindowStation(win32.System.StationsAndDesktops.HWINSTA hWinSta);
        /// <inheritdoc cref = "GetProcessWindowStation()"/>
        internal static unsafe User32.CloseWindowStationSafeHandle GetProcessWindowStation_SafeHandle()
        {
            win32.System.StationsAndDesktops.HWINSTA __result = User32.GetProcessWindowStation();
            return new User32.CloseWindowStationSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>Retrieves a handle to the current window station for the calling process.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the window station.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getprocesswindowstation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.StationsAndDesktops.HWINSTA GetProcessWindowStation();
        /// <inheritdoc cref = "GetUserObjectInformation(win32.System.SystemServices.HANDLE, win32.System.StationsAndDesktops.USER_OBJECT_INFORMATION_INDEX, void *, uint, uint *)"/>
        internal static unsafe bool GetUserObjectInformation(SafeHandle hObj, win32.System.StationsAndDesktops.USER_OBJECT_INFORMATION_INDEX nIndex, void *pvInfo, uint nLength, uint *lpnLengthNeeded)
        {
            bool hObjAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hObjLocal;
                if (hObj is object)
                {
                    hObj.DangerousAddRef(ref hObjAddRef);
                    hObjLocal = (win32.System.SystemServices.HANDLE)hObj.DangerousGetHandle();
                }
                else
                    hObjLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = User32.GetUserObjectInformation(hObjLocal, nIndex, pvInfo, nLength, lpnLengthNeeded);
                return __result;
            }
            finally
            {
                if (hObjAddRef)
                    hObj.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the specified window station or desktop object.</summary>
        /// <param name = "hObj">
        /// <para>A handle to the window station or desktop object. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowstationa">CreateWindowStation</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-openwindowstationa">OpenWindowStation</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createdesktopa">CreateDesktop</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-opendesktopa">OpenDesktop</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getuserobjectinformationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIndex"></param>
        /// <param name = "pvInfo">A pointer to a buffer to receive the object information.</param>
        /// <param name = "nLength">The size of the buffer pointed to by the <i>pvInfo</i> parameter, in bytes.</param>
        /// <param name = "lpnLengthNeeded">A pointer to a variable receiving the number of bytes required to store the requested information. If this variable's value is greater than the value of the <i>nLength</i> parameter when the function returns, the function returns FALSE, and none of the information is copied to the <i>pvInfo</i> buffer. If the value of the variable pointed to by <i>lpnLengthNeeded</i> is less than or equal to the value of <i>nLength</i>, the entire information block is copied.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getuserobjectinformationw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetUserObjectInformationW", SetLastError = true)]
        internal static extern unsafe bool GetUserObjectInformation(win32.System.SystemServices.HANDLE hObj, win32.System.StationsAndDesktops.USER_OBJECT_INFORMATION_INDEX nIndex, [Optional] void *pvInfo, uint nLength, [Optional] uint *lpnLengthNeeded);
        /// <inheritdoc cref = "SetUserObjectInformation(win32.System.SystemServices.HANDLE, int, void *, uint)"/>
        internal static unsafe bool SetUserObjectInformation(SafeHandle hObj, int nIndex, void *pvInfo, uint nLength)
        {
            bool hObjAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hObjLocal;
                if (hObj is object)
                {
                    hObj.DangerousAddRef(ref hObjAddRef);
                    hObjLocal = (win32.System.SystemServices.HANDLE)hObj.DangerousGetHandle();
                }
                else
                    hObjLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = User32.SetUserObjectInformation(hObjLocal, nIndex, pvInfo, nLength);
                return __result;
            }
            finally
            {
                if (hObjAddRef)
                    hObj.DangerousRelease();
            }
        }

        /// <summary>Sets information about the specified window station or desktop object.</summary>
        /// <param name = "hObj">
        /// <para>A handle to the window station, desktop object or a current process pseudo handle. This handle can be returned by the  <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowstationa">CreateWindowStation</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-openwindowstationa">OpenWindowStation</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createdesktopa">CreateDesktop</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-opendesktopa">OpenDesktop</a> or  <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess">GetCurrentProcess</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setuserobjectinformationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIndex">
        /// <para>The object information to be set. This parameter can be the following value. </para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setuserobjectinformationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pvInfo">A pointer to a buffer containing the object information, or a BOOL.</param>
        /// <param name = "nLength">The size of the information contained in the buffer pointed to by <i>pvInfo</i>, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setuserobjectinformationw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SetUserObjectInformationW", SetLastError = true)]
        internal static extern unsafe bool SetUserObjectInformation(win32.System.SystemServices.HANDLE hObj, int nIndex, void *pvInfo, uint nLength);
        /// <summary>Changes the check state of a button control.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>A handle to the dialog box that contains the button.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkdlgbutton#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDButton">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the button to modify.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkdlgbutton#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uCheck">Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkdlgbutton">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool CheckDlgButton(win32.UI.WindowsAndMessaging.HWND hDlg, int nIDButton, win32.UI.Controls.DLG_BUTTON_CHECK_STATE uCheck);
        /// <summary>Adds a check mark to (checks) a specified radio button in a group and removes a check mark from (clears) all other radio buttons in the group.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>A handle to the dialog box that contains the radio button.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkradiobutton#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDFirstButton">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the first radio button in the group.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkradiobutton#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDLastButton">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the last radio button in the group.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkradiobutton#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDCheckButton">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the radio button to select.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkradiobutton#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-checkradiobutton">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool CheckRadioButton(win32.UI.WindowsAndMessaging.HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton);
        /// <summary>The IsDlgButtonChecked function determines whether a button control is checked or whether a three-state button control is checked, unchecked, or indeterminate.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>A handle to the dialog box that contains the button control.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isdlgbuttonchecked#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDButton">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the button control.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isdlgbuttonchecked#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
        /// <para>The return value from a button created with the <a href = "/windows/desktop/Controls/button-styles">BS_AUTOCHECKBOX</a>, <a href = "/windows/desktop/Controls/button-styles">BS_AUTORADIOBUTTON</a>, <a href = "/windows/desktop/Controls/button-styles">BS_AUTO3STATE</a>, <a href = "/windows/desktop/Controls/button-styles">BS_CHECKBOX</a>, <a href = "/windows/desktop/Controls/button-styles">BS_RADIOBUTTON</a>, or <a href = "/windows/desktop/Controls/button-styles">BS_3STATE</a> styles can be one of the values in the following table. If the button has any other style, the return value is zero.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isdlgbuttonchecked">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint IsDlgButtonChecked(win32.UI.WindowsAndMessaging.HWND hDlg, int nIDButton);
        /// <param name = "ch">
        /// <para>Type: <b>TCHAR</b></para>
        /// <para>The character to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ischarlowerw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the character is lowercase, the return value is nonzero.</para>
        /// <para>If the character is not lowercase, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ischarlowerw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "IsCharLowerW", SetLastError = true)]
        internal static extern bool IsCharLower(char ch);
        /// <summary>Configures the touch injection context for the calling application and initializes the maximum number of simultaneous contacts that the app can inject.</summary>
        /// <param name = "maxCount">
        /// <para>The maximum number of touch contacts.</para>
        /// <para>The <i>maxCount</i> parameter must be greater than 0 and less than or equal to MAX_TOUCH_COUNT (256) as  defined in winuser.h.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-initializetouchinjection#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMode">
        /// <para>The contact visualization mode.</para>
        /// <para>The <i>dwMode</i> parameter must be   <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/input_touchinjection/constants">TOUCH_FEEDBACK_DEFAULT</a>, <b>TOUCH_FEEDBACK_INDIRECT</b>, or <b>TOUCH_FEEDBACK_NONE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-initializetouchinjection#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is TRUE.</para>
        /// <para>If the function fails, the return value is FALSE. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-initializetouchinjection">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool InitializeTouchInjection(uint maxCount, win32.UI.Controls.TOUCH_FEEDBACK_MODE dwMode);
        /// <inheritdoc cref = "InjectTouchInput(uint, win32.UI.PointerInput.POINTER_TOUCH_INFO*)"/>
        internal static unsafe bool InjectTouchInput(ReadOnlySpan<win32.UI.PointerInput.POINTER_TOUCH_INFO> contacts)
        {
            fixed (win32.UI.PointerInput.POINTER_TOUCH_INFO*contactsLocal = contacts)
            {
                bool __result = User32.InjectTouchInput((uint)contacts.Length, contactsLocal);
                return __result;
            }
        }

        /// <summary>Simulates touch input.</summary>
        /// <param name = "count">
        /// <para>The size of the array in <i>contacts</i>.</para>
        /// <para>The maximum value for <i>count</i> is specified by the <i>maxCount</i> parameter of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-initializetouchinjection">InitializeTouchInjection</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-injecttouchinput#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "contacts">Array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_touch_info">POINTER_TOUCH_INFO</a> structures that represents all contacts on the desktop. The  screen coordinates of each contact must be within the bounds of the desktop.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-injecttouchinput">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool InjectTouchInput(uint count, win32.UI.PointerInput.POINTER_TOUCH_INFO*contacts);
        /// <summary>Configures the pointer injection device for the calling application, and initializes the maximum number of simultaneous pointers that the app can inject.</summary>
        /// <param name = "pointerType">The pointer injection device type. Must be either <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ne-winuser-tagpointer_input_type">PT_TOUCH</a> or <b>PT_PEN</b>.</param>
        /// <param name = "maxCount">
        /// <para>The maximum number of contacts.</para>
        /// <para>For <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ne-winuser-tagpointer_input_type">PT_TOUCH</a> this value must be greater than 0 and less than or equal to <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/input_touchinjection/constants">MAX_TOUCH_COUNT</a>.</para>
        /// <para>For <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ne-winuser-tagpointer_input_type">PT_PEN</a> this value must be 1.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createsyntheticpointerdevice#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "mode">The contact visualization mode.</param>
        /// <returns>If the function succeeds, the return value is a handle to the pointer injection device. Otherwise, it returns null. To retrieve extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-createsyntheticpointerdevice">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.Controls.HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(win32.UI.WindowsAndMessaging.POINTER_INPUT_TYPE pointerType, uint maxCount, win32.UI.Controls.POINTER_FEEDBACK_MODE mode);
        /// <inheritdoc cref = "InjectSyntheticPointerInput(win32.UI.Controls.HSYNTHETICPOINTERDEVICE, win32.UI.Controls.POINTER_TYPE_INFO*, uint)"/>
        internal static unsafe bool InjectSyntheticPointerInput(win32.UI.Controls.HSYNTHETICPOINTERDEVICE device, ReadOnlySpan<win32.UI.Controls.POINTER_TYPE_INFO> pointerInfo)
        {
            fixed (win32.UI.Controls.POINTER_TYPE_INFO*pointerInfoLocal = pointerInfo)
            {
                bool __result = User32.InjectSyntheticPointerInput(device, pointerInfoLocal, (uint)pointerInfo.Length);
                return __result;
            }
        }

        /// <summary>Simulates pointer input (pen or touch).</summary>
        /// <param name = "device">A handle to the pointer injection device created by <a href = "../winuser/nf-winuser-createsyntheticpointerdevice.md">CreateSyntheticPointerDevice</a>.</param>
        /// <param name = "pointerInfo">
        /// <para>Array of injected pointers.</para>
        /// <para>The type must match the <i>pointerType</i> parameter of the <a href = "../winuser/nf-winuser-createsyntheticpointerdevice.md">CreateSyntheticPointerDevice</a> call that created the injection device.</para>
        /// <para>The ptPixelLocation for each POINTER_TYPE_INFO is specified relative to top left of the virtual screen:</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-injectsyntheticpointerinput#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "count">
        /// <para>The number of contacts.</para>
        /// <para>For <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ne-winuser-tagpointer_input_type">PT_TOUCH</a> this value must be greater than 0 and less than or equal to <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/input_touchinjection/constants">MAX_TOUCH_COUNT</a>.</para>
        /// <para>For <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ne-winuser-tagpointer_input_type">PT_PEN</a> this value must be 1.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-injectsyntheticpointerinput#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-injectsyntheticpointerinput">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool InjectSyntheticPointerInput(win32.UI.Controls.HSYNTHETICPOINTERDEVICE device, win32.UI.Controls.POINTER_TYPE_INFO*pointerInfo, uint count);
        /// <summary>Destroys the specified pointer injection device.</summary>
        /// <param name = "device">A handle to the pointer injection device.</param>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroysyntheticpointerdevice">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern void DestroySyntheticPointerDevice(win32.UI.Controls.HSYNTHETICPOINTERDEVICE device);
        /// <summary>Registers a window to process the WM_TOUCHHITTESTING notification.</summary>
        /// <param name = "hwnd">The window that receives the <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/inputmsg/wm-touchhittesting">WM_TOUCHHITTESTING</a>  notification.</param>
        /// <param name = "value"></param>
        /// <returns>
        /// <para>If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registertouchhittestingwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool RegisterTouchHitTestingWindow(win32.UI.WindowsAndMessaging.HWND hwnd, uint value);
        /// <inheritdoc cref = "EvaluateProximityToRect(win32.UI.DisplayDevices.RECT*, win32.UI.Controls.TOUCH_HIT_TESTING_INPUT*, win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION*)"/>
        internal static unsafe bool EvaluateProximityToRect(in win32.UI.DisplayDevices.RECT controlBoundingBox, in win32.UI.Controls.TOUCH_HIT_TESTING_INPUT pHitTestingInput, out win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION pProximityEval)
        {
            fixed (win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION*pProximityEvalLocal = &pProximityEval)
            {
                fixed (win32.UI.Controls.TOUCH_HIT_TESTING_INPUT*pHitTestingInputLocal = &pHitTestingInput)
                {
                    fixed (win32.UI.DisplayDevices.RECT*controlBoundingBoxLocal = &controlBoundingBox)
                    {
                        bool __result = User32.EvaluateProximityToRect(controlBoundingBoxLocal, pHitTestingInputLocal, pProximityEvalLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Returns the score of a rectangle as the probable touch target, compared to all other rectangles that intersect the touch contact area, and an adjusted touch point within the rectangle.</summary>
        /// <param name = "controlBoundingBox">The <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that defines the bounding box of the UI element.</param>
        /// <param name = "pHitTestingInput">The <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-touch_hit_testing_input">TOUCH_HIT_TESTING_INPUT</a> structure that holds the data for the touch contact area.</param>
        /// <param name = "pProximityEval">The <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ns-winuser-touch_hit_testing_proximity_evaluation">TOUCH_HIT_TESTING_PROXIMITY_EVALUATION</a> structure that holds the score and adjusted touch-point data.</param>
        /// <returns>
        /// <para>If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-evaluateproximitytorect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool EvaluateProximityToRect(win32.UI.DisplayDevices.RECT*controlBoundingBox, win32.UI.Controls.TOUCH_HIT_TESTING_INPUT*pHitTestingInput, win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION*pProximityEval);
        /// <inheritdoc cref = "EvaluateProximityToPolygon(uint, win32.UI.DisplayDevices.POINT*, win32.UI.Controls.TOUCH_HIT_TESTING_INPUT*, win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION*)"/>
        internal static unsafe bool EvaluateProximityToPolygon(ReadOnlySpan<win32.UI.DisplayDevices.POINT> controlPolygon, in win32.UI.Controls.TOUCH_HIT_TESTING_INPUT pHitTestingInput, out win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION pProximityEval)
        {
            fixed (win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION*pProximityEvalLocal = &pProximityEval)
            {
                fixed (win32.UI.Controls.TOUCH_HIT_TESTING_INPUT*pHitTestingInputLocal = &pHitTestingInput)
                {
                    fixed (win32.UI.DisplayDevices.POINT*controlPolygonLocal = controlPolygon)
                    {
                        bool __result = User32.EvaluateProximityToPolygon((uint)controlPolygon.Length, controlPolygonLocal, pHitTestingInputLocal, pProximityEvalLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Returns the score of a polygon as the probable touch target (compared to all other polygons that intersect the touch contact area) and an adjusted touch point within the polygon.</summary>
        /// <param name = "numVertices">
        /// <para>The number of vertices in the polygon. This value must be greater than or equal to 3.</para>
        /// <para>This value indicates the size of the array, as specified by the <i>controlPolygon</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-evaluateproximitytopolygon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "controlPolygon">
        /// <para>The array of x-y screen coordinates that define the shape of the UI element.</para>
        /// <para>The <i>numVertices</i> parameter specifies the number of coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-evaluateproximitytopolygon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pHitTestingInput">The <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-touch_hit_testing_input">TOUCH_HIT_TESTING_INPUT</a> structure that holds the data for the touch contact area.</param>
        /// <param name = "pProximityEval">The <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ns-winuser-touch_hit_testing_proximity_evaluation">TOUCH_HIT_TESTING_PROXIMITY_EVALUATION</a> structure that holds the score and adjusted touch-point data.</param>
        /// <returns>
        /// <para>If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-evaluateproximitytopolygon">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool EvaluateProximityToPolygon(uint numVertices, win32.UI.DisplayDevices.POINT*controlPolygon, win32.UI.Controls.TOUCH_HIT_TESTING_INPUT*pHitTestingInput, win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION*pProximityEval);
        /// <inheritdoc cref = "PackTouchHitTestingProximityEvaluation(win32.UI.Controls.TOUCH_HIT_TESTING_INPUT*, win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION*)"/>
        internal static unsafe win32.System.SystemServices.LRESULT PackTouchHitTestingProximityEvaluation(in win32.UI.Controls.TOUCH_HIT_TESTING_INPUT pHitTestingInput, in win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION pProximityEval)
        {
            fixed (win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION*pProximityEvalLocal = &pProximityEval)
            {
                fixed (win32.UI.Controls.TOUCH_HIT_TESTING_INPUT*pHitTestingInputLocal = &pHitTestingInput)
                {
                    win32.System.SystemServices.LRESULT __result = User32.PackTouchHitTestingProximityEvaluation(pHitTestingInputLocal, pProximityEvalLocal);
                    return __result;
                }
            }
        }

        /// <summary>Returns the proximity evaluation score and the adjusted touch-point coordinates as a packed value for the WM_TOUCHHITTESTING callback.</summary>
        /// <param name = "pHitTestingInput">The <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-touch_hit_testing_input">TOUCH_HIT_TESTING_INPUT</a> structure that holds the data for the touch contact area.</param>
        /// <param name = "pProximityEval">The <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ns-winuser-touch_hit_testing_proximity_evaluation">TOUCH_HIT_TESTING_PROXIMITY_EVALUATION</a> structure that holds the score and adjusted touch-point data that the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-evaluateproximitytopolygon">EvaluateProximityToPolygon</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-evaluateproximitytorect">EvaluateProximityToRect</a> function returns.</param>
        /// <returns>If this function succeeds, it returns the <b>score</b> and <b>adjustedPoint</b> values from <a href = "/windows/win32/api/winuser/ns-winuser-touch_hit_testing_proximity_evaluation">TOUCH_HIT_TESTING_PROXIMITY_EVALUATION</a> as an LRESULT. To retrieve extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-packtouchhittestingproximityevaluation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.LRESULT PackTouchHitTestingProximityEvaluation(win32.UI.Controls.TOUCH_HIT_TESTING_INPUT*pHitTestingInput, win32.UI.Controls.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION*pProximityEval);
        /// <inheritdoc cref = "GetWindowFeedbackSetting(win32.UI.WindowsAndMessaging.HWND, win32.UI.Controls.FEEDBACK_TYPE, uint, uint *, void *)"/>
        internal static unsafe bool GetWindowFeedbackSetting(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.Controls.FEEDBACK_TYPE feedback, uint dwFlags, ref uint pSize, void *config)
        {
            fixed (uint *pSizeLocal = &pSize)
            {
                bool __result = User32.GetWindowFeedbackSetting(hwnd, feedback, dwFlags, pSizeLocal, config);
                return __result;
            }
        }

        /// <summary>Retrieves the feedback configuration for a window.</summary>
        /// <param name = "hwnd">The window to check for feedback configuration.</param>
        /// <param name = "feedback">One of the values from the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ne-winuser-feedback_type">FEEDBACK_TYPE</a> enumeration.</param>
        /// <param name = "dwFlags">Specify <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/input_feedback/constants">GWFS_INCLUDE_ANCESTORS</a> to check the parent window chain until a value is found. The default is 0 and indicates that only the specified window will be checked.</param>
        /// <param name = "pSize">
        /// <para>The size of memory region that the <i>config</i> parameter points to.</para>
        /// <para>The <i>pSize</i> parameter specifies the size of the configuration data for the feedback type in <i>feedback</i> and must be sizeof(BOOL).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowfeedbacksetting#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "config">
        /// <para>The configuration data.</para>
        /// <para>The <i>config</i> parameter must point to a value of type BOOL.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowfeedbacksetting#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>Returns TRUE if the specified feedback setting is configured on the specified window. Otherwise, it returns FALSE (and <i>config</i> won't be modified).</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowfeedbacksetting">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool GetWindowFeedbackSetting(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.Controls.FEEDBACK_TYPE feedback, uint dwFlags, uint *pSize, [Optional] void *config);
        /// <summary>Sets the feedback configuration for a window.</summary>
        /// <param name = "hwnd">The window to configure feedback on.</param>
        /// <param name = "feedback">One of the values from the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ne-winuser-feedback_type">FEEDBACK_TYPE</a> enumeration.</param>
        /// <param name = "dwFlags">Reserved. Must be 0.</param>
        /// <param name = "size">The size, in bytes, of the configuration data. Must be sizeof(BOOL) or 0 if the feedback setting is being reset.</param>
        /// <param name = "configuration">The configuration data. Must be BOOL or NULL if the feedback setting is being reset.</param>
        /// <returns>Returns TRUE if successful; otherwise, returns FALSE.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowfeedbacksetting">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool SetWindowFeedbackSetting(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.Controls.FEEDBACK_TYPE feedback, uint dwFlags, uint size, [Optional] void *configuration);
        /// <inheritdoc cref = "ScrollWindow(win32.UI.WindowsAndMessaging.HWND, int, int, win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool ScrollWindow(win32.UI.WindowsAndMessaging.HWND hWnd, int XAmount, int YAmount, win32.UI.DisplayDevices.RECT? lpRect, win32.UI.DisplayDevices.RECT? lpClipRect)
        {
            win32.UI.DisplayDevices.RECT lpRectLocal = lpRect.HasValue ? lpRect.Value : default(win32.UI.DisplayDevices.RECT);
            win32.UI.DisplayDevices.RECT lpClipRectLocal = lpClipRect.HasValue ? lpClipRect.Value : default(win32.UI.DisplayDevices.RECT);
            bool __result = User32.ScrollWindow(hWnd, XAmount, YAmount, lpRect.HasValue ? &lpRectLocal : null, lpClipRect.HasValue ? &lpClipRectLocal : null);
            return __result;
        }

        /// <summary>The ScrollWindow function scrolls the contents of the specified window's client area.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to the window where the client area is to be scrolled.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "XAmount">
        /// <para>Type: <b>int</b></para>
        /// <para>Specifies the amount, in device units, of horizontal scrolling. If the window being scrolled has the <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-class-styles">CS_OWNDC</a> or <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-class-styles">CS_CLASSDC</a> style, then this parameter uses logical units rather than device units. This parameter must be a negative value to scroll the content of the window to the left.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "YAmount">
        /// <para>Type: <b>int</b></para>
        /// <para>Specifies the amount, in device units, of vertical scrolling. If the window being scrolled has the <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-class-styles">CS_OWNDC</a> or <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-class-styles">CS_CLASSDC</a> style, then this parameter uses logical units rather than device units. This parameter must be a negative value to scroll the content of the window up.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpRect">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b></para>
        /// <para>Pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure specifying the portion of the client area to be scrolled. If this parameter is <b>NULL</b>, the entire client area is scrolled.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpClipRect">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b></para>
        /// <para>Pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure containing the coordinates of the clipping rectangle. Only device bits within the clipping rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside of the rectangle to the outside are not painted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ScrollWindow(win32.UI.WindowsAndMessaging.HWND hWnd, int XAmount, int YAmount, [Optional] win32.UI.DisplayDevices.RECT*lpRect, [Optional] win32.UI.DisplayDevices.RECT*lpClipRect);
        /// <inheritdoc cref = "ScrollDC(win32.Graphics.Gdi.HDC, int, int, win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*, win32.Graphics.Gdi.HRGN, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool ScrollDC(SafeHandle hDC, int dx, int dy, win32.UI.DisplayDevices.RECT? lprcScroll, win32.UI.DisplayDevices.RECT? lprcClip, SafeHandle hrgnUpdate, win32.UI.DisplayDevices.RECT*lprcUpdate)
        {
            bool hDCAddRef = false;
            bool hrgnUpdateAddRef = false;
            try
            {
                win32.Graphics.Gdi.HDC hDCLocal;
                if (hDC is object)
                {
                    hDC.DangerousAddRef(ref hDCAddRef);
                    hDCLocal = (win32.Graphics.Gdi.HDC)hDC.DangerousGetHandle();
                }
                else
                    hDCLocal = default(win32.Graphics.Gdi.HDC);
                win32.UI.DisplayDevices.RECT lprcScrollLocal = lprcScroll.HasValue ? lprcScroll.Value : default(win32.UI.DisplayDevices.RECT);
                win32.UI.DisplayDevices.RECT lprcClipLocal = lprcClip.HasValue ? lprcClip.Value : default(win32.UI.DisplayDevices.RECT);
                win32.Graphics.Gdi.HRGN hrgnUpdateLocal;
                if (hrgnUpdate is object)
                {
                    hrgnUpdate.DangerousAddRef(ref hrgnUpdateAddRef);
                    hrgnUpdateLocal = (win32.Graphics.Gdi.HRGN)hrgnUpdate.DangerousGetHandle();
                }
                else
                    hrgnUpdateLocal = default(win32.Graphics.Gdi.HRGN);
                bool __result = User32.ScrollDC(hDCLocal, dx, dy, lprcScroll.HasValue ? &lprcScrollLocal : null, lprcClip.HasValue ? &lprcClipLocal : null, hrgnUpdateLocal, lprcUpdate);
                return __result;
            }
            finally
            {
                if (hDCAddRef)
                    hDC.DangerousRelease();
                if (hrgnUpdateAddRef)
                    hrgnUpdate.DangerousRelease();
            }
        }

        /// <summary>The ScrollDC function scrolls a rectangle of bits horizontally and vertically.</summary>
        /// <param name = "hDC">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HDC</a></b></para>
        /// <para>Handle to the device context that contains the bits to be scrolled.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrolldc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dx">
        /// <para>Type: <b>int</b></para>
        /// <para>Specifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrolldc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dy">
        /// <para>Type: <b>int</b></para>
        /// <para>Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrolldc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lprcScroll">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b></para>
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure containing the coordinates of the bits to be scrolled. The only bits affected by the scroll operation are bits in the intersection of this rectangle and the rectangle specified by <i>lprcClip</i>. If <i>lprcScroll</i> is <b>NULL</b>, the entire client area is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrolldc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lprcClip">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b></para>
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure containing the coordinates of the clipping rectangle. The only bits that will be painted are the bits that remain inside this rectangle after the scroll operation has been completed. If <i>lprcClip</i> is <b>NULL</b>, the entire client area is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrolldc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hrgnUpdate">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HRGN</a></b></para>
        /// <para>Handle to the region uncovered by the scrolling process. <b>ScrollDC</b> defines this region; it is not necessarily a rectangle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrolldc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lprcUpdate">
        /// <para>Type: <b>LPRECT</b></para>
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the coordinates of the rectangle bounding the scrolling update region. This is the largest rectangular area that requires repainting. When the function returns, the values in the structure are in client coordinates, regardless of the mapping mode for the specified device context. This allows applications to use the update region in a call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-invalidatergn">InvalidateRgn</a> function, if required.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrolldc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrolldc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ScrollDC(win32.Graphics.Gdi.HDC hDC, int dx, int dy, [Optional] win32.UI.DisplayDevices.RECT*lprcScroll, [Optional] win32.UI.DisplayDevices.RECT*lprcClip, win32.Graphics.Gdi.HRGN hrgnUpdate, [Optional] win32.UI.DisplayDevices.RECT*lprcUpdate);
        /// <inheritdoc cref = "ScrollWindowEx(win32.UI.WindowsAndMessaging.HWND, int, int, win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*, win32.Graphics.Gdi.HRGN, win32.UI.DisplayDevices.RECT*, win32.UI.WindowsAndMessaging.SHOW_WINDOW_CMD)"/>
        internal static unsafe int ScrollWindowEx(win32.UI.WindowsAndMessaging.HWND hWnd, int dx, int dy, win32.UI.DisplayDevices.RECT? prcScroll, win32.UI.DisplayDevices.RECT? prcClip, SafeHandle hrgnUpdate, win32.UI.DisplayDevices.RECT*prcUpdate, win32.UI.WindowsAndMessaging.SHOW_WINDOW_CMD flags)
        {
            bool hrgnUpdateAddRef = false;
            try
            {
                win32.UI.DisplayDevices.RECT prcScrollLocal = prcScroll.HasValue ? prcScroll.Value : default(win32.UI.DisplayDevices.RECT);
                win32.UI.DisplayDevices.RECT prcClipLocal = prcClip.HasValue ? prcClip.Value : default(win32.UI.DisplayDevices.RECT);
                win32.Graphics.Gdi.HRGN hrgnUpdateLocal;
                if (hrgnUpdate is object)
                {
                    hrgnUpdate.DangerousAddRef(ref hrgnUpdateAddRef);
                    hrgnUpdateLocal = (win32.Graphics.Gdi.HRGN)hrgnUpdate.DangerousGetHandle();
                }
                else
                    hrgnUpdateLocal = default(win32.Graphics.Gdi.HRGN);
                int __result = User32.ScrollWindowEx(hWnd, dx, dy, prcScroll.HasValue ? &prcScrollLocal : null, prcClip.HasValue ? &prcClipLocal : null, hrgnUpdateLocal, prcUpdate, flags);
                return __result;
            }
            finally
            {
                if (hrgnUpdateAddRef)
                    hrgnUpdate.DangerousRelease();
            }
        }

        /// <summary>The ScrollWindowEx function scrolls the contents of the specified window's client area.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to the window where the client area is to be scrolled.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindowex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dx">
        /// <para>Type: <b>int</b></para>
        /// <para>Specifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindowex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dy">
        /// <para>Type: <b>int</b></para>
        /// <para>Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindowex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "prcScroll">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b></para>
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the portion of the client area to be scrolled. If this parameter is <b>NULL</b>, the entire client area is scrolled.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindowex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "prcClip">
        /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b></para>
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the coordinates of the clipping rectangle. Only device bits within the clipping rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside of the rectangle to the outside are not painted. This parameter may be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindowex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hrgnUpdate">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HRGN</a></b></para>
        /// <para>Handle to the region that is modified to hold the region invalidated by scrolling. This parameter may be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindowex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "prcUpdate">
        /// <para>Type: <b>LPRECT</b></para>
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the boundaries of the rectangle invalidated by scrolling. This parameter may be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindowex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flags">Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is SIMPLEREGION (rectangular invalidated region), COMPLEXREGION (nonrectangular invalidated region; overlapping rectangles), or NULLREGION (no invalidated region).</para>
        /// <para>If the function fails, the return value is ERROR. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-scrollwindowex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int ScrollWindowEx(win32.UI.WindowsAndMessaging.HWND hWnd, int dx, int dy, [Optional] win32.UI.DisplayDevices.RECT*prcScroll, [Optional] win32.UI.DisplayDevices.RECT*prcClip, win32.Graphics.Gdi.HRGN hrgnUpdate, [Optional] win32.UI.DisplayDevices.RECT*prcUpdate, win32.UI.WindowsAndMessaging.SHOW_WINDOW_CMD flags);
        /// <summary>The SetScrollPos function sets the position of the scroll box (thumb) in the specified scroll bar and, if requested, redraws the scroll bar to reflect the new position of the scroll box.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <i>nBar</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBar">Type: <b>int</b></param>
        /// <param name = "nPos">
        /// <para>Type: <b>int</b></para>
        /// <para>Specifies the new position of the scroll box. The position must be within the scrolling range. For more information about the scrolling range, see the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setscrollrange">SetScrollRange</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bRedraw">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>Specifies whether the scroll bar is redrawn to reflect the new scroll box position. If this parameter is <b>TRUE</b>, the scroll bar is redrawn. If it is <b>FALSE</b>, the scroll bar is not redrawn.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b> If the function succeeds, the return value is the previous position of the scroll box.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern int SetScrollPos(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.Controls.SCROLLBAR_CONSTANTS nBar, int nPos, bool bRedraw);
        /// <summary>The GetScrollPos function retrieves the current position of the scroll box (thumb) in the specified scroll bar.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <i>nBar</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollpos#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBar">Type: <b>int</b></param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the current position of the scroll box.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollpos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetScrollPos(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.Controls.SCROLLBAR_CONSTANTS nBar);
        /// <summary>The SetScrollRange function sets the minimum and maximum scroll box positions for the specified scroll bar.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <i>nBar</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollrange#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBar">Type: <b>int</b></param>
        /// <param name = "nMinPos">
        /// <para>Type: <b>int</b></para>
        /// <para>Specifies the minimum scrolling position.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollrange#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nMaxPos">
        /// <para>Type: <b>int</b></para>
        /// <para>Specifies the maximum scrolling position.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollrange#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bRedraw">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>Specifies whether the scroll bar should be redrawn to reflect the change. If this parameter is <b>TRUE</b>, the scroll bar is redrawn. If it is <b>FALSE</b>, the scroll bar is not redrawn.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollrange#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollrange">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetScrollRange(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.Controls.SCROLLBAR_CONSTANTS nBar, int nMinPos, int nMaxPos, bool bRedraw);
        /// <inheritdoc cref = "GetScrollRange(win32.UI.WindowsAndMessaging.HWND, win32.UI.Controls.SCROLLBAR_CONSTANTS, int *, int *)"/>
        internal static unsafe bool GetScrollRange(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.Controls.SCROLLBAR_CONSTANTS nBar, out int lpMinPos, out int lpMaxPos)
        {
            fixed (int *lpMaxPosLocal = &lpMaxPos)
            {
                fixed (int *lpMinPosLocal = &lpMinPos)
                {
                    bool __result = User32.GetScrollRange(hWnd, nBar, lpMinPosLocal, lpMaxPosLocal);
                    return __result;
                }
            }
        }

        /// <summary>The GetScrollRange function retrieves the current minimum and maximum scroll box (thumb) positions for the specified scroll bar.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <i>nBar</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollrange#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBar">Type: <b>int</b></param>
        /// <param name = "lpMinPos">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LPINT</a></b></para>
        /// <para>Pointer to the integer variable that receives the minimum position.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollrange#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMaxPos">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LPINT</a></b></para>
        /// <para>Pointer to the integer variable that receives the maximum position.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollrange#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollrange">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetScrollRange(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.Controls.SCROLLBAR_CONSTANTS nBar, int *lpMinPos, int *lpMaxPos);
        /// <summary>The ShowScrollBar function shows or hides the specified scroll bar.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <i>wBar</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showscrollbar#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wBar">Type: <b>int</b></param>
        /// <param name = "bShow">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>Specifies whether the scroll bar is shown or hidden. If this parameter is <b>TRUE</b>, the scroll bar is shown; otherwise, it is hidden.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showscrollbar#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showscrollbar">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ShowScrollBar(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.Controls.SCROLLBAR_CONSTANTS wBar, bool bShow);
        /// <summary>The EnableScrollBar function enables or disables one or both scroll bar arrows.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to a window or a scroll bar control, depending on the value of the <i>wSBflags</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enablescrollbar#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wSBflags">Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></param>
        /// <param name = "wArrows">Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the arrows are enabled or disabled as specified, the return value is nonzero.</para>
        /// <para>If the arrows are already in the requested state or an error occurs, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enablescrollbar">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool EnableScrollBar(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.Controls.SCROLLBAR_CONSTANTS wSBflags, win32.UI.Controls.ENABLE_SCROLL_BAR_ARROWS wArrows);
        /// <summary>Replaces the contents of a list box with the names of the subdirectories and files in a specified directory. You can filter the list of names by specifying a set of file attributes. The list can optionally include mapped drives.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>A handle to the dialog box that contains the list box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirlistw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpPathSpec">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LPTSTR</a></b></para>
        /// <para>A pointer to a buffer containing a null-terminated string that specifies an absolute path, relative path, or filename. An absolute path can begin with a drive letter (for example, d:\) or a UNC name (for example, \\ <i>machinename</i>\ <i>sharename</i>).</para>
        /// <para>The function splits the string into a directory and a filename. The function searches the directory for names that match the filename. If the string does not specify a directory, the function searches the current directory.</para>
        /// <para>If the string includes a filename, the filename must contain at least one wildcard character (? or *). If the string does not include a filename, the function behaves as if you had specified the asterisk wildcard character (*) as the filename. All names in the specified directory that match the filename and have the attributes specified by the <i>uFileType</i> parameter are added to the list box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirlistw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDListBox">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of a list box in the <i>hDlg</i> dialog box. If this parameter is zero, <b>DlgDirList</b> does not try to fill a list box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirlistw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDStaticPath">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of a static control in the <i>hDlg</i> dialog box. <b>DlgDirList</b> sets the text of this control to display the current drive and directory. This parameter can be zero if you do not want to display the current drive and directory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirlistw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFileType">Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. For example, if the string specified by <i>lpPathSpec</i> is not a valid path, the function fails. To get extended error information, call .</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirlistw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DlgDirListW")]
        internal static extern int DlgDirList(win32.UI.WindowsAndMessaging.HWND hDlg, win32.System.SystemServices.PWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, win32.UI.Controls.DLG_DIR_LIST_FILE_TYPE uFileType);
        /// <summary>Retrieves the current selection from a single-selection list box. It assumes that the list box has been filled by the DlgDirList function and that the selection is a drive letter, filename, or directory name.</summary>
        /// <param name = "hwndDlg">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>A handle to the dialog box that contains the list box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirselectexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LPTSTR</a></b></para>
        /// <para>A pointer to a buffer that receives the selected path.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirselectexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "chCount">
        /// <para>Type: <b>int</b></para>
        /// <para>The length, in <b>TCHARs</b>, of the buffer pointed to by <i>lpString</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirselectexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "idListBox">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of a list box in the dialog box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirselectexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the current selection is a directory name, the return value is nonzero.</para>
        /// <para>If the current selection is not a directory name, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirselectexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DlgDirSelectExW", SetLastError = true)]
        internal static extern bool DlgDirSelectEx(win32.UI.WindowsAndMessaging.HWND hwndDlg, win32.System.SystemServices.PWSTR lpString, int chCount, int idListBox);
        /// <summary>Replaces the contents of a combo box with the names of the subdirectories and files in a specified directory. You can filter the list of names by specifying a set of file attributes. The list of names can include mapped drive letters.</summary>
        /// <param name = "hDlg">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>A handle to the dialog box that contains the combo box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirlistcomboboxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpPathSpec">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LPTSTR</a></b> A pointer to a buffer containing a null-terminated string that specifies an absolute path, relative path, or file name. An absolute path can begin with a drive letter (for example, d:\) or a UNC name (for example, &#92; &#92;<i>machinename</i>&#92;<i>sharename</i>).</para>
        /// <para>The function splits the string into a directory and a file name. The function searches the directory for names that match the file name. If the string does not specify a directory, the function searches the current directory. If the string includes a file name, the file name must contain at least one wildcard character (? or *). If the string does not include a file name, the function behaves as if you had specified the asterisk wildcard character (*) as the file name. All names in the specified directory that match the file name and have the attributes specified by the <i>uFiletype</i> parameter are added to the list displayed in the combo box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirlistcomboboxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDComboBox">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of a combo box in the <i>hDlg</i> dialog box. If this parameter is zero, <b>DlgDirListComboBox</b> does not try to fill a combo box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirlistcomboboxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nIDStaticPath">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of a static control in the <i>hDlg</i> dialog box. <b>DlgDirListComboBox</b> sets the text of this control to display the current drive and directory. This parameter can be zero if you do not want to display the current drive and directory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirlistcomboboxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFiletype">Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></param>
        /// <returns>
        /// <para>Type: <b>int</b> If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. For example, if the string specified by <i>lpPathSpec</i> is not a valid path, the function fails. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirlistcomboboxw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DlgDirListComboBoxW", SetLastError = true)]
        internal static extern int DlgDirListComboBox(win32.UI.WindowsAndMessaging.HWND hDlg, win32.System.SystemServices.PWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, win32.UI.Controls.DLG_DIR_LIST_FILE_TYPE uFiletype);
        /// <summary>Retrieves the current selection from a combo box filled by using the DlgDirListComboBox function. The selection is interpreted as a drive letter, a file, or a directory name.</summary>
        /// <param name = "hwndDlg">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>A handle to the dialog box that contains the combo box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirselectcomboboxexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LPTSTR</a></b></para>
        /// <para>A pointer to the buffer that receives the selected path.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirselectcomboboxexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchOut">
        /// <para>Type: <b>int</b></para>
        /// <para>The length, in characters, of the buffer pointed to by the <i>lpString</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirselectcomboboxexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "idComboBox">
        /// <para>Type: <b>int</b></para>
        /// <para>The integer identifier of the combo box control in the dialog box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirselectcomboboxexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b> If the current selection is a directory name, the return value is nonzero.</para>
        /// <para>If the current selection is not a directory name, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dlgdirselectcomboboxexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DlgDirSelectComboBoxExW", SetLastError = true)]
        internal static extern bool DlgDirSelectComboBoxEx(win32.UI.WindowsAndMessaging.HWND hwndDlg, win32.System.SystemServices.PWSTR lpString, int cchOut, int idComboBox);
        /// <inheritdoc cref = "SetScrollInfo(win32.UI.WindowsAndMessaging.HWND, win32.UI.Controls.SCROLLBAR_CONSTANTS, win32.UI.Controls.SCROLLINFO*, bool)"/>
        internal static unsafe int SetScrollInfo(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.Controls.SCROLLBAR_CONSTANTS nBar, in win32.UI.Controls.SCROLLINFO lpsi, bool redraw)
        {
            fixed (win32.UI.Controls.SCROLLINFO*lpsiLocal = &lpsi)
            {
                int __result = User32.SetScrollInfo(hwnd, nBar, lpsiLocal, redraw);
                return __result;
            }
        }

        /// <summary>The SetScrollInfo function sets the parameters of a scroll bar, including the minimum and maximum scrolling positions, the page size, and the position of the scroll box (thumb). The function also redraws the scroll bar, if requested.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <i>fnBar</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBar">Type: <b>int</b></param>
        /// <param name = "lpsi">
        /// <para>Type: <b>LPCSCROLLINFO</b></para>
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-scrollinfo">SCROLLINFO</a> structure. Before calling <b>SetScrollInfo</b>, set the <b>cbSize</b> member of the structure to <b>sizeof</b>(<b>SCROLLINFO</b>), set the <b>fMask</b> member to indicate the parameters to set, and specify the new parameter values in the appropriate members.</para>
        /// <para>The</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "redraw">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>Specifies whether the scroll bar is redrawn to reflect the changes to the scroll bar. If this parameter is <b>TRUE</b>, the scroll bar is redrawn, otherwise, it is not redrawn.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>The return value is the current position of the scroll box.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setscrollinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int SetScrollInfo(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.Controls.SCROLLBAR_CONSTANTS nBar, win32.UI.Controls.SCROLLINFO*lpsi, bool redraw);
        /// <inheritdoc cref = "GetScrollInfo(win32.UI.WindowsAndMessaging.HWND, win32.UI.Controls.SCROLLBAR_CONSTANTS, win32.UI.Controls.SCROLLINFO*)"/>
        internal static unsafe bool GetScrollInfo(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.Controls.SCROLLBAR_CONSTANTS nBar, ref win32.UI.Controls.SCROLLINFO lpsi)
        {
            fixed (win32.UI.Controls.SCROLLINFO*lpsiLocal = &lpsi)
            {
                bool __result = User32.GetScrollInfo(hwnd, nBar, lpsiLocal);
                return __result;
            }
        }

        /// <summary>The GetScrollInfo function retrieves the parameters of a scroll bar, including the minimum and maximum scrolling positions, the page size, and the position of the scroll box (thumb).</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <i>fnBar</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBar">Type: <b>int</b></param>
        /// <param name = "lpsi">
        /// <para>Type: <b>LPSCROLLINFO</b></para>
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-scrollinfo">SCROLLINFO</a> structure. Before calling <b>GetScrollInfo</b>, set the <b>cbSize</b> member to <b>sizeof</b>(<b>SCROLLINFO</b>), and set the <b>fMask</b> member to specify the scroll bar parameters to retrieve. Before returning, the function copies the specified parameters to the appropriate members of the structure.</para>
        /// <para>The</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the function retrieved any values, the return value is nonzero.</para>
        /// <para>If the function does not retrieve any values, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetScrollInfo(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.Controls.SCROLLBAR_CONSTANTS nBar, win32.UI.Controls.SCROLLINFO*lpsi);
        /// <inheritdoc cref = "GetScrollBarInfo(win32.UI.WindowsAndMessaging.HWND, win32.UI.Controls.SCROLLBAR_OBJID, win32.UI.Controls.SCROLLBARINFO*)"/>
        internal static unsafe bool GetScrollBarInfo(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.Controls.SCROLLBAR_OBJID idObject, ref win32.UI.Controls.SCROLLBARINFO psbi)
        {
            fixed (win32.UI.Controls.SCROLLBARINFO*psbiLocal = &psbi)
            {
                bool __result = User32.GetScrollBarInfo(hwnd, idObject, psbiLocal);
                return __result;
            }
        }

        /// <summary>The GetScrollBarInfo function retrieves information about the specified scroll bar.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to a window associated with the scroll bar whose information is to be retrieved. If the <i>idObject</i> parameter is OBJID_CLIENT, <i>hwnd</i> is a handle to a scroll bar control. Otherwise, <i>hwnd</i> is a handle to a window created with <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-styles">WS_VSCROLL</a> and/or <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-styles">WS_HSCROLL</a> style.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollbarinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "idObject">Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LONG</a></b></param>
        /// <param name = "psbi">
        /// <para>Type: <b>PSCROLLBARINFO</b></para>
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-scrollbarinfo">SCROLLBARINFO</a> structure to receive the information. Before calling <b>GetScrollBarInfo</b>, set the <b>cbSize</b> member to <b>sizeof</b>(<b>SCROLLBARINFO</b>).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollbarinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getscrollbarinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetScrollBarInfo(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.Controls.SCROLLBAR_OBJID idObject, win32.UI.Controls.SCROLLBARINFO*psbi);
        /// <inheritdoc cref = "GetComboBoxInfo(win32.UI.WindowsAndMessaging.HWND, win32.UI.Controls.COMBOBOXINFO*)"/>
        internal static unsafe bool GetComboBoxInfo(win32.UI.WindowsAndMessaging.HWND hwndCombo, ref win32.UI.Controls.COMBOBOXINFO pcbi)
        {
            fixed (win32.UI.Controls.COMBOBOXINFO*pcbiLocal = &pcbi)
            {
                bool __result = User32.GetComboBoxInfo(hwndCombo, pcbiLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about the specified combo box.</summary>
        /// <param name = "hwndCombo">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>A handle to the combo box.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcomboboxinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcbi">
        /// <para>Type: <b>PCOMBOBOXINFO</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-comboboxinfo">COMBOBOXINFO</a> structure that receives the information. You must set <b>COMBOBOXINFO.cbSize</b> before calling this function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcomboboxinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcomboboxinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetComboBoxInfo(win32.UI.WindowsAndMessaging.HWND hwndCombo, win32.UI.Controls.COMBOBOXINFO*pcbi);
        /// <summary>Retrieves the number of items per column in a specified list box.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>A handle to the list box whose number of items per column is to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getlistboxinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">DWORD</a></b></para>
        /// <para>The return value is the number of items per column.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getlistboxinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetListBoxInfo(win32.UI.WindowsAndMessaging.HWND hwnd);
        /// <inheritdoc cref = "GetPointerDevices(uint *, win32.UI.Controls.POINTER_DEVICE_INFO*)"/>
        internal static unsafe bool GetPointerDevices(ref uint deviceCount, win32.UI.Controls.POINTER_DEVICE_INFO*pointerDevices)
        {
            fixed (uint *deviceCountLocal = &deviceCount)
            {
                bool __result = User32.GetPointerDevices(deviceCountLocal, pointerDevices);
                return __result;
            }
        }

        /// <summary>Gets information about the pointer devices attached to the system.</summary>
        /// <param name = "deviceCount">If <i>pointerDevices</i> is NULL, <i>deviceCount</i> returns the total number of attached pointer devices. Otherwise, <i>deviceCount</i> specifies the number of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_device_info">POINTER_DEVICE_INFO</a> structures pointed to by <i>pointerDevices</i>.</param>
        /// <param name = "pointerDevices">Array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_device_info">POINTER_DEVICE_INFO</a> structures for the pointer devices attached to the system. If NULL, the total number of attached pointer devices is returned in <i>deviceCount</i>.</param>
        /// <returns>
        /// <para>If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerdevices">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerDevices(uint *deviceCount, [Optional] win32.UI.Controls.POINTER_DEVICE_INFO*pointerDevices);
        /// <inheritdoc cref = "GetPointerDevice(win32.System.SystemServices.HANDLE, win32.UI.Controls.POINTER_DEVICE_INFO*)"/>
        internal static unsafe bool GetPointerDevice(SafeHandle device, out win32.UI.Controls.POINTER_DEVICE_INFO pointerDevice)
        {
            bool deviceAddRef = false;
            try
            {
                fixed (win32.UI.Controls.POINTER_DEVICE_INFO*pointerDeviceLocal = &pointerDevice)
                {
                    win32.System.SystemServices.HANDLE deviceLocal;
                    if (device is object)
                    {
                        device.DangerousAddRef(ref deviceAddRef);
                        deviceLocal = (win32.System.SystemServices.HANDLE)device.DangerousGetHandle();
                    }
                    else
                        deviceLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = User32.GetPointerDevice(deviceLocal, pointerDeviceLocal);
                    return __result;
                }
            }
            finally
            {
                if (deviceAddRef)
                    device.DangerousRelease();
            }
        }

        /// <summary>Gets information about the pointer device.</summary>
        /// <param name = "device">The handle to the device.</param>
        /// <param name = "pointerDevice">A <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_device_info">POINTER_DEVICE_INFO</a> structure that contains information about the pointer device.</param>
        /// <returns>
        /// <para>If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerdevice">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerDevice(win32.System.SystemServices.HANDLE device, win32.UI.Controls.POINTER_DEVICE_INFO*pointerDevice);
        /// <inheritdoc cref = "GetPointerDeviceProperties(win32.System.SystemServices.HANDLE, uint *, win32.UI.Controls.POINTER_DEVICE_PROPERTY*)"/>
        internal static unsafe bool GetPointerDeviceProperties(SafeHandle device, ref uint propertyCount, win32.UI.Controls.POINTER_DEVICE_PROPERTY*pointerProperties)
        {
            bool deviceAddRef = false;
            try
            {
                fixed (uint *propertyCountLocal = &propertyCount)
                {
                    win32.System.SystemServices.HANDLE deviceLocal;
                    if (device is object)
                    {
                        device.DangerousAddRef(ref deviceAddRef);
                        deviceLocal = (win32.System.SystemServices.HANDLE)device.DangerousGetHandle();
                    }
                    else
                        deviceLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = User32.GetPointerDeviceProperties(deviceLocal, propertyCountLocal, pointerProperties);
                    return __result;
                }
            }
            finally
            {
                if (deviceAddRef)
                    device.DangerousRelease();
            }
        }

        /// <summary>Gets device properties that aren't included in the POINTER_DEVICE_INFO structure.</summary>
        /// <param name = "device">
        /// <para>The pointer device to query properties from.</para>
        /// <para>A call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getpointerdevices">GetPointerDevices</a> function returns this handle in the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_device_info">POINTER_DEVICE_INFO</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerdeviceproperties#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "propertyCount">
        /// <para>The number  of properties.</para>
        /// <para>Returns the count that's written or needed if <i>pointerProperties</i> is NULL.</para>
        /// <para>If this value is less than the number of properties that the pointer device supports and <i>pointerProperties</i> is not NULL, the function returns the actual number of properties in this variable and fails.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerdeviceproperties#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pointerProperties">The array of properties.</param>
        /// <returns>TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function for more information.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerdeviceproperties">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerDeviceProperties(win32.System.SystemServices.HANDLE device, uint *propertyCount, [Optional] win32.UI.Controls.POINTER_DEVICE_PROPERTY*pointerProperties);
        /// <summary>Registers a window to process the WM_POINTERDEVICECHANGE, WM_POINTERDEVICEINRANGE, and WM_POINTERDEVICEOUTOFRANGE pointer device notifications.</summary>
        /// <param name = "window">
        /// <para>The window that receives <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/inputmsg/wm-pointerdevicechange">WM_POINTERDEVICECHANGE</a>, <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/inputmsg/wm-pointerdeviceinrange">WM_POINTERDEVICEINRANGE</a>, and <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/inputmsg/wm-pointerdeviceoutofrange">WM_POINTERDEVICEOUTOFRANGE</a> notifications.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerpointerdevicenotifications#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "notifyRange">
        /// <para>If set to TRUE, process the <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/inputmsg/wm-pointerdeviceinrange">WM_POINTERDEVICEINRANGE</a> and <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/inputmsg/wm-pointerdeviceoutofrange">WM_POINTERDEVICEOUTOFRANGE</a> messages. If set to FALSE, these messages aren't processed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerpointerdevicenotifications#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerpointerdevicenotifications">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool RegisterPointerDeviceNotifications(win32.UI.WindowsAndMessaging.HWND window, bool notifyRange);
        /// <inheritdoc cref = "GetPointerDeviceRects(win32.System.SystemServices.HANDLE, win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool GetPointerDeviceRects(SafeHandle device, out win32.UI.DisplayDevices.RECT pointerDeviceRect, out win32.UI.DisplayDevices.RECT displayRect)
        {
            bool deviceAddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*displayRectLocal = &displayRect)
                {
                    fixed (win32.UI.DisplayDevices.RECT*pointerDeviceRectLocal = &pointerDeviceRect)
                    {
                        win32.System.SystemServices.HANDLE deviceLocal;
                        if (device is object)
                        {
                            device.DangerousAddRef(ref deviceAddRef);
                            deviceLocal = (win32.System.SystemServices.HANDLE)device.DangerousGetHandle();
                        }
                        else
                            deviceLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = User32.GetPointerDeviceRects(deviceLocal, pointerDeviceRectLocal, displayRectLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (deviceAddRef)
                    device.DangerousRelease();
            }
        }

        /// <summary>Gets the x and y range for the pointer device (in himetric) and the x and y range (current resolution) for the display that the pointer device is mapped to.</summary>
        /// <param name = "device">The handle to the pointer device.</param>
        /// <param name = "pointerDeviceRect">The structure for retrieving the device's physical range data.</param>
        /// <param name = "displayRect">The structure for retrieving the display resolution.</param>
        /// <returns>TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function for more information.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerdevicerects">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerDeviceRects(win32.System.SystemServices.HANDLE device, win32.UI.DisplayDevices.RECT*pointerDeviceRect, win32.UI.DisplayDevices.RECT*displayRect);
        /// <inheritdoc cref = "GetPointerDeviceCursors(win32.System.SystemServices.HANDLE, uint *, win32.UI.Controls.POINTER_DEVICE_CURSOR_INFO*)"/>
        internal static unsafe bool GetPointerDeviceCursors(SafeHandle device, ref uint cursorCount, win32.UI.Controls.POINTER_DEVICE_CURSOR_INFO*deviceCursors)
        {
            bool deviceAddRef = false;
            try
            {
                fixed (uint *cursorCountLocal = &cursorCount)
                {
                    win32.System.SystemServices.HANDLE deviceLocal;
                    if (device is object)
                    {
                        device.DangerousAddRef(ref deviceAddRef);
                        deviceLocal = (win32.System.SystemServices.HANDLE)device.DangerousGetHandle();
                    }
                    else
                        deviceLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = User32.GetPointerDeviceCursors(deviceLocal, cursorCountLocal, deviceCursors);
                    return __result;
                }
            }
            finally
            {
                if (deviceAddRef)
                    device.DangerousRelease();
            }
        }

        /// <summary>Gets the cursor IDs that are mapped to the cursors associated with a pointer device.</summary>
        /// <param name = "device">The device handle.</param>
        /// <param name = "cursorCount">The number of cursors associated with the pointer device.</param>
        /// <param name = "deviceCursors">An array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_device_cursor_info">POINTER_DEVICE_CURSOR_INFO</a> structures that contain info about the cursors. If NULL, <i>cursorCount</i> returns the number of cursors associated with the pointer device.</param>
        /// <returns>TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function for more information.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerdevicecursors">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerDeviceCursors(win32.System.SystemServices.HANDLE device, uint *cursorCount, [Optional] win32.UI.Controls.POINTER_DEVICE_CURSOR_INFO*deviceCursors);
        /// <inheritdoc cref = "GetRawPointerDeviceData(uint, uint, uint, win32.UI.Controls.POINTER_DEVICE_PROPERTY*, int *)"/>
        internal static unsafe bool GetRawPointerDeviceData(uint pointerId, uint historyCount, Span<win32.UI.Controls.POINTER_DEVICE_PROPERTY> pProperties, out int pValues)
        {
            fixed (int *pValuesLocal = &pValues)
            {
                fixed (win32.UI.Controls.POINTER_DEVICE_PROPERTY*pPropertiesLocal = pProperties)
                {
                    bool __result = User32.GetRawPointerDeviceData(pointerId, historyCount, (uint)pProperties.Length, pPropertiesLocal, pValuesLocal);
                    return __result;
                }
            }
        }

        /// <summary>Gets the raw input data from the pointer device.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name = "historyCount">The pointer history.</param>
        /// <param name = "propertiesCount">Number of properties to retrieve.</param>
        /// <param name = "pProperties">Array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_device_property">POINTER_DEVICE_PROPERTY</a> structures that contain raw data reported by the device.</param>
        /// <param name = "pValues">The values for <i>pProperties</i>.</param>
        /// <returns>TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function for more information.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawpointerdevicedata">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetRawPointerDeviceData(uint pointerId, uint historyCount, uint propertiesCount, win32.UI.Controls.POINTER_DEVICE_PROPERTY*pProperties, int *pValues);
        /// <inheritdoc cref = "GetCurrentInputMessageSource(win32.UI.Controls.INPUT_MESSAGE_SOURCE*)"/>
        internal static unsafe bool GetCurrentInputMessageSource(out win32.UI.Controls.INPUT_MESSAGE_SOURCE inputMessageSource)
        {
            fixed (win32.UI.Controls.INPUT_MESSAGE_SOURCE*inputMessageSourceLocal = &inputMessageSource)
            {
                bool __result = User32.GetCurrentInputMessageSource(inputMessageSourceLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the source of the input message.</summary>
        /// <param name = "inputMessageSource">
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-input_message_source">INPUT_MESSAGE_SOURCE</a> structure that holds the device type and the ID of the input message source.</para>
        /// <para><div class = "alert"><b>Note</b>  <b>deviceType</b> in <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-input_message_source">INPUT_MESSAGE_SOURCE</a> is set to   <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ne-winuser-input_message_device_type">IMDT_UNAVAILABLE</a> when <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> is used to inject input (system generated or through messages such as <a href = "https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a>). This remains true until  <b>SendMessage</b> returns.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcurrentinputmessagesource#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcurrentinputmessagesource">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCurrentInputMessageSource(win32.UI.Controls.INPUT_MESSAGE_SOURCE*inputMessageSource);
        /// <inheritdoc cref = "GetCIMSSM(win32.UI.Controls.INPUT_MESSAGE_SOURCE*)"/>
        internal static unsafe bool GetCIMSSM(out win32.UI.Controls.INPUT_MESSAGE_SOURCE inputMessageSource)
        {
            fixed (win32.UI.Controls.INPUT_MESSAGE_SOURCE*inputMessageSourceLocal = &inputMessageSource)
            {
                bool __result = User32.GetCIMSSM(inputMessageSourceLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the source of the input message (GetCurrentInputMessageSourceInSendMessage).</summary>
        /// <param name = "inputMessageSource">The <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-input_message_source">INPUT_MESSAGE_SOURCE</a> structure that holds the device type and the ID of the input message source.</param>
        /// <returns>
        /// <para>If this function succeeds, it returns TRUE. Otherwise, it returns ERROR_INVALID_PARAMETER.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcimssm">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool GetCIMSSM(win32.UI.Controls.INPUT_MESSAGE_SOURCE*inputMessageSource);
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetDialogControlDpiChangeBehavior(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.HiDpi.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, win32.UI.HiDpi.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values);
        /// <summary>Retrieves and per-monitor DPI scaling behavior overrides of a child window in a dialog.</summary>
        /// <param name = "hWnd">The handle for the window to examine.</param>
        /// <returns>The flags set on the given window. If passed an invalid handle, this function will return zero, and set its <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">last error</a> to <b>ERROR_INVALID_HANDLE</b>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdialogcontroldpichangebehavior">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.HiDpi.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Dialogs in Per-Monitor v2 contexts are automatically DPI scaled. This method lets you customize their DPI change behavior.</summary>
        /// <param name = "hDlg">A handle for the dialog whose behavior will be modified.</param>
        /// <param name = "mask">A mask specifying the subset of flags to be changed.</param>
        /// <param name = "values">The desired value to be set for the specified subset of flags.</param>
        /// <returns>
        /// <para>This function returns TRUE if the operation was successful, and FALSE otherwise. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>Possible errors are <b>ERROR_INVALID_HANDLE</b> if passed an invalid dialog HWND, and <b>ERROR_ACCESS_DENIED</b> if the dialog belongs to another process.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdialogdpichangebehavior">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetDialogDpiChangeBehavior(win32.UI.WindowsAndMessaging.HWND hDlg, win32.UI.HiDpi.DIALOG_DPI_CHANGE_BEHAVIORS mask, win32.UI.HiDpi.DIALOG_DPI_CHANGE_BEHAVIORS values);
        /// <summary>Returns the flags that might have been set on a given dialog by an earlier call to SetDialogDpiChangeBehavior.</summary>
        /// <param name = "hDlg">The handle for the dialog to examine.</param>
        /// <returns>The flags set on the given dialog. If passed an invalid handle, this function will return zero, and set its <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">last error</a> to <b>ERROR_INVALID_HANDLE</b>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdialogdpichangebehavior">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.HiDpi.DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(win32.UI.WindowsAndMessaging.HWND hDlg);
        /// <summary>Retrieves the specified system metric or system configuration setting taking into account a provided DPI.</summary>
        /// <param name = "nIndex">The system metric or configuration setting to be retrieved. See <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> for the possible values.</param>
        /// <param name = "dpi">The DPI to use for scaling the metric.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getsystemmetricsfordpi">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetSystemMetricsForDpi(int nIndex, uint dpi);
        /// <inheritdoc cref = "AdjustWindowRectExForDpi(win32.UI.DisplayDevices.RECT*, uint, bool, uint, uint)"/>
        internal static unsafe bool AdjustWindowRectExForDpi(ref win32.UI.DisplayDevices.RECT lpRect, uint dwStyle, bool bMenu, uint dwExStyle, uint dpi)
        {
            fixed (win32.UI.DisplayDevices.RECT*lpRectLocal = &lpRect)
            {
                bool __result = User32.AdjustWindowRectExForDpi(lpRectLocal, dwStyle, bMenu, dwExStyle, dpi);
                return __result;
            }
        }

        /// <summary>Calculates the required size of the window rectangle, based on the desired size of the client rectangle and the provided DPI.</summary>
        /// <param name = "lpRect">A pointer to a <b>RECT</b> structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area.</param>
        /// <param name = "dwStyle">The <a href = "https://docs.microsoft.com/windows/desktop/winmsg/window-styles">Window Style</a> of the window whose required size is to be calculated. Note that you cannot specify the <b>WS_OVERLAPPED</b> style.</param>
        /// <param name = "bMenu">Indicates whether the window has a menu.</param>
        /// <param name = "dwExStyle">The <a href = "https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">Extended Window Style</a> of the window whose required size is to be calculated.</param>
        /// <param name = "dpi">The DPI to use for scaling.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-adjustwindowrectexfordpi">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool AdjustWindowRectExForDpi(win32.UI.DisplayDevices.RECT*lpRect, uint dwStyle, bool bMenu, uint dwExStyle, uint dpi);
        /// <inheritdoc cref = "LogicalToPhysicalPointForPerMonitorDPI(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.POINT*)"/>
        internal static unsafe bool LogicalToPhysicalPointForPerMonitorDPI(win32.UI.WindowsAndMessaging.HWND hWnd, ref win32.UI.DisplayDevices.POINT lpPoint)
        {
            fixed (win32.UI.DisplayDevices.POINT*lpPointLocal = &lpPoint)
            {
                bool __result = User32.LogicalToPhysicalPointForPerMonitorDPI(hWnd, lpPointLocal);
                return __result;
            }
        }

        /// <summary>Converts a point in a window from logical coordinates into physical coordinates, regardless of the dots per inch (dpi) awareness of the caller.</summary>
        /// <param name = "hWnd">A handle to the window whose transform is used for the conversion.</param>
        /// <param name = "lpPoint">A pointer to a <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that specifies the logical coordinates to be converted. The new physical coordinates are copied into this structure if the function succeeds.</param>
        /// <returns>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-logicaltophysicalpointforpermonitordpi">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool LogicalToPhysicalPointForPerMonitorDPI(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.POINT*lpPoint);
        /// <inheritdoc cref = "PhysicalToLogicalPointForPerMonitorDPI(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.POINT*)"/>
        internal static unsafe bool PhysicalToLogicalPointForPerMonitorDPI(win32.UI.WindowsAndMessaging.HWND hWnd, ref win32.UI.DisplayDevices.POINT lpPoint)
        {
            fixed (win32.UI.DisplayDevices.POINT*lpPointLocal = &lpPoint)
            {
                bool __result = User32.PhysicalToLogicalPointForPerMonitorDPI(hWnd, lpPointLocal);
                return __result;
            }
        }

        /// <summary>Converts a point in a window from physical coordinates into logical coordinates, regardless of the dots per inch (dpi) awareness of the caller.</summary>
        /// <param name = "hWnd">A handle to the window whose transform is used for the conversion.</param>
        /// <param name = "lpPoint">A pointer to a <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that specifies the physical/screen coordinates to be converted. The new logical coordinates are copied into this structure if the function succeeds.</param>
        /// <returns>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-physicaltologicalpointforpermonitordpi">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool PhysicalToLogicalPointForPerMonitorDPI(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.POINT*lpPoint);
        /// <summary>Retrieves the value of one of the system-wide parameters, taking into account the provided DPI value.</summary>
        /// <param name = "uiAction">The system-wide parameter to be retrieved. This function is only intended for use with <b>SPI_GETICONTITLELOGFONT</b>, <b>SPI_GETICONMETRICS</b>, or <b>SPI_GETNONCLIENTMETRICS</b>. See <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa">SystemParametersInfo</a> for more information on these values.</param>
        /// <param name = "uiParam">A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify zero for this parameter.</param>
        /// <param name = "pvParam">A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify <b>NULL</b> for this parameter. For information on the <b>PVOID</b> datatype, see <a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">Windows Data Types</a>.</param>
        /// <param name = "fWinIni">Has no effect for with this API. This parameter only has an effect if you're setting parameter.</param>
        /// <param name = "dpi">The DPI to use for scaling the metric.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-systemparametersinfofordpi">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SystemParametersInfoForDpi(uint uiAction, uint uiParam, [Optional] void *pvParam, uint fWinIni, uint dpi);
        /// <summary>Set the DPI awareness for the current thread to the provided value.</summary>
        /// <param name = "dpiContext">The new <a href = "https://docs.microsoft.com/windows/desktop/hidpi/dpi-awareness-context">DPI_AWARENESS_CONTEXT</a> for the current thread. This context includes the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ne-windef-dpi_awareness">DPI_AWARENESS</a> value.</param>
        /// <returns>The old <a href = "/windows/desktop/hidpi/dpi-awareness-context">DPI_AWARENESS_CONTEXT</a> for the thread. If the <i>dpiContext</i> is invalid, the thread will not be updated and the return value will be <b>NULL</b>. You can use this value to restore the old <b>DPI_AWARENESS_CONTEXT</b> after overriding it with a predefined value.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setthreaddpiawarenesscontext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.DPI_AWARENESS_CONTEXT SetThreadDpiAwarenessContext(win32.System.SystemServices.DPI_AWARENESS_CONTEXT dpiContext);
        /// <summary>Gets the DPI_AWARENESS_CONTEXT for the current thread.</summary>
        /// <returns>The current <a href = "/windows/desktop/hidpi/dpi-awareness-context">DPI_AWARENESS_CONTEXT</a> for the thread.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getthreaddpiawarenesscontext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.DPI_AWARENESS_CONTEXT GetThreadDpiAwarenessContext();
        /// <summary>Returns the DPI_AWARENESS_CONTEXT associated with a window.</summary>
        /// <param name = "hwnd">The window to query.</param>
        /// <returns>The <a href = "/windows/desktop/hidpi/dpi-awareness-context">DPI_AWARENESS_CONTEXT</a> for the provided window. If the window is not valid, the return value is <b>NULL</b>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowdpiawarenesscontext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.DPI_AWARENESS_CONTEXT GetWindowDpiAwarenessContext(win32.UI.WindowsAndMessaging.HWND hwnd);
        /// <summary>Retrieves the DPI_AWARENESS value from a DPI_AWARENESS_CONTEXT.</summary>
        /// <param name = "value">The <b>DPI_AWARENESS_CONTEXT</b> you want to examine.</param>
        /// <returns>The <a href = "/windows/desktop/api/windef/ne-windef-dpi_awareness">DPI_AWARENESS</a>. If the provided <i>value</i> is <b>null</b> or invalid, this method will return <b>DPI_AWARENESS_INVALID</b>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getawarenessfromdpiawarenesscontext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.HiDpi.DPI_AWARENESS GetAwarenessFromDpiAwarenessContext(win32.System.SystemServices.DPI_AWARENESS_CONTEXT value);
        /// <summary>Retrieves the DPI from a given DPI_AWARENESS_CONTEXT handle. This enables you to determine the DPI of a thread without needed to examine a window created within that thread.</summary>
        /// <param name = "value">The <b>DPI_AWARENESS_CONTEXT</b> handle to examine.</param>
        /// <returns>The DPI value associated with the <b>DPI_AWARENESS_CONTEXT</b> handle.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdpifromdpiawarenesscontext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetDpiFromDpiAwarenessContext(win32.System.SystemServices.DPI_AWARENESS_CONTEXT value);
        /// <summary>Determines whether two DPI_AWARENESS_CONTEXT values are identical.</summary>
        /// <param name = "dpiContextA">The first value to compare.</param>
        /// <param name = "dpiContextB">The second value to compare.</param>
        /// <returns>Returns <b>TRUE</b> if the values are equal, otherwise <b>FALSE</b>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-aredpiawarenesscontextsequal">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool AreDpiAwarenessContextsEqual(win32.System.SystemServices.DPI_AWARENESS_CONTEXT dpiContextA, win32.System.SystemServices.DPI_AWARENESS_CONTEXT dpiContextB);
        /// <summary>Determines if a specified DPI_AWARENESS_CONTEXT is valid and supported by the current system.</summary>
        /// <param name = "value">The context that you want to determine if it is supported.</param>
        /// <returns><b>TRUE</b> if the provided context is supported, otherwise <b>FALSE</b>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isvaliddpiawarenesscontext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsValidDpiAwarenessContext(win32.System.SystemServices.DPI_AWARENESS_CONTEXT value);
        /// <summary>Returns the dots per inch (dpi) value for the associated window.</summary>
        /// <param name = "hwnd">The window you want to get information about.</param>
        /// <returns>The DPI for the window which depends on the <a href = "/windows/desktop/api/windef/ne-windef-dpi_awareness">DPI_AWARENESS</a> of the window. See the Remarks for more information. An invalid <i>hwnd</i> value will result in a return value of 0.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdpiforwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetDpiForWindow(win32.UI.WindowsAndMessaging.HWND hwnd);
        /// <summary>Returns the system DPI.</summary>
        /// <returns>The system DPI value.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdpiforsystem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetDpiForSystem();
        /// <inheritdoc cref = "GetSystemDpiForProcess(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint GetSystemDpiForProcess(SafeHandle hProcess)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = User32.GetSystemDpiForProcess(hProcessLocal);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the system DPI associated with a given process. This is useful for avoiding compatibility issues that arise from sharing DPI-sensitive information between multiple system-aware processes with different system DPI values.</summary>
        /// <param name = "hProcess">The handle for the process to examine. If this value is null, this API behaves identically to <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getdpiforsystem">GetDpiForSystem</a>.</param>
        /// <returns>The process's system DPI value.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getsystemdpiforprocess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetSystemDpiForProcess(win32.System.SystemServices.HANDLE hProcess);
        /// <summary>In high-DPI displays, enables automatic display scaling of the non-client area portions of the specified top-level window. Must be called during the initialization of that window.</summary>
        /// <param name = "hwnd">The window that should have automatic scaling enabled.</param>
        /// <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enablenonclientdpiscaling">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool EnableNonClientDpiScaling(win32.UI.WindowsAndMessaging.HWND hwnd);
        /// <summary>Sets the current process to a specified dots per inch (dpi) awareness context. The DPI awareness contexts are from the DPI_AWARENESS_CONTEXT value.</summary>
        /// <param name = "value">A <a href = "https://docs.microsoft.com/windows/desktop/hidpi/dpi-awareness-context">DPI_AWARENESS_CONTEXT</a> handle to set.</param>
        /// <returns>
        /// <para>This function returns TRUE if the operation was successful, and FALSE otherwise. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>Possible errors are <b>ERROR_INVALID_PARAMETER</b> for an invalid input, and <b>ERROR_ACCESS_DENIED</b> if the default API awareness mode for the process has already been set (via a previous API call or within the application manifest).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setprocessdpiawarenesscontext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetProcessDpiAwarenessContext(win32.System.SystemServices.DPI_AWARENESS_CONTEXT value);
        /// <summary>Sets the thread's DPI_HOSTING_BEHAVIOR. This behavior allows windows created in the thread to host child windows with a different DPI_AWARENESS_CONTEXT.</summary>
        /// <param name = "value">The new <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ne-windef-dpi_hosting_behavior">DPI_HOSTING_BEHAVIOR</a> value for the current thread.</param>
        /// <returns>The previous <a href = "/windows/desktop/api/windef/ne-windef-dpi_hosting_behavior">DPI_HOSTING_BEHAVIOR</a> for the thread. If the hosting behavior passed in is invalid, the thread will not be updated and the return value will be <b>DPI_HOSTING_BEHAVIOR_INVALID</b>. You can use this value to restore the old <b>DPI_HOSTING_BEHAVIOR</b> after overriding it with a predefined value.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setthreaddpihostingbehavior">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.HiDpi.DPI_HOSTING_BEHAVIOR SetThreadDpiHostingBehavior(win32.UI.HiDpi.DPI_HOSTING_BEHAVIOR value);
        /// <summary>Retrieves the DPI_HOSTING_BEHAVIOR from the current thread.</summary>
        /// <returns>The <a href = "/windows/desktop/api/windef/ne-windef-dpi_hosting_behavior">DPI_HOSTING_BEHAVIOR</a> of the current thread.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getthreaddpihostingbehavior">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.HiDpi.DPI_HOSTING_BEHAVIOR GetThreadDpiHostingBehavior();
        /// <summary>Returns the DPI_HOSTING_BEHAVIOR of the specified window.</summary>
        /// <param name = "hwnd">The handle for the window to examine.</param>
        /// <returns>The <a href = "/windows/desktop/api/windef/ne-windef-dpi_hosting_behavior">DPI_HOSTING_BEHAVIOR</a> of the specified window.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowdpihostingbehavior">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.HiDpi.DPI_HOSTING_BEHAVIOR GetWindowDpiHostingBehavior(win32.UI.WindowsAndMessaging.HWND hwnd);
        /// <summary>Associates a Help context identifier with the specified window.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns nonzero if successful, or zero otherwise.</para>
        /// <para>To retrieve extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowcontexthelpid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetWindowContextHelpId(win32.UI.WindowsAndMessaging.HWND param0, uint param1);
        /// <summary>Retrieves the Help context identifier, if any, associated with the specified window.</summary>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>Returns the Help context identifier if the window has one, or zero otherwise.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowcontexthelpid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetWindowContextHelpId(win32.UI.WindowsAndMessaging.HWND param0);
        /// <inheritdoc cref = "SetMenuContextHelpId(win32.UI.MenusAndResources.HMENU, uint)"/>
        internal static unsafe bool SetMenuContextHelpId(SafeHandle param0, uint param1)
        {
            bool param0AddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU param0Local;
                if (param0 is object)
                {
                    param0.DangerousAddRef(ref param0AddRef);
                    param0Local = (win32.UI.MenusAndResources.HMENU)param0.DangerousGetHandle();
                }
                else
                    param0Local = default(win32.UI.MenusAndResources.HMENU);
                bool __result = User32.SetMenuContextHelpId(param0Local, param1);
                return __result;
            }
            finally
            {
                if (param0AddRef)
                    param0.DangerousRelease();
            }
        }

        /// <summary>Associates a Help context identifier with a menu.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns nonzero if successful, or zero otherwise.</para>
        /// <para>To retrieve extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenucontexthelpid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetMenuContextHelpId(win32.UI.MenusAndResources.HMENU param0, uint param1);
        /// <inheritdoc cref = "GetMenuContextHelpId(win32.UI.MenusAndResources.HMENU)"/>
        internal static unsafe uint GetMenuContextHelpId(SafeHandle param0)
        {
            bool param0AddRef = false;
            try
            {
                win32.UI.MenusAndResources.HMENU param0Local;
                if (param0 is object)
                {
                    param0.DangerousAddRef(ref param0AddRef);
                    param0Local = (win32.UI.MenusAndResources.HMENU)param0.DangerousGetHandle();
                }
                else
                    param0Local = default(win32.UI.MenusAndResources.HMENU);
                uint __result = User32.GetMenuContextHelpId(param0Local);
                return __result;
            }
            finally
            {
                if (param0AddRef)
                    param0.DangerousRelease();
            }
        }

        /// <summary>Retrieves the Help context identifier associated with the specified menu.</summary>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>Returns the Help context identifier if the menu has one, or zero otherwise.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenucontexthelpid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetMenuContextHelpId(win32.UI.MenusAndResources.HMENU param0);
        /// <inheritdoc cref = "WinHelp(win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.PCWSTR, uint, nuint)"/>
        internal static unsafe bool WinHelp(win32.UI.WindowsAndMessaging.HWND hWndMain, string lpszHelp, uint uCommand, nuint dwData)
        {
            fixed (char *lpszHelpLocal = lpszHelp)
            {
                bool __result = User32.WinHelp(hWndMain, lpszHelpLocal, uCommand, dwData);
                return __result;
            }
        }

        /// <summary>Launches Windows Help (Winhelp.exe) and passes additional data that indicates the nature of the help requested by the application.</summary>
        /// <param name = "hWndMain">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window requesting help. The <b>WinHelp</b> function uses this handle to keep track of which applications have requested help. If the <i>uCommand</i> parameter specifies <b>HELP_CONTEXTMENU</b> or <b>HELP_WM_HELP</b>, <i>hWndMain</i> identifies the control requesting help.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-winhelpw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszHelp">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The address of a null-terminated string containing the path, if necessary, and the name of the Help file that <b>WinHelp</b> is to display.</para>
        /// <para>The file name can be followed by an angle bracket (&gt;) and the name of a secondary window if the topic is to be displayed in a secondary window rather than in the primary window. You must define the name of the secondary window in the [WINDOWS] section of the Help project (.hpj) file.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-winhelpw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uCommand">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The type of help requested. For a list of possible values and how they affect the value to place in the <i>dwData</i> parameter, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-winhelpw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwData">
        /// <para>Type: <b>ULONG_PTR</b></para>
        /// <para>Additional data. The value used depends on the value of the <i>uCommand</i> parameter. For a list of possible <i>dwData</i> values, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-winhelpw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns nonzero if successful, or zero otherwise. To retrieve extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-winhelpw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "WinHelpW", SetLastError = true)]
        internal static extern bool WinHelp(win32.UI.WindowsAndMessaging.HWND hWndMain, win32.System.SystemServices.PCWSTR lpszHelp, uint uCommand, nuint dwData);
        /// <summary>Allows the caller to register a target window to which all pointer input of the specified type is redirected.</summary>
        /// <param name = "hwnd">
        /// <para>The window to register as a global redirection target.</para>
        /// <para>Redirection can cause the foreground window to lose activation (focus). To avoid this, ensure the window is a message-only window or has the <a href = "https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">WS_EX_NOACTIVATE</a> style set.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerpointerinputtarget#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pointerType">Type of pointer input to be redirected to the specified  window. This is any valid and supported value from the <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ne-winuser-tagpointer_input_type">POINTER_INPUT_TYPE</a> enumeration. Note that the generic <b>PT_POINTER</b> type and the <b>PT_MOUSE</b> type are not valid in this parameter.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerpointerinputtarget">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool RegisterPointerInputTarget(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.WindowsAndMessaging.POINTER_INPUT_TYPE pointerType);
        /// <summary>Allows the caller to unregister a target window to which all pointer input of the specified type is redirected.</summary>
        /// <param name = "hwnd">Window to be un-registered as a global redirection target on its desktop.</param>
        /// <param name = "pointerType">Type of pointer input to no longer be redirected to the specified window. This is any valid and supported value from the <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ne-winuser-tagpointer_input_type">POINTER_INPUT_TYPE </a> enumeration. Note that the generic <b>PT_POINTER</b> type and the<b> PT_MOUSE</b> type are not valid in this parameter.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterpointerinputtarget">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool UnregisterPointerInputTarget(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.WindowsAndMessaging.POINTER_INPUT_TYPE pointerType);
        /// <summary>RegisterPointerInputTargetEx may be altered or unavailable. Instead, use RegisterPointerInputTarget.</summary>
        /// <param name = "hwnd">Not supported.</param>
        /// <param name = "pointerType">Not supported.</param>
        /// <param name = "fObserve">Not supported.</param>
        /// <returns>Not supported.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerpointerinputtargetex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool RegisterPointerInputTargetEx(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.WindowsAndMessaging.POINTER_INPUT_TYPE pointerType, bool fObserve);
        /// <summary>UnregisterPointerInputTargetEx may be altered or unavailable. Instead, use UnregisterPointerInputTarget.</summary>
        /// <param name = "hwnd">Not supported.</param>
        /// <param name = "pointerType">Not supported.</param>
        /// <returns>Not supported.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterpointerinputtargetex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool UnregisterPointerInputTargetEx(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.WindowsAndMessaging.POINTER_INPUT_TYPE pointerType);
        /// <summary>Signals the system that a predefined event occurred. If any client applications have registered a hook function for the event, the system calls the client's hook function.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b></para>
        /// <para>Handle to the window that contains the object that generated the event.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-notifywinevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "idObject">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LONG</a></b></para>
        /// <para>Identifies the object that generated the event. This value is either one of the predefined <a href = "https://docs.microsoft.com/windows/desktop/WinAuto/object-identifiers">object identifiers</a> or a custom object ID value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-notifywinevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "idChild">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LONG</a></b></para>
        /// <para>Identifies whether the event was generated by an object or by a child element of the object. If this value is CHILDID_SELF, the event was generated by the object itself. If not CHILDID_SELF, this value is the child ID of the element that generated the event.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-notifywinevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>Servers call this function to notify the system that an event has occurred. Microsoft Active Accessibility checks to see if any client applications have set hook procedures for the event and, if so, calls the appropriate hook procedures.</para>
        /// <para>If no hook procedures are registered for the event, the performance penalty for calling this function is minor.</para>
        /// <para>Servers call <b>NotifyWinEvent</b> to announce the event to the system after the event has occurred; they must never notify the system of an event before the event has occurred.</para>
        /// <para>When the client's hook procedure is called, it receives a number of parameters that describe the event and the object that generated the event. The hook procedure uses the <a href = "https://docs.microsoft.com/windows/desktop/api/oleacc/nf-oleacc-accessibleobjectfromevent">AccessibleObjectFromEvent</a> function to retrieve a pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/oleacc/nn-oleacc-iaccessible">IAccessible</a> interface of the object that generated the event.</para>
        /// <para>Servers may receive a <a href = "https://docs.microsoft.com/windows/desktop/WinAuto/wm-getobject">WM_GETOBJECT</a> message immediately after calling this function. This can happen if there are any in-context clients that call <a href = "https://docs.microsoft.com/windows/desktop/api/oleacc/nf-oleacc-accessibleobjectfromevent">AccessibleObjectFromEvent</a> in the event callback.</para>
        /// <para>When servers call this function, they must be ready to handle <a href = "https://docs.microsoft.com/windows/desktop/WinAuto/wm-getobject">WM_GETOBJECT</a>, return an <a href = "https://docs.microsoft.com/windows/desktop/api/oleacc/nn-oleacc-iaccessible">IAccessible</a> interface pointer, and handle any of the <b>IAccessible</b> methods.</para>
        /// <para><b>Note to Server Developers:  </b>When you call <b>NotifyWinEvent</b>, if any clients are listening for that event in-context, their event handlers, which typically send <a href = "https://docs.microsoft.com/windows/desktop/WinAuto/wm-getobject">WM_GETOBJECT</a> and call <a href = "https://docs.microsoft.com/windows/desktop/api/oleacc/nn-oleacc-iaccessible">IAccessible</a> methods, will execute before <b>NotifyWinEvent</b> returns. When you call <b>NotifyWinEvent</b>, you should be prepared to handle these calls, if they occur. If you need to do extra setup to allow for this, you should do so before you call <b>NotifyWinEvent</b>, not after.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-notifywinevent#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern void NotifyWinEvent(uint @event, win32.UI.WindowsAndMessaging.HWND hwnd, int idObject, int idChild);
        /// <summary>Removes an event hook function created by a previous call to SetWinEventHook.</summary>
        /// <param name = "hWinEventHook">
        /// <para>Type: <b>HWINEVENTHOOK</b></para>
        /// <para>Handle to the event hook returned in the previous call to <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwineventhook">SetWinEventHook</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unhookwinevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If successful, returns <b>TRUE</b>; otherwise, returns <b>FALSE</b>.</para>
        /// <para>Three common errors cause this function to fail:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unhookwinevent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.BOOL UnhookWinEvent(win32.UI.Accessibility.HWINEVENTHOOK hWinEventHook);
        /// <inheritdoc cref = "SetWinEventHook(uint, uint, win32.System.SystemServices.HINSTANCE, delegate *unmanaged[Stdcall]{win32.UI.Accessibility.HWINEVENTHOOK, uint, win32.UI.WindowsAndMessaging.HWND, int, int, uint, uint, void}, uint, uint, uint)"/>
        internal static unsafe User32.UnhookWinEventSafeHandle SetWinEventHook(uint eventMin, uint eventMax, SafeHandle hmodWinEventProc, delegate *unmanaged[Stdcall]<win32.UI.Accessibility.HWINEVENTHOOK, uint, win32.UI.WindowsAndMessaging.HWND, int, int, uint, uint, void>pfnWinEventProc, uint idProcess, uint idThread, uint dwFlags)
        {
            bool hmodWinEventProcAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hmodWinEventProcLocal;
                if (hmodWinEventProc is object)
                {
                    hmodWinEventProc.DangerousAddRef(ref hmodWinEventProcAddRef);
                    hmodWinEventProcLocal = (win32.System.SystemServices.HINSTANCE)hmodWinEventProc.DangerousGetHandle();
                }
                else
                    hmodWinEventProcLocal = default(win32.System.SystemServices.HINSTANCE);
                win32.UI.Accessibility.HWINEVENTHOOK __result = User32.SetWinEventHook(eventMin, eventMax, hmodWinEventProcLocal, pfnWinEventProc, idProcess, idThread, dwFlags);
                return new User32.UnhookWinEventSafeHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hmodWinEventProcAddRef)
                    hmodWinEventProc.DangerousRelease();
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "User32.UnhookWinEvent"/>.
        /// </summary>
        internal class UnhookWinEventSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal UnhookWinEventSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal UnhookWinEventSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => User32.UnhookWinEvent((win32.UI.Accessibility.HWINEVENTHOOK)this.handle);
        }

        /// <summary>Sets an event hook function for a range of events.</summary>
        /// <param name = "eventMin">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
        /// <para>Specifies the <a href = "https://docs.microsoft.com/windows/desktop/WinAuto/event-constants">event constant</a> for the lowest event value in the range of events that are handled by the hook function. This parameter can be set to <b>EVENT_MIN</b> to indicate the lowest possible event value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "eventMax">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
        /// <para>Specifies the event constant for the highest event value in the range of events that are handled by the hook function. This parameter can be  set to <a href = "https://docs.microsoft.com/windows/desktop/WinAuto/event-constants">EVENT_MAX</a> to indicate the highest possible event value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hmodWinEventProc">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HMODULE</a></b></para>
        /// <para>Handle to the DLL that contains the hook function at <i>lpfnWinEventProc</i>, if the WINEVENT_INCONTEXT flag is specified in the <i>dwFlags</i> parameter. If the hook function is not located in a DLL, or if the WINEVENT_OUTOFCONTEXT flag is specified, this parameter is <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pfnWinEventProc">
        /// <para>Type: <b>WINEVENTPROC</b></para>
        /// <para>Pointer to the event hook function. For more information about this function, see <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-wineventproc">WinEventProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "idProcess">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">DWORD</a></b></para>
        /// <para>Specifies the ID of the process from which the hook function receives events. Specify zero (0) to receive events from all processes on the current desktop.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "idThread">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">DWORD</a></b></para>
        /// <para>Specifies the ID of the thread from which the hook function receives events. If this parameter is zero, the hook function is associated with all existing threads on the current desktop.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
        /// <para>Flag values that specify the location of the hook function and of the events to be skipped. The following flags are valid:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWINEVENTHOOK</b></para>
        /// <para>If successful, returns an <a href = "/windows/desktop/WinAuto/hwineventhook">HWINEVENTHOOK</a> value that identifies this event hook instance. Applications save this return value to use it with the <a href = "/windows/desktop/api/winuser/nf-winuser-unhookwinevent">UnhookWinEvent</a> function.</para>
        /// <para>If unsuccessful, returns zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwineventhook">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe win32.UI.Accessibility.HWINEVENTHOOK SetWinEventHook(uint eventMin, uint eventMax, win32.System.SystemServices.HINSTANCE hmodWinEventProc, delegate *unmanaged[Stdcall]<win32.UI.Accessibility.HWINEVENTHOOK, uint, win32.UI.WindowsAndMessaging.HWND, int, int, uint, uint, void>pfnWinEventProc, uint idProcess, uint idThread, uint dwFlags);
        /// <summary>Determines whether there is an installed WinEvent hook that might be notified of a specified event.</summary>
        /// <returns>
        /// <para>Type: <b><a href = "/windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
        /// <para>If there is a hook to be notified of the specified event, the return value is <b>TRUE</b>.</para>
        /// <para>If there are no hooks to be notified of the specified event, the return value is <b>FALSE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iswineventhookinstalled">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsWinEventHookInstalled(uint @event);
        /// <inheritdoc cref = "GetDisplayConfigBufferSizes(uint, uint *, uint *)"/>
        internal static unsafe int GetDisplayConfigBufferSizes(uint flags, out uint numPathArrayElements, out uint numModeInfoArrayElements)
        {
            fixed (uint *numModeInfoArrayElementsLocal = &numModeInfoArrayElements)
            {
                fixed (uint *numPathArrayElementsLocal = &numPathArrayElements)
                {
                    int __result = User32.GetDisplayConfigBufferSizes(flags, numPathArrayElementsLocal, numModeInfoArrayElementsLocal);
                    return __result;
                }
            }
        }

        /// <summary>The GetDisplayConfigBufferSizes function retrieves the size of the buffers that are required to call the QueryDisplayConfig function.</summary>
        /// <param name = "flags"></param>
        /// <param name = "numPathArrayElements">Pointer to a variable that receives the number of elements in the path information table. The <i>pNumPathArrayElements</i> parameter value is then used by a subsequent call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-querydisplayconfig">QueryDisplayConfig</a> function. This parameter cannot be <b>NULL</b>.</param>
        /// <param name = "numModeInfoArrayElements">Pointer to a variable that receives the number of elements in the mode information table. The <i>pNumModeInfoArrayElements</i> parameter value is then used by a subsequent call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-querydisplayconfig">QueryDisplayConfig</a> function. This parameter cannot be <b>NULL</b>.</param>
        /// <returns>
        /// <para>The function returns one of the following return codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdisplayconfigbuffersizes">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int GetDisplayConfigBufferSizes(uint flags, uint *numPathArrayElements, uint *numModeInfoArrayElements);
        /// <inheritdoc cref = "SetDisplayConfig(uint, win32.UI.DisplayDevices.DISPLAYCONFIG_PATH_INFO*, uint, win32.UI.DisplayDevices.DISPLAYCONFIG_MODE_INFO*, uint)"/>
        internal static unsafe int SetDisplayConfig(Span<win32.UI.DisplayDevices.DISPLAYCONFIG_PATH_INFO> pathArray, Span<win32.UI.DisplayDevices.DISPLAYCONFIG_MODE_INFO> modeInfoArray, uint flags)
        {
            fixed (win32.UI.DisplayDevices.DISPLAYCONFIG_MODE_INFO*modeInfoArrayLocal = modeInfoArray)
            {
                fixed (win32.UI.DisplayDevices.DISPLAYCONFIG_PATH_INFO*pathArrayLocal = pathArray)
                {
                    int __result = User32.SetDisplayConfig((uint)pathArray.Length, pathArrayLocal, (uint)modeInfoArray.Length, modeInfoArrayLocal, flags);
                    return __result;
                }
            }
        }

        /// <summary>The SetDisplayConfig function modifies the display topology, source, and target modes by exclusively enabling the specified paths in the current session.</summary>
        /// <param name = "numPathArrayElements">Number of elements in <i>pathArray</i>.</param>
        /// <param name = "pathArray">Array of all display paths that are to be set. Only the paths within this array that have the DISPLAYCONFIG_PATH_ACTIVE flag set in the <b>flags</b> member of <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-displayconfig_path_info">DISPLAYCONFIG_PATH_INFO</a> are set. This parameter can be <b>NULL</b>. The order in which active paths appear in this array determines the path priority. For more information about path priority order, see <a href = "https://docs.microsoft.com/windows-hardware/drivers/display/path-priority-order">Path Priority Order</a>.</param>
        /// <param name = "numModeInfoArrayElements">Number of elements in <i>modeInfoArray</i>.</param>
        /// <param name = "modeInfoArray">Array of display source and target mode information (<a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-displayconfig_mode_info">DISPLAYCONFIG_MODE_INFO</a>) that is referenced by the <b>modeInfoIdx</b> member of DISPLAYCONFIG_PATH_SOURCE_INFO and DISPLAYCONFIG_PATH_TARGET_INFO element of path information from <i>pathArray</i>. This parameter can be <b>NULL</b>.</param>
        /// <param name = "flags"></param>
        /// <returns>
        /// <para>The function returns one of the following return codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdisplayconfig">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int SetDisplayConfig(uint numPathArrayElements, [Optional] win32.UI.DisplayDevices.DISPLAYCONFIG_PATH_INFO*pathArray, uint numModeInfoArrayElements, [Optional] win32.UI.DisplayDevices.DISPLAYCONFIG_MODE_INFO*modeInfoArray, uint flags);
        /// <inheritdoc cref = "QueryDisplayConfig(uint, uint *, win32.UI.DisplayDevices.DISPLAYCONFIG_PATH_INFO*, uint *, win32.UI.DisplayDevices.DISPLAYCONFIG_MODE_INFO*, win32.UI.DisplayDevices.DISPLAYCONFIG_TOPOLOGY_ID*)"/>
        internal static unsafe int QueryDisplayConfig(uint flags, ref uint numPathArrayElements, win32.UI.DisplayDevices.DISPLAYCONFIG_PATH_INFO*pathArray, ref uint numModeInfoArrayElements, win32.UI.DisplayDevices.DISPLAYCONFIG_MODE_INFO*modeInfoArray, out win32.UI.DisplayDevices.DISPLAYCONFIG_TOPOLOGY_ID currentTopologyId)
        {
            fixed (win32.UI.DisplayDevices.DISPLAYCONFIG_TOPOLOGY_ID*currentTopologyIdLocal = &currentTopologyId)
            {
                fixed (uint *numModeInfoArrayElementsLocal = &numModeInfoArrayElements)
                {
                    fixed (uint *numPathArrayElementsLocal = &numPathArrayElements)
                    {
                        int __result = User32.QueryDisplayConfig(flags, numPathArrayElementsLocal, pathArray, numModeInfoArrayElementsLocal, modeInfoArray, currentTopologyIdLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>The QueryDisplayConfig function retrieves information about all possible display paths for all display devices, or views, in the current setting.</summary>
        /// <param name = "flags"></param>
        /// <param name = "numPathArrayElements">Pointer to a variable that contains the number of elements in <i>pPathInfoArray</i>. This parameter cannot be <b>NULL</b>. If <b>QueryDisplayConfig</b> returns ERROR_SUCCESS, <i>pNumPathInfoElements</i> is updated with the number of valid entries in <i>pPathInfoArray</i>.</param>
        /// <param name = "pathArray">Pointer to a variable that contains an array of <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-displayconfig_path_info">DISPLAYCONFIG_PATH_INFO</a> elements. Each element in <i>pPathInfoArray</i> describes a single path from a source to a target. The source and target mode information indexes are only valid in combination with the <i>pmodeInfoArray</i> tables that are returned for the API at the same time. This parameter cannot be <b>NULL</b>. The <i>pPathInfoArray</i> is always returned in path priority order. For more information about path priority order, see <a href = "https://docs.microsoft.com/windows-hardware/drivers/display/path-priority-order">Path Priority Order</a>.</param>
        /// <param name = "numModeInfoArrayElements">Pointer to a variable that specifies the number in element of the mode information table. This parameter cannot be <b>NULL</b>. If <b>QueryDisplayConfig</b> returns ERROR_SUCCESS, <i>pNumModeInfoArrayElements</i> is updated with the number of valid entries in <i>pModeInfoArray</i>.</param>
        /// <param name = "modeInfoArray">Pointer to a variable that contains an array of <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-displayconfig_mode_info">DISPLAYCONFIG_MODE_INFO</a> elements. This parameter cannot be <b>NULL</b>.</param>
        /// <param name = "currentTopologyId">
        /// <para>Pointer to a variable that receives the identifier of the currently active topology in the CCD database. For a list of possible values, see the <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ne-wingdi-displayconfig_topology_id">DISPLAYCONFIG_TOPOLOGY_ID</a> enumerated type.</para>
        /// <para>The <i>pCurrentTopologyId</i> parameter is only set when the <i>Flags</i> parameter value is QDC_DATABASE_CURRENT.</para>
        /// <para>If the <i>Flags</i> parameter value is set to QDC_DATABASE_CURRENT, the <i>pCurrentTopologyId</i> parameter must not be <b>NULL</b>. If the <i>Flags</i> parameter value is not set to QDC_DATABASE_CURRENT, the <i>pCurrentTopologyId</i> parameter value must be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-querydisplayconfig#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>The function returns one of the following return codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-querydisplayconfig">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int QueryDisplayConfig(uint flags, uint *numPathArrayElements, win32.UI.DisplayDevices.DISPLAYCONFIG_PATH_INFO*pathArray, uint *numModeInfoArrayElements, win32.UI.DisplayDevices.DISPLAYCONFIG_MODE_INFO*modeInfoArray, win32.UI.DisplayDevices.DISPLAYCONFIG_TOPOLOGY_ID*currentTopologyId);
        /// <inheritdoc cref = "DisplayConfigGetDeviceInfo(win32.UI.DisplayDevices.DISPLAYCONFIG_DEVICE_INFO_HEADER*)"/>
        internal static unsafe int DisplayConfigGetDeviceInfo(ref win32.UI.DisplayDevices.DISPLAYCONFIG_DEVICE_INFO_HEADER requestPacket)
        {
            fixed (win32.UI.DisplayDevices.DISPLAYCONFIG_DEVICE_INFO_HEADER*requestPacketLocal = &requestPacket)
            {
                int __result = User32.DisplayConfigGetDeviceInfo(requestPacketLocal);
                return __result;
            }
        }

        /// <summary>The DisplayConfigGetDeviceInfo function retrieves display configuration information about the device.</summary>
        /// <param name = "requestPacket">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-displayconfig_device_info_header">DISPLAYCONFIG_DEVICE_INFO_HEADER</a> structure. This structure contains information about the request, which includes the packet type in the <b>type</b> member. The type and size of additional data that <b>DisplayConfigGetDeviceInfo</b> returns after the header structure depend on the packet type.</param>
        /// <returns>
        /// <para>The function returns one of the following return codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-displayconfiggetdeviceinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int DisplayConfigGetDeviceInfo(win32.UI.DisplayDevices.DISPLAYCONFIG_DEVICE_INFO_HEADER*requestPacket);
        /// <inheritdoc cref = "DisplayConfigSetDeviceInfo(win32.UI.DisplayDevices.DISPLAYCONFIG_DEVICE_INFO_HEADER*)"/>
        internal static unsafe int DisplayConfigSetDeviceInfo(in win32.UI.DisplayDevices.DISPLAYCONFIG_DEVICE_INFO_HEADER setPacket)
        {
            fixed (win32.UI.DisplayDevices.DISPLAYCONFIG_DEVICE_INFO_HEADER*setPacketLocal = &setPacket)
            {
                int __result = User32.DisplayConfigSetDeviceInfo(setPacketLocal);
                return __result;
            }
        }

        /// <summary>The DisplayConfigSetDeviceInfo function sets the properties of a target.</summary>
        /// <param name = "setPacket">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-displayconfig_device_info_header">DISPLAYCONFIG_DEVICE_INFO_HEADER</a> structure that contains information to set for the device. The type and size of additional data that <b>DisplayConfigSetDeviceInfo</b> uses for the configuration comes after the header structure. This additional data depends on the packet type, as specified by the <b>type</b> member of DISPLAYCONFIG_DEVICE_INFO_HEADER. For example, if the caller wants to change the boot persistence, that caller allocates and fills a <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-displayconfig_set_target_persistence">DISPLAYCONFIG_SET_TARGET_PERSISTENCE</a> structure and passes a pointer to this structure in <i>setPacket</i>. Note that the first member of the DISPLAYCONFIG_SET_TARGET_PERSISTENCE structure is the DISPLAYCONFIG_DEVICE_INFO_HEADER.</param>
        /// <returns>
        /// <para>The function returns one of the following return codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-displayconfigsetdeviceinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int DisplayConfigSetDeviceInfo(win32.UI.DisplayDevices.DISPLAYCONFIG_DEVICE_INFO_HEADER*setPacket);
        /// <inheritdoc cref = "LoadKeyboardLayout(win32.System.SystemServices.PCWSTR, win32.UI.KeyboardAndMouseInput.ACTIVATE_KEYBOARD_LAYOUT_FLAGS)"/>
        internal static unsafe win32.UI.TextServices.HKL LoadKeyboardLayout(string pwszKLID, win32.UI.KeyboardAndMouseInput.ACTIVATE_KEYBOARD_LAYOUT_FLAGS Flags)
        {
            fixed (char *pwszKLIDLocal = pwszKLID)
            {
                win32.UI.TextServices.HKL __result = User32.LoadKeyboardLayout(pwszKLIDLocal, Flags);
                return __result;
            }
        }

        /// <summary>Loads a new input locale identifier (formerly called the keyboard layout) into the system.</summary>
        /// <param name = "pwszKLID">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The name of the input locale identifier to load. This name is a string composed of the hexadecimal value of the <a href = "https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">Language Identifier</a> (low word) and a device identifier (high word). For example, U.S. English has a language identifier of 0x0409, so the primary U.S. English layout is named "00000409". Variants of U.S. English layout (such as the Dvorak layout) are named "00010409", "00020409", and so on.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadkeyboardlayoutw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>HKL</b></para>
        /// <para>If the function succeeds, the return value is the input locale identifier corresponding to the name specified in <i>pwszKLID</i>. If no matching locale is available, the return value is the default language of the system.</para>
        /// <para>If the function fails, the return value is NULL. This can occur if the layout library is loaded from the application directory.</para>
        /// <para>To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadkeyboardlayoutw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "LoadKeyboardLayoutW", SetLastError = true)]
        internal static extern win32.UI.TextServices.HKL LoadKeyboardLayout(win32.System.SystemServices.PCWSTR pwszKLID, win32.UI.KeyboardAndMouseInput.ACTIVATE_KEYBOARD_LAYOUT_FLAGS Flags);
        /// <summary>Sets the input locale identifier (formerly called the keyboard layout handle) for the calling thread or the current process. The input locale identifier specifies a locale as well as the physical layout of the keyboard.</summary>
        /// <param name = "hkl">
        /// <para>Type: <b>HKL</b></para>
        /// <para>Input locale identifier to be activated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-activatekeyboardlayout#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags">Type: <b>UINT</b></param>
        /// <returns>
        /// <para>Type: <b>HKL</b></para>
        /// <para>The return value is of type <b>HKL</b>. If the function succeeds, the return value is the previous input locale identifier. Otherwise, it is zero.</para>
        /// <para>To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-activatekeyboardlayout">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.TextServices.HKL ActivateKeyboardLayout(win32.UI.TextServices.HKL hkl, win32.UI.KeyboardAndMouseInput.ACTIVATE_KEYBOARD_LAYOUT_FLAGS Flags);
        /// <inheritdoc cref = "ToUnicodeEx(uint, uint, byte *, win32.System.SystemServices.PWSTR, int, uint, win32.UI.TextServices.HKL)"/>
        internal static unsafe int ToUnicodeEx(uint wVirtKey, uint wScanCode, ReadOnlySpan<byte> lpKeyState, win32.System.SystemServices.PWSTR pwszBuff, int cchBuff, uint wFlags, win32.UI.TextServices.HKL dwhkl)
        {
            fixed (byte *lpKeyStateLocal = lpKeyState)
            {
                if (lpKeyState.Length < 256)
                    throw new ArgumentException();
                int __result = User32.ToUnicodeEx(wVirtKey, wScanCode, lpKeyStateLocal, pwszBuff, cchBuff, wFlags, dwhkl);
                return __result;
            }
        }

        /// <summary>Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters.</summary>
        /// <param name = "wVirtKey">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The virtual-key code to be translated. See <a href = "https://docs.microsoft.com/windows/desktop/inputdev/virtual-key-codes">Virtual-Key Codes</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicodeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wScanCode">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicodeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpKeyState">
        /// <para>Type: <b>const BYTE*</b></para>
        /// <para>A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the high-order bit of a byte is set, the key is down.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicodeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pwszBuff">
        /// <para>Type: <b>LPWSTR</b></para>
        /// <para>The buffer that receives the translated Unicode character or characters. However, this buffer may be returned without being null-terminated even though the variable name suggests that it is null-terminated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicodeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchBuff">
        /// <para>Type: <b>int</b></para>
        /// <para>The size, in characters, of the buffer pointed to by the <i>pwszBuff</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicodeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wFlags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The behavior of the function.</para>
        /// <para>If bit 0 is set, a menu is active.</para>
        /// <para>If bit 2 is set, keyboard state is not changed (Windows 10, version 1607 and newer)</para>
        /// <para>All other bits (through 31) are reserved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicodeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwhkl">
        /// <para>Type: <b>HKL</b></para>
        /// <para>The input locale identifier used to translate the specified code. This parameter can be any input locale identifier previously returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadkeyboardlayouta">LoadKeyboardLayout</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicodeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>The function returns one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicodeex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int ToUnicodeEx(uint wVirtKey, uint wScanCode, byte *lpKeyState, win32.System.SystemServices.PWSTR pwszBuff, int cchBuff, uint wFlags, win32.UI.TextServices.HKL dwhkl);
        /// <summary>Unloads an input locale identifier (formerly called a keyboard layout).</summary>
        /// <param name = "hkl">
        /// <para>Type: <b>HKL</b></para>
        /// <para>The input locale identifier to be unloaded.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unloadkeyboardlayout#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. The function can fail for the following reasons:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unloadkeyboardlayout">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool UnloadKeyboardLayout(win32.UI.TextServices.HKL hkl);
        /// <summary>Retrieves the name of the active input locale identifier (formerly called the keyboard layout) for the system.</summary>
        /// <param name = "pwszKLID">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The buffer (of at least <b>KL_NAMELENGTH</b> characters in length) that receives the name of the input locale identifier, including the terminating null character. This will be a copy of the string provided to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadkeyboardlayouta">LoadKeyboardLayout</a> function, unless layout substitution took place.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeyboardlayoutnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeyboardlayoutnamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetKeyboardLayoutNameW", SetLastError = true)]
        internal static extern bool GetKeyboardLayoutName(win32.System.SystemServices.PWSTR pwszKLID);
        /// <inheritdoc cref = "GetKeyboardLayoutList(int, win32.UI.TextServices.HKL*)"/>
        internal static unsafe int GetKeyboardLayoutList(Span<win32.UI.TextServices.HKL> lpList)
        {
            fixed (win32.UI.TextServices.HKL*lpListLocal = lpList)
            {
                int __result = User32.GetKeyboardLayoutList(lpList.Length, lpListLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the input locale identifiers (formerly called keyboard layout handles) corresponding to the current set of input locales in the system. The function copies the identifiers to the specified buffer.</summary>
        /// <param name = "nBuff">
        /// <para>Type: <b>int</b></para>
        /// <para>The maximum number of handles that the buffer can hold.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeyboardlayoutlist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpList">
        /// <para>Type: <b>HKL*</b></para>
        /// <para>A pointer to the buffer that receives the array of input locale identifiers.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeyboardlayoutlist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the number of input locale identifiers copied to the buffer or, if <i>nBuff</i> is zero, the return value is the size, in array elements, of the buffer needed to receive all current input locale identifiers.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeyboardlayoutlist">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int GetKeyboardLayoutList(int nBuff, [Optional] win32.UI.TextServices.HKL*lpList);
        /// <summary>Retrieves the active input locale identifier (formerly called the keyboard layout).</summary>
        /// <param name = "idThread">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The identifier of the thread to query, or 0 for the current thread.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeyboardlayout#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HKL</b></para>
        /// <para>The return value is the input locale identifier for the thread. The low word contains a <a href = "/windows/desktop/Intl/language-identifiers">Language Identifier</a> for the input language and the high word contains a device handle to the physical layout of the keyboard.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeyboardlayout">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.TextServices.HKL GetKeyboardLayout(uint idThread);
        /// <inheritdoc cref = "GetMouseMovePointsEx(uint, win32.UI.KeyboardAndMouseInput.MOUSEMOVEPOINT*, win32.UI.KeyboardAndMouseInput.MOUSEMOVEPOINT*, int, win32.UI.KeyboardAndMouseInput.GET_MOUSE_MOVE_POINTS_EX_RESOLUTION)"/>
        internal static unsafe int GetMouseMovePointsEx(uint cbSize, in win32.UI.KeyboardAndMouseInput.MOUSEMOVEPOINT lppt, Span<win32.UI.KeyboardAndMouseInput.MOUSEMOVEPOINT> lpptBuf, win32.UI.KeyboardAndMouseInput.GET_MOUSE_MOVE_POINTS_EX_RESOLUTION resolution)
        {
            fixed (win32.UI.KeyboardAndMouseInput.MOUSEMOVEPOINT*lpptBufLocal = lpptBuf)
            {
                fixed (win32.UI.KeyboardAndMouseInput.MOUSEMOVEPOINT*lpptLocal = &lppt)
                {
                    int __result = User32.GetMouseMovePointsEx(cbSize, lpptLocal, lpptBufLocal, lpptBuf.Length, resolution);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves a history of up to 64 previous coordinates of the mouse or pen.</summary>
        /// <param name = "cbSize">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The size, in bytes, of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mousemovepoint">MOUSEMOVEPOINT</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmousemovepointsex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lppt">
        /// <para>Type: <b>LPMOUSEMOVEPOINT</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mousemovepoint">MOUSEMOVEPOINT</a> structure containing valid mouse coordinates (in screen coordinates). It may also contain a time stamp.</para>
        /// <para>The <b>GetMouseMovePointsEx</b> function searches for the point in the mouse coordinates history. If the function finds the point, it returns the last <i>nBufPoints</i> prior to and including the supplied point.</para>
        /// <para>If your application supplies a time stamp, the <b>GetMouseMovePointsEx</b> function will use it to differentiate between two equal points that were recorded at different times.</para>
        /// <para>An application should call this function using the mouse coordinates received from the <a href = "https://docs.microsoft.com/windows/desktop/inputdev/wm-mousemove">WM_MOUSEMOVE</a> message and convert them to screen coordinates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmousemovepointsex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpptBuf">
        /// <para>Type: <b>LPMOUSEMOVEPOINT</b></para>
        /// <para>A pointer to a buffer that will receive the points. It should be at least <i>cbSize</i>* <i>nBufPoints</i> in size.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmousemovepointsex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBufPoints">
        /// <para>Type: <b>int</b></para>
        /// <para>The number of points to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmousemovepointsex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "resolution">Type: <b>DWORD</b></param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value is the number of points in the buffer. Otherwise, the function returns –1. For extended error information, your application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmousemovepointsex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int GetMouseMovePointsEx(uint cbSize, win32.UI.KeyboardAndMouseInput.MOUSEMOVEPOINT*lppt, win32.UI.KeyboardAndMouseInput.MOUSEMOVEPOINT*lpptBuf, int nBufPoints, win32.UI.KeyboardAndMouseInput.GET_MOUSE_MOVE_POINTS_EX_RESOLUTION resolution);
        /// <inheritdoc cref = "TrackMouseEvent(win32.UI.KeyboardAndMouseInput.TRACKMOUSEEVENT*)"/>
        internal static unsafe bool TrackMouseEvent(ref win32.UI.KeyboardAndMouseInput.TRACKMOUSEEVENT lpEventTrack)
        {
            fixed (win32.UI.KeyboardAndMouseInput.TRACKMOUSEEVENT*lpEventTrackLocal = &lpEventTrack)
            {
                bool __result = User32.TrackMouseEvent(lpEventTrackLocal);
                return __result;
            }
        }

        /// <summary>Posts messages when the mouse pointer leaves a window or hovers over a window for a specified amount of time.</summary>
        /// <param name = "lpEventTrack">
        /// <para>Type: <b>LPTRACKMOUSEEVENT</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-trackmouseevent">TRACKMOUSEEVENT</a> structure that contains tracking information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackmouseevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero .</para>
        /// <para>If the function fails, return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-trackmouseevent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool TrackMouseEvent(win32.UI.KeyboardAndMouseInput.TRACKMOUSEEVENT*lpEventTrack);
        /// <summary>Defines a system-wide hot key.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that will receive <a href = "https://docs.microsoft.com/windows/desktop/inputdev/wm-hotkey">WM_HOTKEY</a> messages generated by the hot key. If this parameter is <b>NULL</b>, <b>WM_HOTKEY</b> messages are posted to the message queue of the calling thread and must be processed in the message loop.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "id">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the hot key.  If the <i>hWnd</i> parameter is NULL, then the hot key is associated with the current thread rather than with a particular window. If a hot key already exists with the same <i>hWnd</i> and <i>id</i> parameters, see Remarks for the action taken.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fsModifiers">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The keys that must be pressed in combination with the key specified by the</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "vk">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The virtual-key code of the hot key. See <a href = "https://docs.microsoft.com/windows/desktop/inputdev/virtual-key-codes">Virtual Key Codes</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerhotkey">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool RegisterHotKey(win32.UI.WindowsAndMessaging.HWND hWnd, int id, win32.UI.KeyboardAndMouseInput.HOT_KEY_MODIFIERS fsModifiers, uint vk);
        /// <summary>Frees a hot key previously registered by the calling thread.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window associated with the hot key to be freed. This parameter should be <b>NULL</b> if the hot key is not associated with a window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "id">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the hot key to be freed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterhotkey">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool UnregisterHotKey(win32.UI.WindowsAndMessaging.HWND hWnd, int id);
        /// <summary>Reverses or restores the meaning of the left and right mouse buttons.</summary>
        /// <param name = "fSwap">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If this parameter is <b>TRUE</b>, the left button generates right-button messages and the right button generates left-button messages. If this parameter is <b>FALSE</b>, the buttons are restored to their original meanings.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-swapmousebutton#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the meaning of the mouse buttons was reversed previously, before the function was called, the return value is nonzero.</para>
        /// <para>If the meaning of the mouse buttons was not reversed, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-swapmousebutton">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool SwapMouseButton(bool fSwap);
        /// <summary>Retrieves the current double-click time for the mouse.</summary>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>The return value specifies the current double-click time, in milliseconds. The maximum return value is 5000 milliseconds.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdoubleclicktime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetDoubleClickTime();
        /// <summary>Sets the double-click time for the mouse.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setdoubleclicktime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetDoubleClickTime(uint param0);
        /// <summary>Sets the keyboard focus to the specified window. The window must be attached to the calling thread's message queue.</summary>
        /// <param name = "hWnd">
        /// <para>Type: **HWND**</para>
        /// <para>A handle to the window that will receive the keyboard input. If this parameter is NULL, keystrokes are ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setfocus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: **HWND**</para>
        /// <para>If the function succeeds, the return value is the handle to the window that previously had the keyboard focus. If the *hWnd* parameter is invalid or the window is not attached to the calling thread's message queue, the return value is NULL. To get extended error information, call [GetLastError function](../errhandlingapi/nf-errhandlingapi-getlasterror.md).</para>
        /// <para>Extended error ERROR_INVALID_PARAMETER (0x57) means that window is in disabled state.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setfocus">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND SetFocus(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Retrieves the window handle to the active window attached to the calling thread's message queue.</summary>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is the handle to the active window attached to the calling thread's message queue. Otherwise, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getactivewindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetActiveWindow();
        /// <summary>Retrieves the handle to the window that has the keyboard focus, if the window is attached to the calling thread's message queue.</summary>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is the handle to the window with the keyboard focus. If the calling thread's message queue does not have an associated window with the keyboard focus, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getfocus">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetFocus();
        /// <summary>Retrieves the current code page.</summary>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>The return value is an OEM code-page identifier, or it is the default identifier if the registry value is not readable. For a list of OEM code-page identifiers, see <a href = "/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkbcodepage">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetKBCodePage();
        /// <summary>Retrieves the status of the specified virtual key. The status specifies whether the key is up, down, or toggled (on, off�alternating each time the key is pressed).</summary>
        /// <param name = "nVirtKey">
        /// <para>Type: <b>int</b></para>
        /// <para>A virtual key. If the desired virtual key is a letter or digit (A through Z, a through z, or 0 through 9), <i>nVirtKey</i> must be set to the ASCII value of that character. For other keys, it must be a virtual-key code.</para>
        /// <para>If a non-English keyboard layout is used, virtual keys with values in the range ASCII A through Z and 0 through 9 are used to specify most of the character keys. For example, for the German keyboard layout, the virtual key of value ASCII O (0x4F) refers to the "o" key, whereas VK_OEM_1 refers to the "o with umlaut" key.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeystate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>SHORT</b></para>
        /// <para>The return value specifies the status of the specified virtual key, as follows:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeystate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern short GetKeyState(int nVirtKey);
        /// <summary>Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.</summary>
        /// <param name = "vKey">
        /// <para>Type: <b>int</b></para>
        /// <para>The virtual-key code. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/inputdev/virtual-key-codes">Virtual Key Codes</a>.</para>
        /// <para>You can use left- and right-distinguishing constants to specify certain keys. See the Remarks section for further information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getasynckeystate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>SHORT</b></para>
        /// <para>If the function succeeds, the return value specifies whether the key was pressed since the last call to <b>GetAsyncKeyState</b>, and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to <b>GetAsyncKeyState</b>. However, you should not rely on this last behavior; for more information, see the Remarks.</para>
        /// <para>The return value is zero for the following cases:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getasynckeystate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern short GetAsyncKeyState(int vKey);
        /// <inheritdoc cref = "GetKeyboardState(byte *)"/>
        internal static unsafe bool GetKeyboardState(Span<byte> lpKeyState)
        {
            fixed (byte *lpKeyStateLocal = lpKeyState)
            {
                if (lpKeyState.Length < 256)
                    throw new ArgumentException();
                bool __result = User32.GetKeyboardState(lpKeyStateLocal);
                return __result;
            }
        }

        /// <summary>Copies the status of the 256 virtual keys to the specified buffer.</summary>
        /// <param name = "lpKeyState">
        /// <para>Type: <b>PBYTE</b></para>
        /// <para>The 256-byte array that receives the status data for each virtual key.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeyboardstate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeyboardstate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetKeyboardState(byte *lpKeyState);
        /// <inheritdoc cref = "SetKeyboardState(byte *)"/>
        internal static unsafe bool SetKeyboardState(Span<byte> lpKeyState)
        {
            fixed (byte *lpKeyStateLocal = lpKeyState)
            {
                if (lpKeyState.Length < 256)
                    throw new ArgumentException();
                bool __result = User32.SetKeyboardState(lpKeyStateLocal);
                return __result;
            }
        }

        /// <summary>Copies an array of keyboard key states into the calling thread's keyboard input-state table. This is the same table accessed by the GetKeyboardState and GetKeyState functions. Changes made to this table do not affect keyboard input to any other thread.</summary>
        /// <param name = "lpKeyState">
        /// <para>Type: <b>LPBYTE</b></para>
        /// <para>A pointer to a 256-byte array that contains keyboard key states.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setkeyboardstate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setkeyboardstate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetKeyboardState(byte *lpKeyState);
        /// <summary>Retrieves a string that represents the name of a key.</summary>
        /// <param name = "lParam">
        /// <para>Type: <b>LONG</b></para>
        /// <para>The second parameter of the keyboard message (such as <a href = "https://docs.microsoft.com/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a>) to be processed. The function interprets the following bit positions in the <i>lParam</i>.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeynametextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The buffer that will receive the key name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeynametextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchSize">
        /// <para>Type: <b>int</b></para>
        /// <para>The maximum length, in characters, of the key name, including the terminating null character. (This parameter should be equal to the size of the buffer pointed to by the <i>lpString</i> parameter.)</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeynametextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, a null-terminated string is copied into the specified buffer, and the return value is the length of the string, in characters, not counting the terminating null character.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeynametextw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetKeyNameTextW", SetLastError = true)]
        internal static extern int GetKeyNameText(int lParam, win32.System.SystemServices.PWSTR lpString, int cchSize);
        /// <summary>Retrieves information about the current keyboard.</summary>
        /// <param name = "nTypeFlag">Type: <b>int</b></param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the function succeeds, the return value specifies the requested information.</para>
        /// <para>If the function fails and <i>nTypeFlag</i> is not 1, the return value is 0; 0 is a valid return value when <i>nTypeFlag</i> is 1 (keyboard subtype). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getkeyboardtype">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetKeyboardType(int nTypeFlag);
        /// <inheritdoc cref = "ToAscii(uint, uint, byte *, ushort *, uint)"/>
        internal static unsafe int ToAscii(uint uVirtKey, uint uScanCode, ReadOnlySpan<byte> lpKeyState, out ushort lpChar, uint uFlags)
        {
            fixed (ushort *lpCharLocal = &lpChar)
            {
                fixed (byte *lpKeyStateLocal = lpKeyState)
                {
                    if (lpKeyState.Length < 256)
                        throw new ArgumentException();
                    int __result = User32.ToAscii(uVirtKey, uScanCode, lpKeyStateLocal, lpCharLocal, uFlags);
                    return __result;
                }
            }
        }

        /// <summary>Translates the specified virtual-key code and keyboard state to the corresponding character or characters.</summary>
        /// <param name = "uVirtKey">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The virtual-key code to be translated. See <a href = "https://docs.microsoft.com/windows/desktop/inputdev/virtual-key-codes">Virtual-Key Codes</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toascii#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uScanCode">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up (not pressed).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toascii#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpKeyState">
        /// <para>Type: <b>const BYTE*</b></para>
        /// <para>A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the high-order bit of a byte is set, the key is down (pressed).</para>
        /// <para>The low bit, if set, indicates that the key is toggled on. In this function, only the toggle bit of the CAPS LOCK key is relevant. The toggle state of the NUM LOCK and SCROLL LOCK keys is ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toascii#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpChar">
        /// <para>Type: <b>LPWORD</b></para>
        /// <para>The buffer that receives the translated character or characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toascii#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>This parameter must be 1 if a menu is active, or 0 otherwise.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toascii#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the specified key is a dead key, the return value is negative. Otherwise, it is one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toascii">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int ToAscii(uint uVirtKey, uint uScanCode, [Optional] byte *lpKeyState, ushort *lpChar, uint uFlags);
        /// <inheritdoc cref = "ToAsciiEx(uint, uint, byte *, ushort *, uint, win32.UI.TextServices.HKL)"/>
        internal static unsafe int ToAsciiEx(uint uVirtKey, uint uScanCode, ReadOnlySpan<byte> lpKeyState, out ushort lpChar, uint uFlags, win32.UI.TextServices.HKL dwhkl)
        {
            fixed (ushort *lpCharLocal = &lpChar)
            {
                fixed (byte *lpKeyStateLocal = lpKeyState)
                {
                    if (lpKeyState.Length < 256)
                        throw new ArgumentException();
                    int __result = User32.ToAsciiEx(uVirtKey, uScanCode, lpKeyStateLocal, lpCharLocal, uFlags, dwhkl);
                    return __result;
                }
            }
        }

        /// <summary>Translates the specified virtual-key code and keyboard state to the corresponding character or characters. The function translates the code using the input language and physical keyboard layout identified by the input locale identifier.</summary>
        /// <param name = "uVirtKey">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The virtual-key code to be translated. See <a href = "https://docs.microsoft.com/windows/desktop/inputdev/virtual-key-codes">Virtual-Key Codes</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toasciiex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uScanCode">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up (not pressed).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toasciiex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpKeyState">
        /// <para>Type: <b>const BYTE*</b></para>
        /// <para>A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the high-order bit of a byte is set, the key is down (pressed).</para>
        /// <para>The low bit, if set, indicates that the key is toggled on. In this function, only the toggle bit of the CAPS LOCK key is relevant. The toggle state of the NUM LOCK and SCOLL LOCK keys is ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toasciiex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpChar">
        /// <para>Type: <b>LPWORD</b></para>
        /// <para>A pointer to the buffer that receives the translated character or characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toasciiex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uFlags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>This parameter must be 1 if a menu is active, zero otherwise.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toasciiex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwhkl">
        /// <para>Type: <b>HKL</b></para>
        /// <para>Input locale identifier to use to translate the code. This parameter can be any input locale identifier previously returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadkeyboardlayouta">LoadKeyboardLayout</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toasciiex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the specified key is a dead key, the return value is negative. Otherwise, it is one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-toasciiex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int ToAsciiEx(uint uVirtKey, uint uScanCode, [Optional] byte *lpKeyState, ushort *lpChar, uint uFlags, win32.UI.TextServices.HKL dwhkl);
        /// <inheritdoc cref = "ToUnicode(uint, uint, byte *, win32.System.SystemServices.PWSTR, int, uint)"/>
        internal static unsafe int ToUnicode(uint wVirtKey, uint wScanCode, ReadOnlySpan<byte> lpKeyState, win32.System.SystemServices.PWSTR pwszBuff, int cchBuff, uint wFlags)
        {
            fixed (byte *lpKeyStateLocal = lpKeyState)
            {
                if (lpKeyState.Length < 256)
                    throw new ArgumentException();
                int __result = User32.ToUnicode(wVirtKey, wScanCode, lpKeyStateLocal, pwszBuff, cchBuff, wFlags);
                return __result;
            }
        }

        /// <summary>Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters.</summary>
        /// <param name = "wVirtKey">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The virtual-key code to be translated. See <a href = "https://docs.microsoft.com/windows/desktop/inputdev/virtual-key-codes">Virtual-Key Codes</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wScanCode">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpKeyState">
        /// <para>Type: <b>const BYTE*</b></para>
        /// <para>A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the high-order bit of a byte is set, the key is down.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pwszBuff">
        /// <para>Type: <b>LPWSTR</b></para>
        /// <para>The buffer that receives the translated Unicode character or characters. However, this buffer may be returned without being null-terminated even though the variable name suggests that it is null-terminated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchBuff">
        /// <para>Type: <b>int</b></para>
        /// <para>The size, in characters, of the buffer pointed to by the <i>pwszBuff</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wFlags">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The behavior of the function.</para>
        /// <para>If bit 0 is set, a menu is active.</para>
        /// <para>If bit 2 is set, keyboard state is not changed (Windows 10, version 1607 and newer)</para>
        /// <para>All other bits (through 31) are reserved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>The function returns one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tounicode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int ToUnicode(uint wVirtKey, uint wScanCode, [Optional] byte *lpKeyState, win32.System.SystemServices.PWSTR pwszBuff, int cchBuff, uint wFlags);
        /// <summary>Maps OEMASCII codes 0 through 0x0FF into the OEM scan codes and shift states. The function provides information that allows a program to send OEM text to another program by simulating keyboard input.</summary>
        /// <param name = "wOemChar">
        /// <para>Type: <b>WORD</b></para>
        /// <para>The ASCII value of the OEM character.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-oemkeyscan#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The low-order word of the return value contains the scan code of the OEM character, and the high-order word contains the shift state, which can be a combination of the following bits.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-oemkeyscan">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint OemKeyScan(ushort wOemChar);
        /// <summary>Translates a character to the corresponding virtual-key code and shift state for the current keyboard.</summary>
        /// <param name = "ch">
        /// <para>Type: <b>TCHAR</b></para>
        /// <para>The character to be translated into a virtual-key code.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-vkkeyscanw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>SHORT</b></para>
        /// <para>If the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains the shift state, which can be a combination of the following flag bits.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-vkkeyscanw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "VkKeyScanW")]
        internal static extern short VkKeyScan(char ch);
        /// <summary>Translates a character to the corresponding virtual-key code and shift state. The function translates the character using the input language and physical keyboard layout identified by the input locale identifier.</summary>
        /// <param name = "ch">
        /// <para>Type: <b>TCHAR</b></para>
        /// <para>The character to be translated into a virtual-key code.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-vkkeyscanexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwhkl">
        /// <para>Type: <b>HKL</b></para>
        /// <para>Input locale identifier used to translate the character. This parameter can be any input locale identifier previously returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadkeyboardlayouta">LoadKeyboardLayout</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-vkkeyscanexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>SHORT</b></para>
        /// <para>If the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains the shift state, which can be a combination of the following flag bits.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-vkkeyscanexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "VkKeyScanExW")]
        internal static extern short VkKeyScanEx(char ch, win32.UI.TextServices.HKL dwhkl);
        /// <summary>Synthesizes a keystroke.</summary>
        /// <param name = "bVk">
        /// <para>Type: <b>BYTE</b></para>
        /// <para>A virtual-key code. The code must be a value in the range 1 to 254. For a complete list, see <a href = "https://docs.microsoft.com/windows/desktop/inputdev/virtual-key-codes">Virtual Key Codes</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-keybd_event#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bScan">
        /// <para>Type: <b>BYTE</b></para>
        /// <para>A hardware scan code for the key.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-keybd_event#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Type: <b>DWORD</b></param>
        /// <param name = "dwExtraInfo">
        /// <para>Type: <b>ULONG_PTR</b></para>
        /// <para>An additional value associated with the key stroke.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-keybd_event#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>An application can simulate a press of the PRINTSCRN key in order to obtain a screen snapshot and save it to the clipboard. To do this, call <b>keybd_event</b> with the <i>bVk</i> parameter set to <b>VK_SNAPSHOT</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-keybd_event#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern void keybd_event(byte bVk, byte bScan, win32.UI.KeyboardAndMouseInput.KEYBD_EVENT_FLAGS dwFlags, nuint dwExtraInfo);
        /// <summary>The mouse_event function synthesizes mouse motion and button clicks.</summary>
        /// <param name = "dwFlags">Type: <b>DWORD</b></param>
        /// <param name = "dx">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The mouse's absolute position along the x-axis or its amount of motion since the last mouse event was generated, depending on the setting of <b>MOUSEEVENTF_ABSOLUTE</b>. Absolute data is specified as the mouse's actual x-coordinate; relative data is specified as the number of mickeys moved. A <i>mickey</i> is the amount that a mouse has to move for it to report that it has moved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mouse_event#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dy">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The mouse's absolute position along the y-axis or its amount of motion since the last mouse event was generated, depending on the setting of <b>MOUSEEVENTF_ABSOLUTE</b>. Absolute data is specified as the mouse's actual y-coordinate; relative data is specified as the number of mickeys moved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mouse_event#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwData">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>If <i>dwFlags</i> contains <b>MOUSEEVENTF_WHEEL</b>, then <i>dwData</i> specifies the amount of wheel movement. A positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel was rotated backward, toward the user. One wheel click is defined as <b>WHEEL_DELTA</b>, which is 120.</para>
        /// <para>If <i>dwFlags</i> contains <b>MOUSEEVENTF_HWHEEL</b>, then <i>dwData</i> specifies the amount of wheel movement. A positive value indicates that the wheel was tilted to the right; a negative value indicates that the wheel was tilted to the left.</para>
        /// <para>If <i>dwFlags</i> contains <b>MOUSEEVENTF_XDOWN</b> or <b>MOUSEEVENTF_XUP</b>, then <i>dwData</i> specifies which X buttons were pressed or released. This value may be any combination of the following flags.</para>
        /// <para>If <i>dwFlags</i> is not <b>MOUSEEVENTF_WHEEL</b>, <b>MOUSEEVENTF_XDOWN</b>, or <b>MOUSEEVENTF_XUP</b>, then <i>dwData</i> should be zero.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mouse_event#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwExtraInfo">
        /// <para>Type: <b>ULONG_PTR</b></para>
        /// <para>An additional value associated with the mouse event. An application calls <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessageextrainfo">GetMessageExtraInfo</a> to obtain this extra information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mouse_event#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>If the mouse has moved, indicated by <b>MOUSEEVENTF_MOVE</b> being set, <i>dx</i> and <i>dy</i> hold information about that motion. The information is specified as absolute or relative integer values.</para>
        /// <para>If <b>MOUSEEVENTF_ABSOLUTE</b> value is specified, <i>dx</i> and <i>dy</i> contain normalized absolute coordinates between 0 and 65,535. The event procedure maps these coordinates onto the display surface. Coordinate (0,0) maps onto the upper-left corner of the display surface, (65535,65535) maps onto the lower-right corner.</para>
        /// <para>If the <b>MOUSEEVENTF_ABSOLUTE</b> value is not specified, <i>dx</i> and <i>dy</i> specify relative motions from when the last mouse event was generated (the last reported position). Positive values mean the mouse moved right (or down); negative values mean the mouse moved left (or up).</para>
        /// <para>Relative mouse motion is subject to the settings for mouse speed and acceleration level. An end user sets these values using the Mouse application in Control Panel. An application obtains and sets these values with the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa">SystemParametersInfo</a> function.</para>
        /// <para>The system applies two tests to the specified relative mouse motion when applying acceleration. If the specified distance along either the x or y axis is greater than the first mouse threshold value, and the mouse acceleration level is not zero, the operating system doubles the distance. If the specified distance along either the x- or y-axis is greater than the second mouse threshold value, and the mouse acceleration level is equal to two, the operating system doubles the distance that resulted from applying the first threshold test. It is thus possible for the operating system to multiply relatively-specified mouse motion along the x- or y-axis by up to four times.</para>
        /// <para>Once acceleration has been applied, the system scales the resultant value by the desired mouse speed. Mouse speed can range from 1 (slowest) to 20 (fastest) and represents how much the pointer moves based on the distance the mouse moves. The default value is 10, which results in no additional modification to the mouse motion.</para>
        /// <para>The <b>mouse_event</b> function is used to synthesize mouse events by applications that need to do so. It is also used by applications that need to obtain more information from the mouse than its position and button state. For example, if a tablet manufacturer wants to pass pen-based information to its own applications, it can write a DLL that communicates directly to the tablet hardware, obtains the extra information, and saves it in a queue. The DLL then calls <b>mouse_event</b> with the standard button and x/y position data, along with, in the <i>dwExtraInfo</i> parameter, some pointer or index to the queued extra information. When the application needs the extra information, it calls the DLL with the pointer or index stored in <i>dwExtraInfo</i>, and the DLL returns the extra information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mouse_event#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern void mouse_event(win32.UI.KeyboardAndMouseInput.MOUSE_EVENT_FLAGS dwFlags, int dx, int dy, uint dwData, nuint dwExtraInfo);
        /// <inheritdoc cref = "SendInput(uint, win32.UI.KeyboardAndMouseInput.INPUT*, int)"/>
        internal static unsafe uint SendInput(Span<win32.UI.KeyboardAndMouseInput.INPUT> pInputs, int cbSize)
        {
            fixed (win32.UI.KeyboardAndMouseInput.INPUT*pInputsLocal = pInputs)
            {
                uint __result = User32.SendInput((uint)pInputs.Length, pInputsLocal, cbSize);
                return __result;
            }
        }

        /// <summary>Synthesizes keystrokes, mouse motions, and button clicks.</summary>
        /// <param name = "cInputs">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The number of structures in the <i>pInputs</i> array.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendinput#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pInputs">
        /// <para>Type: <b>LPINPUT</b></para>
        /// <para>An array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-input">INPUT</a> structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendinput#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbSize">
        /// <para>Type: <b>int</b></para>
        /// <para>The size, in bytes, of an <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-input">INPUT</a> structure. If <i>cbSize</i> is not the size of an <b>INPUT</b> structure, the function fails.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendinput#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>The function returns the number of events that it successfully inserted into the keyboard or mouse input stream. If the function returns zero, the input was already blocked by another thread. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>This function fails when it is blocked by UIPI. Note that neither <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> nor the return value will indicate the failure was caused by UIPI blocking.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendinput">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint SendInput(uint cInputs, win32.UI.KeyboardAndMouseInput.INPUT*pInputs, int cbSize);
        /// <inheritdoc cref = "GetLastInputInfo(win32.UI.KeyboardAndMouseInput.LASTINPUTINFO*)"/>
        internal static unsafe bool GetLastInputInfo(out win32.UI.KeyboardAndMouseInput.LASTINPUTINFO plii)
        {
            fixed (win32.UI.KeyboardAndMouseInput.LASTINPUTINFO*pliiLocal = &plii)
            {
                bool __result = User32.GetLastInputInfo(pliiLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the time of the last input event.</summary>
        /// <param name = "plii">
        /// <para>Type: <b>PLASTINPUTINFO</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-lastinputinfo">LASTINPUTINFO</a> structure that receives the time of the last input event.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getlastinputinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getlastinputinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool GetLastInputInfo(win32.UI.KeyboardAndMouseInput.LASTINPUTINFO*plii);
        /// <summary>Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code.</summary>
        /// <param name = "uCode">
        /// <para>Type: **UINT**</para>
        /// <para>The [virtual key code](/windows/desktop/inputdev/virtual-key-codes) or scan code for a key. How this value is interpreted depends on the value of the *uMapType* parameter.</para>
        /// <para>**Starting with Windows Vista**, the high byte of the *uCode* value can contain either 0xe0 or 0xe1 to specify the extended scan code.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mapvirtualkeyw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uMapType">
        /// <para>Type: **UINT**</para>
        /// <para>The translation to be performed. The value of this parameter depends on the value of the *uCode* parameter.</para>
        /// <para>| Value | Meaning | |-------|---------| | **MAPVK\_VK\_TO\_VSC**<br>0 | The *uCode* parameter is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not distinguish between left- and right-hand keys, the left-hand scan code is returned. If there is no translation, the function returns 0. | | **MAPVK\_VSC\_TO\_VK**<br>1 | The *uCode* parameter is a scan code and is translated into a virtual-key code that does not distinguish between left- and right-hand keys. If there is no translation, the function returns 0. | | **MAPVK\_VK\_TO\_CHAR**<br>2 | The *uCode* parameter is a virtual-key code and is translated into an unshifted character value in the low order word of the return value. Dead keys (diacritics) are indicated by setting the top bit of the return value. If there is no translation, the function returns 0. | | **MAPVK\_VSC\_TO\_VK\_EX**<br>3 | The *uCode* parameter is a scan code and is translated into a virtual-key code that distinguishes between left- and right-hand keys. If there is no translation, the function returns 0. | | **MAPVK\_VK\_TO\_VSC\_EX**<br>4 | **Windows Vista and later:** The *uCode* parameter is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not distinguish between left- and right-hand keys, the left-hand scan code is returned. If the scan code is an extended scan code, the high byte of the *uCode* value can contain either 0xe0 or 0xe1 to specify the extended scan code. If there is no translation, the function returns 0. |</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mapvirtualkeyw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: **UINT**</para>
        /// <para>The return value is either a scan code, a virtual-key code, or a character value, depending on the value of *uCode* and *uMapType*. If there is no translation, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mapvirtualkeyw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "MapVirtualKeyW")]
        internal static extern uint MapVirtualKey(uint uCode, uint uMapType);
        /// <summary>Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code. The function translates the codes using the input language and an input locale identifier.</summary>
        /// <param name = "uCode">
        /// <para>Type: **UINT**</para>
        /// <para>The [virtual key code](/windows/desktop/inputdev/virtual-key-codes) or scan code for a key. How this value is interpreted depends on the value of the *uMapType* parameter.</para>
        /// <para>**Starting with Windows Vista**, the high byte of the *uCode* value can contain either 0xe0 or 0xe1 to specify the extended scan code.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mapvirtualkeyexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uMapType">
        /// <para>Type: **UINT**</para>
        /// <para>The translation to perform. The value of this parameter depends on the value of the <i>uCode</i> parameter.</para>
        /// <para>| Value | Meaning | |-------|---------| | **MAPVK\_VK\_TO\_VSC**<br>0 | The *uCode* parameter is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not distinguish between left- and right-hand keys, the left-hand scan code is returned. If there is no translation, the function returns 0. | | **MAPVK\_VSC\_TO\_VK**<br>1 | The *uCode* parameter is a scan code and is translated into a virtual-key code that does not distinguish between left- and right-hand keys. If there is no translation, the function returns 0. | | **MAPVK\_VK\_TO\_CHAR**<br>2 | The *uCode* parameter is a virtual-key code and is translated into an unshifted character value in the low order word of the return value. Dead keys (diacritics) are indicated by setting the top bit of the return value. If there is no translation, the function returns 0. | | **MAPVK\_VSC\_TO\_VK\_EX**<br>3 | The *uCode* parameter is a scan code and is translated into a virtual-key code that distinguishes between left- and right-hand keys. If there is no translation, the function returns 0. | | **MAPVK\_VK\_TO\_VSC\_EX**<br>4 | **Windows Vista and later:** The *uCode* parameter is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not distinguish between left- and right-hand keys, the left-hand scan code is returned. If the scan code is an extended scan code, the high byte of the *uCode* value can contain either 0xe0 or 0xe1 to specify the extended scan code. If there is no translation, the function returns 0. |</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mapvirtualkeyexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwhkl">
        /// <para>Type: **HKL**</para>
        /// <para>Input locale identifier to use for translating the specified code. This parameter can be any input locale identifier previously returned by the [LoadKeyboardLayout](nf-winuser-loadkeyboardlayoutw.md) function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mapvirtualkeyexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: **UINT**</para>
        /// <para>The return value is either a scan code, a virtual-key code, or a character value, depending on the value of *uCode* and *uMapType*. If there is no translation, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mapvirtualkeyexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "MapVirtualKeyExW")]
        internal static extern uint MapVirtualKeyEx(uint uCode, uint uMapType, win32.UI.TextServices.HKL dwhkl);
        /// <summary>Retrieves a handle to the window (if any) that has captured the mouse. Only one window at a time can capture the mouse; this window receives mouse input whether or not the cursor is within its borders.</summary>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is a handle to the capture window associated with the current thread. If no window in the thread has captured the mouse, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getcapture">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetCapture();
        /// <summary>Sets the mouse capture to the specified window belonging to the current thread.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window in the current thread that is to capture the mouse.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcapture#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>The return value is a handle to the window that had previously captured the mouse. If there is no such window, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setcapture">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND SetCapture(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Releases the mouse capture from a window in the current thread and restores normal mouse input processing.</summary>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-releasecapture">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ReleaseCapture();
        /// <summary>Enables or disables mouse and keyboard input to the specified window or control. When input is disabled, the window does not receive input such as mouse clicks and key presses. When input is enabled, the window receives all input.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be enabled or disabled.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enablewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bEnable">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether to enable or disable the window. If this parameter is <b>TRUE</b>, the window is enabled. If the parameter is <b>FALSE</b>, the window is disabled.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enablewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the window was previously disabled, the return value is nonzero.</para>
        /// <para>If the window was not previously disabled, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enablewindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool EnableWindow(win32.UI.WindowsAndMessaging.HWND hWnd, bool bEnable);
        /// <summary>Determines whether the specified window is enabled for mouse and keyboard input.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to be tested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iswindowenabled#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the window is enabled, the return value is nonzero.</para>
        /// <para>If the window is not enabled, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-iswindowenabled">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsWindowEnabled(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Captures the mouse and tracks its movement until the user releases the left button, presses the ESC key, or moves the mouse outside the drag rectangle around the specified point.</summary>
        /// <param name = "hwnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window receiving mouse input.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dragdetect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pt">
        /// <para>Type: <b><a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a></b></para>
        /// <para>Initial position of the mouse, in screen coordinates. The function determines the coordinates of the drag rectangle by using this point.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dragdetect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the user moved the mouse outside of the drag rectangle while holding down the left button, the return value is nonzero.</para>
        /// <para>If the user did not move the mouse outside of the drag rectangle while holding down the left button, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-dragdetect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool DragDetect(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.DisplayDevices.POINT pt);
        /// <summary>Activates a window. The window must be attached to the calling thread's message queue.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the top-level window to be activated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setactivewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is the handle to the window that was previously active.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setactivewindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND SetActiveWindow(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <summary>Blocks keyboard and mouse input events from reaching applications.</summary>
        /// <param name = "fBlockIt">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The function's purpose. If this parameter is <b>TRUE</b>, keyboard and mouse input events are blocked. If this parameter is <b>FALSE</b>, keyboard and mouse events are unblocked. Note that only the thread that blocked input can successfully unblock input.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-blockinput#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If input is already blocked, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-blockinput">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool BlockInput(bool fBlockIt);
        /// <inheritdoc cref = "GetRawInputData(win32.UI.KeyboardAndMouseInput.HRAWINPUT, win32.UI.KeyboardAndMouseInput.RAW_INPUT_DATA_COMMAND_FLAGS, void *, uint *, uint)"/>
        internal static unsafe uint GetRawInputData(win32.UI.KeyboardAndMouseInput.HRAWINPUT hRawInput, win32.UI.KeyboardAndMouseInput.RAW_INPUT_DATA_COMMAND_FLAGS uiCommand, void *pData, ref uint pcbSize, uint cbSizeHeader)
        {
            fixed (uint *pcbSizeLocal = &pcbSize)
            {
                uint __result = User32.GetRawInputData(hRawInput, uiCommand, pData, pcbSizeLocal, cbSizeHeader);
                return __result;
            }
        }

        /// <summary>Retrieves the raw input from the specified device.</summary>
        /// <param name = "hRawInput">
        /// <para>Type: <b>HRAWINPUT</b></para>
        /// <para>A handle to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinput">RAWINPUT</a> structure. This comes from the <i>lParam</i> in <a href = "https://docs.microsoft.com/windows/desktop/inputdev/wm-input">WM_INPUT</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uiCommand">Type: <b>UINT</b></param>
        /// <param name = "pData">
        /// <para>Type: <b>LPVOID</b></para>
        /// <para>A pointer to the data that comes from the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinput">RAWINPUT</a> structure. This depends on the value of <i>uiCommand</i>. If <i>pData</i> is <b>NULL</b>, the required size of the buffer is returned in *<i>pcbSize</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcbSize">
        /// <para>Type: <b>PUINT</b></para>
        /// <para>The size, in bytes, of the data in <i>pData</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbSizeHeader">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The size, in bytes, of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputheader">RAWINPUTHEADER</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If <i>pData</i> is <b>NULL</b> and the function is successful, the return value is 0. If <i>pData</i> is not <b>NULL</b> and the function is successful, the return value is the number of bytes copied into pData.</para>
        /// <para>If there is an error, the return value is (<b>UINT</b>)-1.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdata">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe uint GetRawInputData(win32.UI.KeyboardAndMouseInput.HRAWINPUT hRawInput, win32.UI.KeyboardAndMouseInput.RAW_INPUT_DATA_COMMAND_FLAGS uiCommand, [Optional] void *pData, uint *pcbSize, uint cbSizeHeader);
        /// <inheritdoc cref = "GetRawInputDeviceInfo(win32.System.SystemServices.HANDLE, win32.UI.KeyboardAndMouseInput.RAW_INPUT_DEVICE_INFO_COMMAND, void *, uint *)"/>
        internal static unsafe uint GetRawInputDeviceInfo(SafeHandle hDevice, win32.UI.KeyboardAndMouseInput.RAW_INPUT_DEVICE_INFO_COMMAND uiCommand, void *pData, ref uint pcbSize)
        {
            bool hDeviceAddRef = false;
            try
            {
                fixed (uint *pcbSizeLocal = &pcbSize)
                {
                    win32.System.SystemServices.HANDLE hDeviceLocal;
                    if (hDevice is object)
                    {
                        hDevice.DangerousAddRef(ref hDeviceAddRef);
                        hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                    }
                    else
                        hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                    uint __result = User32.GetRawInputDeviceInfo(hDeviceLocal, uiCommand, pData, pcbSizeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the raw input device.</summary>
        /// <param name = "hDevice">
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>A handle to the raw input device. This comes from the <b>hDevice</b> member of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputheader">RAWINPUTHEADER</a> or from <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getrawinputdevicelist">GetRawInputDeviceList</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdeviceinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uiCommand">Type: <b>UINT</b></param>
        /// <param name = "pData">
        /// <para>Type: <b>LPVOID</b></para>
        /// <para>A pointer to a buffer that contains the information specified by <i>uiCommand</i>.</para>
        /// <para>If <i>uiCommand</i> is <b>RIDI_DEVICEINFO</b>, set the <b>cbSize</b> member of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rid_device_info">RID_DEVICE_INFO</a> to <c>sizeof(RID_DEVICE_INFO)</c> before calling <b>GetRawInputDeviceInfo</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdeviceinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcbSize">
        /// <para>Type: <b>PUINT</b></para>
        /// <para>The size, in bytes, of the data in <i>pData</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdeviceinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If successful, this function returns a non-negative number indicating the number of bytes copied to <i>pData</i>.</para>
        /// <para>If <i>pData</i> is not large enough for the data, the function returns -1. If <i>pData</i> is <b>NULL</b>, the function returns a value of zero. In both of these cases, <i>pcbSize</i> is set to the minimum size required for the <i>pData</i> buffer.</para>
        /// <para>Call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to identify any other errors.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdeviceinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetRawInputDeviceInfoW", SetLastError = true)]
        internal static extern unsafe uint GetRawInputDeviceInfo(win32.System.SystemServices.HANDLE hDevice, win32.UI.KeyboardAndMouseInput.RAW_INPUT_DEVICE_INFO_COMMAND uiCommand, [Optional] void *pData, uint *pcbSize);
        /// <inheritdoc cref = "GetRawInputBuffer(win32.UI.KeyboardAndMouseInput.RAWINPUT*, uint *, uint)"/>
        internal static unsafe uint GetRawInputBuffer(win32.UI.KeyboardAndMouseInput.RAWINPUT*pData, ref uint pcbSize, uint cbSizeHeader)
        {
            fixed (uint *pcbSizeLocal = &pcbSize)
            {
                uint __result = User32.GetRawInputBuffer(pData, pcbSizeLocal, cbSizeHeader);
                return __result;
            }
        }

        /// <summary>Performs a buffered read of the raw input data.</summary>
        /// <param name = "pData">
        /// <para>Type: **PRAWINPUT**</para>
        /// <para>A pointer to a buffer of [RAWINPUT](ns-winuser-rawinput.md) structures that contain the raw input data. If **NULL**, size of the first raw input message data (minimum required buffer), in bytes, is returned in \**pcbSize*.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputbuffer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcbSize">
        /// <para>Type: **PUINT**</para>
        /// <para>The size, in bytes, of the provided [RAWINPUT](ns-winuser-rawinput.md) buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputbuffer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbSizeHeader">
        /// <para>Type: **UINT**</para>
        /// <para>The size, in bytes, of the [RAWINPUTHEADER](ns-winuser-rawinputheader.md) structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputbuffer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: **UINT**</para>
        /// <para>If *pData* is **NULL** and the function is successful, the return value is zero. If *pData* is not **NULL** and the function is successful, the return value is the number of [RAWINPUT](ns-winuser-rawinput.md) structures written to *pData*.</para>
        /// <para>If an error occurs, the return value is (**UINT**)-1. Call [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) for the error code.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputbuffer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint GetRawInputBuffer([Optional] win32.UI.KeyboardAndMouseInput.RAWINPUT*pData, uint *pcbSize, uint cbSizeHeader);
        /// <inheritdoc cref = "RegisterRawInputDevices(win32.UI.KeyboardAndMouseInput.RAWINPUTDEVICE*, uint, uint)"/>
        internal static unsafe bool RegisterRawInputDevices(Span<win32.UI.KeyboardAndMouseInput.RAWINPUTDEVICE> pRawInputDevices, uint cbSize)
        {
            fixed (win32.UI.KeyboardAndMouseInput.RAWINPUTDEVICE*pRawInputDevicesLocal = pRawInputDevices)
            {
                bool __result = User32.RegisterRawInputDevices(pRawInputDevicesLocal, (uint)pRawInputDevices.Length, cbSize);
                return __result;
            }
        }

        /// <summary>Registers the devices that supply the raw input data.</summary>
        /// <param name = "pRawInputDevices">
        /// <para>Type: <b>PCRAWINPUTDEVICE</b></para>
        /// <para>An array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputdevice">RAWINPUTDEVICE</a> structures that represent the devices that supply the raw input.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerrawinputdevices#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uiNumDevices">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The number of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputdevice">RAWINPUTDEVICE</a> structures pointed to by <i>pRawInputDevices</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerrawinputdevices#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbSize">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The size, in bytes, of a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputdevice">RAWINPUTDEVICE</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerrawinputdevices#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para><b>TRUE</b> if the function succeeds; otherwise, <b>FALSE</b>. If the function fails, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for more information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerrawinputdevices">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool RegisterRawInputDevices(win32.UI.KeyboardAndMouseInput.RAWINPUTDEVICE*pRawInputDevices, uint uiNumDevices, uint cbSize);
        /// <inheritdoc cref = "GetRegisteredRawInputDevices(win32.UI.KeyboardAndMouseInput.RAWINPUTDEVICE*, uint *, uint)"/>
        internal static unsafe uint GetRegisteredRawInputDevices(win32.UI.KeyboardAndMouseInput.RAWINPUTDEVICE*pRawInputDevices, ref uint puiNumDevices, uint cbSize)
        {
            fixed (uint *puiNumDevicesLocal = &puiNumDevices)
            {
                uint __result = User32.GetRegisteredRawInputDevices(pRawInputDevices, puiNumDevicesLocal, cbSize);
                return __result;
            }
        }

        /// <summary>Retrieves the information about the raw input devices for the current application.</summary>
        /// <param name = "pRawInputDevices">
        /// <para>Type: <b>PRAWINPUTDEVICE</b></para>
        /// <para>An array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputdevice">RAWINPUTDEVICE</a> structures for the application.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getregisteredrawinputdevices#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "puiNumDevices">
        /// <para>Type: <b>PUINT</b></para>
        /// <para>The number of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputdevice">RAWINPUTDEVICE</a> structures in *<i>pRawInputDevices</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getregisteredrawinputdevices#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbSize">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The size, in bytes, of a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputdevice">RAWINPUTDEVICE</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getregisteredrawinputdevices#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If successful, the function returns a non-negative number that is the number of <a href = "/windows/desktop/api/winuser/ns-winuser-rawinputdevice">RAWINPUTDEVICE</a> structures written to the buffer.</para>
        /// <para>If the <i>pRawInputDevices</i> buffer is too small or <b>NULL</b>, the function sets the last error as <b>ERROR_INSUFFICIENT_BUFFER</b>, returns -1, and sets <i>puiNumDevices</i> to the required number of devices. If the function fails for any other reason, it returns -1. For more details, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getregisteredrawinputdevices">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint GetRegisteredRawInputDevices([Optional] win32.UI.KeyboardAndMouseInput.RAWINPUTDEVICE*pRawInputDevices, uint *puiNumDevices, uint cbSize);
        /// <inheritdoc cref = "GetRawInputDeviceList(win32.UI.KeyboardAndMouseInput.RAWINPUTDEVICELIST*, uint *, uint)"/>
        internal static unsafe uint GetRawInputDeviceList(win32.UI.KeyboardAndMouseInput.RAWINPUTDEVICELIST*pRawInputDeviceList, ref uint puiNumDevices, uint cbSize)
        {
            fixed (uint *puiNumDevicesLocal = &puiNumDevices)
            {
                uint __result = User32.GetRawInputDeviceList(pRawInputDeviceList, puiNumDevicesLocal, cbSize);
                return __result;
            }
        }

        /// <summary>Enumerates the raw input devices attached to the system.</summary>
        /// <param name = "pRawInputDeviceList">
        /// <para>Type: <b>PRAWINPUTDEVICELIST</b></para>
        /// <para>An array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputdevicelist">RAWINPUTDEVICELIST</a> structures for the devices attached to the system. If <b>NULL</b>, the number of devices are returned in *<i>puiNumDevices</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdevicelist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "puiNumDevices">
        /// <para>Type: <b>PUINT</b></para>
        /// <para>If <i>pRawInputDeviceList</i> is <b>NULL</b>, the function populates this variable with the number of devices attached to the system; otherwise, this variable specifies the number of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputdevicelist">RAWINPUTDEVICELIST</a> structures that can be contained in the buffer to which <i>pRawInputDeviceList</i> points. If this value is less than the number of devices attached to the system, the function returns the actual number of devices in this variable and fails with <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdevicelist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbSize">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The size of a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputdevicelist">RAWINPUTDEVICELIST</a> structure, in bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdevicelist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function is successful, the return value is the number of devices stored in the buffer pointed to by <i>pRawInputDeviceList</i>.</para>
        /// <para>On any other error, the function returns (<b>UINT</b>) -1 and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the error indication.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getrawinputdevicelist">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint GetRawInputDeviceList([Optional] win32.UI.KeyboardAndMouseInput.RAWINPUTDEVICELIST*pRawInputDeviceList, uint *puiNumDevices, uint cbSize);
        /// <summary>Verifies that the size of the RAWINPUTHEADER structure is correct.</summary>
        /// <param name = "paRawInput">
        /// <para>Type: <b>PRAWINPUT*</b></para>
        /// <para>Ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defrawinputproc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nInput">
        /// <para>Type: <b>INT</b></para>
        /// <para>Ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defrawinputproc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbSizeHeader">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The size, in bytes, of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-rawinputheader">RAWINPUTHEADER</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defrawinputproc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>If successful, the function returns <b>0</b>. Otherwise it returns <b>-1</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-defrawinputproc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe win32.System.SystemServices.LRESULT DefRawInputProc(win32.UI.KeyboardAndMouseInput.RAWINPUT**paRawInput, int nInput, uint cbSizeHeader);
        /// <inheritdoc cref = "GetTouchInputInfo(win32.UI.TouchInput.HTOUCHINPUT, uint, win32.UI.TouchInput.TOUCHINPUT*, int)"/>
        internal static unsafe bool GetTouchInputInfo(win32.UI.TouchInput.HTOUCHINPUT hTouchInput, Span<win32.UI.TouchInput.TOUCHINPUT> pInputs, int cbSize)
        {
            fixed (win32.UI.TouchInput.TOUCHINPUT*pInputsLocal = pInputs)
            {
                bool __result = User32.GetTouchInputInfo(hTouchInput, (uint)pInputs.Length, pInputsLocal, cbSize);
                return __result;
            }
        }

        /// <summary>Retrieves detailed information about touch inputs associated with a particular touch input handle.</summary>
        /// <param name = "hTouchInput">The touch input handle received in the <b>LPARAM</b> of a touch message. The function fails with <b>ERROR_INVALID_HANDLE</b> if this handle is not valid. Note that the handle is not valid after it has been used in a successful call to <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-closetouchinputhandle">CloseTouchInputHandle</a> or after it has been passed to <a href = "https://docs.microsoft.com/windows/desktop/wintouch/sendmessage--postmessage--and-related-functions">DefWindowProc, PostMessage, SendMessage</a> or one of their variants.</param>
        /// <param name = "cInputs">The number of structures in the <i>pInputs</i> array. This should ideally be at least equal to the number of touch points associated with the message as indicated in the message <b>WPARAM</b>. If <i>cInputs</i> is less than the number of touch points, the function will still succeed and populate the <i>pInputs</i> buffer with information about <i>cInputs</i> touch points.</param>
        /// <param name = "pInputs">A pointer to an array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-touchinput">TOUCHINPUT</a> structures to receive information about the touch points associated with the specified touch input handle.</param>
        /// <param name = "cbSize">The size, in bytes, of a single <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-touchinput">TOUCHINPUT</a> structure. If <i>cbSize</i> is not the size of a single <b>TOUCHINPUT</b> structure, the function fails with <b>ERROR_INVALID_PARAMETER</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-gettouchinputinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetTouchInputInfo(win32.UI.TouchInput.HTOUCHINPUT hTouchInput, uint cInputs, win32.UI.TouchInput.TOUCHINPUT*pInputs, int cbSize);
        /// <summary>Closes a touch input handle, frees process memory associated with it, and invalidates the handle.</summary>
        /// <param name = "hTouchInput">The touch input handle received in the <b>LPARAM</b> of a touch message. The function fails with <b>ERROR_INVALID_HANDLE</b> if this handle is not valid. Note that the handle is not valid after it has been used in a successful call to <b>CloseTouchInputHandle</b> or after it has been passed to <a href = "https://docs.microsoft.com/windows/desktop/wintouch/sendmessage--postmessage--and-related-functions">DefWindowProc, PostMessage, SendMessage</a> or one of their variants.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-closetouchinputhandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool CloseTouchInputHandle(win32.UI.TouchInput.HTOUCHINPUT hTouchInput);
        /// <summary>Registers a window as being touch-capable.</summary>
        /// <param name = "hwnd">The handle of the window being registered. The function fails with <b>ERROR_ACCESS_DENIED</b> if the calling thread does not own the specified window.</param>
        /// <param name = "ulFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registertouchwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool RegisterTouchWindow(win32.UI.WindowsAndMessaging.HWND hwnd, win32.UI.TouchInput.REGISTER_TOUCH_WINDOW_FLAGS ulFlags);
        /// <summary>Registers a window as no longer being touch-capable.</summary>
        /// <param name = "hwnd">The handle of the window. The function fails with <b>ERROR_ACCESS_DENIED</b> if the calling thread does not own the specified window.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregistertouchwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool UnregisterTouchWindow(win32.UI.WindowsAndMessaging.HWND hwnd);
        /// <summary>Checks whether a specified window is touch-capable and, optionally, retrieves the modifier flags set for the window's touch capability.</summary>
        /// <param name = "hwnd">The handle of the window. The function fails with <b>ERROR_ACCESS_DENIED</b> if the calling thread is not on the same desktop as the specified window.</param>
        /// <param name = "pulFlags">The address of the <b>ULONG</b> variable to receive the modifier flags for the specified window's touch capability.</param>
        /// <returns>Returns <b>TRUE</b> if the window supports Windows Touch; returns <b>FALSE</b> if the window does not support Windows Touch.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-istouchwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool IsTouchWindow(win32.UI.WindowsAndMessaging.HWND hwnd, [Optional] uint *pulFlags);
        /// <inheritdoc cref = "GetGestureInfo(win32.UI.TouchInput.HGESTUREINFO, win32.UI.TouchInput.GESTUREINFO*)"/>
        internal static unsafe bool GetGestureInfo(win32.UI.TouchInput.HGESTUREINFO hGestureInfo, out win32.UI.TouchInput.GESTUREINFO pGestureInfo)
        {
            fixed (win32.UI.TouchInput.GESTUREINFO*pGestureInfoLocal = &pGestureInfo)
            {
                bool __result = User32.GetGestureInfo(hGestureInfo, pGestureInfoLocal);
                return __result;
            }
        }

        /// <summary>Retrieves a GESTUREINFO structure given a handle to the gesture information.</summary>
        /// <param name = "hGestureInfo">The gesture information handle.</param>
        /// <param name = "pGestureInfo">A pointer to the gesture information structure.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getgestureinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetGestureInfo(win32.UI.TouchInput.HGESTUREINFO hGestureInfo, win32.UI.TouchInput.GESTUREINFO*pGestureInfo);
        /// <inheritdoc cref = "GetGestureExtraArgs(win32.UI.TouchInput.HGESTUREINFO, uint, byte *)"/>
        internal static unsafe bool GetGestureExtraArgs(win32.UI.TouchInput.HGESTUREINFO hGestureInfo, uint cbExtraArgs, out byte pExtraArgs)
        {
            fixed (byte *pExtraArgsLocal = &pExtraArgs)
            {
                bool __result = User32.GetGestureExtraArgs(hGestureInfo, cbExtraArgs, pExtraArgsLocal);
                return __result;
            }
        }

        /// <summary>Retrieves additional information about a gesture from its GESTUREINFO handle.</summary>
        /// <param name = "hGestureInfo">The handle to the gesture information that is passed in the <i>lParam</i> of a <a href = "https://docs.microsoft.com/windows/desktop/wintouch/wm-gesture">WM_GESTURE</a> message.</param>
        /// <param name = "cbExtraArgs">A count of the bytes of data stored in the extra arguments.</param>
        /// <param name = "pExtraArgs">A pointer to the extra argument information.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getgestureextraargs">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetGestureExtraArgs(win32.UI.TouchInput.HGESTUREINFO hGestureInfo, uint cbExtraArgs, byte *pExtraArgs);
        /// <summary>Closes resources associated with a gesture information handle.</summary>
        /// <param name = "hGestureInfo">The gesture information handle.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-closegestureinfohandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool CloseGestureInfoHandle(win32.UI.TouchInput.HGESTUREINFO hGestureInfo);
        /// <inheritdoc cref = "SetGestureConfig(win32.UI.WindowsAndMessaging.HWND, uint, uint, win32.UI.TouchInput.GESTURECONFIG*, uint)"/>
        internal static unsafe bool SetGestureConfig(win32.UI.WindowsAndMessaging.HWND hwnd, uint dwReserved, Span<win32.UI.TouchInput.GESTURECONFIG> pGestureConfig, uint cbSize)
        {
            fixed (win32.UI.TouchInput.GESTURECONFIG*pGestureConfigLocal = pGestureConfig)
            {
                bool __result = User32.SetGestureConfig(hwnd, dwReserved, (uint)pGestureConfig.Length, pGestureConfigLocal, cbSize);
                return __result;
            }
        }

        /// <summary>Configures the messages that are sent from a window for Windows Touch gestures.</summary>
        /// <param name = "hwnd">A handle to the window to set the gesture configuration on.</param>
        /// <param name = "dwReserved">This value is reserved and must be set to 0.</param>
        /// <param name = "cIDs">A count of the gesture configuration structures that are being passed.</param>
        /// <param name = "pGestureConfig">An array of gesture configuration structures that specify the gesture configuration.</param>
        /// <param name = "cbSize">The size of the gesture configuration (<a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-gestureconfig">GESTURECONFIG</a>) structure.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setgestureconfig">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetGestureConfig(win32.UI.WindowsAndMessaging.HWND hwnd, uint dwReserved, uint cIDs, win32.UI.TouchInput.GESTURECONFIG*pGestureConfig, uint cbSize);
        /// <inheritdoc cref = "GetGestureConfig(win32.UI.WindowsAndMessaging.HWND, uint, uint, uint *, win32.UI.TouchInput.GESTURECONFIG*, uint)"/>
        internal static unsafe bool GetGestureConfig(win32.UI.WindowsAndMessaging.HWND hwnd, uint dwReserved, uint dwFlags, in uint pcIDs, win32.UI.TouchInput.GESTURECONFIG*pGestureConfig, uint cbSize)
        {
            fixed (uint *pcIDsLocal = &pcIDs)
            {
                bool __result = User32.GetGestureConfig(hwnd, dwReserved, dwFlags, pcIDsLocal, pGestureConfig, cbSize);
                return __result;
            }
        }

        /// <summary>Retrieves the configuration for which Windows Touch gesture messages are sent from a window.</summary>
        /// <param name = "hwnd">A handle to the window to get the gesture configuration from.</param>
        /// <param name = "dwReserved">This value is reserved and must be set to 0.</param>
        /// <param name = "dwFlags">A gesture command flag value indicating options for retrieving the gesture configuration.  See Remarks for additional information and supported values.</param>
        /// <param name = "pcIDs">The size, in number of gesture configuration structures, that is in the <i>pGestureConfig</i> buffer.</param>
        /// <param name = "pGestureConfig">An array of gesture configuration structures that specify the gesture configuration.</param>
        /// <param name = "cbSize">The size of the gesture configuration (<a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-gestureconfig">GESTURECONFIG</a>) structure.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getgestureconfig">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetGestureConfig(win32.UI.WindowsAndMessaging.HWND hwnd, uint dwReserved, uint dwFlags, uint *pcIDs, win32.UI.TouchInput.GESTURECONFIG*pGestureConfig, uint cbSize);
        /// <summary>Gets pointer data before it has gone through touch prediction processing.</summary>
        /// <returns>The screen location of the pointer input.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getunpredictedmessagepos">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern uint GetUnpredictedMessagePos();
        /// <inheritdoc cref = "GetPointerType(uint, win32.UI.WindowsAndMessaging.POINTER_INPUT_TYPE*)"/>
        internal static unsafe bool GetPointerType(uint pointerId, out win32.UI.WindowsAndMessaging.POINTER_INPUT_TYPE pointerType)
        {
            fixed (win32.UI.WindowsAndMessaging.POINTER_INPUT_TYPE*pointerTypeLocal = &pointerType)
            {
                bool __result = User32.GetPointerType(pointerId, pointerTypeLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the pointer type for a specified pointer.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve pointer type.</param>
        /// <param name = "pointerType">An address of a <a href = "https://docs.microsoft.com/windows/win32/api/winuser/ne-winuser-tagpointer_input_type">POINTER_INPUT_TYPE</a> type to receive a pointer input type.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointertype">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerType(uint pointerId, win32.UI.WindowsAndMessaging.POINTER_INPUT_TYPE*pointerType);
        /// <inheritdoc cref = "GetPointerCursorId(uint, uint *)"/>
        internal static unsafe bool GetPointerCursorId(uint pointerId, out uint cursorId)
        {
            fixed (uint *cursorIdLocal = &cursorId)
            {
                bool __result = User32.GetPointerCursorId(pointerId, cursorIdLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the cursor identifier associated with the specified pointer.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve the cursor identifier.</param>
        /// <param name = "cursorId">An address of a <b>UINT32</b> to receive the tablet cursor identifier, if any, associated with the specified pointer.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointercursorid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerCursorId(uint pointerId, uint *cursorId);
        /// <inheritdoc cref = "GetPointerInfo(uint, win32.UI.PointerInput.POINTER_INFO*)"/>
        internal static unsafe bool GetPointerInfo(uint pointerId, out win32.UI.PointerInput.POINTER_INFO pointerInfo)
        {
            fixed (win32.UI.PointerInput.POINTER_INFO*pointerInfoLocal = &pointerInfo)
            {
                bool __result = User32.GetPointerInfo(pointerId, pointerInfoLocal);
                return __result;
            }
        }

        /// <summary>Gets the information for the specified pointer associated with the current message.</summary>
        /// <param name = "pointerId">The pointer identifier.</param>
        /// <param name = "pointerInfo">Address of a  <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_info">POINTER_INFO</a> structure that receives the pointer information.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerInfo(uint pointerId, win32.UI.PointerInput.POINTER_INFO*pointerInfo);
        /// <inheritdoc cref = "GetPointerInfoHistory(uint, uint *, win32.UI.PointerInput.POINTER_INFO*)"/>
        internal static unsafe bool GetPointerInfoHistory(uint pointerId, ref uint entriesCount, win32.UI.PointerInput.POINTER_INFO*pointerInfo)
        {
            fixed (uint *entriesCountLocal = &entriesCount)
            {
                bool __result = User32.GetPointerInfoHistory(pointerId, entriesCountLocal, pointerInfo);
                return __result;
            }
        }

        /// <summary>Gets the information associated with the individual inputs, if any, that were coalesced into the current message for the specified pointer.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name = "entriesCount">A pointer to a variable that specifies the count of structures in the buffer to which pointerInfo points. If <b>GetPointerInfoHistory</b> succceeds, <i>entriesCount</i>  is updated with the total count of structures available. The total count of structures available is the same as the <b>historyCount</b> field of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_info">POINTER_INFO</a> structure returned by a call to <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getpointerinfo">GetPointerInfo</a>.</param>
        /// <param name = "pointerInfo">Address of an array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_info">POINTER_INFO</a> structures to receive the pointer information. This parameter can be NULL if <i>*entriesCount</i> is zero.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerinfohistory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerInfoHistory(uint pointerId, uint *entriesCount, [Optional] win32.UI.PointerInput.POINTER_INFO*pointerInfo);
        /// <inheritdoc cref = "GetPointerFrameInfo(uint, uint *, win32.UI.PointerInput.POINTER_INFO*)"/>
        internal static unsafe bool GetPointerFrameInfo(uint pointerId, ref uint pointerCount, win32.UI.PointerInput.POINTER_INFO*pointerInfo)
        {
            fixed (uint *pointerCountLocal = &pointerCount)
            {
                bool __result = User32.GetPointerFrameInfo(pointerId, pointerCountLocal, pointerInfo);
                return __result;
            }
        }

        /// <summary>Gets the entire frame of information for the specified pointers associated with the current message.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve frame information.</param>
        /// <param name = "pointerCount">A pointer to a variable that specifies the count of structures in the buffer to which pointerInfo points. If <b>GetPointerFrameInfo</b> succeeds, <i>pointerCount</i> is updated with the total count of pointers in the frame.</param>
        /// <param name = "pointerInfo">Address of an array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_info">POINTER_INFO</a> structures to receive the pointer information. This parameter can be <b>NULL</b> if <i>*pointerCount</i> is zero.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerframeinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerFrameInfo(uint pointerId, uint *pointerCount, [Optional] win32.UI.PointerInput.POINTER_INFO*pointerInfo);
        /// <inheritdoc cref = "GetPointerFrameInfoHistory(uint, uint *, uint *, win32.UI.PointerInput.POINTER_INFO*)"/>
        internal static unsafe bool GetPointerFrameInfoHistory(uint pointerId, ref uint entriesCount, ref uint pointerCount, win32.UI.PointerInput.POINTER_INFO*pointerInfo)
        {
            fixed (uint *pointerCountLocal = &pointerCount)
            {
                fixed (uint *entriesCountLocal = &entriesCount)
                {
                    bool __result = User32.GetPointerFrameInfoHistory(pointerId, entriesCountLocal, pointerCountLocal, pointerInfo);
                    return __result;
                }
            }
        }

        /// <summary>Gets the entire frame of information (including coalesced input frames) for the specified pointers associated with the current message.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve frame information.</param>
        /// <param name = "entriesCount">A pointer to a variable that specifies the count of rows in the two-dimensional array to which pointerInfo points. If <b>GetPointerFrameInfoHistory</b> succeeds, <i>entriesCount</i> is updated with the total count of frames available in the history.</param>
        /// <param name = "pointerCount">A pointer to a variable that specifies the count of columns in the two-dimensional array to which pointerInfo points. If <b>GetPointerFrameInfoHistory</b> succeeds, <i>pointerCount</i> is updated with the total count of pointers in each frame.</param>
        /// <param name = "pointerInfo">
        /// <para>Address of a two-dimensional array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_info">POINTER_INFO</a> structures to receive the pointer information. This parameter can be NULL if <i>*entriesCount</i> and <i>*pointerCount</i> are both zero.</para>
        /// <para>This array is interpreted as <c>POINTER_INFO[*entriesCount][*pointerCount]</c>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerframeinfohistory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerframeinfohistory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerFrameInfoHistory(uint pointerId, uint *entriesCount, uint *pointerCount, [Optional] win32.UI.PointerInput.POINTER_INFO*pointerInfo);
        /// <inheritdoc cref = "GetPointerTouchInfo(uint, win32.UI.PointerInput.POINTER_TOUCH_INFO*)"/>
        internal static unsafe bool GetPointerTouchInfo(uint pointerId, out win32.UI.PointerInput.POINTER_TOUCH_INFO touchInfo)
        {
            fixed (win32.UI.PointerInput.POINTER_TOUCH_INFO*touchInfoLocal = &touchInfo)
            {
                bool __result = User32.GetPointerTouchInfo(pointerId, touchInfoLocal);
                return __result;
            }
        }

        /// <summary>Gets the touch-based information for the specified pointer (of type PT_TOUCH) associated with the current message.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name = "touchInfo">Address of a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_touch_info">POINTER_TOUCH_INFO</a> structure to receive the touch-specific pointer information.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointertouchinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerTouchInfo(uint pointerId, win32.UI.PointerInput.POINTER_TOUCH_INFO*touchInfo);
        /// <inheritdoc cref = "GetPointerTouchInfoHistory(uint, uint *, win32.UI.PointerInput.POINTER_TOUCH_INFO*)"/>
        internal static unsafe bool GetPointerTouchInfoHistory(uint pointerId, ref uint entriesCount, win32.UI.PointerInput.POINTER_TOUCH_INFO*touchInfo)
        {
            fixed (uint *entriesCountLocal = &entriesCount)
            {
                bool __result = User32.GetPointerTouchInfoHistory(pointerId, entriesCountLocal, touchInfo);
                return __result;
            }
        }

        /// <summary>Gets the touch-based information associated with the individual inputs, if any, that were coalesced into the current message for the specified pointer (of type PT_TOUCH).</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name = "entriesCount">A pointer to a variable that specifies the count of structures in the buffer to which touchInfo points. If <b>GetPointerTouchInfoHistory</b> succeeds, <i>entriesCount</i> is updated with the total count of structures available. The total count of structures available is the same as the <i>historyCount</i> field in the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_info">POINTER_INFO</a> structure returned by a call to <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getpointerinfo">GetPointerInfo</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getpointertouchinfo">GetPointerTouchInfo</a>.</param>
        /// <param name = "touchInfo">Address of an array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_touch_info">POINTER_TOUCH_INFO</a> structures to receive the pointer information. This parameter can be NULL if *entriesCount is zero.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointertouchinfohistory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerTouchInfoHistory(uint pointerId, uint *entriesCount, [Optional] win32.UI.PointerInput.POINTER_TOUCH_INFO*touchInfo);
        /// <inheritdoc cref = "GetPointerFrameTouchInfo(uint, uint *, win32.UI.PointerInput.POINTER_TOUCH_INFO*)"/>
        internal static unsafe bool GetPointerFrameTouchInfo(uint pointerId, ref uint pointerCount, win32.UI.PointerInput.POINTER_TOUCH_INFO*touchInfo)
        {
            fixed (uint *pointerCountLocal = &pointerCount)
            {
                bool __result = User32.GetPointerFrameTouchInfo(pointerId, pointerCountLocal, touchInfo);
                return __result;
            }
        }

        /// <summary>Gets the entire frame of touch-based information for the specified pointers (of type PT_TOUCH) associated with the current message.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve frame information.</param>
        /// <param name = "pointerCount">A pointer to a variable that specifies the count of structures in the buffer to which touchInfo points. If <b>GetPointerFrameTouchInfo</b> succeeds, <i>pointerCount</i> is updated with the total count of pointers in the frame.</param>
        /// <param name = "touchInfo">Address of an array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_touch_info">POINTER_TOUCH_INFO</a> structures to receive the pointer information. This parameter can be NULL if <i>*pointerCount</i> is zero.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerframetouchinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerFrameTouchInfo(uint pointerId, uint *pointerCount, [Optional] win32.UI.PointerInput.POINTER_TOUCH_INFO*touchInfo);
        /// <inheritdoc cref = "GetPointerFrameTouchInfoHistory(uint, uint *, uint *, win32.UI.PointerInput.POINTER_TOUCH_INFO*)"/>
        internal static unsafe bool GetPointerFrameTouchInfoHistory(uint pointerId, ref uint entriesCount, ref uint pointerCount, win32.UI.PointerInput.POINTER_TOUCH_INFO*touchInfo)
        {
            fixed (uint *pointerCountLocal = &pointerCount)
            {
                fixed (uint *entriesCountLocal = &entriesCount)
                {
                    bool __result = User32.GetPointerFrameTouchInfoHistory(pointerId, entriesCountLocal, pointerCountLocal, touchInfo);
                    return __result;
                }
            }
        }

        /// <summary>Gets the entire frame of touch-based information (including coalesced input frames) for the specified pointers (of type PT_TOUCH) associated with the current message.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve frame information.</param>
        /// <param name = "entriesCount">A pointer to variable that specifies the count of rows in the two-dimensional array to which touchInfo points. If <b>GetPointerFrameTouchInfoHistory</b> succeeds,  <i>entriesCount</i> is updated with the total count of frames available in the history.</param>
        /// <param name = "pointerCount">A pointer to a variable that specifies the count of columns in the two-dimensional array to which touchInfo points. If <b>GetPointerFrameTouchInfoHistory</b> succeeds, <i>pointerCount</i> is updated with the total count of pointers in each frame.</param>
        /// <param name = "touchInfo">
        /// <para>Address of a two-dimensional array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_touch_info">POINTER_TOUCH_INFO</a> structures to receive the pointer information. This parameter can be NULL if <i>*entriesCount</i> and <i>*pointerCount</i> are both zero.</para>
        /// <para>This array is interpreted as <c>POINTER_TOUCH_INFO[*entriesCount][*pointerCount]</c>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerframetouchinfohistory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerframetouchinfohistory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerFrameTouchInfoHistory(uint pointerId, uint *entriesCount, uint *pointerCount, [Optional] win32.UI.PointerInput.POINTER_TOUCH_INFO*touchInfo);
        /// <inheritdoc cref = "GetPointerPenInfo(uint, win32.UI.PointerInput.POINTER_PEN_INFO*)"/>
        internal static unsafe bool GetPointerPenInfo(uint pointerId, out win32.UI.PointerInput.POINTER_PEN_INFO penInfo)
        {
            fixed (win32.UI.PointerInput.POINTER_PEN_INFO*penInfoLocal = &penInfo)
            {
                bool __result = User32.GetPointerPenInfo(pointerId, penInfoLocal);
                return __result;
            }
        }

        /// <summary>Gets the pen-based information for the specified pointer (of type PT_PEN) associated with the current message.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name = "penInfo">Address of a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_pen_info">POINTER_PEN_INFO</a> structure to receive the pen-specific pointer information.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerpeninfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerPenInfo(uint pointerId, win32.UI.PointerInput.POINTER_PEN_INFO*penInfo);
        /// <inheritdoc cref = "GetPointerPenInfoHistory(uint, uint *, win32.UI.PointerInput.POINTER_PEN_INFO*)"/>
        internal static unsafe bool GetPointerPenInfoHistory(uint pointerId, ref uint entriesCount, win32.UI.PointerInput.POINTER_PEN_INFO*penInfo)
        {
            fixed (uint *entriesCountLocal = &entriesCount)
            {
                bool __result = User32.GetPointerPenInfoHistory(pointerId, entriesCountLocal, penInfo);
                return __result;
            }
        }

        /// <summary>Gets the pen-based information associated with the individual inputs, if any, that were coalesced into the current message for the specified pointer (of type PT_PEN).</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name = "entriesCount">
        /// <para>A pointer to a variable that specifies the count of structures in the buffer to which <i>penInfo</i> points. If <b>GetPointerPenInfoHistory</b> succeeds, <i>entriesCount</i> is updated with the total count of structures available. The total count of structures available is the same as the <i>historyCount</i> field in the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_pen_info">POINTER_PEN_INFO</a> structure returned by a call to  <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getpointerpeninfo">GetPointerPenInfo</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerpeninfohistory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "penInfo">
        /// <para>Address of an array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_pen_info">POINTER_PEN_INFO</a> structures to receive the pointer information. This parameter can be NULL if <i>*entriesCount</i> is zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerpeninfohistory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerpeninfohistory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerPenInfoHistory(uint pointerId, uint *entriesCount, [Optional] win32.UI.PointerInput.POINTER_PEN_INFO*penInfo);
        /// <inheritdoc cref = "GetPointerFramePenInfo(uint, uint *, win32.UI.PointerInput.POINTER_PEN_INFO*)"/>
        internal static unsafe bool GetPointerFramePenInfo(uint pointerId, ref uint pointerCount, win32.UI.PointerInput.POINTER_PEN_INFO*penInfo)
        {
            fixed (uint *pointerCountLocal = &pointerCount)
            {
                bool __result = User32.GetPointerFramePenInfo(pointerId, pointerCountLocal, penInfo);
                return __result;
            }
        }

        /// <summary>Gets the entire frame of pen-based information for the specified pointers (of type PT_PEN) associated with the current message.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve frame information.</param>
        /// <param name = "pointerCount">A pointer to a variable that specifies the count of structures in the buffer to which penInfo points. If <b>GetPointerFramePenInfo</b> succeeds, <i>pointerCount</i>  is updated with the total count of pointers in the frame.</param>
        /// <param name = "penInfo">Address of an array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_pen_info">POINTER_PEN_INFO</a> structures to receive the pointer information. This parameter can be NULL if <i>*pointerCount</i> is zero.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerframepeninfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerFramePenInfo(uint pointerId, uint *pointerCount, [Optional] win32.UI.PointerInput.POINTER_PEN_INFO*penInfo);
        /// <inheritdoc cref = "GetPointerFramePenInfoHistory(uint, uint *, uint *, win32.UI.PointerInput.POINTER_PEN_INFO*)"/>
        internal static unsafe bool GetPointerFramePenInfoHistory(uint pointerId, ref uint entriesCount, ref uint pointerCount, win32.UI.PointerInput.POINTER_PEN_INFO*penInfo)
        {
            fixed (uint *pointerCountLocal = &pointerCount)
            {
                fixed (uint *entriesCountLocal = &entriesCount)
                {
                    bool __result = User32.GetPointerFramePenInfoHistory(pointerId, entriesCountLocal, pointerCountLocal, penInfo);
                    return __result;
                }
            }
        }

        /// <summary>Gets the entire frame of pen-based information (including coalesced input frames) for the specified pointers (of type PT_PEN) associated with the current message.</summary>
        /// <param name = "pointerId">The identifier of the pointer for which to retrieve frame information.</param>
        /// <param name = "entriesCount">A pointer to a variable that specifies the count of rows in the two-dimensional array to which penInfo points. If <b>GetPointerFramePenInfoHistory</b> succeeds,  <i>entriesCount</i> is updated with the total count of frames available in the history.</param>
        /// <param name = "pointerCount">A pointer to a variaable that specifies the count of columns in the two-dimensional array to which penInfo points. If <b>GetPointerFramePenInfoHistory</b> succeeds, <i>pointerCount</i> is updated with  the total count of pointers in each frame.</param>
        /// <param name = "penInfo">
        /// <para>Address of a two-dimensional array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_pen_info">POINTER_PEN_INFO</a> structures to receive the pointer information. This parameter can be NULL if *entriesCount and *pointerCount are both zero.</para>
        /// <para>This array is interpreted as POINTER_PEN_INFO[*entriesCount][*pointerCount].</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerframepeninfohistory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerframepeninfohistory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerFramePenInfoHistory(uint pointerId, uint *entriesCount, uint *pointerCount, [Optional] win32.UI.PointerInput.POINTER_PEN_INFO*penInfo);
        /// <summary>Determines which pointer input frame generated the most recently retrieved message for the specified pointer and discards any queued (unretrieved) pointer input messages generated from the same pointer input frame.</summary>
        /// <param name = "pointerId">Identifier of the pointer. Pending messages will be skipped for the frame that includes the most recently retrieved input for this pointer.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-skippointerframemessages">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SkipPointerFrameMessages(uint pointerId);
        /// <summary>Enables the mouse to act as a pointer input device and send WM_POINTER messages.</summary>
        /// <param name = "fEnable"><b>TRUE</b> to turn on mouse input support in <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/inputmsg/messages">WM_POINTER</a>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enablemouseinpointer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool EnableMouseInPointer(bool fEnable);
        /// <summary>Indicates whether EnableMouseInPointer is set for the mouse to act as a pointer input device and send WM_POINTER messages.</summary>
        /// <returns>
        /// <para>If <a href = "/windows/desktop/api/winuser/nf-winuser-enablemouseinpointer">EnableMouseInPointer</a> is set, the return value is nonzero.</para>
        /// <para>If <a href = "/windows/desktop/api/winuser/nf-winuser-enablemouseinpointer">EnableMouseInPointer</a> is not set, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ismouseinpointerenabled">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool IsMouseInPointerEnabled();
        /// <inheritdoc cref = "GetPointerInputTransform(uint, uint, win32.UI.PointerInput.INPUT_TRANSFORM*)"/>
        internal static unsafe bool GetPointerInputTransform(uint pointerId, Span<win32.UI.PointerInput.INPUT_TRANSFORM> inputTransform)
        {
            fixed (win32.UI.PointerInput.INPUT_TRANSFORM*inputTransformLocal = inputTransform)
            {
                bool __result = User32.GetPointerInputTransform(pointerId, (uint)inputTransform.Length, inputTransformLocal);
                return __result;
            }
        }

        /// <summary>Gets one or more transforms for the pointer information coordinates associated with the current message.</summary>
        /// <param name = "pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name = "historyCount">
        /// <para>The number of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-input_transform">INPUT_TRANSFORM</a> structures that <i>inputTransform</i> can point to.</para>
        /// <para>This value must be no less than 1 and no greater than the value specified in <b>historyCount</b> of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_info">POINTER_INFO</a> structure returned by <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getpointerinfo">GetPointerInfo</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getpointertouchinfo">GetPointerTouchInfo</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getpointerpeninfo">GetPointerPenInfo</a> (for a single input transform) or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getpointerinfohistory">GetPointerInfoHistory</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getpointertouchinfohistory">GetPointerTouchInfoHistory</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getpointerpeninfohistory">GetPointerPenInfoHistory</a> (for an array of input transforms).</para>
        /// <para>If <b>GetPointerInputTransform</b> succeeds, <i>inputTransform</i>  is updated with the total count of structures available. The total count of structures available is the same as the <b>historyCount</b> field of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-pointer_info">POINTER_INFO</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerinputtransform#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "inputTransform">Address of an array of <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-input_transform">INPUT_TRANSFORM</a> structures to receive the transform information. This parameter cannot be NULL.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getpointerinputtransform">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPointerInputTransform(uint pointerId, uint historyCount, win32.UI.PointerInput.INPUT_TRANSFORM*inputTransform);
        /// <inheritdoc cref = "DrawEdge(win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.RECT*, win32.Graphics.Gdi.DRAWEDGE_FLAGS, win32.Graphics.Gdi.DRAW_EDGE_FLAGS)"/>
        internal static unsafe bool DrawEdge(SafeHandle hdc, ref win32.UI.DisplayDevices.RECT qrc, win32.Graphics.Gdi.DRAWEDGE_FLAGS edge, win32.Graphics.Gdi.DRAW_EDGE_FLAGS grfFlags)
        {
            bool hdcAddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*qrcLocal = &qrc)
                {
                    win32.Graphics.Gdi.HDC hdcLocal;
                    if (hdc is object)
                    {
                        hdc.DangerousAddRef(ref hdcAddRef);
                        hdcLocal = (win32.Graphics.Gdi.HDC)hdc.DangerousGetHandle();
                    }
                    else
                        hdcLocal = default(win32.Graphics.Gdi.HDC);
                    bool __result = User32.DrawEdge(hdcLocal, qrcLocal, edge, grfFlags);
                    return __result;
                }
            }
            finally
            {
                if (hdcAddRef)
                    hdc.DangerousRelease();
            }
        }

        /// <summary>The DrawEdge function draws one or more edges of rectangle.</summary>
        /// <param name = "hdc">A handle to the device context.</param>
        /// <param name = "qrc">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the logical coordinates of the rectangle.</param>
        /// <param name = "edge">
        /// <para>The type of inner and outer edges to draw. This parameter must be a combination of one inner-border flag and one outer-border flag. The inner-border flags are as follows.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawedge#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "grfFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawedge">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool DrawEdge(win32.Graphics.Gdi.HDC hdc, win32.UI.DisplayDevices.RECT*qrc, win32.Graphics.Gdi.DRAWEDGE_FLAGS edge, win32.Graphics.Gdi.DRAW_EDGE_FLAGS grfFlags);
        /// <inheritdoc cref = "DrawFrameControl(win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.RECT*, win32.Graphics.Gdi.DFC_TYPE, win32.Graphics.Gdi.DFCS_STATE)"/>
        internal static unsafe bool DrawFrameControl(SafeHandle param0, ref win32.UI.DisplayDevices.RECT param1, win32.Graphics.Gdi.DFC_TYPE param2, win32.Graphics.Gdi.DFCS_STATE param3)
        {
            bool param0AddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*param1Local = &param1)
                {
                    win32.Graphics.Gdi.HDC param0Local;
                    if (param0 is object)
                    {
                        param0.DangerousAddRef(ref param0AddRef);
                        param0Local = (win32.Graphics.Gdi.HDC)param0.DangerousGetHandle();
                    }
                    else
                        param0Local = default(win32.Graphics.Gdi.HDC);
                    bool __result = User32.DrawFrameControl(param0Local, param1Local, param2, param3);
                    return __result;
                }
            }
            finally
            {
                if (param0AddRef)
                    param0.DangerousRelease();
            }
        }

        /// <summary>The DrawFrameControl function draws a frame control of the specified type and style.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawframecontrol">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool DrawFrameControl(win32.Graphics.Gdi.HDC param0, win32.UI.DisplayDevices.RECT*param1, win32.Graphics.Gdi.DFC_TYPE param2, win32.Graphics.Gdi.DFCS_STATE param3);
        /// <inheritdoc cref = "DrawCaption(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.RECT*, win32.Graphics.Gdi.DRAW_CAPTION_FLAGS)"/>
        internal static unsafe bool DrawCaption(win32.UI.WindowsAndMessaging.HWND hwnd, SafeHandle hdc, in win32.UI.DisplayDevices.RECT lprect, win32.Graphics.Gdi.DRAW_CAPTION_FLAGS flags)
        {
            bool hdcAddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*lprectLocal = &lprect)
                {
                    win32.Graphics.Gdi.HDC hdcLocal;
                    if (hdc is object)
                    {
                        hdc.DangerousAddRef(ref hdcAddRef);
                        hdcLocal = (win32.Graphics.Gdi.HDC)hdc.DangerousGetHandle();
                    }
                    else
                        hdcLocal = default(win32.Graphics.Gdi.HDC);
                    bool __result = User32.DrawCaption(hwnd, hdcLocal, lprectLocal, flags);
                    return __result;
                }
            }
            finally
            {
                if (hdcAddRef)
                    hdc.DangerousRelease();
            }
        }

        /// <summary>The DrawCaption function draws a window caption.</summary>
        /// <param name = "hwnd">A handle to a window that supplies text and an icon for the window caption.</param>
        /// <param name = "hdc">A handle to a device context. The function draws the window caption into this device context.</param>
        /// <param name = "lprect">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the bounding rectangle for the window caption in logical coordinates.</param>
        /// <param name = "flags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawcaption">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool DrawCaption(win32.UI.WindowsAndMessaging.HWND hwnd, win32.Graphics.Gdi.HDC hdc, win32.UI.DisplayDevices.RECT*lprect, win32.Graphics.Gdi.DRAW_CAPTION_FLAGS flags);
        /// <inheritdoc cref = "DrawAnimatedRects(win32.UI.WindowsAndMessaging.HWND, int, win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool DrawAnimatedRects(win32.UI.WindowsAndMessaging.HWND hwnd, int idAni, in win32.UI.DisplayDevices.RECT lprcFrom, in win32.UI.DisplayDevices.RECT lprcTo)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcToLocal = &lprcTo)
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcFromLocal = &lprcFrom)
                {
                    bool __result = User32.DrawAnimatedRects(hwnd, idAni, lprcFromLocal, lprcToLocal);
                    return __result;
                }
            }
        }

        /// <summary>Animates the caption of a window to indicate the opening of an icon or the minimizing or maximizing of a window.</summary>
        /// <param name = "hwnd">A handle to the window whose caption should be animated on the screen. The animation will be clipped to the parent of this window.</param>
        /// <param name = "idAni">The type of animation. This must be IDANI_CAPTION. With the IDANI_CAPTION animation type, the window caption will animate from the position specified by lprcFrom to the position specified by lprcTo. The effect is similar to minimizing or maximizing a window.</param>
        /// <param name = "lprcFrom">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure specifying the location and size of the icon or minimized window. Coordinates are relative to the clipping window <i>hwnd</i>.</param>
        /// <param name = "lprcTo">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure specifying the location and size of the restored window. Coordinates are relative to the clipping window <i>hwnd</i>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawanimatedrects">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool DrawAnimatedRects(win32.UI.WindowsAndMessaging.HWND hwnd, int idAni, win32.UI.DisplayDevices.RECT*lprcFrom, win32.UI.DisplayDevices.RECT*lprcTo);
        /// <inheritdoc cref = "DrawText(win32.Graphics.Gdi.HDC, win32.System.SystemServices.PCWSTR, int, win32.UI.DisplayDevices.RECT*, win32.Graphics.Gdi.DRAW_TEXT_FORMAT)"/>
        internal static unsafe int DrawText(SafeHandle hdc, string lpchText, int cchText, ref win32.UI.DisplayDevices.RECT lprc, win32.Graphics.Gdi.DRAW_TEXT_FORMAT format)
        {
            bool hdcAddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
                {
                    fixed (char *lpchTextLocal = lpchText)
                    {
                        win32.Graphics.Gdi.HDC hdcLocal;
                        if (hdc is object)
                        {
                            hdc.DangerousAddRef(ref hdcAddRef);
                            hdcLocal = (win32.Graphics.Gdi.HDC)hdc.DangerousGetHandle();
                        }
                        else
                            hdcLocal = default(win32.Graphics.Gdi.HDC);
                        int __result = User32.DrawText(hdcLocal, lpchTextLocal, cchText, lprcLocal, format);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hdcAddRef)
                    hdc.DangerousRelease();
            }
        }

        /// <summary>The DrawText function draws formatted text in the specified rectangle. It formats the text according to the specified method (expanding tabs, justifying characters, breaking lines, and so forth).</summary>
        /// <param name = "hdc">A handle to the device context.</param>
        /// <param name = "lpchText">
        /// <para>A pointer to the string that specifies the text to be drawn. If the <i>nCount</i> parameter is -1, the string must be null-terminated.</para>
        /// <para>If <i>uFormat</i> includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer containing the string should be large enough to accommodate these extra characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawtextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchText">The length, in characters, of the string. If <i>nCount</i> is -1, then the <i>lpchText</i> parameter is assumed to be a pointer to a null-terminated string and <b>DrawText</b> computes the character count automatically.</param>
        /// <param name = "lprc">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the rectangle (in logical coordinates) in which the text is to be formatted.</param>
        /// <param name = "format"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from <code>lpRect-&gt;top</code> to the bottom of the drawn text</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawtextw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DrawTextW")]
        internal static extern unsafe int DrawText(win32.Graphics.Gdi.HDC hdc, win32.System.SystemServices.PCWSTR lpchText, int cchText, win32.UI.DisplayDevices.RECT*lprc, win32.Graphics.Gdi.DRAW_TEXT_FORMAT format);
        /// <inheritdoc cref = "DrawTextEx(win32.Graphics.Gdi.HDC, win32.System.SystemServices.PWSTR, int, win32.UI.DisplayDevices.RECT*, win32.Graphics.Gdi.DRAW_TEXT_FORMAT, win32.Graphics.Gdi.DRAWTEXTPARAMS*)"/>
        internal static unsafe int DrawTextEx(SafeHandle hdc, win32.System.SystemServices.PWSTR lpchText, int cchText, ref win32.UI.DisplayDevices.RECT lprc, win32.Graphics.Gdi.DRAW_TEXT_FORMAT format, win32.Graphics.Gdi.DRAWTEXTPARAMS? lpdtp)
        {
            bool hdcAddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
                {
                    win32.Graphics.Gdi.HDC hdcLocal;
                    if (hdc is object)
                    {
                        hdc.DangerousAddRef(ref hdcAddRef);
                        hdcLocal = (win32.Graphics.Gdi.HDC)hdc.DangerousGetHandle();
                    }
                    else
                        hdcLocal = default(win32.Graphics.Gdi.HDC);
                    win32.Graphics.Gdi.DRAWTEXTPARAMS lpdtpLocal = lpdtp.HasValue ? lpdtp.Value : default(win32.Graphics.Gdi.DRAWTEXTPARAMS);
                    int __result = User32.DrawTextEx(hdcLocal, lpchText, cchText, lprcLocal, format, lpdtp.HasValue ? &lpdtpLocal : null);
                    return __result;
                }
            }
            finally
            {
                if (hdcAddRef)
                    hdc.DangerousRelease();
            }
        }

        /// <summary>The DrawTextEx function draws formatted text in the specified rectangle.</summary>
        /// <param name = "hdc">A handle to the device context in which to draw.</param>
        /// <param name = "lpchText">
        /// <para>A pointer to the string that contains the text to draw. If the <i>cchText</i> parameter is -1, the string must be null-terminated.</para>
        /// <para>If <i>dwDTFormat</i> includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer containing the string should be large enough to accommodate these extra characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawtextexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchText">The <a href = "https://docs.microsoft.com/windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpchText</i>. If <i>cchText</i> is -1, then the <i>lpchText</i> parameter is assumed to be a pointer to a null-terminated string and <b>DrawTextEx</b> computes the character count automatically.</param>
        /// <param name = "lprc">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted.</param>
        /// <param name = "format"></param>
        /// <param name = "lpdtp">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-drawtextparams">DRAWTEXTPARAMS</a> structure that specifies additional formatting options. This parameter can be <b>NULL</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the text height in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from <code>lprc-&gt;top</code> to the bottom of the drawn text</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawtextexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DrawTextExW")]
        internal static extern unsafe int DrawTextEx(win32.Graphics.Gdi.HDC hdc, win32.System.SystemServices.PWSTR lpchText, int cchText, win32.UI.DisplayDevices.RECT*lprc, win32.Graphics.Gdi.DRAW_TEXT_FORMAT format, [Optional] win32.Graphics.Gdi.DRAWTEXTPARAMS*lpdtp);
        /// <inheritdoc cref = "GrayString(win32.Graphics.Gdi.HDC, win32.Graphics.Gdi.HBRUSH, delegate *unmanaged[Stdcall]{win32.Graphics.Gdi.HDC, win32.UI.WindowsAndMessaging.LPARAM, int, win32.System.SystemServices.BOOL}, win32.UI.WindowsAndMessaging.LPARAM, int, int, int, int, int)"/>
        internal static unsafe bool GrayString(SafeHandle hDC, SafeHandle hBrush, delegate *unmanaged[Stdcall]<win32.Graphics.Gdi.HDC, win32.UI.WindowsAndMessaging.LPARAM, int, win32.System.SystemServices.BOOL>lpOutputFunc, win32.UI.WindowsAndMessaging.LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
        {
            bool hDCAddRef = false;
            bool hBrushAddRef = false;
            try
            {
                win32.Graphics.Gdi.HDC hDCLocal;
                if (hDC is object)
                {
                    hDC.DangerousAddRef(ref hDCAddRef);
                    hDCLocal = (win32.Graphics.Gdi.HDC)hDC.DangerousGetHandle();
                }
                else
                    hDCLocal = default(win32.Graphics.Gdi.HDC);
                win32.Graphics.Gdi.HBRUSH hBrushLocal;
                if (hBrush is object)
                {
                    hBrush.DangerousAddRef(ref hBrushAddRef);
                    hBrushLocal = (win32.Graphics.Gdi.HBRUSH)hBrush.DangerousGetHandle();
                }
                else
                    hBrushLocal = default(win32.Graphics.Gdi.HBRUSH);
                bool __result = User32.GrayString(hDCLocal, hBrushLocal, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
                return __result;
            }
            finally
            {
                if (hDCAddRef)
                    hDC.DangerousRelease();
                if (hBrushAddRef)
                    hBrush.DangerousRelease();
            }
        }

        /// <summary>The GrayString function draws gray text at the specified location.</summary>
        /// <param name = "hDC">A handle to the device context.</param>
        /// <param name = "hBrush">A handle to the brush to be used for graying. If this parameter is <b>NULL</b>, the text is grayed with the same brush that was used to draw window text.</param>
        /// <param name = "lpOutputFunc">A pointer to the application-defined function that will draw the string, or, if <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-textouta">TextOut</a> is to be used to draw the string, it is a <b>NULL</b> pointer. For details, see the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-graystringproc">OutputProc</a> callback function.</param>
        /// <param name = "lpData">A pointer to data to be passed to the output function. If the <i>lpOutputFunc</i> parameter is <b>NULL</b>, <i>lpData</i> must be a pointer to the string to be output.</param>
        /// <param name = "nCount">The number of characters to be output. If the <i>nCount</i> parameter is zero, <b>GrayString</b> calculates the length of the string (assuming <i>lpData</i> is a pointer to the string). If <i>nCount</i> is 1 and the function pointed to by <i>lpOutputFunc</i> returns <b>FALSE</b>, the image is shown but not grayed.</param>
        /// <param name = "X">The device x-coordinate of the starting position of the rectangle that encloses the string.</param>
        /// <param name = "Y">The device y-coordinate of the starting position of the rectangle that encloses the string.</param>
        /// <param name = "nWidth">The width, in device units, of the rectangle that encloses the string. If this parameter is zero, <b>GrayString</b> calculates the width of the area, assuming <i>lpData</i> is a pointer to the string.</param>
        /// <param name = "nHeight">The height, in device units, of the rectangle that encloses the string. If this parameter is zero, <b>GrayString</b> calculates the height of the area, assuming <i>lpData</i> is a pointer to the string.</param>
        /// <returns>
        /// <para>If the string is drawn, the return value is nonzero.</para>
        /// <para>If either the <a href = "/windows/desktop/api/wingdi/nf-wingdi-textouta">TextOut</a> function or the application-defined output function returned zero, or there was insufficient memory to create a memory bitmap for graying, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-graystringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GrayStringW")]
        internal static extern unsafe bool GrayString(win32.Graphics.Gdi.HDC hDC, win32.Graphics.Gdi.HBRUSH hBrush, delegate *unmanaged[Stdcall]<win32.Graphics.Gdi.HDC, win32.UI.WindowsAndMessaging.LPARAM, int, win32.System.SystemServices.BOOL>lpOutputFunc, win32.UI.WindowsAndMessaging.LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight);
        /// <inheritdoc cref = "DrawState(win32.Graphics.Gdi.HDC, win32.Graphics.Gdi.HBRUSH, delegate *unmanaged[Stdcall]{win32.Graphics.Gdi.HDC, win32.UI.WindowsAndMessaging.LPARAM, win32.UI.WindowsAndMessaging.WPARAM, int, int, win32.System.SystemServices.BOOL}, win32.UI.WindowsAndMessaging.LPARAM, win32.UI.WindowsAndMessaging.WPARAM, int, int, int, int, win32.Graphics.Gdi.DRAWSTATE_FLAGS)"/>
        internal static unsafe bool DrawState(SafeHandle hdc, SafeHandle hbrFore, delegate *unmanaged[Stdcall]<win32.Graphics.Gdi.HDC, win32.UI.WindowsAndMessaging.LPARAM, win32.UI.WindowsAndMessaging.WPARAM, int, int, win32.System.SystemServices.BOOL>qfnCallBack, win32.UI.WindowsAndMessaging.LPARAM lData, win32.UI.WindowsAndMessaging.WPARAM wData, int x, int y, int cx, int cy, win32.Graphics.Gdi.DRAWSTATE_FLAGS uFlags)
        {
            bool hdcAddRef = false;
            bool hbrForeAddRef = false;
            try
            {
                win32.Graphics.Gdi.HDC hdcLocal;
                if (hdc is object)
                {
                    hdc.DangerousAddRef(ref hdcAddRef);
                    hdcLocal = (win32.Graphics.Gdi.HDC)hdc.DangerousGetHandle();
                }
                else
                    hdcLocal = default(win32.Graphics.Gdi.HDC);
                win32.Graphics.Gdi.HBRUSH hbrForeLocal;
                if (hbrFore is object)
                {
                    hbrFore.DangerousAddRef(ref hbrForeAddRef);
                    hbrForeLocal = (win32.Graphics.Gdi.HBRUSH)hbrFore.DangerousGetHandle();
                }
                else
                    hbrForeLocal = default(win32.Graphics.Gdi.HBRUSH);
                bool __result = User32.DrawState(hdcLocal, hbrForeLocal, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
                return __result;
            }
            finally
            {
                if (hdcAddRef)
                    hdc.DangerousRelease();
                if (hbrForeAddRef)
                    hbrFore.DangerousRelease();
            }
        }

        /// <summary>The DrawState function displays an image and applies a visual effect to indicate a state, such as a disabled or default state.</summary>
        /// <param name = "hdc">A handle to the device context to draw in.</param>
        /// <param name = "hbrFore">A handle to the brush used to draw the image, if the state specified by the <i>fuFlags</i> parameter is DSS_MONO. This parameter is ignored for other states.</param>
        /// <param name = "qfnCallBack">A pointer to an application-defined callback function used to render the image. This parameter is required if the image type in <i>fuFlags</i> is DST_COMPLEX. It is optional and can be <b>NULL</b> if the image type is DST_TEXT. For all other image types, this parameter is ignored. For more information about the callback function, see the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-drawstateproc">DrawStateProc</a> function.</param>
        /// <param name = "lData">Information about the image. The meaning of this parameter depends on the image type.</param>
        /// <param name = "wData">Information about the image. The meaning of this parameter depends on the image type. It is, however, zero extended for use with the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-drawstateproc">DrawStateProc</a> function.</param>
        /// <param name = "x">The horizontal location, in device units, at which to draw the image.</param>
        /// <param name = "y">The vertical location, in device units, at which to draw the image.</param>
        /// <param name = "cx">The width of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero to calculate the width of the image.</param>
        /// <param name = "cy">The height of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero to calculate the height of the image.</param>
        /// <param name = "uFlags">
        /// <para>The image type and state. This parameter can be one of the following type values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawstatew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawstatew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "DrawStateW")]
        internal static extern unsafe bool DrawState(win32.Graphics.Gdi.HDC hdc, win32.Graphics.Gdi.HBRUSH hbrFore, delegate *unmanaged[Stdcall]<win32.Graphics.Gdi.HDC, win32.UI.WindowsAndMessaging.LPARAM, win32.UI.WindowsAndMessaging.WPARAM, int, int, win32.System.SystemServices.BOOL>qfnCallBack, win32.UI.WindowsAndMessaging.LPARAM lData, win32.UI.WindowsAndMessaging.WPARAM wData, int x, int y, int cx, int cy, win32.Graphics.Gdi.DRAWSTATE_FLAGS uFlags);
        /// <inheritdoc cref = "TabbedTextOut(win32.Graphics.Gdi.HDC, int, int, win32.System.SystemServices.PCWSTR, int, int, int *, int)"/>
        internal static unsafe int TabbedTextOut(SafeHandle hdc, int x, int y, string lpString, int chCount, ReadOnlySpan<int> lpnTabStopPositions, int nTabOrigin)
        {
            bool hdcAddRef = false;
            try
            {
                fixed (int *lpnTabStopPositionsLocal = lpnTabStopPositions)
                {
                    fixed (char *lpStringLocal = lpString)
                    {
                        win32.Graphics.Gdi.HDC hdcLocal;
                        if (hdc is object)
                        {
                            hdc.DangerousAddRef(ref hdcAddRef);
                            hdcLocal = (win32.Graphics.Gdi.HDC)hdc.DangerousGetHandle();
                        }
                        else
                            hdcLocal = default(win32.Graphics.Gdi.HDC);
                        int __result = User32.TabbedTextOut(hdcLocal, x, y, lpStringLocal, chCount, lpnTabStopPositions.Length, lpnTabStopPositionsLocal, nTabOrigin);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hdcAddRef)
                    hdc.DangerousRelease();
            }
        }

        /// <summary>The TabbedTextOut function writes a character string at a specified location, expanding tabs to the values specified in an array of tab-stop positions. Text is written in the currently selected font, background color, and text color.</summary>
        /// <param name = "hdc">A handle to the device context.</param>
        /// <param name = "x">The x-coordinate of the starting point of the string, in logical units.</param>
        /// <param name = "y">The y-coordinate of the starting point of the string, in logical units.</param>
        /// <param name = "lpString">A pointer to the character string to draw. The string does not need to be zero-terminated, since <i>nCount</i> specifies the length of the string.</param>
        /// <param name = "chCount">The <a href = "https://docs.microsoft.com/windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</param>
        /// <param name = "nTabPositions">The number of values in the array of tab-stop positions.</param>
        /// <param name = "lpnTabStopPositions">A pointer to an array containing the tab-stop positions, in logical units. The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array.</param>
        /// <param name = "nTabOrigin">The x-coordinate of the starting position from which tabs are expanded, in logical units.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the dimensions, in logical units, of the string. The height is in the high-order word and the width is in the low-order word.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-tabbedtextoutw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "TabbedTextOutW")]
        internal static extern unsafe int TabbedTextOut(win32.Graphics.Gdi.HDC hdc, int x, int y, win32.System.SystemServices.PCWSTR lpString, int chCount, int nTabPositions, [Optional] int *lpnTabStopPositions, int nTabOrigin);
        /// <inheritdoc cref = "GetTabbedTextExtent(win32.Graphics.Gdi.HDC, win32.System.SystemServices.PCWSTR, int, int, int *)"/>
        internal static unsafe uint GetTabbedTextExtent(SafeHandle hdc, string lpString, int chCount, ReadOnlySpan<int> lpnTabStopPositions)
        {
            bool hdcAddRef = false;
            try
            {
                fixed (int *lpnTabStopPositionsLocal = lpnTabStopPositions)
                {
                    fixed (char *lpStringLocal = lpString)
                    {
                        win32.Graphics.Gdi.HDC hdcLocal;
                        if (hdc is object)
                        {
                            hdc.DangerousAddRef(ref hdcAddRef);
                            hdcLocal = (win32.Graphics.Gdi.HDC)hdc.DangerousGetHandle();
                        }
                        else
                            hdcLocal = default(win32.Graphics.Gdi.HDC);
                        uint __result = User32.GetTabbedTextExtent(hdcLocal, lpStringLocal, chCount, lpnTabStopPositions.Length, lpnTabStopPositionsLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hdcAddRef)
                    hdc.DangerousRelease();
            }
        }

        /// <summary>The GetTabbedTextExtent function computes the width and height of a character string.</summary>
        /// <param name = "hdc">A handle to the device context.</param>
        /// <param name = "lpString">A pointer to a character string.</param>
        /// <param name = "chCount">The length of the text string. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</param>
        /// <param name = "nTabPositions">The number of tab-stop positions in the array pointed to by the <i>lpnTabStopPositions</i> parameter.</param>
        /// <param name = "lpnTabStopPositions">A pointer to an array containing the tab-stop positions, in device units. The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the dimensions of the string in logical units. The height is in the high-order word and the width is in the low-order word.</para>
        /// <para>If the function fails, the return value is 0. <b>GetTabbedTextExtent</b> will fail if <i>hDC</i> is invalid and if <i>nTabPositions</i> is less than 0.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-gettabbedtextextentw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetTabbedTextExtentW")]
        internal static extern unsafe uint GetTabbedTextExtent(win32.Graphics.Gdi.HDC hdc, win32.System.SystemServices.PCWSTR lpString, int chCount, int nTabPositions, [Optional] int *lpnTabStopPositions);
        /// <summary>The UpdateWindow function updates the client area of the specified window by sending a WM_PAINT message to the window if the window's update region is not empty.</summary>
        /// <param name = "hWnd">Handle to the window to be updated.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-updatewindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool UpdateWindow(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <inheritdoc cref = "PaintDesktop(win32.Graphics.Gdi.HDC)"/>
        internal static unsafe bool PaintDesktop(SafeHandle hdc)
        {
            bool hdcAddRef = false;
            try
            {
                win32.Graphics.Gdi.HDC hdcLocal;
                if (hdc is object)
                {
                    hdc.DangerousAddRef(ref hdcAddRef);
                    hdcLocal = (win32.Graphics.Gdi.HDC)hdc.DangerousGetHandle();
                }
                else
                    hdcLocal = default(win32.Graphics.Gdi.HDC);
                bool __result = User32.PaintDesktop(hdcLocal);
                return __result;
            }
            finally
            {
                if (hdcAddRef)
                    hdc.DangerousRelease();
            }
        }

        /// <summary>The PaintDesktop function fills the clipping region in the specified device context with the desktop pattern or wallpaper. The function is provided primarily for shell desktops.</summary>
        /// <param name = "hdc">Handle to the device context.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-paintdesktop">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool PaintDesktop(win32.Graphics.Gdi.HDC hdc);
        /// <inheritdoc cref = "WindowFromDC(win32.Graphics.Gdi.HDC)"/>
        internal static unsafe win32.UI.WindowsAndMessaging.HWND WindowFromDC(SafeHandle hDC)
        {
            bool hDCAddRef = false;
            try
            {
                win32.Graphics.Gdi.HDC hDCLocal;
                if (hDC is object)
                {
                    hDC.DangerousAddRef(ref hDCAddRef);
                    hDCLocal = (win32.Graphics.Gdi.HDC)hDC.DangerousGetHandle();
                }
                else
                    hDCLocal = default(win32.Graphics.Gdi.HDC);
                win32.UI.WindowsAndMessaging.HWND __result = User32.WindowFromDC(hDCLocal);
                return __result;
            }
            finally
            {
                if (hDCAddRef)
                    hDC.DangerousRelease();
            }
        }

        /// <summary>The WindowFromDC function returns a handle to the window associated with the specified display device context (DC). Output functions that use the specified device context draw into this window.</summary>
        /// <param name = "hDC">Handle to the device context from which a handle to the associated window is to be retrieved.</param>
        /// <returns>The return value is a handle to the window associated with the specified DC. If no window is associated with the specified DC, the return value is <b>NULL</b>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-windowfromdc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND WindowFromDC(win32.Graphics.Gdi.HDC hDC);
        /// <summary>The GetDC function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen.</summary>
        /// <param name = "hWnd">A handle to the window whose DC is to be retrieved. If this value is <b>NULL</b>, <b>GetDC</b> retrieves the DC for the entire screen.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the DC for the specified window's client area.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.Graphics.Gdi.HDC GetDC(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <inheritdoc cref = "GetDCEx(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.HRGN, win32.Graphics.Gdi.GET_DCX_FLAGS)"/>
        internal static unsafe win32.Graphics.Gdi.HDC GetDCEx(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hrgnClip, win32.Graphics.Gdi.GET_DCX_FLAGS flags)
        {
            bool hrgnClipAddRef = false;
            try
            {
                win32.Graphics.Gdi.HRGN hrgnClipLocal;
                if (hrgnClip is object)
                {
                    hrgnClip.DangerousAddRef(ref hrgnClipAddRef);
                    hrgnClipLocal = (win32.Graphics.Gdi.HRGN)hrgnClip.DangerousGetHandle();
                }
                else
                    hrgnClipLocal = default(win32.Graphics.Gdi.HRGN);
                win32.Graphics.Gdi.HDC __result = User32.GetDCEx(hWnd, hrgnClipLocal, flags);
                return __result;
            }
            finally
            {
                if (hrgnClipAddRef)
                    hrgnClip.DangerousRelease();
            }
        }

        /// <summary>The GetDCEx function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen.</summary>
        /// <param name = "hWnd">A handle to the window whose DC is to be retrieved. If this value is <b>NULL</b>, <b>GetDCEx</b> retrieves the DC for the entire screen.</param>
        /// <param name = "hrgnClip">A clipping region that may be combined with the visible region of the DC. If the value of <i>flags</i> is DCX_INTERSECTRGN or DCX_EXCLUDERGN, then the operating system assumes ownership of the region and will automatically delete it when it is no longer needed. In this case, the application should not use or delete the region after a successful call to <b>GetDCEx</b>.</param>
        /// <param name = "flags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the handle to the DC for the specified window.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. An invalid value for the <i>hWnd</i> parameter will cause the function to fail.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getdcex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.Graphics.Gdi.HDC GetDCEx(win32.UI.WindowsAndMessaging.HWND hWnd, win32.Graphics.Gdi.HRGN hrgnClip, win32.Graphics.Gdi.GET_DCX_FLAGS flags);
        /// <summary>The GetWindowDC function retrieves the device context (DC) for the entire window, including title bar, menus, and scroll bars.</summary>
        /// <param name = "hWnd">
        /// <para>A handle to the window with a device context that is to be retrieved. If this value is <b>NULL</b>, <b>GetWindowDC</b> retrieves the device context for the entire screen.</para>
        /// <para>If this parameter is <b>NULL</b>, <b>GetWindowDC</b> retrieves the device context for the primary display monitor. To get the device context for other display monitors, use the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumdisplaymonitors">EnumDisplayMonitors</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createdca">CreateDC</a> functions.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowdc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to a device context for the specified window.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>, indicating an error or an invalid <i>hWnd</i> parameter.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowdc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.Graphics.Gdi.HDC GetWindowDC(win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <inheritdoc cref = "BeginPaint(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.PAINTSTRUCT*)"/>
        internal static unsafe win32.Graphics.Gdi.HDC BeginPaint(win32.UI.WindowsAndMessaging.HWND hWnd, out win32.Graphics.Gdi.PAINTSTRUCT lpPaint)
        {
            fixed (win32.Graphics.Gdi.PAINTSTRUCT*lpPaintLocal = &lpPaint)
            {
                win32.Graphics.Gdi.HDC __result = User32.BeginPaint(hWnd, lpPaintLocal);
                return __result;
            }
        }

        /// <summary>The BeginPaint function prepares the specified window for painting and fills a PAINTSTRUCT structure with information about the painting.</summary>
        /// <param name = "hWnd">Handle to the window to be repainted.</param>
        /// <param name = "lpPaint">Pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-paintstruct">PAINTSTRUCT</a> structure that will receive painting information.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the handle to a display device context for the specified window.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>, indicating that no display device context is available.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-beginpaint">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe win32.Graphics.Gdi.HDC BeginPaint(win32.UI.WindowsAndMessaging.HWND hWnd, win32.Graphics.Gdi.PAINTSTRUCT*lpPaint);
        /// <inheritdoc cref = "EndPaint(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.PAINTSTRUCT*)"/>
        internal static unsafe bool EndPaint(win32.UI.WindowsAndMessaging.HWND hWnd, in win32.Graphics.Gdi.PAINTSTRUCT lpPaint)
        {
            fixed (win32.Graphics.Gdi.PAINTSTRUCT*lpPaintLocal = &lpPaint)
            {
                bool __result = User32.EndPaint(hWnd, lpPaintLocal);
                return __result;
            }
        }

        /// <summary>The EndPaint function marks the end of painting in the specified window. This function is required for each call to the BeginPaint function, but only after painting is complete.</summary>
        /// <param name = "hWnd">Handle to the window that has been repainted.</param>
        /// <param name = "lpPaint">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-paintstruct">PAINTSTRUCT</a> structure that contains the painting information retrieved by <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-beginpaint">BeginPaint</a>.</param>
        /// <returns>The return value is always nonzero.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-endpaint">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool EndPaint(win32.UI.WindowsAndMessaging.HWND hWnd, win32.Graphics.Gdi.PAINTSTRUCT*lpPaint);
        /// <summary>The GetUpdateRect function retrieves the coordinates of the smallest rectangle that completely encloses the update region of the specified window.</summary>
        /// <param name = "hWnd">Handle to the window whose update region is to be retrieved.</param>
        /// <param name = "lpRect">
        /// <para>Pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the coordinates, in device units, of the enclosing rectangle.</para>
        /// <para>An application can set this parameter to <b>NULL</b> to determine whether an update region exists for the window. If this parameter is <b>NULL</b>, <b>GetUpdateRect</b> returns nonzero if an update region exists, and zero if one does not. This provides a simple and efficient means of determining whether a <b>WM_PAINT</b> message resulted from an invalid area.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getupdaterect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bErase">Specifies whether the background in the update region is to be erased. If this parameter is <b>TRUE</b> and the update region is not empty, <b>GetUpdateRect</b> sends a <b>WM_ERASEBKGND</b> message to the specified window to erase the background.</param>
        /// <returns>
        /// <para>If the update region is not empty, the return value is nonzero.</para>
        /// <para>If there is no update region, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getupdaterect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool GetUpdateRect(win32.UI.WindowsAndMessaging.HWND hWnd, [Optional] win32.UI.DisplayDevices.RECT*lpRect, bool bErase);
        /// <inheritdoc cref = "GetUpdateRgn(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.HRGN, bool)"/>
        internal static unsafe int GetUpdateRgn(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hRgn, bool bErase)
        {
            bool hRgnAddRef = false;
            try
            {
                win32.Graphics.Gdi.HRGN hRgnLocal;
                if (hRgn is object)
                {
                    hRgn.DangerousAddRef(ref hRgnAddRef);
                    hRgnLocal = (win32.Graphics.Gdi.HRGN)hRgn.DangerousGetHandle();
                }
                else
                    hRgnLocal = default(win32.Graphics.Gdi.HRGN);
                int __result = User32.GetUpdateRgn(hWnd, hRgnLocal, bErase);
                return __result;
            }
            finally
            {
                if (hRgnAddRef)
                    hRgn.DangerousRelease();
            }
        }

        /// <summary>The GetUpdateRgn function retrieves the update region of a window by copying it into the specified region. The coordinates of the update region are relative to the upper-left corner of the window (that is, they are client coordinates).</summary>
        /// <param name = "hWnd">Handle to the window with an update region that is to be retrieved.</param>
        /// <param name = "hRgn">Handle to the region to receive the update region.</param>
        /// <param name = "bErase">Specifies whether the window background should be erased and whether nonclient areas of child windows should be drawn. If this parameter is <b>FALSE</b>, no drawing is done.</param>
        /// <returns>
        /// <para>The return value indicates the complexity of the resulting region; it can be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getupdatergn">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern int GetUpdateRgn(win32.UI.WindowsAndMessaging.HWND hWnd, win32.Graphics.Gdi.HRGN hRgn, bool bErase);
        /// <inheritdoc cref = "SetWindowRgn(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.HRGN, bool)"/>
        internal static unsafe int SetWindowRgn(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hRgn, bool bRedraw)
        {
            bool hRgnAddRef = false;
            try
            {
                win32.Graphics.Gdi.HRGN hRgnLocal;
                if (hRgn is object)
                {
                    hRgn.DangerousAddRef(ref hRgnAddRef);
                    hRgnLocal = (win32.Graphics.Gdi.HRGN)hRgn.DangerousGetHandle();
                }
                else
                    hRgnLocal = default(win32.Graphics.Gdi.HRGN);
                int __result = User32.SetWindowRgn(hWnd, hRgnLocal, bRedraw);
                return __result;
            }
            finally
            {
                if (hRgnAddRef)
                    hRgn.DangerousRelease();
            }
        }

        /// <summary>The SetWindowRgn function sets the window region of a window.</summary>
        /// <param name = "hWnd">A handle to the window whose window region is to be set.</param>
        /// <param name = "hRgn">
        /// <para>A handle to a region. The function sets the window region of the window to this region.</para>
        /// <para>If <i>hRgn</i> is <b>NULL</b>, the function sets the window region to <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowrgn#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bRedraw">
        /// <para>Specifies whether the system redraws the window after setting the window region. If <i>bRedraw</i> is <b>TRUE</b>, the system does so; otherwise, it does not.</para>
        /// <para>Typically, you set <i>bRedraw</i> to <b>TRUE</b> if the window is visible.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowrgn#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowrgn">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern int SetWindowRgn(win32.UI.WindowsAndMessaging.HWND hWnd, win32.Graphics.Gdi.HRGN hRgn, bool bRedraw);
        /// <inheritdoc cref = "GetWindowRgn(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.HRGN)"/>
        internal static unsafe int GetWindowRgn(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hRgn)
        {
            bool hRgnAddRef = false;
            try
            {
                win32.Graphics.Gdi.HRGN hRgnLocal;
                if (hRgn is object)
                {
                    hRgn.DangerousAddRef(ref hRgnAddRef);
                    hRgnLocal = (win32.Graphics.Gdi.HRGN)hRgn.DangerousGetHandle();
                }
                else
                    hRgnLocal = default(win32.Graphics.Gdi.HRGN);
                int __result = User32.GetWindowRgn(hWnd, hRgnLocal);
                return __result;
            }
            finally
            {
                if (hRgnAddRef)
                    hRgn.DangerousRelease();
            }
        }

        /// <summary>The GetWindowRgn function obtains a copy of the window region of a window.</summary>
        /// <param name = "hWnd">Handle to the window whose window region is to be obtained.</param>
        /// <param name = "hRgn">Handle to the region which will be modified to represent the window region.</param>
        /// <returns>
        /// <para>The return value specifies the type of the region that the function obtains. It can be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowrgn">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern int GetWindowRgn(win32.UI.WindowsAndMessaging.HWND hWnd, win32.Graphics.Gdi.HRGN hRgn);
        /// <inheritdoc cref = "GetWindowRgnBox(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe int GetWindowRgnBox(win32.UI.WindowsAndMessaging.HWND hWnd, out win32.UI.DisplayDevices.RECT lprc)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
            {
                int __result = User32.GetWindowRgnBox(hWnd, lprcLocal);
                return __result;
            }
        }

        /// <summary>The GetWindowRgnBox function retrieves the dimensions of the tightest bounding rectangle for the window region of a window.</summary>
        /// <param name = "hWnd">Handle to the window.</param>
        /// <param name = "lprc">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the rectangle dimensions, in device units relative to the upper-left corner of the window.</param>
        /// <returns>
        /// <para>The return value specifies the type of the region that the function obtains. It can be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowrgnbox">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int GetWindowRgnBox(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.RECT*lprc);
        /// <inheritdoc cref = "ExcludeUpdateRgn(win32.Graphics.Gdi.HDC, win32.UI.WindowsAndMessaging.HWND)"/>
        internal static unsafe int ExcludeUpdateRgn(SafeHandle hDC, win32.UI.WindowsAndMessaging.HWND hWnd)
        {
            bool hDCAddRef = false;
            try
            {
                win32.Graphics.Gdi.HDC hDCLocal;
                if (hDC is object)
                {
                    hDC.DangerousAddRef(ref hDCAddRef);
                    hDCLocal = (win32.Graphics.Gdi.HDC)hDC.DangerousGetHandle();
                }
                else
                    hDCLocal = default(win32.Graphics.Gdi.HDC);
                int __result = User32.ExcludeUpdateRgn(hDCLocal, hWnd);
                return __result;
            }
            finally
            {
                if (hDCAddRef)
                    hDC.DangerousRelease();
            }
        }

        /// <summary>The ExcludeUpdateRgn function prevents drawing within invalid areas of a window by excluding an updated region in the window from a clipping region.</summary>
        /// <param name = "hDC">Handle to the device context associated with the clipping region.</param>
        /// <param name = "hWnd">Handle to the window to update.</param>
        /// <returns>
        /// <para>The return value specifies the complexity of the excluded region; it can be any one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-excludeupdatergn">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern int ExcludeUpdateRgn(win32.Graphics.Gdi.HDC hDC, win32.UI.WindowsAndMessaging.HWND hWnd);
        /// <inheritdoc cref = "InvalidateRect(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.RECT*, bool)"/>
        internal static unsafe bool InvalidateRect(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.RECT? lpRect, bool bErase)
        {
            win32.UI.DisplayDevices.RECT lpRectLocal = lpRect.HasValue ? lpRect.Value : default(win32.UI.DisplayDevices.RECT);
            bool __result = User32.InvalidateRect(hWnd, lpRect.HasValue ? &lpRectLocal : null, bErase);
            return __result;
        }

        /// <summary>The InvalidateRect function adds a rectangle to the specified window's update region. The update region represents the portion of the window's client area that must be redrawn.</summary>
        /// <param name = "hWnd">A handle to the window whose update region has changed. If this parameter is <b>NULL</b>, the system invalidates and redraws all windows, not just the windows for this application, and sends the <a href = "https://docs.microsoft.com/windows/desktop/winmsg/wm-erasebkgnd">WM_ERASEBKGND</a> and <a href = "https://docs.microsoft.com/windows/desktop/gdi/wm-ncpaint">WM_NCPAINT</a> messages before the function returns. Setting this parameter to <b>NULL</b> is not recommended.</param>
        /// <param name = "lpRect">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the client coordinates of the rectangle to be added to the update region. If this parameter is <b>NULL</b>, the entire client area is added to the update region.</param>
        /// <param name = "bErase">Specifies whether the background within the update region is to be erased when the update region is processed. If this parameter is <b>TRUE</b>, the background is erased when the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-beginpaint">BeginPaint</a> function is called. If this parameter is <b>FALSE</b>, the background remains unchanged.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-invalidaterect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool InvalidateRect(win32.UI.WindowsAndMessaging.HWND hWnd, [Optional] win32.UI.DisplayDevices.RECT*lpRect, bool bErase);
        /// <inheritdoc cref = "ValidateRect(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool ValidateRect(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.RECT? lpRect)
        {
            win32.UI.DisplayDevices.RECT lpRectLocal = lpRect.HasValue ? lpRect.Value : default(win32.UI.DisplayDevices.RECT);
            bool __result = User32.ValidateRect(hWnd, lpRect.HasValue ? &lpRectLocal : null);
            return __result;
        }

        /// <summary>The ValidateRect function validates the client area within a rectangle by removing the rectangle from the update region of the specified window.</summary>
        /// <param name = "hWnd">Handle to the window whose update region is to be modified. If this parameter is <b>NULL</b>, the system invalidates and redraws all windows and sends the <b>WM_ERASEBKGND</b> and <b>WM_NCPAINT</b> messages to the window procedure before the function returns.</param>
        /// <param name = "lpRect">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the client coordinates of the rectangle to be removed from the update region. If this parameter is <b>NULL</b>, the entire client area is removed.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-validaterect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool ValidateRect(win32.UI.WindowsAndMessaging.HWND hWnd, [Optional] win32.UI.DisplayDevices.RECT*lpRect);
        /// <inheritdoc cref = "InvalidateRgn(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.HRGN, bool)"/>
        internal static unsafe bool InvalidateRgn(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hRgn, bool bErase)
        {
            bool hRgnAddRef = false;
            try
            {
                win32.Graphics.Gdi.HRGN hRgnLocal;
                if (hRgn is object)
                {
                    hRgn.DangerousAddRef(ref hRgnAddRef);
                    hRgnLocal = (win32.Graphics.Gdi.HRGN)hRgn.DangerousGetHandle();
                }
                else
                    hRgnLocal = default(win32.Graphics.Gdi.HRGN);
                bool __result = User32.InvalidateRgn(hWnd, hRgnLocal, bErase);
                return __result;
            }
            finally
            {
                if (hRgnAddRef)
                    hRgn.DangerousRelease();
            }
        }

        /// <summary>The InvalidateRgn function invalidates the client area within the specified region by adding it to the current update region of a window.</summary>
        /// <param name = "hWnd">A handle to the window with an update region that is to be modified.</param>
        /// <param name = "hRgn">A handle to the region to be added to the update region. The region is assumed to have client coordinates. If this parameter is <b>NULL</b>, the entire client area is added to the update region.</param>
        /// <param name = "bErase">Specifies whether the background within the update region should be erased when the update region is processed. If this parameter is <b>TRUE</b>, the background is erased when the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-beginpaint">BeginPaint</a> function is called. If the parameter is <b>FALSE</b>, the background remains unchanged.</param>
        /// <returns>The return value is always nonzero.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-invalidatergn">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool InvalidateRgn(win32.UI.WindowsAndMessaging.HWND hWnd, win32.Graphics.Gdi.HRGN hRgn, bool bErase);
        /// <inheritdoc cref = "ValidateRgn(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.HRGN)"/>
        internal static unsafe bool ValidateRgn(win32.UI.WindowsAndMessaging.HWND hWnd, SafeHandle hRgn)
        {
            bool hRgnAddRef = false;
            try
            {
                win32.Graphics.Gdi.HRGN hRgnLocal;
                if (hRgn is object)
                {
                    hRgn.DangerousAddRef(ref hRgnAddRef);
                    hRgnLocal = (win32.Graphics.Gdi.HRGN)hRgn.DangerousGetHandle();
                }
                else
                    hRgnLocal = default(win32.Graphics.Gdi.HRGN);
                bool __result = User32.ValidateRgn(hWnd, hRgnLocal);
                return __result;
            }
            finally
            {
                if (hRgnAddRef)
                    hRgn.DangerousRelease();
            }
        }

        /// <summary>The ValidateRgn function validates the client area within a region by removing the region from the current update region of the specified window.</summary>
        /// <param name = "hWnd">Handle to the window whose update region is to be modified.</param>
        /// <param name = "hRgn">Handle to a region that defines the area to be removed from the update region. If this parameter is <b>NULL</b>, the entire client area is removed.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-validatergn">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool ValidateRgn(win32.UI.WindowsAndMessaging.HWND hWnd, win32.Graphics.Gdi.HRGN hRgn);
        /// <inheritdoc cref = "RedrawWindow(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.RECT*, win32.Graphics.Gdi.HRGN, win32.Graphics.Gdi.REDRAW_WINDOW_FLAGS)"/>
        internal static unsafe bool RedrawWindow(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.RECT? lprcUpdate, SafeHandle hrgnUpdate, win32.Graphics.Gdi.REDRAW_WINDOW_FLAGS flags)
        {
            bool hrgnUpdateAddRef = false;
            try
            {
                win32.UI.DisplayDevices.RECT lprcUpdateLocal = lprcUpdate.HasValue ? lprcUpdate.Value : default(win32.UI.DisplayDevices.RECT);
                win32.Graphics.Gdi.HRGN hrgnUpdateLocal;
                if (hrgnUpdate is object)
                {
                    hrgnUpdate.DangerousAddRef(ref hrgnUpdateAddRef);
                    hrgnUpdateLocal = (win32.Graphics.Gdi.HRGN)hrgnUpdate.DangerousGetHandle();
                }
                else
                    hrgnUpdateLocal = default(win32.Graphics.Gdi.HRGN);
                bool __result = User32.RedrawWindow(hWnd, lprcUpdate.HasValue ? &lprcUpdateLocal : null, hrgnUpdateLocal, flags);
                return __result;
            }
            finally
            {
                if (hrgnUpdateAddRef)
                    hrgnUpdate.DangerousRelease();
            }
        }

        /// <summary>The RedrawWindow function updates the specified rectangle or region in a window's client area.</summary>
        /// <param name = "hWnd">A handle to the window to be redrawn. If this parameter is <b>NULL</b>, the desktop window is updated.</param>
        /// <param name = "lprcUpdate">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure containing the coordinates, in device units, of the update rectangle. This parameter is ignored if the <i>hrgnUpdate</i> parameter identifies a region.</param>
        /// <param name = "hrgnUpdate">A handle to the update region. If both the <i>hrgnUpdate</i> and <i>lprcUpdate</i> parameters are <b>NULL</b>, the entire client area is added to the update region.</param>
        /// <param name = "flags">
        /// <para>One or more redraw flags. This parameter can be used to invalidate or validate a window, control repainting, and control which windows are affected by <b>RedrawWindow</b>.</para>
        /// <para>The following flags are used to invalidate the window.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-redrawwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-redrawwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool RedrawWindow(win32.UI.WindowsAndMessaging.HWND hWnd, [Optional] win32.UI.DisplayDevices.RECT*lprcUpdate, win32.Graphics.Gdi.HRGN hrgnUpdate, win32.Graphics.Gdi.REDRAW_WINDOW_FLAGS flags);
        /// <summary>The LockWindowUpdate function disables or enables drawing in the specified window. Only one window can be locked at a time.</summary>
        /// <param name = "hWndLock">The window in which drawing will be disabled. If this parameter is <b>NULL</b>, drawing in the locked window is enabled.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero, indicating that an error occurred or another window was already locked.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-lockwindowupdate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool LockWindowUpdate(win32.UI.WindowsAndMessaging.HWND hWndLock);
        /// <inheritdoc cref = "ClientToScreen(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.POINT*)"/>
        internal static unsafe bool ClientToScreen(win32.UI.WindowsAndMessaging.HWND hWnd, ref win32.UI.DisplayDevices.POINT lpPoint)
        {
            fixed (win32.UI.DisplayDevices.POINT*lpPointLocal = &lpPoint)
            {
                bool __result = User32.ClientToScreen(hWnd, lpPointLocal);
                return __result;
            }
        }

        /// <summary>The ClientToScreen function converts the client-area coordinates of a specified point to screen coordinates.</summary>
        /// <param name = "hWnd">A handle to the window whose client area is used for the conversion.</param>
        /// <param name = "lpPoint">A pointer to a <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that contains the client coordinates to be converted. The new screen coordinates are copied into this structure if the function succeeds.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-clienttoscreen">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool ClientToScreen(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.POINT*lpPoint);
        /// <inheritdoc cref = "ScreenToClient(win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.POINT*)"/>
        internal static unsafe bool ScreenToClient(win32.UI.WindowsAndMessaging.HWND hWnd, ref win32.UI.DisplayDevices.POINT lpPoint)
        {
            fixed (win32.UI.DisplayDevices.POINT*lpPointLocal = &lpPoint)
            {
                bool __result = User32.ScreenToClient(hWnd, lpPointLocal);
                return __result;
            }
        }

        /// <summary>The ScreenToClient function converts the screen coordinates of a specified point on the screen to client-area coordinates.</summary>
        /// <param name = "hWnd">A handle to the window whose client area will be used for the conversion.</param>
        /// <param name = "lpPoint">A pointer to a <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that specifies the screen coordinates to be converted.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-screentoclient">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool ScreenToClient(win32.UI.WindowsAndMessaging.HWND hWnd, win32.UI.DisplayDevices.POINT*lpPoint);
        /// <inheritdoc cref = "MapWindowPoints(win32.UI.WindowsAndMessaging.HWND, win32.UI.WindowsAndMessaging.HWND, win32.UI.DisplayDevices.POINT*, uint)"/>
        internal static unsafe int MapWindowPoints(win32.UI.WindowsAndMessaging.HWND hWndFrom, win32.UI.WindowsAndMessaging.HWND hWndTo, Span<win32.UI.DisplayDevices.POINT> lpPoints)
        {
            fixed (win32.UI.DisplayDevices.POINT*lpPointsLocal = lpPoints)
            {
                int __result = User32.MapWindowPoints(hWndFrom, hWndTo, lpPointsLocal, (uint)lpPoints.Length);
                return __result;
            }
        }

        /// <summary>The MapWindowPoints function converts (maps) a set of points from a coordinate space relative to one window to a coordinate space relative to another window.</summary>
        /// <param name = "hWndFrom">A handle to the window from which points are converted. If this parameter is <b>NULL</b> or HWND_DESKTOP, the points are presumed to be in screen coordinates.</param>
        /// <param name = "hWndTo">A handle to the window to which points are converted. If this parameter is <b>NULL</b> or HWND_DESKTOP, the points are converted to screen coordinates.</param>
        /// <param name = "lpPoints">A pointer to an array of <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structures that contain the set of points to be converted. The points are in device units. This parameter can also point to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure, in which case the <i>cPoints</i> parameter should be set to 2.</param>
        /// <param name = "cPoints">The number of <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structures in the array pointed to by the <i>lpPoints</i> parameter.</param>
        /// <returns>
        /// <para>If the function succeeds, the low-order word of the return value is the number of pixels added to the horizontal coordinate of each source point in order to compute the horizontal coordinate of each destination point. (In addition to that, if precisely one of <i>hWndFrom</i> and <i>hWndTo</i> is mirrored, then each resulting horizontal coordinate is multiplied by -1.) The high-order word is the number of pixels added to the vertical coordinate of each source point in order to compute the vertical coordinate of each destination point.</para>
        /// <para>If the function fails, the return value is zero. Call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> prior to calling this method to differentiate an error return value from a legitimate "0" return value.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-mapwindowpoints">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int MapWindowPoints(win32.UI.WindowsAndMessaging.HWND hWndFrom, win32.UI.WindowsAndMessaging.HWND hWndTo, win32.UI.DisplayDevices.POINT*lpPoints, uint cPoints);
        /// <inheritdoc cref = "GetSysColorBrush(int)"/>
        internal static unsafe Gdi32.DeleteObjectSafeHandle GetSysColorBrush_SafeHandle(int nIndex)
        {
            win32.Graphics.Gdi.HBRUSH __result = User32.GetSysColorBrush(nIndex);
            return new Gdi32.DeleteObjectSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>The GetSysColorBrush function retrieves a handle identifying a logical brush that corresponds to the specified color index.</summary>
        /// <param name = "nIndex">A color index. This value corresponds to the color used to paint one of the window elements. See <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsyscolor">GetSysColor</a> for system color index values.</param>
        /// <returns>The return value identifies a logical brush if the <i>nIndex</i> parameter is supported by the current platform. Otherwise, it returns <b>NULL</b>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getsyscolorbrush">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.Graphics.Gdi.HBRUSH GetSysColorBrush(int nIndex);
        /// <inheritdoc cref = "DrawFocusRect(win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool DrawFocusRect(SafeHandle hDC, in win32.UI.DisplayDevices.RECT lprc)
        {
            bool hDCAddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
                {
                    win32.Graphics.Gdi.HDC hDCLocal;
                    if (hDC is object)
                    {
                        hDC.DangerousAddRef(ref hDCAddRef);
                        hDCLocal = (win32.Graphics.Gdi.HDC)hDC.DangerousGetHandle();
                    }
                    else
                        hDCLocal = default(win32.Graphics.Gdi.HDC);
                    bool __result = User32.DrawFocusRect(hDCLocal, lprcLocal);
                    return __result;
                }
            }
            finally
            {
                if (hDCAddRef)
                    hDC.DangerousRelease();
            }
        }

        /// <summary>The DrawFocusRect function draws a rectangle in the style used to indicate that the rectangle has the focus.</summary>
        /// <param name = "hDC">A handle to the device context.</param>
        /// <param name = "lprc">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the logical coordinates of the rectangle.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-drawfocusrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool DrawFocusRect(win32.Graphics.Gdi.HDC hDC, win32.UI.DisplayDevices.RECT*lprc);
        /// <inheritdoc cref = "FillRect(win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.RECT*, win32.Graphics.Gdi.HBRUSH)"/>
        internal static unsafe int FillRect(SafeHandle hDC, in win32.UI.DisplayDevices.RECT lprc, SafeHandle hbr)
        {
            bool hDCAddRef = false;
            bool hbrAddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
                {
                    win32.Graphics.Gdi.HDC hDCLocal;
                    if (hDC is object)
                    {
                        hDC.DangerousAddRef(ref hDCAddRef);
                        hDCLocal = (win32.Graphics.Gdi.HDC)hDC.DangerousGetHandle();
                    }
                    else
                        hDCLocal = default(win32.Graphics.Gdi.HDC);
                    win32.Graphics.Gdi.HBRUSH hbrLocal;
                    if (hbr is object)
                    {
                        hbr.DangerousAddRef(ref hbrAddRef);
                        hbrLocal = (win32.Graphics.Gdi.HBRUSH)hbr.DangerousGetHandle();
                    }
                    else
                        hbrLocal = default(win32.Graphics.Gdi.HBRUSH);
                    int __result = User32.FillRect(hDCLocal, lprcLocal, hbrLocal);
                    return __result;
                }
            }
            finally
            {
                if (hDCAddRef)
                    hDC.DangerousRelease();
                if (hbrAddRef)
                    hbr.DangerousRelease();
            }
        }

        /// <summary>The FillRect function fills a rectangle by using the specified brush. This function includes the left and top borders, but excludes the right and bottom borders of the rectangle.</summary>
        /// <param name = "hDC">A handle to the device context.</param>
        /// <param name = "lprc">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the logical coordinates of the rectangle to be filled.</param>
        /// <param name = "hbr">A handle to the brush used to fill the rectangle.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-fillrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int FillRect(win32.Graphics.Gdi.HDC hDC, win32.UI.DisplayDevices.RECT*lprc, win32.Graphics.Gdi.HBRUSH hbr);
        /// <inheritdoc cref = "FrameRect(win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.RECT*, win32.Graphics.Gdi.HBRUSH)"/>
        internal static unsafe int FrameRect(SafeHandle hDC, in win32.UI.DisplayDevices.RECT lprc, SafeHandle hbr)
        {
            bool hDCAddRef = false;
            bool hbrAddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
                {
                    win32.Graphics.Gdi.HDC hDCLocal;
                    if (hDC is object)
                    {
                        hDC.DangerousAddRef(ref hDCAddRef);
                        hDCLocal = (win32.Graphics.Gdi.HDC)hDC.DangerousGetHandle();
                    }
                    else
                        hDCLocal = default(win32.Graphics.Gdi.HDC);
                    win32.Graphics.Gdi.HBRUSH hbrLocal;
                    if (hbr is object)
                    {
                        hbr.DangerousAddRef(ref hbrAddRef);
                        hbrLocal = (win32.Graphics.Gdi.HBRUSH)hbr.DangerousGetHandle();
                    }
                    else
                        hbrLocal = default(win32.Graphics.Gdi.HBRUSH);
                    int __result = User32.FrameRect(hDCLocal, lprcLocal, hbrLocal);
                    return __result;
                }
            }
            finally
            {
                if (hDCAddRef)
                    hDC.DangerousRelease();
                if (hbrAddRef)
                    hbr.DangerousRelease();
            }
        }

        /// <summary>The FrameRect function draws a border around the specified rectangle by using the specified brush. The width and height of the border are always one logical unit.</summary>
        /// <param name = "hDC">A handle to the device context in which the border is drawn.</param>
        /// <param name = "lprc">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the logical coordinates of the upper-left and lower-right corners of the rectangle.</param>
        /// <param name = "hbr">A handle to the brush used to draw the border.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-framerect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe int FrameRect(win32.Graphics.Gdi.HDC hDC, win32.UI.DisplayDevices.RECT*lprc, win32.Graphics.Gdi.HBRUSH hbr);
        /// <inheritdoc cref = "InvertRect(win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool InvertRect(SafeHandle hDC, in win32.UI.DisplayDevices.RECT lprc)
        {
            bool hDCAddRef = false;
            try
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
                {
                    win32.Graphics.Gdi.HDC hDCLocal;
                    if (hDC is object)
                    {
                        hDC.DangerousAddRef(ref hDCAddRef);
                        hDCLocal = (win32.Graphics.Gdi.HDC)hDC.DangerousGetHandle();
                    }
                    else
                        hDCLocal = default(win32.Graphics.Gdi.HDC);
                    bool __result = User32.InvertRect(hDCLocal, lprcLocal);
                    return __result;
                }
            }
            finally
            {
                if (hDCAddRef)
                    hDC.DangerousRelease();
            }
        }

        /// <summary>The InvertRect function inverts a rectangle in a window by performing a logical NOT operation on the color values for each pixel in the rectangle's interior.</summary>
        /// <param name = "hDC">A handle to the device context.</param>
        /// <param name = "lprc">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the logical coordinates of the rectangle to be inverted.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-invertrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool InvertRect(win32.Graphics.Gdi.HDC hDC, win32.UI.DisplayDevices.RECT*lprc);
        /// <inheritdoc cref = "SetRect(win32.UI.DisplayDevices.RECT*, int, int, int, int)"/>
        internal static unsafe bool SetRect(out win32.UI.DisplayDevices.RECT lprc, int xLeft, int yTop, int xRight, int yBottom)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
            {
                bool __result = User32.SetRect(lprcLocal, xLeft, yTop, xRight, yBottom);
                return __result;
            }
        }

        /// <summary>The SetRect function sets the coordinates of the specified rectangle. This is equivalent to assigning the left, top, right, and bottom arguments to the appropriate members of the RECT structure.</summary>
        /// <param name = "lprc">Pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the rectangle to be set.</param>
        /// <param name = "xLeft">Specifies the x-coordinate of the rectangle's upper-left corner.</param>
        /// <param name = "yTop">Specifies the y-coordinate of the rectangle's upper-left corner.</param>
        /// <param name = "xRight">Specifies the x-coordinate of the rectangle's lower-right corner.</param>
        /// <param name = "yBottom">Specifies the y-coordinate of the rectangle's lower-right corner.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool SetRect(win32.UI.DisplayDevices.RECT*lprc, int xLeft, int yTop, int xRight, int yBottom);
        /// <inheritdoc cref = "SetRectEmpty(win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool SetRectEmpty(out win32.UI.DisplayDevices.RECT lprc)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
            {
                bool __result = User32.SetRectEmpty(lprcLocal);
                return __result;
            }
        }

        /// <summary>The SetRectEmpty function creates an empty rectangle in which all coordinates are set to zero.</summary>
        /// <param name = "lprc">Pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the coordinates of the rectangle.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setrectempty">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool SetRectEmpty(win32.UI.DisplayDevices.RECT*lprc);
        /// <inheritdoc cref = "CopyRect(win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool CopyRect(out win32.UI.DisplayDevices.RECT lprcDst, in win32.UI.DisplayDevices.RECT lprcSrc)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcSrcLocal = &lprcSrc)
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcDstLocal = &lprcDst)
                {
                    bool __result = User32.CopyRect(lprcDstLocal, lprcSrcLocal);
                    return __result;
                }
            }
        }

        /// <summary>The CopyRect function copies the coordinates of one rectangle to another.</summary>
        /// <param name = "lprcDst">Pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the logical coordinates of the source rectangle.</param>
        /// <param name = "lprcSrc">Pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure whose coordinates are to be copied in logical units.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-copyrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool CopyRect(win32.UI.DisplayDevices.RECT*lprcDst, win32.UI.DisplayDevices.RECT*lprcSrc);
        /// <inheritdoc cref = "InflateRect(win32.UI.DisplayDevices.RECT*, int, int)"/>
        internal static unsafe bool InflateRect(ref win32.UI.DisplayDevices.RECT lprc, int dx, int dy)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
            {
                bool __result = User32.InflateRect(lprcLocal, dx, dy);
                return __result;
            }
        }

        /// <summary>The InflateRect function increases or decreases the width and height of the specified rectangle.</summary>
        /// <param name = "lprc">A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that increases or decreases in size.</param>
        /// <param name = "dx">The amount to increase or decrease the rectangle width. This parameter must be negative to decrease the width.</param>
        /// <param name = "dy">The amount to increase or decrease the rectangle height. This parameter must be negative to decrease the height.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-inflaterect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool InflateRect(win32.UI.DisplayDevices.RECT*lprc, int dx, int dy);
        /// <inheritdoc cref = "IntersectRect(win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool IntersectRect(out win32.UI.DisplayDevices.RECT lprcDst, in win32.UI.DisplayDevices.RECT lprcSrc1, in win32.UI.DisplayDevices.RECT lprcSrc2)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcSrc2Local = &lprcSrc2)
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcSrc1Local = &lprcSrc1)
                {
                    fixed (win32.UI.DisplayDevices.RECT*lprcDstLocal = &lprcDst)
                    {
                        bool __result = User32.IntersectRect(lprcDstLocal, lprcSrc1Local, lprcSrc2Local);
                        return __result;
                    }
                }
            }
        }

        /// <summary>The IntersectRect function calculates the intersection of two source rectangles and places the coordinates of the intersection rectangle into the destination rectangle.</summary>
        /// <param name = "lprcDst">A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that is to receive the intersection of the rectangles pointed to by the <i>lprcSrc1</i> and <i>lprcSrc2</i> parameters. This parameter cannot be <b>NULL</b>.</param>
        /// <param name = "lprcSrc1">A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the first source rectangle.</param>
        /// <param name = "lprcSrc2">A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the second source rectangle.</param>
        /// <returns>
        /// <para>If the rectangles intersect, the return value is nonzero.</para>
        /// <para>If the rectangles do not intersect, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-intersectrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool IntersectRect(win32.UI.DisplayDevices.RECT*lprcDst, win32.UI.DisplayDevices.RECT*lprcSrc1, win32.UI.DisplayDevices.RECT*lprcSrc2);
        /// <inheritdoc cref = "UnionRect(win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool UnionRect(out win32.UI.DisplayDevices.RECT lprcDst, in win32.UI.DisplayDevices.RECT lprcSrc1, in win32.UI.DisplayDevices.RECT lprcSrc2)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcSrc2Local = &lprcSrc2)
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcSrc1Local = &lprcSrc1)
                {
                    fixed (win32.UI.DisplayDevices.RECT*lprcDstLocal = &lprcDst)
                    {
                        bool __result = User32.UnionRect(lprcDstLocal, lprcSrc1Local, lprcSrc2Local);
                        return __result;
                    }
                }
            }
        }

        /// <summary>The UnionRect function creates the union of two rectangles. The union is the smallest rectangle that contains both source rectangles.</summary>
        /// <param name = "lprcDst">A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that will receive a rectangle containing the rectangles pointed to by the <i>lprcSrc1</i> and <i>lprcSrc2</i> parameters.</param>
        /// <param name = "lprcSrc1">A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the first source rectangle.</param>
        /// <param name = "lprcSrc2">A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the second source rectangle.</param>
        /// <returns>
        /// <para>If the specified structure contains a nonempty rectangle, the return value is nonzero.</para>
        /// <para>If the specified structure does not contain a nonempty rectangle, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unionrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool UnionRect(win32.UI.DisplayDevices.RECT*lprcDst, win32.UI.DisplayDevices.RECT*lprcSrc1, win32.UI.DisplayDevices.RECT*lprcSrc2);
        /// <inheritdoc cref = "SubtractRect(win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool SubtractRect(out win32.UI.DisplayDevices.RECT lprcDst, in win32.UI.DisplayDevices.RECT lprcSrc1, in win32.UI.DisplayDevices.RECT lprcSrc2)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcSrc2Local = &lprcSrc2)
            {
                fixed (win32.UI.DisplayDevices.RECT*lprcSrc1Local = &lprcSrc1)
                {
                    fixed (win32.UI.DisplayDevices.RECT*lprcDstLocal = &lprcDst)
                    {
                        bool __result = User32.SubtractRect(lprcDstLocal, lprcSrc1Local, lprcSrc2Local);
                        return __result;
                    }
                }
            }
        }

        /// <summary>The SubtractRect function determines the coordinates of a rectangle formed by subtracting one rectangle from another.</summary>
        /// <param name = "lprcDst">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the coordinates of the rectangle determined by subtracting the rectangle pointed to by <i>lprcSrc2</i> from the rectangle pointed to by <i>lprcSrc1</i>.</param>
        /// <param name = "lprcSrc1">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure from which the function subtracts the rectangle pointed to by <i>lprcSrc2</i>.</param>
        /// <param name = "lprcSrc2">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that the function subtracts from the rectangle pointed to by <i>lprcSrc1</i>.</param>
        /// <returns>
        /// <para>If the resulting rectangle is empty, the return value is zero.</para>
        /// <para>If the resulting rectangle is not empty, the return value is nonzero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-subtractrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool SubtractRect(win32.UI.DisplayDevices.RECT*lprcDst, win32.UI.DisplayDevices.RECT*lprcSrc1, win32.UI.DisplayDevices.RECT*lprcSrc2);
        /// <inheritdoc cref = "OffsetRect(win32.UI.DisplayDevices.RECT*, int, int)"/>
        internal static unsafe bool OffsetRect(ref win32.UI.DisplayDevices.RECT lprc, int dx, int dy)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
            {
                bool __result = User32.OffsetRect(lprcLocal, dx, dy);
                return __result;
            }
        }

        /// <summary>The OffsetRect function moves the specified rectangle by the specified offsets.</summary>
        /// <param name = "lprc">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the logical coordinates of the rectangle to be moved.</param>
        /// <param name = "dx">Specifies the amount to move the rectangle left or right. This parameter must be a negative value to move the rectangle to the left.</param>
        /// <param name = "dy">Specifies the amount to move the rectangle up or down. This parameter must be a negative value to move the rectangle up.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-offsetrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool OffsetRect(win32.UI.DisplayDevices.RECT*lprc, int dx, int dy);
        /// <inheritdoc cref = "IsRectEmpty(win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool IsRectEmpty(in win32.UI.DisplayDevices.RECT lprc)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
            {
                bool __result = User32.IsRectEmpty(lprcLocal);
                return __result;
            }
        }

        /// <summary>The IsRectEmpty function determines whether the specified rectangle is empty.</summary>
        /// <param name = "lprc">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the logical coordinates of the rectangle.</param>
        /// <returns>
        /// <para>If the rectangle is empty, the return value is nonzero.</para>
        /// <para>If the rectangle is not empty, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-isrectempty">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool IsRectEmpty(win32.UI.DisplayDevices.RECT*lprc);
        /// <inheritdoc cref = "EqualRect(win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.RECT*)"/>
        internal static unsafe bool EqualRect(in win32.UI.DisplayDevices.RECT lprc1, in win32.UI.DisplayDevices.RECT lprc2)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprc2Local = &lprc2)
            {
                fixed (win32.UI.DisplayDevices.RECT*lprc1Local = &lprc1)
                {
                    bool __result = User32.EqualRect(lprc1Local, lprc2Local);
                    return __result;
                }
            }
        }

        /// <summary>The EqualRect function determines whether the two specified rectangles are equal by comparing the coordinates of their upper-left and lower-right corners.</summary>
        /// <param name = "lprc1">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the logical coordinates of the first rectangle.</param>
        /// <param name = "lprc2">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the logical coordinates of the second rectangle.</param>
        /// <returns>
        /// <para>If the two rectangles are identical, the return value is nonzero.</para>
        /// <para>If the two rectangles are not identical, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-equalrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool EqualRect(win32.UI.DisplayDevices.RECT*lprc1, win32.UI.DisplayDevices.RECT*lprc2);
        /// <inheritdoc cref = "PtInRect(win32.UI.DisplayDevices.RECT*, win32.UI.DisplayDevices.POINT)"/>
        internal static unsafe bool PtInRect(in win32.UI.DisplayDevices.RECT lprc, win32.UI.DisplayDevices.POINT pt)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
            {
                bool __result = User32.PtInRect(lprcLocal, pt);
                return __result;
            }
        }

        /// <summary>The PtInRect function determines whether the specified point lies within the specified rectangle.</summary>
        /// <param name = "lprc">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the specified rectangle.</param>
        /// <param name = "pt">A <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that contains the specified point.</param>
        /// <returns>
        /// <para>If the specified point lies within the rectangle, the return value is nonzero.</para>
        /// <para>If the specified point does not lie within the rectangle, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-ptinrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool PtInRect(win32.UI.DisplayDevices.RECT*lprc, win32.UI.DisplayDevices.POINT pt);
        /// <inheritdoc cref = "LoadBitmap(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Gdi32.DeleteObjectSafeHandle LoadBitmap(SafeHandle hInstance, string lpBitmapName)
        {
            bool hInstanceAddRef = false;
            try
            {
                fixed (char *lpBitmapNameLocal = lpBitmapName)
                {
                    win32.System.SystemServices.HINSTANCE hInstanceLocal;
                    if (hInstance is object)
                    {
                        hInstance.DangerousAddRef(ref hInstanceAddRef);
                        hInstanceLocal = (win32.System.SystemServices.HINSTANCE)hInstance.DangerousGetHandle();
                    }
                    else
                        hInstanceLocal = default(win32.System.SystemServices.HINSTANCE);
                    win32.Graphics.Gdi.HBITMAP __result = User32.LoadBitmap(hInstanceLocal, lpBitmapNameLocal);
                    return new Gdi32.DeleteObjectSafeHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hInstanceAddRef)
                    hInstance.DangerousRelease();
            }
        }

        /// <summary>The LoadBitmap function loads the specified bitmap resource from a module's executable file.</summary>
        /// <param name = "hInstance">A handle to the instance of the module whose executable file contains the bitmap to be loaded.</param>
        /// <param name = "lpBitmapName">A pointer to a null-terminated string that contains the name of the bitmap resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro can be used to create this value.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the handle to the specified bitmap.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-loadbitmapw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "LoadBitmapW")]
        internal static extern win32.Graphics.Gdi.HBITMAP LoadBitmap(win32.System.SystemServices.HINSTANCE hInstance, win32.System.SystemServices.PCWSTR lpBitmapName);
        /// <inheritdoc cref = "ChangeDisplaySettings(win32.UI.DisplayDevices.DEVMODEW*, win32.Graphics.Gdi.CDS_TYPE)"/>
        internal static unsafe win32.Graphics.Gdi.DISP_CHANGE ChangeDisplaySettings(win32.UI.DisplayDevices.DEVMODEW? lpDevMode, win32.Graphics.Gdi.CDS_TYPE dwFlags)
        {
            win32.UI.DisplayDevices.DEVMODEW lpDevModeLocal = lpDevMode.HasValue ? lpDevMode.Value : default(win32.UI.DisplayDevices.DEVMODEW);
            win32.Graphics.Gdi.DISP_CHANGE __result = User32.ChangeDisplaySettings(lpDevMode.HasValue ? &lpDevModeLocal : null, dwFlags);
            return __result;
        }

        /// <summary>The ChangeDisplaySettings function changes the settings of the default display device to the specified graphics mode.</summary>
        /// <param name = "lpDevMode">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> structure that describes the new graphics mode. If <i>lpDevMode</i> is <b>NULL</b>, all the values currently in the registry will be used for the display setting. Passing <b>NULL</b> for the <i>lpDevMode</i> parameter and 0 for the <i>dwFlags</i> parameter is the easiest way to return to the default mode after a dynamic mode change.</para>
        /// <para>The <b>dmSize</b> member of <a href = "https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> must be initialized to the size, in bytes, of the <b>DEVMODE</b> structure. The <b>dmDriverExtra</b> member of <b>DEVMODE</b> must be initialized to indicate the number of bytes of private driver data following the <b>DEVMODE</b> structure. In addition, you can use any or all of the following members of the <b>DEVMODE</b> structure.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changedisplaysettingsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>The <b>ChangeDisplaySettings</b> function returns one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changedisplaysettingsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "ChangeDisplaySettingsW")]
        internal static extern unsafe win32.Graphics.Gdi.DISP_CHANGE ChangeDisplaySettings([Optional] win32.UI.DisplayDevices.DEVMODEW*lpDevMode, win32.Graphics.Gdi.CDS_TYPE dwFlags);
        /// <inheritdoc cref = "ChangeDisplaySettingsEx(win32.System.SystemServices.PCWSTR, win32.UI.DisplayDevices.DEVMODEW*, win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.CDS_TYPE, void *)"/>
        internal static unsafe win32.Graphics.Gdi.DISP_CHANGE ChangeDisplaySettingsEx(string lpszDeviceName, win32.UI.DisplayDevices.DEVMODEW? lpDevMode, win32.UI.WindowsAndMessaging.HWND hwnd, win32.Graphics.Gdi.CDS_TYPE dwflags, void *lParam)
        {
            fixed (char *lpszDeviceNameLocal = lpszDeviceName)
            {
                win32.UI.DisplayDevices.DEVMODEW lpDevModeLocal = lpDevMode.HasValue ? lpDevMode.Value : default(win32.UI.DisplayDevices.DEVMODEW);
                win32.Graphics.Gdi.DISP_CHANGE __result = User32.ChangeDisplaySettingsEx(lpszDeviceNameLocal, lpDevMode.HasValue ? &lpDevModeLocal : null, hwnd, dwflags, lParam);
                return __result;
            }
        }

        /// <summary>The ChangeDisplaySettingsEx function changes the settings of the specified display device to the specified graphics mode.</summary>
        /// <param name = "lpszDeviceName">
        /// <para>A pointer to a null-terminated string that specifies the display device whose graphics mode will change. Only display device names as returned by <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumdisplaydevicesa">EnumDisplayDevices</a> are valid. See <b>EnumDisplayDevices</b> for further information on the names associated with these display devices.</para>
        /// <para>The <i>lpszDeviceName</i> parameter can be <b>NULL</b>. A <b>NULL</b> value specifies the default display device. The default device can be determined by calling <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumdisplaydevicesa">EnumDisplayDevices</a> and checking for the DISPLAY_DEVICE_PRIMARY_DEVICE flag.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changedisplaysettingsexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDevMode">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> structure that describes the new graphics mode. If <i>lpDevMode</i> is <b>NULL</b>, all the values currently in the registry will be used for the display setting. Passing <b>NULL</b> for the <i>lpDevMode</i> parameter and 0 for the <i>dwFlags</i> parameter is the easiest way to return to the default mode after a dynamic mode change.</para>
        /// <para>The <b>dmSize</b> member must be initialized to the size, in bytes, of the <a href = "https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> structure. The <b>dmDriverExtra</b> member must be initialized to indicate the number of bytes of private driver data following the <b>DEVMODE</b> structure. In addition, you can use any of the following members of the <b>DEVMODE</b> structure.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changedisplaysettingsexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hwnd">Reserved; must be <b>NULL</b>.</param>
        /// <param name = "dwflags"></param>
        /// <param name = "lParam">If <i>dwFlags</i> is <b>CDS_VIDEOPARAMETERS</b>, <i>lParam</i> is a pointer to a <a href = "https://docs.microsoft.com/previous-versions/dd145196(v=vs.85)">VIDEOPARAMETERS</a> structure. Otherwise <i>lParam</i> must be <b>NULL</b>.</param>
        /// <returns>
        /// <para>The <b>ChangeDisplaySettingsEx</b> function returns one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-changedisplaysettingsexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "ChangeDisplaySettingsExW")]
        internal static extern unsafe win32.Graphics.Gdi.DISP_CHANGE ChangeDisplaySettingsEx(win32.System.SystemServices.PCWSTR lpszDeviceName, [Optional] win32.UI.DisplayDevices.DEVMODEW*lpDevMode, win32.UI.WindowsAndMessaging.HWND hwnd, win32.Graphics.Gdi.CDS_TYPE dwflags, [Optional] void *lParam);
        /// <inheritdoc cref = "EnumDisplaySettings(win32.System.SystemServices.PCWSTR, win32.Graphics.Gdi.ENUM_DISPLAY_SETTINGS_MODE, win32.UI.DisplayDevices.DEVMODEW*)"/>
        internal static unsafe bool EnumDisplaySettings(string lpszDeviceName, win32.Graphics.Gdi.ENUM_DISPLAY_SETTINGS_MODE iModeNum, ref win32.UI.DisplayDevices.DEVMODEW lpDevMode)
        {
            fixed (win32.UI.DisplayDevices.DEVMODEW*lpDevModeLocal = &lpDevMode)
            {
                fixed (char *lpszDeviceNameLocal = lpszDeviceName)
                {
                    bool __result = User32.EnumDisplaySettings(lpszDeviceNameLocal, iModeNum, lpDevModeLocal);
                    return __result;
                }
            }
        }

        /// <summary>The EnumDisplaySettings function retrieves information about one of the graphics modes for a display device. To retrieve information for all the graphics modes of a display device, make a series of calls to this function.</summary>
        /// <param name = "lpszDeviceName">
        /// <para>A pointer to a null-terminated string that specifies the display device about whose graphics mode the function will obtain information.</para>
        /// <para>This parameter is either <b>NULL</b> or a <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-display_devicea">DISPLAY_DEVICE</a>.<b>DeviceName</b> returned from <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumdisplaydevicesa">EnumDisplayDevices</a>. A <b>NULL</b> value specifies the current display device on the computer on which the calling thread is running.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaysettingsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "iModeNum"></param>
        /// <param name = "lpDevMode">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> structure into which the function stores information about the specified graphics mode. Before calling <b>EnumDisplaySettings</b>, set the <b>dmSize</b> member to <c>sizeof(DEVMODE)</c>, and set the <b>dmDriverExtra</b> member to indicate the size, in bytes, of the additional space available to receive private driver data.</para>
        /// <para>The <b>EnumDisplaySettings</b> function sets values for the following five <a href = "https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> members:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaysettingsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaysettingsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "EnumDisplaySettingsW")]
        internal static extern unsafe bool EnumDisplaySettings(win32.System.SystemServices.PCWSTR lpszDeviceName, win32.Graphics.Gdi.ENUM_DISPLAY_SETTINGS_MODE iModeNum, win32.UI.DisplayDevices.DEVMODEW*lpDevMode);
        /// <inheritdoc cref = "EnumDisplaySettingsEx(win32.System.SystemServices.PCWSTR, win32.Graphics.Gdi.ENUM_DISPLAY_SETTINGS_MODE, win32.UI.DisplayDevices.DEVMODEW*, uint)"/>
        internal static unsafe bool EnumDisplaySettingsEx(string lpszDeviceName, win32.Graphics.Gdi.ENUM_DISPLAY_SETTINGS_MODE iModeNum, ref win32.UI.DisplayDevices.DEVMODEW lpDevMode, uint dwFlags)
        {
            fixed (win32.UI.DisplayDevices.DEVMODEW*lpDevModeLocal = &lpDevMode)
            {
                fixed (char *lpszDeviceNameLocal = lpszDeviceName)
                {
                    bool __result = User32.EnumDisplaySettingsEx(lpszDeviceNameLocal, iModeNum, lpDevModeLocal, dwFlags);
                    return __result;
                }
            }
        }

        /// <summary>The EnumDisplaySettingsEx function retrieves information about one of the graphics modes for a display device. To retrieve information for all the graphics modes for a display device, make a series of calls to this function.</summary>
        /// <param name = "lpszDeviceName">
        /// <para>A pointer to a null-terminated string that specifies the display device about which graphics mode the function will obtain information.</para>
        /// <para>This parameter is either <b>NULL</b> or a <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-display_devicea">DISPLAY_DEVICE</a>. <b>DeviceName</b> returned from <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumdisplaydevicesa">EnumDisplayDevices</a>. A <b>NULL</b> value specifies the current display device on the computer that the calling thread is running on.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaysettingsexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "iModeNum"></param>
        /// <param name = "lpDevMode">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> structure into which the function stores information about the specified graphics mode. Before calling <b>EnumDisplaySettingsEx</b>, set the <b>dmSize</b> member to <b>sizeof</b> (<a href = "https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a>), and set the <b>dmDriverExtra</b> member to indicate the size, in bytes, of the additional space available to receive private driver data.</para>
        /// <para>The <b>EnumDisplaySettingsEx</b> function will populate the <b>dmFields</b> member of the <b>lpDevMode</b> and one or more other members of the <a href = "https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> structure. To determine which members were set by the call to <b>EnumDisplaySettingsEx</b>, inspect the <i>dmFields</i> bitmask. Some of the fields typically populated by this function include:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaysettingsexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>This parameter can be the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaysettingsexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaysettingsexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "EnumDisplaySettingsExW")]
        internal static extern unsafe bool EnumDisplaySettingsEx(win32.System.SystemServices.PCWSTR lpszDeviceName, win32.Graphics.Gdi.ENUM_DISPLAY_SETTINGS_MODE iModeNum, win32.UI.DisplayDevices.DEVMODEW*lpDevMode, uint dwFlags);
        /// <inheritdoc cref = "EnumDisplayDevices(win32.System.SystemServices.PCWSTR, uint, win32.Graphics.Gdi.DISPLAY_DEVICEW*, uint)"/>
        internal static unsafe bool EnumDisplayDevices(string lpDevice, uint iDevNum, ref win32.Graphics.Gdi.DISPLAY_DEVICEW lpDisplayDevice, uint dwFlags)
        {
            fixed (win32.Graphics.Gdi.DISPLAY_DEVICEW*lpDisplayDeviceLocal = &lpDisplayDevice)
            {
                fixed (char *lpDeviceLocal = lpDevice)
                {
                    bool __result = User32.EnumDisplayDevices(lpDeviceLocal, iDevNum, lpDisplayDeviceLocal, dwFlags);
                    return __result;
                }
            }
        }

        /// <summary>The EnumDisplayDevices function lets you obtain information about the display devices in the current session.</summary>
        /// <param name = "lpDevice">
        /// <para>A pointer to the device name. If <b>NULL</b>, function returns information for the display adapter(s) on the machine, based on <i>iDevNum</i>.</para>
        /// <para>For more information, see Remarks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaydevicesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "iDevNum">
        /// <para>An index value that specifies the display device of interest.</para>
        /// <para>The operating system identifies each display device in the current session with an index value. The index values are consecutive integers, starting at 0. If the current session has three display devices, for example, they are specified by the index values 0, 1, and 2.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaydevicesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDisplayDevice">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-display_devicea">DISPLAY_DEVICE</a> structure that receives information about the display device specified by <i>iDevNum</i>.</para>
        /// <para>Before calling <b>EnumDisplayDevices</b>, you must initialize the <b>cb</b> member of <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-display_devicea">DISPLAY_DEVICE</a> to the size, in bytes, of <b>DISPLAY_DEVICE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaydevicesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Set this flag to EDD_GET_DEVICE_INTERFACE_NAME (0x00000001) to retrieve the device interface name for GUID_DEVINTERFACE_MONITOR, which is registered by the operating system on a per monitor basis. The value is placed in the DeviceID member of the <a href = "https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-display_devicea">DISPLAY_DEVICE</a> structure returned in <i>lpDisplayDevice</i>. The resulting device interface name can be used with <a href = "https://docs.microsoft.com/windows-hardware/drivers/install/setupapi">SetupAPI functions</a> and serves as a link between GDI monitor devices and SetupAPI monitor devices.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. The function fails if <i>iDevNum</i> is greater than the largest device index.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaydevicesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "EnumDisplayDevicesW")]
        internal static extern unsafe bool EnumDisplayDevices(win32.System.SystemServices.PCWSTR lpDevice, uint iDevNum, win32.Graphics.Gdi.DISPLAY_DEVICEW*lpDisplayDevice, uint dwFlags);
        /// <summary>The MonitorFromPoint function retrieves a handle to the display monitor that contains a specified point.</summary>
        /// <param name = "pt">A <a href = "https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that specifies the point of interest in virtual-screen coordinates.</param>
        /// <param name = "dwFlags">Determines the function's return value if the point is not contained within any display monitor.</param>
        /// <returns>
        /// <para>If the point is contained by a display monitor, the return value is an <b>HMONITOR</b> handle to that display monitor.</para>
        /// <para>If the point is not contained by a display monitor, the return value depends on the value of <i>dwFlags</i>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-monitorfrompoint">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.Graphics.Gdi.HMONITOR MonitorFromPoint(win32.UI.DisplayDevices.POINT pt, win32.Graphics.Gdi.MONITOR_FROM_FLAGS dwFlags);
        /// <inheritdoc cref = "MonitorFromRect(win32.UI.DisplayDevices.RECT*, win32.Graphics.Gdi.MONITOR_FROM_FLAGS)"/>
        internal static unsafe win32.Graphics.Gdi.HMONITOR MonitorFromRect(in win32.UI.DisplayDevices.RECT lprc, win32.Graphics.Gdi.MONITOR_FROM_FLAGS dwFlags)
        {
            fixed (win32.UI.DisplayDevices.RECT*lprcLocal = &lprc)
            {
                win32.Graphics.Gdi.HMONITOR __result = User32.MonitorFromRect(lprcLocal, dwFlags);
                return __result;
            }
        }

        /// <summary>The MonitorFromRect function retrieves a handle to the display monitor that has the largest area of intersection with a specified rectangle.</summary>
        /// <param name = "lprc">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the rectangle of interest in virtual-screen coordinates.</param>
        /// <param name = "dwFlags">Determines the function's return value if the rectangle does not intersect any display monitor.</param>
        /// <returns>
        /// <para>If the rectangle intersects one or more display monitor rectangles, the return value is an <b>HMONITOR</b> handle to the display monitor that has the largest area of intersection with the rectangle.</para>
        /// <para>If the rectangle does not intersect a display monitor, the return value depends on the value of <i>dwFlags</i>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-monitorfromrect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe win32.Graphics.Gdi.HMONITOR MonitorFromRect(win32.UI.DisplayDevices.RECT*lprc, win32.Graphics.Gdi.MONITOR_FROM_FLAGS dwFlags);
        /// <summary>The MonitorFromWindow function retrieves a handle to the display monitor that has the largest area of intersection with the bounding rectangle of a specified window.</summary>
        /// <param name = "hwnd">A handle to the window of interest.</param>
        /// <param name = "dwFlags">Determines the function's return value if the window does not intersect any display monitor.</param>
        /// <returns>
        /// <para>If the window intersects one or more display monitor rectangles, the return value is an <b>HMONITOR</b> handle to the display monitor that has the largest area of intersection with the window.</para>
        /// <para>If the window does not intersect a display monitor, the return value depends on the value of <i>dwFlags</i>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-monitorfromwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern win32.Graphics.Gdi.HMONITOR MonitorFromWindow(win32.UI.WindowsAndMessaging.HWND hwnd, win32.Graphics.Gdi.MONITOR_FROM_FLAGS dwFlags);
        /// <inheritdoc cref = "GetMonitorInfo(win32.Graphics.Gdi.HMONITOR, win32.Graphics.Gdi.MONITORINFO*)"/>
        internal static unsafe bool GetMonitorInfo(win32.Graphics.Gdi.HMONITOR hMonitor, ref win32.Graphics.Gdi.MONITORINFO lpmi)
        {
            fixed (win32.Graphics.Gdi.MONITORINFO*lpmiLocal = &lpmi)
            {
                bool __result = User32.GetMonitorInfo(hMonitor, lpmiLocal);
                return __result;
            }
        }

        /// <summary>The GetMonitorInfo function retrieves information about a display monitor.</summary>
        /// <param name = "hMonitor">A handle to the display monitor of interest.</param>
        /// <param name = "lpmi">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfo">MONITORINFO</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfoexa">MONITORINFOEX</a> structure that receives information about the specified display monitor.</para>
        /// <para>You must set the <b>cbSize</b> member of the structure to sizeof(MONITORINFO) or sizeof(MONITORINFOEX) before calling the <b>GetMonitorInfo</b> function. Doing so lets the function determine the type of structure you are passing to it.</para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfoexa">MONITORINFOEX</a> structure is a superset of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfo">MONITORINFO</a> structure. It has one additional member: a string that contains a name for the display monitor. Most applications have no use for a display monitor name, and so can save some bytes by using a <b>MONITORINFO</b> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmonitorinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmonitorinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "GetMonitorInfoW")]
        internal static extern unsafe bool GetMonitorInfo(win32.Graphics.Gdi.HMONITOR hMonitor, win32.Graphics.Gdi.MONITORINFO*lpmi);
        /// <inheritdoc cref = "EnumDisplayMonitors(win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.RECT*, delegate *unmanaged[Stdcall]{win32.Graphics.Gdi.HMONITOR, win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.RECT*, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL}, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe bool EnumDisplayMonitors(SafeHandle hdc, win32.UI.DisplayDevices.RECT? lprcClip, delegate *unmanaged[Stdcall]<win32.Graphics.Gdi.HMONITOR, win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.RECT*, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpfnEnum, win32.UI.WindowsAndMessaging.LPARAM dwData)
        {
            bool hdcAddRef = false;
            try
            {
                win32.Graphics.Gdi.HDC hdcLocal;
                if (hdc is object)
                {
                    hdc.DangerousAddRef(ref hdcAddRef);
                    hdcLocal = (win32.Graphics.Gdi.HDC)hdc.DangerousGetHandle();
                }
                else
                    hdcLocal = default(win32.Graphics.Gdi.HDC);
                win32.UI.DisplayDevices.RECT lprcClipLocal = lprcClip.HasValue ? lprcClip.Value : default(win32.UI.DisplayDevices.RECT);
                bool __result = User32.EnumDisplayMonitors(hdcLocal, lprcClip.HasValue ? &lprcClipLocal : null, lpfnEnum, dwData);
                return __result;
            }
            finally
            {
                if (hdcAddRef)
                    hdc.DangerousRelease();
            }
        }

        /// <summary>The EnumDisplayMonitors function enumerates display monitors (including invisible pseudo-monitors associated with the mirroring drivers) that intersect a region formed by the intersection of a specified clipping rectangle and the visible region of a device context. EnumDisplayMonitors calls an application-defined MonitorEnumProc callback function once for each monitor that is enumerated. Note that GetSystemMetrics (SM_CMONITORS) counts only the display monitors.</summary>
        /// <param name = "hdc">
        /// <para>A handle to a display device context that defines the visible region of interest.</para>
        /// <para>If this parameter is <b>NULL</b>, the <i>hdcMonitor</i> parameter passed to the callback function will be <b>NULL</b>, and the visible region of interest is the virtual screen that encompasses all the displays on the desktop.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaymonitors#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lprcClip">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies a clipping rectangle. The region of interest is the intersection of the clipping rectangle with the visible region specified by <i>hdc</i>.</para>
        /// <para>If <i>hdc</i> is non-<b>NULL</b>, the coordinates of the clipping rectangle are relative to the origin of the <i>hdc</i>. If <i>hdc</i> is <b>NULL</b>, the coordinates are virtual-screen coordinates.</para>
        /// <para>This parameter can be <b>NULL</b> if you don't want to clip the region specified by <i>hdc</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaymonitors#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpfnEnum">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-monitorenumproc">MonitorEnumProc</a> application-defined callback function.</param>
        /// <param name = "dwData">Application-defined data that <b>EnumDisplayMonitors</b> passes directly to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-monitorenumproc">MonitorEnumProc</a> function.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-enumdisplaymonitors">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern unsafe bool EnumDisplayMonitors(win32.Graphics.Gdi.HDC hdc, [Optional] win32.UI.DisplayDevices.RECT*lprcClip, delegate *unmanaged[Stdcall]<win32.Graphics.Gdi.HMONITOR, win32.Graphics.Gdi.HDC, win32.UI.DisplayDevices.RECT*, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpfnEnum, win32.UI.WindowsAndMessaging.LPARAM dwData);
        /// <inheritdoc cref = "PrintWindow(win32.UI.WindowsAndMessaging.HWND, win32.Graphics.Gdi.HDC, win32.Storage.Xps.PRINT_WINDOW_FLAGS)"/>
        internal static unsafe bool PrintWindow(win32.UI.WindowsAndMessaging.HWND hwnd, SafeHandle hdcBlt, win32.Storage.Xps.PRINT_WINDOW_FLAGS nFlags)
        {
            bool hdcBltAddRef = false;
            try
            {
                win32.Graphics.Gdi.HDC hdcBltLocal;
                if (hdcBlt is object)
                {
                    hdcBlt.DangerousAddRef(ref hdcBltAddRef);
                    hdcBltLocal = (win32.Graphics.Gdi.HDC)hdcBlt.DangerousGetHandle();
                }
                else
                    hdcBltLocal = default(win32.Graphics.Gdi.HDC);
                bool __result = User32.PrintWindow(hwnd, hdcBltLocal, nFlags);
                return __result;
            }
            finally
            {
                if (hdcBltAddRef)
                    hdcBlt.DangerousRelease();
            }
        }

        /// <summary>The PrintWindow function copies a visual window into the specified device context (DC), typically a printer DC.</summary>
        /// <param name = "hwnd">A handle to the window that will be copied.</param>
        /// <param name = "hdcBlt">A handle to the device context.</param>
        /// <param name = "nFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, it returns zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-printwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        internal static extern bool PrintWindow(win32.UI.WindowsAndMessaging.HWND hwnd, win32.Graphics.Gdi.HDC hdcBlt, win32.Storage.Xps.PRINT_WINDOW_FLAGS nFlags);
        /// <inheritdoc cref = "SetUserObjectSecurity(win32.System.SystemServices.HANDLE, win32.Security.OBJECT_SECURITY_INFORMATION*, win32.Security.SECURITY_DESCRIPTOR*)"/>
        internal static unsafe bool SetUserObjectSecurity(SafeHandle hObj, in win32.Security.OBJECT_SECURITY_INFORMATION pSIRequested, in win32.Security.SECURITY_DESCRIPTOR pSID)
        {
            bool hObjAddRef = false;
            try
            {
                fixed (win32.Security.SECURITY_DESCRIPTOR*pSIDLocal = &pSID)
                {
                    fixed (win32.Security.OBJECT_SECURITY_INFORMATION*pSIRequestedLocal = &pSIRequested)
                    {
                        win32.System.SystemServices.HANDLE hObjLocal;
                        if (hObj is object)
                        {
                            hObj.DangerousAddRef(ref hObjAddRef);
                            hObjLocal = (win32.System.SystemServices.HANDLE)hObj.DangerousGetHandle();
                        }
                        else
                            hObjLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = User32.SetUserObjectSecurity(hObjLocal, pSIRequestedLocal, pSIDLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hObjAddRef)
                    hObj.DangerousRelease();
            }
        }

        /// <summary>Sets the security of a user object. This can be, for example, a window or a DDE conversation.</summary>
        /// <param name = "hObj">A handle to a user object for which security information is set.</param>
        /// <param name = "pSIRequested"></param>
        /// <param name = "pSID">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> structure that contains the new security information.</para>
        /// <para>This buffer must be aligned on a 4-byte boundary.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setuserobjectsecurity#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the function returns nonzero.</para>
        /// <para>If the function fails, it returns zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setuserobjectsecurity">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetUserObjectSecurity(win32.System.SystemServices.HANDLE hObj, win32.Security.OBJECT_SECURITY_INFORMATION*pSIRequested, win32.Security.SECURITY_DESCRIPTOR*pSID);
        /// <inheritdoc cref = "GetUserObjectSecurity(win32.System.SystemServices.HANDLE, uint *, win32.Security.SECURITY_DESCRIPTOR*, uint, uint *)"/>
        internal static unsafe bool GetUserObjectSecurity(SafeHandle hObj, in uint pSIRequested, win32.Security.SECURITY_DESCRIPTOR*pSID, uint nLength, out uint lpnLengthNeeded)
        {
            bool hObjAddRef = false;
            try
            {
                fixed (uint *lpnLengthNeededLocal = &lpnLengthNeeded)
                {
                    fixed (uint *pSIRequestedLocal = &pSIRequested)
                    {
                        win32.System.SystemServices.HANDLE hObjLocal;
                        if (hObj is object)
                        {
                            hObj.DangerousAddRef(ref hObjAddRef);
                            hObjLocal = (win32.System.SystemServices.HANDLE)hObj.DangerousGetHandle();
                        }
                        else
                            hObjLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = User32.GetUserObjectSecurity(hObjLocal, pSIRequestedLocal, pSID, nLength, lpnLengthNeededLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hObjAddRef)
                    hObj.DangerousRelease();
            }
        }

        /// <summary>Retrieves security information for the specified user object.</summary>
        /// <param name = "hObj">A handle to the user object for which to return security information.</param>
        /// <param name = "pSIRequested">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> value that specifies the security information being requested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getuserobjectsecurity#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pSID">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> structure in <a href = "https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">self-relative</a> format that contains the requested information when the function returns. This buffer must be aligned on a 4-byte boundary.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getuserobjectsecurity#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nLength">The length, in bytes, of the buffer pointed to by the <i>pSD</i> parameter.</param>
        /// <param name = "lpnLengthNeeded">A pointer to a variable to receive the number of bytes required to store the complete <a href = "https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">security descriptor</a>. If this variable's value is greater than the value of the <i>nLength</i> parameter when the function returns, the function returns <b>FALSE</b> and none of the security descriptor is copied to the buffer. Otherwise, the entire security descriptor is copied.</param>
        /// <returns>
        /// <para>If the function succeeds, the function returns nonzero.</para>
        /// <para>If the function fails, it returns zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getuserobjectsecurity">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetUserObjectSecurity(win32.System.SystemServices.HANDLE hObj, uint *pSIRequested, [Optional] win32.Security.SECURITY_DESCRIPTOR*pSID, uint nLength, uint *lpnLengthNeeded);
    }
}