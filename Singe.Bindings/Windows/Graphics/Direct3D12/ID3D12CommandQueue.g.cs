// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable CS1591, CS1573, CS0465, CS0649, CS8019, CS1570, CS1584, CS1658
namespace Windows.Win32
{
    using global::System;
    using global::System.Diagnostics;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;
    using win32 = global::Windows.Win32;

    namespace Graphics.Direct3D12
    {
        [Guid("0EC870A6-5D7E-4C22-8CFC-5BAAE07616ED")]
        internal unsafe struct ID3D12CommandQueue
        {
            /// <inheritdoc cref = "QueryInterface(global::System.Guid*, void **)"/>
            internal unsafe win32.System.Com.HRESULT QueryInterface(in global::System.Guid riid, out void *ppvObject)
            {
                fixed (void **ppvObjectLocal = &ppvObject)
                {
                    fixed (global::System.Guid*riidLocal = &riid)
                    {
                        win32.System.Com.HRESULT __result = this.QueryInterface(riidLocal, ppvObjectLocal);
                        return __result;
                    }
                }
            }

            internal unsafe win32.System.Com.HRESULT QueryInterface(global::System.Guid*riid, void **ppvObject)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->QueryInterface_1(pThis, riid, ppvObject);
            }

            internal uint AddRef()
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->AddRef_2(pThis);
            }

            internal uint Release()
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->Release_3(pThis);
            }

            /// <inheritdoc cref = "GetPrivateData(global::System.Guid*, uint *, void *)"/>
            internal unsafe win32.System.Com.HRESULT GetPrivateData(in global::System.Guid guid, ref uint pDataSize, void *pData)
            {
                fixed (uint *pDataSizeLocal = &pDataSize)
                {
                    fixed (global::System.Guid*guidLocal = &guid)
                    {
                        win32.System.Com.HRESULT __result = this.GetPrivateData(guidLocal, pDataSizeLocal, pData);
                        return __result;
                    }
                }
            }

            internal unsafe win32.System.Com.HRESULT GetPrivateData(global::System.Guid*guid, uint *pDataSize, [Optional] void *pData)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->GetPrivateData_4(pThis, guid, pDataSize, pData);
            }

            /// <inheritdoc cref = "SetPrivateData(global::System.Guid*, uint, void *)"/>
            internal unsafe win32.System.Com.HRESULT SetPrivateData(in global::System.Guid guid, uint DataSize, void *pData)
            {
                fixed (global::System.Guid*guidLocal = &guid)
                {
                    win32.System.Com.HRESULT __result = this.SetPrivateData(guidLocal, DataSize, pData);
                    return __result;
                }
            }

            internal unsafe win32.System.Com.HRESULT SetPrivateData(global::System.Guid*guid, uint DataSize, [Optional] void *pData)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->SetPrivateData_5(pThis, guid, DataSize, pData);
            }

            /// <inheritdoc cref = "SetPrivateDataInterface(global::System.Guid*, win32.System.Com.IUnknown*)"/>
            internal unsafe win32.System.Com.HRESULT SetPrivateDataInterface(in global::System.Guid guid, win32.System.Com.IUnknown*pData)
            {
                fixed (global::System.Guid*guidLocal = &guid)
                {
                    win32.System.Com.HRESULT __result = this.SetPrivateDataInterface(guidLocal, pData);
                    return __result;
                }
            }

            internal unsafe win32.System.Com.HRESULT SetPrivateDataInterface(global::System.Guid*guid, [Optional] win32.System.Com.IUnknown*pData)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->SetPrivateDataInterface_6(pThis, guid, pData);
            }

            /// <inheritdoc cref = "SetName(win32.System.SystemServices.PCWSTR)"/>
            internal unsafe win32.System.Com.HRESULT SetName(string Name)
            {
                fixed (char *NameLocal = Name)
                {
                    win32.System.Com.HRESULT __result = this.SetName(NameLocal);
                    return __result;
                }
            }

            internal win32.System.Com.HRESULT SetName(win32.System.SystemServices.PCWSTR Name)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->SetName_7(pThis, Name);
            }

            /// <inheritdoc cref = "GetDevice(global::System.Guid*, void **)"/>
            internal unsafe win32.System.Com.HRESULT GetDevice(in global::System.Guid riid, void **ppvDevice)
            {
                fixed (global::System.Guid*riidLocal = &riid)
                {
                    win32.System.Com.HRESULT __result = this.GetDevice(riidLocal, ppvDevice);
                    return __result;
                }
            }

            internal unsafe win32.System.Com.HRESULT GetDevice(global::System.Guid*riid, [Optional] void **ppvDevice)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->GetDevice_8(pThis, riid, ppvDevice);
            }

            /// <inheritdoc cref = "UpdateTileMappings(win32.Graphics.Direct3D12.ID3D12Resource*, uint, win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*, win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*, win32.Graphics.Direct3D12.ID3D12Heap*, uint, win32.Graphics.Direct3D12.D3D12_TILE_RANGE_FLAGS*, uint *, uint *, win32.Graphics.Direct3D12.D3D12_TILE_MAPPING_FLAGS)"/>
            internal unsafe void UpdateTileMappings(win32.Graphics.Direct3D12.ID3D12Resource*pResource, ReadOnlySpan<win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE> pResourceRegionStartCoordinates, ReadOnlySpan<win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE> pResourceRegionSizes, win32.Graphics.Direct3D12.ID3D12Heap*pHeap, ReadOnlySpan<win32.Graphics.Direct3D12.D3D12_TILE_RANGE_FLAGS> pRangeFlags, ReadOnlySpan<uint> pHeapRangeStartOffsets, ReadOnlySpan<uint> pRangeTileCounts, win32.Graphics.Direct3D12.D3D12_TILE_MAPPING_FLAGS Flags)
            {
                fixed (uint *pRangeTileCountsLocal = pRangeTileCounts)
                {
                    fixed (uint *pHeapRangeStartOffsetsLocal = pHeapRangeStartOffsets)
                    {
                        fixed (win32.Graphics.Direct3D12.D3D12_TILE_RANGE_FLAGS*pRangeFlagsLocal = pRangeFlags)
                        {
                            fixed (win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*pResourceRegionSizesLocal = pResourceRegionSizes)
                            {
                                fixed (win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*pResourceRegionStartCoordinatesLocal = pResourceRegionStartCoordinates)
                                {
                                    if (pResourceRegionStartCoordinates.Length != pResourceRegionSizes.Length)
                                        throw new ArgumentException();
                                    if (pRangeFlags.Length != pHeapRangeStartOffsets.Length)
                                        throw new ArgumentException();
                                    if (pRangeFlags.Length != pRangeTileCounts.Length)
                                        throw new ArgumentException();
                                    this.UpdateTileMappings(pResource, (uint)pResourceRegionSizes.Length, pResourceRegionStartCoordinatesLocal, pResourceRegionSizesLocal, pHeap, (uint)pRangeTileCounts.Length, pRangeFlagsLocal, pHeapRangeStartOffsetsLocal, pRangeTileCountsLocal, Flags);
                                }
                            }
                        }
                    }
                }
            }

            /// <summary>Updates mappings of tile locations in reserved resources to memory locations in a resource heap.</summary>
            /// <param name = "pResource">A pointer to the reserved resource.</param>
            /// <param name = "NumResourceRegions">The number of reserved resource regions.</param>
            /// <param name = "pResourceRegionStartCoordinates">An array of <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ns-d3d12-d3d12_tiled_resource_coordinate">D3D12_TILED_RESOURCE_COORDINATE</a> structures that describe the starting coordinates of the reserved resource regions. The <i>NumResourceRegions</i> parameter specifies the number of <b>D3D12_TILED_RESOURCE_COORDINATE</b> structures in the array.</param>
            /// <param name = "pResourceRegionSizes">An array of <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ns-d3d12-d3d12_tile_region_size">D3D12_TILE_REGION_SIZE</a> structures that describe the sizes of the reserved resource regions. The <i>NumResourceRegions</i> parameter specifies the number of <b>D3D12_TILE_REGION_SIZE</b> structures in the array.</param>
            /// <param name = "pHeap">A pointer to the resource heap.</param>
            /// <param name = "NumRanges">The number of tile  ranges.</param>
            /// <param name = "pRangeFlags">A pointer to an  array of <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ne-d3d12-d3d12_tile_range_flags">D3D12_TILE_RANGE_FLAGS</a> values that describes each tile range. The <i>NumRanges</i> parameter specifies the number of values in the array.</param>
            /// <param name = "pHeapRangeStartOffsets">An array of offsets into the resource heap. These are 0-based tile offsets, counting in tiles (not bytes).</param>
            /// <param name = "pRangeTileCounts">
            /// <para>An array of tiles. An array of values that specify the number of tiles in each tile range. The <i>NumRanges</i> parameter specifies the number of values in the array.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-updatetilemappings#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "Flags">A combination of <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ne-d3d12-d3d12_tile_mapping_flags">D3D12_TILE_MAPPING_FLAGS</a> values that are combined by using a bitwise OR operation.</param>
            /// <remarks>
            /// <para>Use <b>UpdateTileMappings</b> to map the virtual pages of a reserved resource to the physical pages of a heap. The mapping does not have to be in order. The operation is similar to  <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_2/nf-d3d11_2-id3d11devicecontext2-updatetilemappings">ID3D11DeviceContext2::UpdateTileMappings</a> with the one key difference that D3D12 allows a reserved resource to have tiles from multiple heaps. In a single call to <b>UpdateTileMappings</b>, you can map one or more ranges of resource tiles to one or more ranges of heap tiles.</para>
            /// <para>You can organize the parameters of  <b>UpdateTileMappings</b> in these ways to perform an update:</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-updatetilemappings#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void UpdateTileMappings(win32.Graphics.Direct3D12.ID3D12Resource*pResource, uint NumResourceRegions, [Optional] win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*pResourceRegionStartCoordinates, [Optional] win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*pResourceRegionSizes, [Optional] win32.Graphics.Direct3D12.ID3D12Heap*pHeap, uint NumRanges, [Optional] win32.Graphics.Direct3D12.D3D12_TILE_RANGE_FLAGS*pRangeFlags, [Optional] uint *pHeapRangeStartOffsets, [Optional] uint *pRangeTileCounts, win32.Graphics.Direct3D12.D3D12_TILE_MAPPING_FLAGS Flags)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    lpVtbl->UpdateTileMappings_9(pThis, pResource, NumResourceRegions, pResourceRegionStartCoordinates, pResourceRegionSizes, pHeap, NumRanges, pRangeFlags, pHeapRangeStartOffsets, pRangeTileCounts, Flags);
            }

            /// <inheritdoc cref = "CopyTileMappings(win32.Graphics.Direct3D12.ID3D12Resource*, win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*, win32.Graphics.Direct3D12.ID3D12Resource*, win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*, win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*, win32.Graphics.Direct3D12.D3D12_TILE_MAPPING_FLAGS)"/>
            internal unsafe void CopyTileMappings(win32.Graphics.Direct3D12.ID3D12Resource*pDstResource, in win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE pDstRegionStartCoordinate, win32.Graphics.Direct3D12.ID3D12Resource*pSrcResource, in win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE pSrcRegionStartCoordinate, in win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE pRegionSize, win32.Graphics.Direct3D12.D3D12_TILE_MAPPING_FLAGS Flags)
            {
                fixed (win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*pRegionSizeLocal = &pRegionSize)
                {
                    fixed (win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*pSrcRegionStartCoordinateLocal = &pSrcRegionStartCoordinate)
                    {
                        fixed (win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*pDstRegionStartCoordinateLocal = &pDstRegionStartCoordinate)
                        {
                            this.CopyTileMappings(pDstResource, pDstRegionStartCoordinateLocal, pSrcResource, pSrcRegionStartCoordinateLocal, pRegionSizeLocal, Flags);
                        }
                    }
                }
            }

            /// <summary>Copies mappings from a source reserved resource to a destination reserved resource.</summary>
            /// <param name = "pDstResource">A pointer to the destination reserved resource.</param>
            /// <param name = "pDstRegionStartCoordinate">
            /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ns-d3d12-d3d12_tiled_resource_coordinate">D3D12_TILED_RESOURCE_COORDINATE</a> structure that describes the starting coordinates of the destination reserved resource.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-copytilemappings#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pSrcResource">A pointer to the source reserved resource.</param>
            /// <param name = "pSrcRegionStartCoordinate">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ns-d3d12-d3d12_tiled_resource_coordinate">D3D12_TILED_RESOURCE_COORDINATE</a> structure that describes the starting coordinates of the source reserved resource.</param>
            /// <param name = "pRegionSize">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ns-d3d12-d3d12_tile_region_size">D3D12_TILE_REGION_SIZE</a> structure that describes the size of the reserved region.</param>
            /// <param name = "Flags">One member of <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ne-d3d12-d3d12_tile_mapping_flags">D3D12_TILE_MAPPING_FLAGS</a>.</param>
            /// <remarks>
            /// <para>Use <b>CopyTileMappings</b> to copy the tile mappings from one reserved resource to another, either to duplicate a resource mapping, or to initialize a new mapping before modifying it using <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-updatetilemappings">UpdateTileMappings</a>. <b>CopyTileMappings</b> helps with tasks such as shifting mappings around within and across reserved resources, for example, scrolling tiles. The source and destination regions can overlap; the result of the copy in this situation is as if the source was saved to a temporary location and from there written to the destination.</para>
            /// <para>The destination and the source regions must each entirely fit in their resource or behavior is undefined and the debug layer will emit an error.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-copytilemappings#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void CopyTileMappings(win32.Graphics.Direct3D12.ID3D12Resource*pDstResource, win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*pDstRegionStartCoordinate, win32.Graphics.Direct3D12.ID3D12Resource*pSrcResource, win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*pSrcRegionStartCoordinate, win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*pRegionSize, win32.Graphics.Direct3D12.D3D12_TILE_MAPPING_FLAGS Flags)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    lpVtbl->CopyTileMappings_10(pThis, pDstResource, pDstRegionStartCoordinate, pSrcResource, pSrcRegionStartCoordinate, pRegionSize, Flags);
            }

            /// <summary>Submits an array of command lists for execution.</summary>
            /// <param name = "NumCommandLists">The number of command lists to be executed.</param>
            /// <param name = "ppCommandLists">The array of <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/nn-d3d12-id3d12commandlist">ID3D12CommandList</a> command lists to be executed.</param>
            /// <remarks>
            /// <para>Calling **ExecuteCommandLists** twice in succession (from the same thread, or different threads) guarantees that the first workload (A) finishes before the second workload (B). Calling **ExecuteCommandLists** with *two* command lists allows the driver to merge the two command lists such that the second command list (D) may begin executing work before all work from the first (C) has finished. Specifically, your application is allowed to insert a fence signal or wait between A and B, and the driver has no visibility into this, so the driver must ensure that everything in A is complete before the fence operation. There is no such opportunity in a single call to the API, so the driver is able to optimize that scenario.</para>
            /// <para>The driver is free to patch the submitted command lists. It is the calling application’s responsibility to ensure that the graphics processing unit (GPU) is not currently reading the any of the submitted command lists from a previous execution.</para>
            /// <para>Applications are encouraged to batch together command list executions to reduce fixed costs associated with submitted commands to the GPU.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-executecommandlists#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void ExecuteCommandLists(uint NumCommandLists, win32.Graphics.Direct3D12.ID3D12CommandList**ppCommandLists)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    lpVtbl->ExecuteCommandLists_11(pThis, NumCommandLists, ppCommandLists);
            }

            /// <summary>Not intended to be called directly.  Use the PIX event runtime to insert events into a command queue.</summary>
            /// <param name = "Metadata">
            /// <para>Type: <b>UINT</b></para>
            /// <para>Internal.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-setmarker#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pData">
            /// <para>Type: <b>const void*</b></para>
            /// <para>Internal.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-setmarker#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "Size">
            /// <para>Type: <b>UINT</b></para>
            /// <para>Internal.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-setmarker#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>This is a support method used internally by the PIX event runtime.  It is not intended to be called directly.</para>
            /// <para>To insert instrumentation markers at the current location within a D3D12 command queue, use the <b>PIXSetMarker</b> function.  This is provided by the <a href = "https://devblogs.microsoft.com/pix/winpixeventruntime/">WinPixEventRuntime</a> NuGet package.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-setmarker#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void SetMarker(uint Metadata, [Optional] void *pData, uint Size)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    lpVtbl->SetMarker_12(pThis, Metadata, pData, Size);
            }

            /// <summary>Not intended to be called directly.  Use the PIX event runtime to insert events into a command queue.</summary>
            /// <param name = "Metadata">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>Internal.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-beginevent#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pData">
            /// <para>Type: <b>const void*</b></para>
            /// <para>Internal.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-beginevent#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "Size">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>Internal.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-beginevent#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>This is a support method used internally by the PIX event runtime.  It is not intended to be called directly.</para>
            /// <para>To mark the start of an instrumentation region at the current location within a D3D12 command queue, use the <b>PIXBeginEvent</b> function or <b>PIXScopedEvent</b> macro.  These are provided by the <a href = "https://devblogs.microsoft.com/pix/winpixeventruntime/">WinPixEventRuntime</a> NuGet package.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-beginevent#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void BeginEvent(uint Metadata, [Optional] void *pData, uint Size)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    lpVtbl->BeginEvent_13(pThis, Metadata, pData, Size);
            }

            /// <summary>Not intended to be called directly.  Use the PIX event runtime to insert events into a command queue.</summary>
            /// <remarks>
            /// <para>This is a support method used internally by the PIX event runtime.  It is not intended to be called directly.</para>
            /// <para>To mark the end of an instrumentation region at the current location within a D3D12 command queue, use the <b>PIXEndEvent</b> function or <b>PIXScopedEvent</b> macro.  These are provided by the <a href = "https://devblogs.microsoft.com/pix/winpixeventruntime/">WinPixEventRuntime</a> NuGet package.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-endevent#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal void EndEvent()
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    lpVtbl->EndEvent_14(pThis);
            }

            /// <summary>Updates a fence to a specified value.</summary>
            /// <param name = "pFence">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/win32/api/d3d12/nn-d3d12-id3d12fence">ID3D12Fence</a>*</b></para>
            /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/win32/api/d3d12/nn-d3d12-id3d12fence">ID3D12Fence</a> object.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-signal#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "Value">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/win32/WinProg/windows-data-types">UINT64</a></b></para>
            /// <para>The value to set the fence to.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-signal#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <returns>
            /// <para>Type: <b><a href = "/windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
            /// <para>This method returns one of the <a href = "/windows/win32/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
            /// </returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-signal">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe win32.System.Com.HRESULT Signal(win32.Graphics.Direct3D12.ID3D12Fence*pFence, ulong Value)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->Signal_15(pThis, pFence, Value);
            }

            /// <summary>Queues a GPU-side wait, and returns immediately. A GPU-side wait is where the GPU waits until the specified fence reaches or exceeds the specified value.</summary>
            /// <param name = "pFence">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/win32/api/d3d12/nn-d3d12-id3d12fence">ID3D12Fence</a>*</b></para>
            /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/win32/api/d3d12/nn-d3d12-id3d12fence">ID3D12Fence</a> object.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-wait#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "Value">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/win32/WinProg/windows-data-types">UINT64</a></b></para>
            /// <para>The value that the command queue is waiting for the fence to reach or exceed.  So when  <a href = "https://docs.microsoft.com/windows/win32/api/d3d12/nf-d3d12-id3d12fence-getcompletedvalue">ID3D12Fence::GetCompletedValue</a> is greater than or equal to <i>Value</i>, the wait is terminated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-wait#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <returns>
            /// <para>Type: <b><a href = "/windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
            /// <para>This method returns one of the <a href = "/windows/win32/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
            /// </returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-wait">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe win32.System.Com.HRESULT Wait(win32.Graphics.Direct3D12.ID3D12Fence*pFence, ulong Value)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->Wait_16(pThis, pFence, Value);
            }

            /// <inheritdoc cref = "GetTimestampFrequency(ulong *)"/>
            internal unsafe win32.System.Com.HRESULT GetTimestampFrequency(out ulong pFrequency)
            {
                fixed (ulong *pFrequencyLocal = &pFrequency)
                {
                    win32.System.Com.HRESULT __result = this.GetTimestampFrequency(pFrequencyLocal);
                    return __result;
                }
            }

            /// <summary>This method is used to determine the rate at which the GPU timestamp counter increments.</summary>
            /// <param name = "pFrequency">
            /// <para>Type: <b>UINT64*</b></para>
            /// <para>The GPU timestamp counter frequency (in ticks/second).</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-gettimestampfrequency#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <returns>
            /// <para>Type: <b><a href = "/windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
            /// <para>This method returns one of the <a href = "/windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
            /// </returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-gettimestampfrequency">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe win32.System.Com.HRESULT GetTimestampFrequency(ulong *pFrequency)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->GetTimestampFrequency_17(pThis, pFrequency);
            }

            /// <inheritdoc cref = "GetClockCalibration(ulong *, ulong *)"/>
            internal unsafe win32.System.Com.HRESULT GetClockCalibration(out ulong pGpuTimestamp, out ulong pCpuTimestamp)
            {
                fixed (ulong *pCpuTimestampLocal = &pCpuTimestamp)
                {
                    fixed (ulong *pGpuTimestampLocal = &pGpuTimestamp)
                    {
                        win32.System.Com.HRESULT __result = this.GetClockCalibration(pGpuTimestampLocal, pCpuTimestampLocal);
                        return __result;
                    }
                }
            }

            /// <summary>This method samples the CPU and GPU timestamp counters at the same moment in time.</summary>
            /// <param name = "pGpuTimestamp">
            /// <para>Type: <b>UINT64*</b></para>
            /// <para>The value of the GPU timestamp counter.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-getclockcalibration#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pCpuTimestamp">
            /// <para>Type: <b>UINT64*</b></para>
            /// <para>The value of the CPU timestamp counter.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-getclockcalibration#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <returns>
            /// <para>Type: <b><a href = "/windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
            /// <para>This method returns one of the <a href = "/windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
            /// </returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-getclockcalibration">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe win32.System.Com.HRESULT GetClockCalibration(ulong *pGpuTimestamp, ulong *pCpuTimestamp)
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->GetClockCalibration_18(pThis, pGpuTimestamp, pCpuTimestamp);
            }

            /// <summary>Gets the description of the command queue.</summary>
            /// <returns>
            /// <para>Type: <b><a href = "/windows/desktop/api/d3d12/ns-d3d12-d3d12_command_queue_desc">D3D12_COMMAND_QUEUE_DESC</a></b></para>
            /// <para>The description of the command queue, as a <a href = "/windows/desktop/api/d3d12/ns-d3d12-d3d12_command_queue_desc">D3D12_COMMAND_QUEUE_DESC</a> structure.</para>
            /// </returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12commandqueue-getdesc">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal win32.Graphics.Direct3D12.D3D12_COMMAND_QUEUE_DESC GetDesc()
            {
                fixed (ID3D12CommandQueue*pThis = &this)
                    return lpVtbl->GetDesc_19(pThis);
            }

            private struct Vtbl
            {
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, global::System.Guid*, void **, win32.System.Com.HRESULT>QueryInterface_1;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, uint>AddRef_2;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, uint>Release_3;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, global::System.Guid*, uint *, void *, win32.System.Com.HRESULT>GetPrivateData_4;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, global::System.Guid*, uint, void *, win32.System.Com.HRESULT>SetPrivateData_5;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, global::System.Guid*, win32.System.Com.IUnknown*, win32.System.Com.HRESULT>SetPrivateDataInterface_6;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, win32.System.SystemServices.PCWSTR, win32.System.Com.HRESULT>SetName_7;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, global::System.Guid*, void **, win32.System.Com.HRESULT>GetDevice_8;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, win32.Graphics.Direct3D12.ID3D12Resource*, uint, win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*, win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*, win32.Graphics.Direct3D12.ID3D12Heap*, uint, win32.Graphics.Direct3D12.D3D12_TILE_RANGE_FLAGS*, uint *, uint *, win32.Graphics.Direct3D12.D3D12_TILE_MAPPING_FLAGS, void>UpdateTileMappings_9;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, win32.Graphics.Direct3D12.ID3D12Resource*, win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*, win32.Graphics.Direct3D12.ID3D12Resource*, win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*, win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*, win32.Graphics.Direct3D12.D3D12_TILE_MAPPING_FLAGS, void>CopyTileMappings_10;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, uint, win32.Graphics.Direct3D12.ID3D12CommandList**, void>ExecuteCommandLists_11;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, uint, void *, uint, void>SetMarker_12;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, uint, void *, uint, void>BeginEvent_13;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, void>EndEvent_14;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, win32.Graphics.Direct3D12.ID3D12Fence*, ulong, win32.System.Com.HRESULT>Signal_15;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, win32.Graphics.Direct3D12.ID3D12Fence*, ulong, win32.System.Com.HRESULT>Wait_16;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, ulong *, win32.System.Com.HRESULT>GetTimestampFrequency_17;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, ulong *, ulong *, win32.System.Com.HRESULT>GetClockCalibration_18;
                internal delegate *unmanaged[Stdcall]<ID3D12CommandQueue*, win32.Graphics.Direct3D12.D3D12_COMMAND_QUEUE_DESC>GetDesc_19;
            }

            private Vtbl*lpVtbl;
        }
    }
}