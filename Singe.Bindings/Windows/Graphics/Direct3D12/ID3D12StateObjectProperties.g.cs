// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable CS1591, CS1573, CS0465, CS0649, CS8019, CS1570, CS1584, CS1658
namespace Windows.Win32
{
    using global::System;
    using global::System.Diagnostics;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;
    using win32 = global::Windows.Win32;

    namespace Graphics.Direct3D12
    {
        [Guid("DE5FA827-9BF9-4F26-89FF-D7F56FDE3860")]
        internal unsafe struct ID3D12StateObjectProperties
        {
            /// <inheritdoc cref = "QueryInterface(global::System.Guid*, void **)"/>
            internal unsafe win32.System.Com.HRESULT QueryInterface(in global::System.Guid riid, out void *ppvObject)
            {
                fixed (void **ppvObjectLocal = &ppvObject)
                {
                    fixed (global::System.Guid*riidLocal = &riid)
                    {
                        win32.System.Com.HRESULT __result = this.QueryInterface(riidLocal, ppvObjectLocal);
                        return __result;
                    }
                }
            }

            internal unsafe win32.System.Com.HRESULT QueryInterface(global::System.Guid*riid, void **ppvObject)
            {
                fixed (ID3D12StateObjectProperties*pThis = &this)
                    return lpVtbl->QueryInterface_1(pThis, riid, ppvObject);
            }

            internal uint AddRef()
            {
                fixed (ID3D12StateObjectProperties*pThis = &this)
                    return lpVtbl->AddRef_2(pThis);
            }

            internal uint Release()
            {
                fixed (ID3D12StateObjectProperties*pThis = &this)
                    return lpVtbl->Release_3(pThis);
            }

            /// <inheritdoc cref = "GetShaderIdentifier(win32.System.SystemServices.PCWSTR)"/>
            internal unsafe void *GetShaderIdentifier(string pExportName)
            {
                fixed (char *pExportNameLocal = pExportName)
                {
                    void *__result = this.GetShaderIdentifier(pExportNameLocal);
                    return __result;
                }
            }

            /// <summary>Retrieves the unique identifier for a shader that can be used in a shader record.</summary>
            /// <param name = "pExportName">Entrypoint in the state object for which to retrieve an identifier.</param>
            /// <returns>
            /// <para>A pointer to the shader identifier.</para>
            /// <para>The data referenced by this pointer is valid as long as the state object it came from is valid.  The size of the data returned is <a href = "/windows/desktop/direct3d12/constants">D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES</a>.  Applications should copy and cache this data to avoid the cost of searching for it in the state object if it will need to be retrieved many times.  The identifier is used in shader records within shader tables in GPU memory, which the app must populate.</para>
            /// <para>The data itself globally identifies the shader, so even if the shader appears in a different state object with same associations, like any root signatures, it will have the same identifier.</para>
            /// <para>If the shader isn’t fully resolved in the state object, the return value is <b>nullptr</b>.</para>
            /// </returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12stateobjectproperties-getshaderidentifier">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void *GetShaderIdentifier(win32.System.SystemServices.PCWSTR pExportName)
            {
                fixed (ID3D12StateObjectProperties*pThis = &this)
                    return lpVtbl->GetShaderIdentifier_4(pThis, pExportName);
            }

            /// <inheritdoc cref = "GetShaderStackSize(win32.System.SystemServices.PCWSTR)"/>
            internal unsafe ulong GetShaderStackSize(string pExportName)
            {
                fixed (char *pExportNameLocal = pExportName)
                {
                    ulong __result = this.GetShaderStackSize(pExportNameLocal);
                    return __result;
                }
            }

            /// <summary>Gets the amount of stack memory required to invoke a raytracing shader in HLSL.</summary>
            /// <param name = "pExportName">
            /// <para>The shader entrypoint in the state object for which to retrieve stack size.  For hit groups, an individual shader within the hit group must be specified using the syntax:</para>
            /// <para>hitGroupName::shaderType</para>
            /// <para>Where <i>hitGroupName</i> is the entrypoint name for the hit group and <i>shaderType</i> is one of:</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12stateobjectproperties-getshaderstacksize#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <returns>Amount of stack memory, in bytes, required to invoke the shader.  If the shader isn’t fully resolved in the state object, or the shader is unknown or of a type for which a stack size isn’t relevant, such as a hit group, the return value is 0xffffffff.  The 32-bit 0xffffffff value is used  for the UINT64 return value to ensure that bad return values don’t get lost when summed up with other values as part of calculating an overall pipeline stack size.</returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12stateobjectproperties-getshaderstacksize">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal ulong GetShaderStackSize(win32.System.SystemServices.PCWSTR pExportName)
            {
                fixed (ID3D12StateObjectProperties*pThis = &this)
                    return lpVtbl->GetShaderStackSize_5(pThis, pExportName);
            }

            /// <summary>Gets the current pipeline stack size.</summary>
            /// <returns>The current pipeline stack size in bytes. When called on non-executable state objects, such as collections, the return value is 0.</returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12stateobjectproperties-getpipelinestacksize">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal ulong GetPipelineStackSize()
            {
                fixed (ID3D12StateObjectProperties*pThis = &this)
                    return lpVtbl->GetPipelineStackSize_6(pThis);
            }

            /// <summary>Set the current pipeline stack size.</summary>
            /// <param name = "PipelineStackSizeInBytes">
            /// <para>Stack size in bytes to use during pipeline execution for each shader thread. There can be many thousands of threads in flight at once on the GPU.</para>
            /// <para>If the value is greater than 0xffffffff (the maximum value of a 32-bit UINT) the runtime will drop the call, and the debug layer will print an error, as this is likely the result of summing up invalid stack sizes returned from <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/nf-d3d12-id3d12stateobjectproperties-getshaderstacksize">GetShaderStackSize</a> called with invalid parameters, which return 0xffffffff.  In this case, the previously set stack size, or the default, remains.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12stateobjectproperties-setpipelinestacksize#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>This method and <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/nf-d3d12-id3d12stateobjectproperties-getpipelinestacksize">GetPipelineStackSize</a> are not re-entrant.  This means if calling either or both from separate threads, the app must synchronize on its own.</para>
            /// <para>The runtime drops calls to state objects other than raytracing pipelines, such as collections.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12stateobjectproperties-setpipelinestacksize#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal void SetPipelineStackSize(ulong PipelineStackSizeInBytes)
            {
                fixed (ID3D12StateObjectProperties*pThis = &this)
                    lpVtbl->SetPipelineStackSize_7(pThis, PipelineStackSizeInBytes);
            }

            private struct Vtbl
            {
                internal delegate *unmanaged[Stdcall]<ID3D12StateObjectProperties*, global::System.Guid*, void **, win32.System.Com.HRESULT>QueryInterface_1;
                internal delegate *unmanaged[Stdcall]<ID3D12StateObjectProperties*, uint>AddRef_2;
                internal delegate *unmanaged[Stdcall]<ID3D12StateObjectProperties*, uint>Release_3;
                internal delegate *unmanaged[Stdcall]<ID3D12StateObjectProperties*, win32.System.SystemServices.PCWSTR, void *>GetShaderIdentifier_4;
                internal delegate *unmanaged[Stdcall]<ID3D12StateObjectProperties*, win32.System.SystemServices.PCWSTR, ulong>GetShaderStackSize_5;
                internal delegate *unmanaged[Stdcall]<ID3D12StateObjectProperties*, ulong>GetPipelineStackSize_6;
                internal delegate *unmanaged[Stdcall]<ID3D12StateObjectProperties*, ulong, void>SetPipelineStackSize_7;
            }

            private Vtbl*lpVtbl;
        }
    }
}