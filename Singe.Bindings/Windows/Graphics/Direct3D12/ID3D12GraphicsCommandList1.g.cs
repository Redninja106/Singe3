// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable CS1591, CS1573, CS0465, CS0649, CS8019, CS1570, CS1584, CS1658
namespace Windows.Win32
{
    using global::System;
    using global::System.Diagnostics;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;
    using win32 = global::Windows.Win32;

    namespace Graphics.Direct3D12
    {
        [Guid("553103FB-1FE7-4557-BB38-946D7D0E7CA7")]
        internal unsafe struct ID3D12GraphicsCommandList1
        {
            /// <inheritdoc cref = "QueryInterface(global::System.Guid*, void **)"/>
            internal unsafe win32.System.Com.HRESULT QueryInterface(in global::System.Guid riid, out void *ppvObject)
            {
                fixed (void **ppvObjectLocal = &ppvObject)
                {
                    fixed (global::System.Guid*riidLocal = &riid)
                    {
                        win32.System.Com.HRESULT __result = this.QueryInterface(riidLocal, ppvObjectLocal);
                        return __result;
                    }
                }
            }

            internal unsafe win32.System.Com.HRESULT QueryInterface(global::System.Guid*riid, void **ppvObject)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    return lpVtbl->QueryInterface_1(pThis, riid, ppvObject);
            }

            internal uint AddRef()
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    return lpVtbl->AddRef_2(pThis);
            }

            internal uint Release()
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    return lpVtbl->Release_3(pThis);
            }

            /// <inheritdoc cref = "GetPrivateData(global::System.Guid*, uint *, void *)"/>
            internal unsafe win32.System.Com.HRESULT GetPrivateData(in global::System.Guid guid, ref uint pDataSize, void *pData)
            {
                fixed (uint *pDataSizeLocal = &pDataSize)
                {
                    fixed (global::System.Guid*guidLocal = &guid)
                    {
                        win32.System.Com.HRESULT __result = this.GetPrivateData(guidLocal, pDataSizeLocal, pData);
                        return __result;
                    }
                }
            }

            internal unsafe win32.System.Com.HRESULT GetPrivateData(global::System.Guid*guid, uint *pDataSize, [Optional] void *pData)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    return lpVtbl->GetPrivateData_4(pThis, guid, pDataSize, pData);
            }

            /// <inheritdoc cref = "SetPrivateData(global::System.Guid*, uint, void *)"/>
            internal unsafe win32.System.Com.HRESULT SetPrivateData(in global::System.Guid guid, uint DataSize, void *pData)
            {
                fixed (global::System.Guid*guidLocal = &guid)
                {
                    win32.System.Com.HRESULT __result = this.SetPrivateData(guidLocal, DataSize, pData);
                    return __result;
                }
            }

            internal unsafe win32.System.Com.HRESULT SetPrivateData(global::System.Guid*guid, uint DataSize, [Optional] void *pData)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    return lpVtbl->SetPrivateData_5(pThis, guid, DataSize, pData);
            }

            /// <inheritdoc cref = "SetPrivateDataInterface(global::System.Guid*, win32.System.Com.IUnknown*)"/>
            internal unsafe win32.System.Com.HRESULT SetPrivateDataInterface(in global::System.Guid guid, win32.System.Com.IUnknown*pData)
            {
                fixed (global::System.Guid*guidLocal = &guid)
                {
                    win32.System.Com.HRESULT __result = this.SetPrivateDataInterface(guidLocal, pData);
                    return __result;
                }
            }

            internal unsafe win32.System.Com.HRESULT SetPrivateDataInterface(global::System.Guid*guid, [Optional] win32.System.Com.IUnknown*pData)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    return lpVtbl->SetPrivateDataInterface_6(pThis, guid, pData);
            }

            /// <inheritdoc cref = "SetName(win32.System.SystemServices.PCWSTR)"/>
            internal unsafe win32.System.Com.HRESULT SetName(string Name)
            {
                fixed (char *NameLocal = Name)
                {
                    win32.System.Com.HRESULT __result = this.SetName(NameLocal);
                    return __result;
                }
            }

            internal win32.System.Com.HRESULT SetName(win32.System.SystemServices.PCWSTR Name)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    return lpVtbl->SetName_7(pThis, Name);
            }

            /// <inheritdoc cref = "GetDevice(global::System.Guid*, void **)"/>
            internal unsafe win32.System.Com.HRESULT GetDevice(in global::System.Guid riid, void **ppvDevice)
            {
                fixed (global::System.Guid*riidLocal = &riid)
                {
                    win32.System.Com.HRESULT __result = this.GetDevice(riidLocal, ppvDevice);
                    return __result;
                }
            }

            internal unsafe win32.System.Com.HRESULT GetDevice(global::System.Guid*riid, [Optional] void **ppvDevice)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    return lpVtbl->GetDevice_8(pThis, riid, ppvDevice);
            }

            internal new win32.Graphics.Direct3D12.D3D12_COMMAND_LIST_TYPE GetType()
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    return lpVtbl->GetType_9(pThis);
            }

            internal win32.System.Com.HRESULT Close()
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    return lpVtbl->Close_10(pThis);
            }

            internal unsafe win32.System.Com.HRESULT Reset(win32.Graphics.Direct3D12.ID3D12CommandAllocator*pAllocator, [Optional] win32.Graphics.Direct3D12.ID3D12PipelineState*pInitialState)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    return lpVtbl->Reset_11(pThis, pAllocator, pInitialState);
            }

            internal unsafe void ClearState([Optional] win32.Graphics.Direct3D12.ID3D12PipelineState*pPipelineState)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->ClearState_12(pThis, pPipelineState);
            }

            internal void DrawInstanced(uint VertexCountPerInstance, uint InstanceCount, uint StartVertexLocation, uint StartInstanceLocation)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->DrawInstanced_13(pThis, VertexCountPerInstance, InstanceCount, StartVertexLocation, StartInstanceLocation);
            }

            internal void DrawIndexedInstanced(uint IndexCountPerInstance, uint InstanceCount, uint StartIndexLocation, int BaseVertexLocation, uint StartInstanceLocation)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->DrawIndexedInstanced_14(pThis, IndexCountPerInstance, InstanceCount, StartIndexLocation, BaseVertexLocation, StartInstanceLocation);
            }

            internal void Dispatch(uint ThreadGroupCountX, uint ThreadGroupCountY, uint ThreadGroupCountZ)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->Dispatch_15(pThis, ThreadGroupCountX, ThreadGroupCountY, ThreadGroupCountZ);
            }

            internal unsafe void CopyBufferRegion(win32.Graphics.Direct3D12.ID3D12Resource*pDstBuffer, ulong DstOffset, win32.Graphics.Direct3D12.ID3D12Resource*pSrcBuffer, ulong SrcOffset, ulong NumBytes)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->CopyBufferRegion_16(pThis, pDstBuffer, DstOffset, pSrcBuffer, SrcOffset, NumBytes);
            }

            /// <inheritdoc cref = "CopyTextureRegion(win32.Graphics.Direct3D12.D3D12_TEXTURE_COPY_LOCATION*, uint, uint, uint, win32.Graphics.Direct3D12.D3D12_TEXTURE_COPY_LOCATION*, win32.Graphics.Direct3D12.D3D12_BOX*)"/>
            internal unsafe void CopyTextureRegion(in win32.Graphics.Direct3D12.D3D12_TEXTURE_COPY_LOCATION pDst, uint DstX, uint DstY, uint DstZ, in win32.Graphics.Direct3D12.D3D12_TEXTURE_COPY_LOCATION pSrc, win32.Graphics.Direct3D12.D3D12_BOX? pSrcBox)
            {
                fixed (win32.Graphics.Direct3D12.D3D12_TEXTURE_COPY_LOCATION*pSrcLocal = &pSrc)
                {
                    fixed (win32.Graphics.Direct3D12.D3D12_TEXTURE_COPY_LOCATION*pDstLocal = &pDst)
                    {
                        win32.Graphics.Direct3D12.D3D12_BOX pSrcBoxLocal = pSrcBox.HasValue ? pSrcBox.Value : default(win32.Graphics.Direct3D12.D3D12_BOX);
                        this.CopyTextureRegion(pDstLocal, DstX, DstY, DstZ, pSrcLocal, pSrcBox.HasValue ? &pSrcBoxLocal : null);
                    }
                }
            }

            internal unsafe void CopyTextureRegion(win32.Graphics.Direct3D12.D3D12_TEXTURE_COPY_LOCATION*pDst, uint DstX, uint DstY, uint DstZ, win32.Graphics.Direct3D12.D3D12_TEXTURE_COPY_LOCATION*pSrc, [Optional] win32.Graphics.Direct3D12.D3D12_BOX*pSrcBox)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->CopyTextureRegion_17(pThis, pDst, DstX, DstY, DstZ, pSrc, pSrcBox);
            }

            internal unsafe void CopyResource(win32.Graphics.Direct3D12.ID3D12Resource*pDstResource, win32.Graphics.Direct3D12.ID3D12Resource*pSrcResource)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->CopyResource_18(pThis, pDstResource, pSrcResource);
            }

            /// <inheritdoc cref = "CopyTiles(win32.Graphics.Direct3D12.ID3D12Resource*, win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*, win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, win32.Graphics.Direct3D12.D3D12_TILE_COPY_FLAGS)"/>
            internal unsafe void CopyTiles(win32.Graphics.Direct3D12.ID3D12Resource*pTiledResource, in win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE pTileRegionStartCoordinate, in win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE pTileRegionSize, win32.Graphics.Direct3D12.ID3D12Resource*pBuffer, ulong BufferStartOffsetInBytes, win32.Graphics.Direct3D12.D3D12_TILE_COPY_FLAGS Flags)
            {
                fixed (win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*pTileRegionSizeLocal = &pTileRegionSize)
                {
                    fixed (win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*pTileRegionStartCoordinateLocal = &pTileRegionStartCoordinate)
                    {
                        this.CopyTiles(pTiledResource, pTileRegionStartCoordinateLocal, pTileRegionSizeLocal, pBuffer, BufferStartOffsetInBytes, Flags);
                    }
                }
            }

            internal unsafe void CopyTiles(win32.Graphics.Direct3D12.ID3D12Resource*pTiledResource, win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*pTileRegionStartCoordinate, win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*pTileRegionSize, win32.Graphics.Direct3D12.ID3D12Resource*pBuffer, ulong BufferStartOffsetInBytes, win32.Graphics.Direct3D12.D3D12_TILE_COPY_FLAGS Flags)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->CopyTiles_19(pThis, pTiledResource, pTileRegionStartCoordinate, pTileRegionSize, pBuffer, BufferStartOffsetInBytes, Flags);
            }

            internal unsafe void ResolveSubresource(win32.Graphics.Direct3D12.ID3D12Resource*pDstResource, uint DstSubresource, win32.Graphics.Direct3D12.ID3D12Resource*pSrcResource, uint SrcSubresource, win32.Graphics.Dxgi.DXGI_FORMAT Format)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->ResolveSubresource_20(pThis, pDstResource, DstSubresource, pSrcResource, SrcSubresource, Format);
            }

            internal void IASetPrimitiveTopology(win32.Graphics.Direct3D11.D3D_PRIMITIVE_TOPOLOGY PrimitiveTopology)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->IASetPrimitiveTopology_21(pThis, PrimitiveTopology);
            }

            /// <inheritdoc cref = "RSSetViewports(uint, win32.Graphics.Direct3D12.D3D12_VIEWPORT*)"/>
            internal unsafe void RSSetViewports(ReadOnlySpan<win32.Graphics.Direct3D12.D3D12_VIEWPORT> pViewports)
            {
                fixed (win32.Graphics.Direct3D12.D3D12_VIEWPORT*pViewportsLocal = pViewports)
                {
                    this.RSSetViewports((uint)pViewports.Length, pViewportsLocal);
                }
            }

            internal unsafe void RSSetViewports(uint NumViewports, win32.Graphics.Direct3D12.D3D12_VIEWPORT*pViewports)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->RSSetViewports_22(pThis, NumViewports, pViewports);
            }

            /// <inheritdoc cref = "RSSetScissorRects(uint, win32.UI.DisplayDevices.RECT*)"/>
            internal unsafe void RSSetScissorRects(ReadOnlySpan<win32.UI.DisplayDevices.RECT> pRects)
            {
                fixed (win32.UI.DisplayDevices.RECT*pRectsLocal = pRects)
                {
                    this.RSSetScissorRects((uint)pRects.Length, pRectsLocal);
                }
            }

            internal unsafe void RSSetScissorRects(uint NumRects, win32.UI.DisplayDevices.RECT*pRects)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->RSSetScissorRects_23(pThis, NumRects, pRects);
            }

            /// <inheritdoc cref = "OMSetBlendFactor(float *)"/>
            internal unsafe void OMSetBlendFactor(ReadOnlySpan<float> BlendFactor)
            {
                fixed (float *BlendFactorLocal = BlendFactor)
                {
                    if (BlendFactor.Length < 4)
                        throw new ArgumentException();
                    this.OMSetBlendFactor(BlendFactorLocal);
                }
            }

            internal unsafe void OMSetBlendFactor([Optional] float *BlendFactor)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->OMSetBlendFactor_24(pThis, BlendFactor);
            }

            internal void OMSetStencilRef(uint StencilRef)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->OMSetStencilRef_25(pThis, StencilRef);
            }

            internal unsafe void SetPipelineState(win32.Graphics.Direct3D12.ID3D12PipelineState*pPipelineState)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetPipelineState_26(pThis, pPipelineState);
            }

            /// <inheritdoc cref = "ResourceBarrier(uint, win32.Graphics.Direct3D12.D3D12_RESOURCE_BARRIER*)"/>
            internal unsafe void ResourceBarrier(ReadOnlySpan<win32.Graphics.Direct3D12.D3D12_RESOURCE_BARRIER> pBarriers)
            {
                fixed (win32.Graphics.Direct3D12.D3D12_RESOURCE_BARRIER*pBarriersLocal = pBarriers)
                {
                    this.ResourceBarrier((uint)pBarriers.Length, pBarriersLocal);
                }
            }

            internal unsafe void ResourceBarrier(uint NumBarriers, win32.Graphics.Direct3D12.D3D12_RESOURCE_BARRIER*pBarriers)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->ResourceBarrier_27(pThis, NumBarriers, pBarriers);
            }

            internal unsafe void ExecuteBundle(win32.Graphics.Direct3D12.ID3D12GraphicsCommandList*pCommandList)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->ExecuteBundle_28(pThis, pCommandList);
            }

            internal unsafe void SetDescriptorHeaps(uint NumDescriptorHeaps, win32.Graphics.Direct3D12.ID3D12DescriptorHeap**ppDescriptorHeaps)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetDescriptorHeaps_29(pThis, NumDescriptorHeaps, ppDescriptorHeaps);
            }

            internal unsafe void SetComputeRootSignature([Optional] win32.Graphics.Direct3D12.ID3D12RootSignature*pRootSignature)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetComputeRootSignature_30(pThis, pRootSignature);
            }

            internal unsafe void SetGraphicsRootSignature([Optional] win32.Graphics.Direct3D12.ID3D12RootSignature*pRootSignature)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetGraphicsRootSignature_31(pThis, pRootSignature);
            }

            internal void SetComputeRootDescriptorTable(uint RootParameterIndex, win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetComputeRootDescriptorTable_32(pThis, RootParameterIndex, BaseDescriptor);
            }

            internal void SetGraphicsRootDescriptorTable(uint RootParameterIndex, win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetGraphicsRootDescriptorTable_33(pThis, RootParameterIndex, BaseDescriptor);
            }

            internal void SetComputeRoot32BitConstant(uint RootParameterIndex, uint SrcData, uint DestOffsetIn32BitValues)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetComputeRoot32BitConstant_34(pThis, RootParameterIndex, SrcData, DestOffsetIn32BitValues);
            }

            internal void SetGraphicsRoot32BitConstant(uint RootParameterIndex, uint SrcData, uint DestOffsetIn32BitValues)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetGraphicsRoot32BitConstant_35(pThis, RootParameterIndex, SrcData, DestOffsetIn32BitValues);
            }

            internal unsafe void SetComputeRoot32BitConstants(uint RootParameterIndex, uint Num32BitValuesToSet, void *pSrcData, uint DestOffsetIn32BitValues)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetComputeRoot32BitConstants_36(pThis, RootParameterIndex, Num32BitValuesToSet, pSrcData, DestOffsetIn32BitValues);
            }

            internal unsafe void SetGraphicsRoot32BitConstants(uint RootParameterIndex, uint Num32BitValuesToSet, void *pSrcData, uint DestOffsetIn32BitValues)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetGraphicsRoot32BitConstants_37(pThis, RootParameterIndex, Num32BitValuesToSet, pSrcData, DestOffsetIn32BitValues);
            }

            internal void SetComputeRootConstantBufferView(uint RootParameterIndex, ulong BufferLocation)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetComputeRootConstantBufferView_38(pThis, RootParameterIndex, BufferLocation);
            }

            internal void SetGraphicsRootConstantBufferView(uint RootParameterIndex, ulong BufferLocation)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetGraphicsRootConstantBufferView_39(pThis, RootParameterIndex, BufferLocation);
            }

            internal void SetComputeRootShaderResourceView(uint RootParameterIndex, ulong BufferLocation)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetComputeRootShaderResourceView_40(pThis, RootParameterIndex, BufferLocation);
            }

            internal void SetGraphicsRootShaderResourceView(uint RootParameterIndex, ulong BufferLocation)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetGraphicsRootShaderResourceView_41(pThis, RootParameterIndex, BufferLocation);
            }

            internal void SetComputeRootUnorderedAccessView(uint RootParameterIndex, ulong BufferLocation)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetComputeRootUnorderedAccessView_42(pThis, RootParameterIndex, BufferLocation);
            }

            internal void SetGraphicsRootUnorderedAccessView(uint RootParameterIndex, ulong BufferLocation)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetGraphicsRootUnorderedAccessView_43(pThis, RootParameterIndex, BufferLocation);
            }

            /// <inheritdoc cref = "IASetIndexBuffer(win32.Graphics.Direct3D12.D3D12_INDEX_BUFFER_VIEW*)"/>
            internal unsafe void IASetIndexBuffer(win32.Graphics.Direct3D12.D3D12_INDEX_BUFFER_VIEW? pView)
            {
                win32.Graphics.Direct3D12.D3D12_INDEX_BUFFER_VIEW pViewLocal = pView.HasValue ? pView.Value : default(win32.Graphics.Direct3D12.D3D12_INDEX_BUFFER_VIEW);
                this.IASetIndexBuffer(pView.HasValue ? &pViewLocal : null);
            }

            internal unsafe void IASetIndexBuffer([Optional] win32.Graphics.Direct3D12.D3D12_INDEX_BUFFER_VIEW*pView)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->IASetIndexBuffer_44(pThis, pView);
            }

            /// <inheritdoc cref = "IASetVertexBuffers(uint, uint, win32.Graphics.Direct3D12.D3D12_VERTEX_BUFFER_VIEW*)"/>
            internal unsafe void IASetVertexBuffers(uint StartSlot, ReadOnlySpan<win32.Graphics.Direct3D12.D3D12_VERTEX_BUFFER_VIEW> pViews)
            {
                fixed (win32.Graphics.Direct3D12.D3D12_VERTEX_BUFFER_VIEW*pViewsLocal = pViews)
                {
                    this.IASetVertexBuffers(StartSlot, (uint)pViews.Length, pViewsLocal);
                }
            }

            internal unsafe void IASetVertexBuffers(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D12.D3D12_VERTEX_BUFFER_VIEW*pViews)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->IASetVertexBuffers_45(pThis, StartSlot, NumViews, pViews);
            }

            /// <inheritdoc cref = "SOSetTargets(uint, uint, win32.Graphics.Direct3D12.D3D12_STREAM_OUTPUT_BUFFER_VIEW*)"/>
            internal unsafe void SOSetTargets(uint StartSlot, ReadOnlySpan<win32.Graphics.Direct3D12.D3D12_STREAM_OUTPUT_BUFFER_VIEW> pViews)
            {
                fixed (win32.Graphics.Direct3D12.D3D12_STREAM_OUTPUT_BUFFER_VIEW*pViewsLocal = pViews)
                {
                    this.SOSetTargets(StartSlot, (uint)pViews.Length, pViewsLocal);
                }
            }

            internal unsafe void SOSetTargets(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D12.D3D12_STREAM_OUTPUT_BUFFER_VIEW*pViews)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SOSetTargets_46(pThis, StartSlot, NumViews, pViews);
            }

            /// <inheritdoc cref = "OMSetRenderTargets(uint, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE*, win32.System.SystemServices.BOOL, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE*)"/>
            internal unsafe void OMSetRenderTargets(uint NumRenderTargetDescriptors, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE? pRenderTargetDescriptors, win32.System.SystemServices.BOOL RTsSingleHandleToDescriptorRange, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE? pDepthStencilDescriptor)
            {
                win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE pRenderTargetDescriptorsLocal = pRenderTargetDescriptors.HasValue ? pRenderTargetDescriptors.Value : default(win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE);
                win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE pDepthStencilDescriptorLocal = pDepthStencilDescriptor.HasValue ? pDepthStencilDescriptor.Value : default(win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE);
                this.OMSetRenderTargets(NumRenderTargetDescriptors, pRenderTargetDescriptors.HasValue ? &pRenderTargetDescriptorsLocal : null, RTsSingleHandleToDescriptorRange, pDepthStencilDescriptor.HasValue ? &pDepthStencilDescriptorLocal : null);
            }

            internal unsafe void OMSetRenderTargets(uint NumRenderTargetDescriptors, [Optional] win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE*pRenderTargetDescriptors, win32.System.SystemServices.BOOL RTsSingleHandleToDescriptorRange, [Optional] win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE*pDepthStencilDescriptor)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->OMSetRenderTargets_47(pThis, NumRenderTargetDescriptors, pRenderTargetDescriptors, RTsSingleHandleToDescriptorRange, pDepthStencilDescriptor);
            }

            /// <inheritdoc cref = "ClearDepthStencilView(win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE, win32.Graphics.Direct3D12.D3D12_CLEAR_FLAGS, float, byte, uint, win32.UI.DisplayDevices.RECT*)"/>
            internal unsafe void ClearDepthStencilView(win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView, win32.Graphics.Direct3D12.D3D12_CLEAR_FLAGS ClearFlags, float Depth, byte Stencil, ReadOnlySpan<win32.UI.DisplayDevices.RECT> pRects)
            {
                fixed (win32.UI.DisplayDevices.RECT*pRectsLocal = pRects)
                {
                    this.ClearDepthStencilView(DepthStencilView, ClearFlags, Depth, Stencil, (uint)pRects.Length, pRectsLocal);
                }
            }

            internal unsafe void ClearDepthStencilView(win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView, win32.Graphics.Direct3D12.D3D12_CLEAR_FLAGS ClearFlags, float Depth, byte Stencil, uint NumRects, win32.UI.DisplayDevices.RECT*pRects)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->ClearDepthStencilView_48(pThis, DepthStencilView, ClearFlags, Depth, Stencil, NumRects, pRects);
            }

            /// <inheritdoc cref = "ClearRenderTargetView(win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE, float *, uint, win32.UI.DisplayDevices.RECT*)"/>
            internal unsafe void ClearRenderTargetView(win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView, in float ColorRGBA, ReadOnlySpan<win32.UI.DisplayDevices.RECT> pRects)
            {
                fixed (win32.UI.DisplayDevices.RECT*pRectsLocal = pRects)
                {
                    fixed (float *ColorRGBALocal = &ColorRGBA)
                    {
                        this.ClearRenderTargetView(RenderTargetView, ColorRGBALocal, (uint)pRects.Length, pRectsLocal);
                    }
                }
            }

            internal unsafe void ClearRenderTargetView(win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView, float *ColorRGBA, uint NumRects, win32.UI.DisplayDevices.RECT*pRects)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->ClearRenderTargetView_49(pThis, RenderTargetView, ColorRGBA, NumRects, pRects);
            }

            /// <inheritdoc cref = "ClearUnorderedAccessViewUint(win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE, win32.Graphics.Direct3D12.ID3D12Resource*, uint *, uint, win32.UI.DisplayDevices.RECT*)"/>
            internal unsafe void ClearUnorderedAccessViewUint(win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle, win32.Graphics.Direct3D12.ID3D12Resource*pResource, in uint Values, ReadOnlySpan<win32.UI.DisplayDevices.RECT> pRects)
            {
                fixed (win32.UI.DisplayDevices.RECT*pRectsLocal = pRects)
                {
                    fixed (uint *ValuesLocal = &Values)
                    {
                        this.ClearUnorderedAccessViewUint(ViewGPUHandleInCurrentHeap, ViewCPUHandle, pResource, ValuesLocal, (uint)pRects.Length, pRectsLocal);
                    }
                }
            }

            internal unsafe void ClearUnorderedAccessViewUint(win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle, win32.Graphics.Direct3D12.ID3D12Resource*pResource, uint *Values, uint NumRects, win32.UI.DisplayDevices.RECT*pRects)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->ClearUnorderedAccessViewUint_50(pThis, ViewGPUHandleInCurrentHeap, ViewCPUHandle, pResource, Values, NumRects, pRects);
            }

            /// <inheritdoc cref = "ClearUnorderedAccessViewFloat(win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE, win32.Graphics.Direct3D12.ID3D12Resource*, float *, uint, win32.UI.DisplayDevices.RECT*)"/>
            internal unsafe void ClearUnorderedAccessViewFloat(win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle, win32.Graphics.Direct3D12.ID3D12Resource*pResource, in float Values, ReadOnlySpan<win32.UI.DisplayDevices.RECT> pRects)
            {
                fixed (win32.UI.DisplayDevices.RECT*pRectsLocal = pRects)
                {
                    fixed (float *ValuesLocal = &Values)
                    {
                        this.ClearUnorderedAccessViewFloat(ViewGPUHandleInCurrentHeap, ViewCPUHandle, pResource, ValuesLocal, (uint)pRects.Length, pRectsLocal);
                    }
                }
            }

            internal unsafe void ClearUnorderedAccessViewFloat(win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle, win32.Graphics.Direct3D12.ID3D12Resource*pResource, float *Values, uint NumRects, win32.UI.DisplayDevices.RECT*pRects)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->ClearUnorderedAccessViewFloat_51(pThis, ViewGPUHandleInCurrentHeap, ViewCPUHandle, pResource, Values, NumRects, pRects);
            }

            /// <inheritdoc cref = "DiscardResource(win32.Graphics.Direct3D12.ID3D12Resource*, win32.Graphics.Direct3D12.D3D12_DISCARD_REGION*)"/>
            internal unsafe void DiscardResource(win32.Graphics.Direct3D12.ID3D12Resource*pResource, win32.Graphics.Direct3D12.D3D12_DISCARD_REGION? pRegion)
            {
                win32.Graphics.Direct3D12.D3D12_DISCARD_REGION pRegionLocal = pRegion.HasValue ? pRegion.Value : default(win32.Graphics.Direct3D12.D3D12_DISCARD_REGION);
                this.DiscardResource(pResource, pRegion.HasValue ? &pRegionLocal : null);
            }

            internal unsafe void DiscardResource(win32.Graphics.Direct3D12.ID3D12Resource*pResource, [Optional] win32.Graphics.Direct3D12.D3D12_DISCARD_REGION*pRegion)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->DiscardResource_52(pThis, pResource, pRegion);
            }

            internal unsafe void BeginQuery(win32.Graphics.Direct3D12.ID3D12QueryHeap*pQueryHeap, win32.Graphics.Direct3D12.D3D12_QUERY_TYPE Type, uint Index)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->BeginQuery_53(pThis, pQueryHeap, Type, Index);
            }

            internal unsafe void EndQuery(win32.Graphics.Direct3D12.ID3D12QueryHeap*pQueryHeap, win32.Graphics.Direct3D12.D3D12_QUERY_TYPE Type, uint Index)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->EndQuery_54(pThis, pQueryHeap, Type, Index);
            }

            internal unsafe void ResolveQueryData(win32.Graphics.Direct3D12.ID3D12QueryHeap*pQueryHeap, win32.Graphics.Direct3D12.D3D12_QUERY_TYPE Type, uint StartIndex, uint NumQueries, win32.Graphics.Direct3D12.ID3D12Resource*pDestinationBuffer, ulong AlignedDestinationBufferOffset)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->ResolveQueryData_55(pThis, pQueryHeap, Type, StartIndex, NumQueries, pDestinationBuffer, AlignedDestinationBufferOffset);
            }

            internal unsafe void SetPredication([Optional] win32.Graphics.Direct3D12.ID3D12Resource*pBuffer, ulong AlignedBufferOffset, win32.Graphics.Direct3D12.D3D12_PREDICATION_OP Operation)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetPredication_56(pThis, pBuffer, AlignedBufferOffset, Operation);
            }

            internal unsafe void SetMarker(uint Metadata, [Optional] void *pData, uint Size)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetMarker_57(pThis, Metadata, pData, Size);
            }

            internal unsafe void BeginEvent(uint Metadata, [Optional] void *pData, uint Size)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->BeginEvent_58(pThis, Metadata, pData, Size);
            }

            internal void EndEvent()
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->EndEvent_59(pThis);
            }

            internal unsafe void ExecuteIndirect(win32.Graphics.Direct3D12.ID3D12CommandSignature*pCommandSignature, uint MaxCommandCount, win32.Graphics.Direct3D12.ID3D12Resource*pArgumentBuffer, ulong ArgumentBufferOffset, [Optional] win32.Graphics.Direct3D12.ID3D12Resource*pCountBuffer, ulong CountBufferOffset)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->ExecuteIndirect_60(pThis, pCommandSignature, MaxCommandCount, pArgumentBuffer, ArgumentBufferOffset, pCountBuffer, CountBufferOffset);
            }

            /// <inheritdoc cref = "AtomicCopyBufferUINT(win32.Graphics.Direct3D12.ID3D12Resource*, ulong, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, uint, win32.Graphics.Direct3D12.ID3D12Resource**, win32.Graphics.Direct3D12.D3D12_SUBRESOURCE_RANGE_UINT64*)"/>
            internal unsafe void AtomicCopyBufferUINT(win32.Graphics.Direct3D12.ID3D12Resource*pDstBuffer, ulong DstOffset, win32.Graphics.Direct3D12.ID3D12Resource*pSrcBuffer, ulong SrcOffset, win32.Graphics.Direct3D12.ID3D12Resource**ppDependentResources, ReadOnlySpan<win32.Graphics.Direct3D12.D3D12_SUBRESOURCE_RANGE_UINT64> pDependentSubresourceRanges)
            {
                fixed (win32.Graphics.Direct3D12.D3D12_SUBRESOURCE_RANGE_UINT64*pDependentSubresourceRangesLocal = pDependentSubresourceRanges)
                {
                    this.AtomicCopyBufferUINT(pDstBuffer, DstOffset, pSrcBuffer, SrcOffset, (uint)pDependentSubresourceRanges.Length, ppDependentResources, pDependentSubresourceRangesLocal);
                }
            }

            /// <summary>Atomically copies a primary data element of type UINT from one resource to another, along with optional dependent resources.</summary>
            /// <param name = "pDstBuffer">
            /// <para>Type: <b>ID3D12Resource*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>The resource that the UINT primary data element is copied into.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "DstOffset">
            /// <para>Type: <b>UINT64</b></para>
            /// <para>An offset into the destination resource buffer that specifies where the primary data element is copied into, in bytes. This offset combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT values.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pSrcBuffer">
            /// <para>Type: <b>ID3D12Resource*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>The resource that the UINT primary data element is copied from. This data is typically an address, index, or other handle that shader code can use to locate the most-recent version of latency-sensitive information.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "SrcOffset">
            /// <para>Type: <b>UINT64</b></para>
            /// <para>An offset into the source resource buffer that specifies where the primary data element is copied from, in bytes. This offset combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT values.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "Dependencies">
            /// <para>Type: <b>UINT</b></para>
            /// <para>The number of dependent resources.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "ppDependentResources">
            /// <para>Type: <b>ID3D12Resource*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_reads_(Dependencies)</c></para>
            /// <para>An array of resources that contain the dependent elements of the data payload.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pDependentSubresourceRanges">
            /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ns-d3d12-d3d12_subresource_range_uint64">D3D12_SUBRESOURCE_RANGE_UINT64</a>*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_reads_(Dependencies)</c></para>
            /// <para>An array of subresource ranges that specify the dependent elements of the data payload. These elements are completely updated before the primary data element is itself atomically copied. This ensures that the entire operation is logically atomic; that is, the primary data element never refers to an incomplete data payload.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>This method is typically used to update resources for which normal rendering pipeline latency can be detrimental to user experience. For example, an application can compute a view matrix from the latest user input (such as from the sensors of a head-mounted display), and use this function to update and activate this matrix in command lists already dispatched to the GPU to reduce percieved latency between input and rendering.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void AtomicCopyBufferUINT(win32.Graphics.Direct3D12.ID3D12Resource*pDstBuffer, ulong DstOffset, win32.Graphics.Direct3D12.ID3D12Resource*pSrcBuffer, ulong SrcOffset, uint Dependencies, win32.Graphics.Direct3D12.ID3D12Resource**ppDependentResources, win32.Graphics.Direct3D12.D3D12_SUBRESOURCE_RANGE_UINT64*pDependentSubresourceRanges)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->AtomicCopyBufferUINT_61(pThis, pDstBuffer, DstOffset, pSrcBuffer, SrcOffset, Dependencies, ppDependentResources, pDependentSubresourceRanges);
            }

            /// <inheritdoc cref = "AtomicCopyBufferUINT64(win32.Graphics.Direct3D12.ID3D12Resource*, ulong, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, uint, win32.Graphics.Direct3D12.ID3D12Resource**, win32.Graphics.Direct3D12.D3D12_SUBRESOURCE_RANGE_UINT64*)"/>
            internal unsafe void AtomicCopyBufferUINT64(win32.Graphics.Direct3D12.ID3D12Resource*pDstBuffer, ulong DstOffset, win32.Graphics.Direct3D12.ID3D12Resource*pSrcBuffer, ulong SrcOffset, win32.Graphics.Direct3D12.ID3D12Resource**ppDependentResources, ReadOnlySpan<win32.Graphics.Direct3D12.D3D12_SUBRESOURCE_RANGE_UINT64> pDependentSubresourceRanges)
            {
                fixed (win32.Graphics.Direct3D12.D3D12_SUBRESOURCE_RANGE_UINT64*pDependentSubresourceRangesLocal = pDependentSubresourceRanges)
                {
                    this.AtomicCopyBufferUINT64(pDstBuffer, DstOffset, pSrcBuffer, SrcOffset, (uint)pDependentSubresourceRanges.Length, ppDependentResources, pDependentSubresourceRangesLocal);
                }
            }

            /// <summary>Atomically copies a primary data element of type UINT64 from one resource to another, along with optional dependent resources.</summary>
            /// <param name = "pDstBuffer">
            /// <para>Type: <b>ID3D12Resource*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>The resource that the UINT64 primary data element is copied into.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "DstOffset">
            /// <para>Type: <b>UINT64</b></para>
            /// <para>An offset into the destination resource buffer that specifies where the primary data element is copied into, in bytes. This offset combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT64 values.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pSrcBuffer">
            /// <para>Type: <b>ID3D12Resource*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>The resource that the UINT64 primary data element is copied from. This data is typically an address, index, or other handle that shader code can use to locate the most-recent version of latency-sensitive information.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "SrcOffset">
            /// <para>Type: <b>UINT64</b></para>
            /// <para>An offset into the source resource buffer that specifies where the primary data element is copied from, in bytes. This offset combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT64 values.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "Dependencies">
            /// <para>Type: <b>UINT</b></para>
            /// <para>The number of dependent resources.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "ppDependentResources">
            /// <para>Type: <b>ID3D12Resource*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_reads_(Dependencies)</c></para>
            /// <para>An array of resources that contain the dependent elements of the data payload.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pDependentSubresourceRanges">
            /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ns-d3d12-d3d12_subresource_range_uint64">D3D12_SUBRESOURCE_RANGE_UINT64</a>*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_reads_(Dependencies)</c></para>
            /// <para>An array of subresource ranges that specify the dependent elements of the data payload. These elements are completely updated before the primary data element is itself atomically copied. This ensures that the entire operation is logically atomic; that is, the primary data element never refers to an incomplete data payload.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>This method is typically used to update resources for which normal rendering pipeline latency can be detrimental to user experience. For example, an application can compute a view matrix from the latest user input (such as from the sensors of a head-mounted display), and use this function to update and activate this matrix in command lists already dispatched to the GPU to reduce percieved latency between input and rendering.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void AtomicCopyBufferUINT64(win32.Graphics.Direct3D12.ID3D12Resource*pDstBuffer, ulong DstOffset, win32.Graphics.Direct3D12.ID3D12Resource*pSrcBuffer, ulong SrcOffset, uint Dependencies, win32.Graphics.Direct3D12.ID3D12Resource**ppDependentResources, win32.Graphics.Direct3D12.D3D12_SUBRESOURCE_RANGE_UINT64*pDependentSubresourceRanges)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->AtomicCopyBufferUINT64_62(pThis, pDstBuffer, DstOffset, pSrcBuffer, SrcOffset, Dependencies, ppDependentResources, pDependentSubresourceRanges);
            }

            /// <summary>This method enables you to change the depth bounds dynamically.</summary>
            /// <param name = "Min">
            /// <para>Type: <b>FLOAT</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>Specifies the minimum depth bounds. The default value is 0. NaN values silently convert to 0.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-omsetdepthbounds#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "Max">
            /// <para>Type: <b>FLOAT</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>Specifies the maximum depth bounds. The default value is 1. NaN values silently convert to 0.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-omsetdepthbounds#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>Depth-bounds testing allows pixels and samples to be discarded if the currently-stored depth value is outside the range specified by <i>Min</i> and <i>Max</i>, inclusive. If the currently-stored depth value of the pixel or sample is inside this range, then the depth-bounds test passes and it is rendered; otherwise, the depth-bounds test fails and the pixel or sample is discarded. Note that the depth-bounds test considers the currently-stored depth value, not the depth value generated by the executing pixel shader.</para>
            /// <para>To use depth-bounds testing, the application must use the new <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/nf-d3d12-id3d12device2-createpipelinestate">CreatePipelineState</a> method to enable depth-bounds testing on the PSO and then can use this command list method to change the depth-bounds dynamically.</para>
            /// <para>OMSetDepthBounds is an optional feature. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport">CheckFeatureSupport</a> method to determine whether or not this feature is supported by the user-mode driver. Support for this feature is reported through the [D3D12_FEATURE_D3D12_OPTIONS1](./ne-d3d12-d3d12_feature.md) structure.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-omsetdepthbounds#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal void OMSetDepthBounds(float Min, float Max)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->OMSetDepthBounds_63(pThis, Min, Max);
            }

            /// <inheritdoc cref = "SetSamplePositions(uint, uint, win32.Graphics.Direct3D12.D3D12_SAMPLE_POSITION*)"/>
            internal unsafe void SetSamplePositions(uint NumSamplesPerPixel, uint NumPixels, in win32.Graphics.Direct3D12.D3D12_SAMPLE_POSITION pSamplePositions)
            {
                fixed (win32.Graphics.Direct3D12.D3D12_SAMPLE_POSITION*pSamplePositionsLocal = &pSamplePositions)
                {
                    this.SetSamplePositions(NumSamplesPerPixel, NumPixels, pSamplePositionsLocal);
                }
            }

            /// <summary>This method configures the sample positions used by subsequent draw, copy, resolve, and similar operations.</summary>
            /// <param name = "NumSamplesPerPixel">
            /// <para>Type: <b>UINT</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>Specifies the number of samples to take, per pixel. This value can be 1, 2, 4, 8, or 16, otherwise the SetSamplePosition call is dropped. The number of samples must match the sample count configured in the PSO at draw time, otherwise the behavior is undefined.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-setsamplepositions#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "NumPixels">
            /// <para>Type: <b>UINT</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>Specifies the number of pixels that sample patterns are being specified for. This value can be either 1 or 4, otherwise the SetSamplePosition call is dropped. A value of 1 configures a single sample pattern to be used for each pixel; a value of 4 configures separate sample patterns for each pixel in a 2x2 pixel grid which is repeated over the render-target or viewport space, aligned to even coordintes.</para>
            /// <para>Note that the maximum number of combined samples can't exceed 16, otherwise the call is dropped. If NumPixels is set to 4, NumSamplesPerPixel can specify no more than 4 samples.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-setsamplepositions#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pSamplePositions">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ns-d3d12-d3d12_sample_position">D3D12_SAMPLE_POSITION</a>*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_reads_(NumSamplesPerPixel*NumPixels)</c></para>
            /// <para>Specifies an array of D3D12_SAMPLE_POSITION elements. The size of the array is NumPixels * NumSamplesPerPixel. If NumPixels is set to 4, then the first group of sample positions corresponds to the upper-left pixel in the 2x2 grid of pixels; the next group of sample positions corresponds to the upper-right pixel, the next group to the lower-left pixel, and the final group to the lower-right pixel.</para>
            /// <para>If centroid interpolation is used during rendering, the order of positions for each pixel determines centroid-sampling prioritiy. That is, the first covered sample in the order specified is chosen as the centroid sample location.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-setsamplepositions#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>The operational semantics of sample positions are determined by the various draw, copy, resolve, and other operations that can occur.</para>
            /// <para><b>CommandList:</b> In the absense of any prior calls to SetSamplePositions in a CommandList, samples assume the default position based on the Pipeline State Object (PSO). The default positions are determined either by the SAMPLE_DESC portion of the PSO if it is present, or by the standard sample positions if the RASTERIZER_DESC portion of the PSO has ForcedSampleCount set to a value greater than 0.</para>
            /// <para>After SetSamplePosition has been called, subsequent draw calls must use a PSO that specifies a matching sample count either using the SAMPLE_DESC portion of the PSO, or ForcedSampleCount in the RASTERIZER_DESC portion of the PSO.</para>
            /// <para>SetSamplePositions can only be called on a graphics CommandList. It can't be called in a bundle; bundles inherit sample position state from the calling CommandList and don't modify it.</para>
            /// <para>Calling SetSamplePositions(0, 0, NULL) reverts the sample positions to their default values.</para>
            /// <para><b>Clear RenderTarget:</b> Sample positions are ignored when clearing a render target.</para>
            /// <para><b>Clear DepthStencil:</b> When clearing the depth portion of a depth-stencil surface or any region of it, the sample positions must be set to match those of future rendering to the cleared surface or region; the contents of any uncleared regions produced using different sample positions become undefined.</para>
            /// <para>When clearing the stencil portion of a depth-stencil surface or any region of it, the sample positions are ignored.</para>
            /// <para><b>Draw to RenderTarget:</b> When drawing to a render target the sample positions can be changed for each draw call, even when drawing to a region that overlaps previous draw calls. The current sample positions determine the operational semantics of each draw call and samples are taken from taken from the stored contents of the render target, even if the contents were produced using different sample positions.</para>
            /// <para><b>Draw using DepthStencil:</b> When drawing to a depth-stencil surface (read or write) or any region of it, the sample positions must be set to match those used to clear the affected region previously. To use a different sample position, the target region must be cleared first. The pixels outside the clear region are unaffected.</para>
            /// <para>Hardware may store the depth portion or a depth-stencil surface as plane equations, and evaluate them to produce depth values when the application issues a read. Only the rasterizer and output-merger are required to suport programmable sample positions of the depth portion of a depth-stencil surface. Any other read or write of the depth portion that has been rendered with sample positions set may ignore them and instead sample at the standard positions.</para>
            /// <para><b>Resolve RenderTarget:</b> When resolving a render target or any region of it, the sample positions are ignored; these APIs operate only on stored color values.</para>
            /// <para><b>Resolve DepthStencil:</b> When resolving the depth portion of a depth-stencil surface or any region of it, the sample positions must be set to match those of past rendering to the resolved surface or region. To use a different sample position, the target region must be cleared first.</para>
            /// <para>When resolving the stencil portion of a depth-stencil surface or any region of it, the sample positions are ignored; stencil resolves operate only on stored stencil values.</para>
            /// <para><b>Copy RenderTarget:</b> When copying from a render target, the sample positions are ignored regardless of whether it is a full or partial copy.</para>
            /// <para><b>Copy DepthStencil (Full Subresource):</b> When copying a full subresource from a depth-stencil surface, the sample positions must be set to match the sample positions used to generate the source surface. To use a different sample position, the target region must be cleared first.</para>
            /// <para>On some hardware properties of the source surface (such as stored plane equations for depth values) transfer to the destination. Therefore, if the destination surface is subsequently drawn to, the sample positions originally used to generate the source content need to be used with the destination surface. The API requires this on all hardware for consistency even if it may only apply to some.</para>
            /// <para><b>Copy DepthStencil (Partial Subresource):</b> When copying a partial subresource from a depth-stencil surface, the sample positions must be set to match the sample positions used to generate the source surface, similarly to copying a full subresource. However, if the content of an affected destination subresources is only partially covered by the copy, the contents of the uncovered portion within those subresources becomes undefined unless all of it was generated using the same sample positions as the copy source. To use a different sample position, the target region must be cleared first.</para>
            /// <para>When copying a partial subresource from the stencil portion of a depth-stencil surface, the sample postions are ignored. It doesn’t matter what sample positions were used to generate content for any other areas of the destination buffer not covered by the copy – those contents remain valid.</para>
            /// <para><b>Shader SamplePos:</b> The HLSL SamplePos intrinsic is not aware of programmable sample positions and results returned to shaders calling this on a surface rendered with programmable positions is undefined. Applications must pass coordinates into their shader manually if needed. Similarly evaluating attributes by sample index is undefined with programmable sample positions.</para>
            /// <para><b>Transitioning out of DEPTH_READ or DEPTH_WRITE state:</b> If a subresource in DEPTH_READ or DEPTH_WRITE state is transitioned to any other state, including COPY_SOURCE or RESOLVE_SOURCE, some hardware might need to decompress the surface. Therefore, the sample positions must be set on the command list to match those used to generate the content in the source surface. Furthermore, for any subsequent transitions of the surface while the same depth data remains in it, the sample positions must continue to match those set on the command list. To use a different sample position, the target region must be cleared first.</para>
            /// <para>If an application wants to minimize the decompressed area when only a portion needs to be used, or just to preserve compression, ResolveSubresourceRegion() can be called in DECOMPRESS mode with a rect specified.  This will decompress just the relevant area to a separate resource leaving the source intact on some hardware, though on other hardware even the source area is decompressed. The separate explicitly decompressed resource can then be transitioned to the desired state (such as SHADER_RESOURCE).</para>
            /// <para><b>Transitioning out of RENDER_TARGET state:</b> If a subresource in RENDER_TARGET state is transitioned to anything other than COPY_SOURCE or RESOLVE_SOURCE, some implementations may need to decompress the surface. This decompression is agnostic to sample positions.</para>
            /// <para>If an application wants to minimize the decompressed area when only a portion needs to be used, or just to preserve compression, ResolveSubresourceRegion() can be called in DECOMPRESS mode with a rect specified.  This will decompress just the relevant area to a separate resource leaving the source intact on some hardware, though on other hardware even the source area is decompressed. The separate explicitly decompressed resource can then be transitioned to the desired state (such as SHADER_RESOURCE).</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-setsamplepositions#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void SetSamplePositions(uint NumSamplesPerPixel, uint NumPixels, win32.Graphics.Direct3D12.D3D12_SAMPLE_POSITION*pSamplePositions)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetSamplePositions_64(pThis, NumSamplesPerPixel, NumPixels, pSamplePositions);
            }

            /// <inheritdoc cref = "ResolveSubresourceRegion(win32.Graphics.Direct3D12.ID3D12Resource*, uint, uint, uint, win32.Graphics.Direct3D12.ID3D12Resource*, uint, win32.UI.DisplayDevices.RECT*, win32.Graphics.Dxgi.DXGI_FORMAT, win32.Graphics.Direct3D12.D3D12_RESOLVE_MODE)"/>
            internal unsafe void ResolveSubresourceRegion(win32.Graphics.Direct3D12.ID3D12Resource*pDstResource, uint DstSubresource, uint DstX, uint DstY, win32.Graphics.Direct3D12.ID3D12Resource*pSrcResource, uint SrcSubresource, win32.UI.DisplayDevices.RECT? pSrcRect, win32.Graphics.Dxgi.DXGI_FORMAT Format, win32.Graphics.Direct3D12.D3D12_RESOLVE_MODE ResolveMode)
            {
                win32.UI.DisplayDevices.RECT pSrcRectLocal = pSrcRect.HasValue ? pSrcRect.Value : default(win32.UI.DisplayDevices.RECT);
                this.ResolveSubresourceRegion(pDstResource, DstSubresource, DstX, DstY, pSrcResource, SrcSubresource, pSrcRect.HasValue ? &pSrcRectLocal : null, Format, ResolveMode);
            }

            /// <summary>Copy a region of a multisampled or compressed resource into a non-multisampled or non-compressed resource.</summary>
            /// <param name = "pDstResource">
            /// <para>Type: <b>ID3D12Resource*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>Destination resource. Must be created with the <b>D3D11_USAGE_DEFAULT</b> flag and must be single-sampled unless its to be resolved from a compressed resource (<b>D3D12_RESOLVE_MODE_DECOMPRESS</b>); in this case it must have the same sample count as the compressed source.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "DstSubresource">
            /// <para>Type: <b>UINT</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>A zero-based index that identifies the destination subresource. Use <a href = "https://docs.microsoft.com/windows/desktop/direct3d12/d3d12calcsubresource">D3D12CalcSubresource</a> to calculate the subresource index if the parent resource is complex.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "DstX">
            /// <para>Type: <b>UINT</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>The X coordinate of the left-most edge of the destination region. The width of the destination region is the same as the width of the source rect.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "DstY">
            /// <para>Type: <b>UINT</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>The Y coordinate of the top-most edge of the destination region. The height of the destination region is the same as the height of the source rect.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pSrcResource">
            /// <para>Type: <b>ID3D12Resource*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>Source resource. Must be multisampled or compressed.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "SrcSubresource">
            /// <para>Type: <b>UINT</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>A zero-based index that identifies the source subresource.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pSrcRect">
            /// <para>Type: <b>D3D12_RECT*</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_opt_</c></para>
            /// <para>Specifies the rectangular region of the source resource to be resolved. Passing NULL for <i>pSrcRect</i> specifies that the entire subresource is to be resolved.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "Format">
            /// <para>Type: <b>DXGI_FORMAT</b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>A DXGI_FORMAT that specifies how the source and destination resource formats are consolidated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "ResolveMode">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/ne-d3d12-d3d12_resolve_mode">D3D12_RESOLVE_MODE</a></b></para>
            /// <para><a href = "https://docs.microsoft.com/visualstudio/code-quality/annotating-function-parameters-and-return-values?view=vs-2015">SAL</a>: <c>_In_</c></para>
            /// <para>Specifies the operation used to resolve the source samples.</para>
            /// <para>When using the <b>D3D12_RESOLVE_MODE_DECOMPRESS</b> operation, the sample count can be larger than 1 as long as the source and destination have the same sample count, and source and destination may specify the same resource as long as the source rect aligns with the destination X and Y coordinates, in which case decompression occurs in place.</para>
            /// <para>When using the <b>D3D12_RESOLVE_MODE_MIN</b>, <b>D3D12_RESOLVE_MODE_MAX</b>, or <b>D3D12_RESOLVE_MODE_AVERAGE</b> operation, the destination must have a sample count of 1.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>ResolveSubresourceRegion operates like <a href = "https://docs.microsoft.com/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvesubresource">ResolveSubresource</a> but allows for only part of a resource to be resolved and for source samples to be resolved in several ways. Partial resolves can be useful in multi-adapter scenarios; for example, when the rendered area has been partitioned across adapters, each adapter might only need to resolve the portion of a subresource that corresponds to its assigned partition.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void ResolveSubresourceRegion(win32.Graphics.Direct3D12.ID3D12Resource*pDstResource, uint DstSubresource, uint DstX, uint DstY, win32.Graphics.Direct3D12.ID3D12Resource*pSrcResource, uint SrcSubresource, [Optional] win32.UI.DisplayDevices.RECT*pSrcRect, win32.Graphics.Dxgi.DXGI_FORMAT Format, win32.Graphics.Direct3D12.D3D12_RESOLVE_MODE ResolveMode)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->ResolveSubresourceRegion_65(pThis, pDstResource, DstSubresource, DstX, DstY, pSrcResource, SrcSubresource, pSrcRect, Format, ResolveMode);
            }

            /// <summary>Set a mask that controls which view instances are enabled for subsequent draws.</summary>
            /// <param name = "Mask">
            /// <para>Type: <b>UINT</b></para>
            /// <para>A mask that specifies which views are enabled or disabled. If bit <i>i</i> starting from the least-significant bit is set, view instance <i>i</i> is enabled.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-setviewinstancemask#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>The view instance mask only affects PSOs that declare view instance masking by specifying the D3D12_VIEW_INSTANCING_FLAG_ENABLE_VIEW_INSTANCE_MASKING flag during their creation. Attempting to create a PSO that declares view instance masking will fail on adapters that don't support view instancing.</para>
            /// <para>The view instance mask defaults to 0 which disables all views. This forces applications that declare view instance masking to explicitly choose the views to enable, otherwise nothing will be rendered. If the view instance mask enabled all views by default the application might not remember to disable unused views, resulting in lost performance due to wasted work.</para>
            /// <para>Bundles don't inherit their view instance mask from their caller, defaulting to 0 instead. This is because the mask setting must be known when the bundle is recorded if it affects how an implementation records draws. The view instance mask set by a bundle does persist to the caller after the bundle completes, however. These inheritence semantics are similar to those of PSOs.</para>
            /// <para>No shader code paths that are dependent on SV_ViewID are executed at any shader stage for view instances that are masked off and no clipping, viewport processing, or rasterization is performed. Implementations that inspect the mask during rendering can incur a small performance penalty over PSOs that don't declare view instance masking at all, but usually the penalty can be overcome by the performance savings that result from skipping the work associated with the masked off views. Depending on the frequency and amount of skipped work, the performance gains can be significant.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist1-setviewinstancemask#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal void SetViewInstanceMask(uint Mask)
            {
                fixed (ID3D12GraphicsCommandList1*pThis = &this)
                    lpVtbl->SetViewInstanceMask_66(pThis, Mask);
            }

            private struct Vtbl
            {
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, global::System.Guid*, void **, win32.System.Com.HRESULT>QueryInterface_1;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint>AddRef_2;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint>Release_3;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, global::System.Guid*, uint *, void *, win32.System.Com.HRESULT>GetPrivateData_4;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, global::System.Guid*, uint, void *, win32.System.Com.HRESULT>SetPrivateData_5;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, global::System.Guid*, win32.System.Com.IUnknown*, win32.System.Com.HRESULT>SetPrivateDataInterface_6;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.System.SystemServices.PCWSTR, win32.System.Com.HRESULT>SetName_7;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, global::System.Guid*, void **, win32.System.Com.HRESULT>GetDevice_8;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.D3D12_COMMAND_LIST_TYPE>GetType_9;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.System.Com.HRESULT>Close_10;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12CommandAllocator*, win32.Graphics.Direct3D12.ID3D12PipelineState*, win32.System.Com.HRESULT>Reset_11;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12PipelineState*, void>ClearState_12;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, uint, uint, uint, void>DrawInstanced_13;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, uint, uint, int, uint, void>DrawIndexedInstanced_14;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, uint, uint, void>Dispatch_15;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, ulong, void>CopyBufferRegion_16;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.D3D12_TEXTURE_COPY_LOCATION*, uint, uint, uint, win32.Graphics.Direct3D12.D3D12_TEXTURE_COPY_LOCATION*, win32.Graphics.Direct3D12.D3D12_BOX*, void>CopyTextureRegion_17;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12Resource*, win32.Graphics.Direct3D12.ID3D12Resource*, void>CopyResource_18;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12Resource*, win32.Graphics.Direct3D12.D3D12_TILED_RESOURCE_COORDINATE*, win32.Graphics.Direct3D12.D3D12_TILE_REGION_SIZE*, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, win32.Graphics.Direct3D12.D3D12_TILE_COPY_FLAGS, void>CopyTiles_19;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12Resource*, uint, win32.Graphics.Direct3D12.ID3D12Resource*, uint, win32.Graphics.Dxgi.DXGI_FORMAT, void>ResolveSubresource_20;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D11.D3D_PRIMITIVE_TOPOLOGY, void>IASetPrimitiveTopology_21;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, win32.Graphics.Direct3D12.D3D12_VIEWPORT*, void>RSSetViewports_22;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, win32.UI.DisplayDevices.RECT*, void>RSSetScissorRects_23;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, float *, void>OMSetBlendFactor_24;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, void>OMSetStencilRef_25;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12PipelineState*, void>SetPipelineState_26;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, win32.Graphics.Direct3D12.D3D12_RESOURCE_BARRIER*, void>ResourceBarrier_27;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12GraphicsCommandList*, void>ExecuteBundle_28;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, win32.Graphics.Direct3D12.ID3D12DescriptorHeap**, void>SetDescriptorHeaps_29;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12RootSignature*, void>SetComputeRootSignature_30;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12RootSignature*, void>SetGraphicsRootSignature_31;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE, void>SetComputeRootDescriptorTable_32;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE, void>SetGraphicsRootDescriptorTable_33;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, uint, uint, void>SetComputeRoot32BitConstant_34;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, uint, uint, void>SetGraphicsRoot32BitConstant_35;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, uint, void *, uint, void>SetComputeRoot32BitConstants_36;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, uint, void *, uint, void>SetGraphicsRoot32BitConstants_37;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, ulong, void>SetComputeRootConstantBufferView_38;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, ulong, void>SetGraphicsRootConstantBufferView_39;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, ulong, void>SetComputeRootShaderResourceView_40;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, ulong, void>SetGraphicsRootShaderResourceView_41;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, ulong, void>SetComputeRootUnorderedAccessView_42;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, ulong, void>SetGraphicsRootUnorderedAccessView_43;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.D3D12_INDEX_BUFFER_VIEW*, void>IASetIndexBuffer_44;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, uint, win32.Graphics.Direct3D12.D3D12_VERTEX_BUFFER_VIEW*, void>IASetVertexBuffers_45;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, uint, win32.Graphics.Direct3D12.D3D12_STREAM_OUTPUT_BUFFER_VIEW*, void>SOSetTargets_46;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE*, win32.System.SystemServices.BOOL, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE*, void>OMSetRenderTargets_47;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE, win32.Graphics.Direct3D12.D3D12_CLEAR_FLAGS, float, byte, uint, win32.UI.DisplayDevices.RECT*, void>ClearDepthStencilView_48;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE, float *, uint, win32.UI.DisplayDevices.RECT*, void>ClearRenderTargetView_49;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE, win32.Graphics.Direct3D12.ID3D12Resource*, uint *, uint, win32.UI.DisplayDevices.RECT*, void>ClearUnorderedAccessViewUint_50;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE, win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE, win32.Graphics.Direct3D12.ID3D12Resource*, float *, uint, win32.UI.DisplayDevices.RECT*, void>ClearUnorderedAccessViewFloat_51;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12Resource*, win32.Graphics.Direct3D12.D3D12_DISCARD_REGION*, void>DiscardResource_52;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12QueryHeap*, win32.Graphics.Direct3D12.D3D12_QUERY_TYPE, uint, void>BeginQuery_53;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12QueryHeap*, win32.Graphics.Direct3D12.D3D12_QUERY_TYPE, uint, void>EndQuery_54;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12QueryHeap*, win32.Graphics.Direct3D12.D3D12_QUERY_TYPE, uint, uint, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, void>ResolveQueryData_55;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, win32.Graphics.Direct3D12.D3D12_PREDICATION_OP, void>SetPredication_56;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, void *, uint, void>SetMarker_57;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, void *, uint, void>BeginEvent_58;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, void>EndEvent_59;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12CommandSignature*, uint, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, void>ExecuteIndirect_60;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, uint, win32.Graphics.Direct3D12.ID3D12Resource**, win32.Graphics.Direct3D12.D3D12_SUBRESOURCE_RANGE_UINT64*, void>AtomicCopyBufferUINT_61;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, win32.Graphics.Direct3D12.ID3D12Resource*, ulong, uint, win32.Graphics.Direct3D12.ID3D12Resource**, win32.Graphics.Direct3D12.D3D12_SUBRESOURCE_RANGE_UINT64*, void>AtomicCopyBufferUINT64_62;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, float, float, void>OMSetDepthBounds_63;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, uint, win32.Graphics.Direct3D12.D3D12_SAMPLE_POSITION*, void>SetSamplePositions_64;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, win32.Graphics.Direct3D12.ID3D12Resource*, uint, uint, uint, win32.Graphics.Direct3D12.ID3D12Resource*, uint, win32.UI.DisplayDevices.RECT*, win32.Graphics.Dxgi.DXGI_FORMAT, win32.Graphics.Direct3D12.D3D12_RESOLVE_MODE, void>ResolveSubresourceRegion_65;
                internal delegate *unmanaged[Stdcall]<ID3D12GraphicsCommandList1*, uint, void>SetViewInstanceMask_66;
            }

            private Vtbl*lpVtbl;
        }
    }
}