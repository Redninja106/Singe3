// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable CS1591, CS1573, CS0465, CS0649, CS8019, CS1570, CS1584, CS1658
namespace Windows.Win32
{
    using global::System;
    using global::System.Diagnostics;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;
    using win32 = global::Windows.Win32;

    namespace Graphics.Direct3D11
    {
        [Guid("BB2C6FAA-B5FB-4082-8E6B-388B8CFA90E1")]
        internal unsafe struct ID3D11DeviceContext1
        {
            /// <inheritdoc cref = "QueryInterface(global::System.Guid*, void **)"/>
            internal unsafe win32.System.Com.HRESULT QueryInterface(in global::System.Guid riid, out void *ppvObject)
            {
                fixed (void **ppvObjectLocal = &ppvObject)
                {
                    fixed (global::System.Guid*riidLocal = &riid)
                    {
                        win32.System.Com.HRESULT __result = this.QueryInterface(riidLocal, ppvObjectLocal);
                        return __result;
                    }
                }
            }

            internal unsafe win32.System.Com.HRESULT QueryInterface(global::System.Guid*riid, void **ppvObject)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->QueryInterface_1(pThis, riid, ppvObject);
            }

            internal uint AddRef()
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->AddRef_2(pThis);
            }

            internal uint Release()
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->Release_3(pThis);
            }

            internal unsafe void GetDevice(win32.Graphics.Direct3D11.ID3D11Device**ppDevice)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GetDevice_4(pThis, ppDevice);
            }

            /// <inheritdoc cref = "GetPrivateData(global::System.Guid*, uint *, void *)"/>
            internal unsafe win32.System.Com.HRESULT GetPrivateData(in global::System.Guid guid, ref uint pDataSize, void *pData)
            {
                fixed (uint *pDataSizeLocal = &pDataSize)
                {
                    fixed (global::System.Guid*guidLocal = &guid)
                    {
                        win32.System.Com.HRESULT __result = this.GetPrivateData(guidLocal, pDataSizeLocal, pData);
                        return __result;
                    }
                }
            }

            internal unsafe win32.System.Com.HRESULT GetPrivateData(global::System.Guid*guid, uint *pDataSize, [Optional] void *pData)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->GetPrivateData_5(pThis, guid, pDataSize, pData);
            }

            /// <inheritdoc cref = "SetPrivateData(global::System.Guid*, uint, void *)"/>
            internal unsafe win32.System.Com.HRESULT SetPrivateData(in global::System.Guid guid, uint DataSize, void *pData)
            {
                fixed (global::System.Guid*guidLocal = &guid)
                {
                    win32.System.Com.HRESULT __result = this.SetPrivateData(guidLocal, DataSize, pData);
                    return __result;
                }
            }

            internal unsafe win32.System.Com.HRESULT SetPrivateData(global::System.Guid*guid, uint DataSize, [Optional] void *pData)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->SetPrivateData_6(pThis, guid, DataSize, pData);
            }

            /// <inheritdoc cref = "SetPrivateDataInterface(global::System.Guid*, win32.System.Com.IUnknown*)"/>
            internal unsafe win32.System.Com.HRESULT SetPrivateDataInterface(in global::System.Guid guid, win32.System.Com.IUnknown*pData)
            {
                fixed (global::System.Guid*guidLocal = &guid)
                {
                    win32.System.Com.HRESULT __result = this.SetPrivateDataInterface(guidLocal, pData);
                    return __result;
                }
            }

            internal unsafe win32.System.Com.HRESULT SetPrivateDataInterface(global::System.Guid*guid, [Optional] win32.System.Com.IUnknown*pData)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->SetPrivateDataInterface_7(pThis, guid, pData);
            }

            internal unsafe void VSSetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->VSSetConstantBuffers_8(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal unsafe void PSSetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->PSSetShaderResources_9(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            internal unsafe void PSSetShader([Optional] win32.Graphics.Direct3D11.ID3D11PixelShader*pPixelShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, uint NumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->PSSetShader_10(pThis, pPixelShader, ppClassInstances, NumClassInstances);
            }

            internal unsafe void PSSetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->PSSetSamplers_11(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void VSSetShader([Optional] win32.Graphics.Direct3D11.ID3D11VertexShader*pVertexShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, uint NumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->VSSetShader_12(pThis, pVertexShader, ppClassInstances, NumClassInstances);
            }

            internal void DrawIndexed(uint IndexCount, uint StartIndexLocation, int BaseVertexLocation)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DrawIndexed_13(pThis, IndexCount, StartIndexLocation, BaseVertexLocation);
            }

            internal void Draw(uint VertexCount, uint StartVertexLocation)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->Draw_14(pThis, VertexCount, StartVertexLocation);
            }

            internal unsafe win32.System.Com.HRESULT Map(win32.Graphics.Direct3D11.ID3D11Resource*pResource, uint Subresource, win32.Graphics.Direct3D11.D3D11_MAP MapType, uint MapFlags, [Optional] win32.Graphics.Direct3D11.D3D11_MAPPED_SUBRESOURCE*pMappedResource)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->Map_15(pThis, pResource, Subresource, MapType, MapFlags, pMappedResource);
            }

            internal unsafe void Unmap(win32.Graphics.Direct3D11.ID3D11Resource*pResource, uint Subresource)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->Unmap_16(pThis, pResource, Subresource);
            }

            internal unsafe void PSSetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->PSSetConstantBuffers_17(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal unsafe void IASetInputLayout([Optional] win32.Graphics.Direct3D11.ID3D11InputLayout*pInputLayout)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->IASetInputLayout_18(pThis, pInputLayout);
            }

            /// <inheritdoc cref = "IASetVertexBuffers(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void IASetVertexBuffers(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppVertexBuffers, ReadOnlySpan<uint> pStrides, ReadOnlySpan<uint> pOffsets)
            {
                fixed (uint *pOffsetsLocal = pOffsets)
                {
                    fixed (uint *pStridesLocal = pStrides)
                    {
                        if (pStrides.Length != pOffsets.Length)
                            throw new ArgumentException();
                        this.IASetVertexBuffers(StartSlot, (uint)pOffsets.Length, ppVertexBuffers, pStridesLocal, pOffsetsLocal);
                    }
                }
            }

            internal unsafe void IASetVertexBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppVertexBuffers, [Optional] uint *pStrides, [Optional] uint *pOffsets)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->IASetVertexBuffers_19(pThis, StartSlot, NumBuffers, ppVertexBuffers, pStrides, pOffsets);
            }

            internal unsafe void IASetIndexBuffer([Optional] win32.Graphics.Direct3D11.ID3D11Buffer*pIndexBuffer, win32.Graphics.Dxgi.DXGI_FORMAT Format, uint Offset)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->IASetIndexBuffer_20(pThis, pIndexBuffer, Format, Offset);
            }

            internal void DrawIndexedInstanced(uint IndexCountPerInstance, uint InstanceCount, uint StartIndexLocation, int BaseVertexLocation, uint StartInstanceLocation)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DrawIndexedInstanced_21(pThis, IndexCountPerInstance, InstanceCount, StartIndexLocation, BaseVertexLocation, StartInstanceLocation);
            }

            internal void DrawInstanced(uint VertexCountPerInstance, uint InstanceCount, uint StartVertexLocation, uint StartInstanceLocation)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DrawInstanced_22(pThis, VertexCountPerInstance, InstanceCount, StartVertexLocation, StartInstanceLocation);
            }

            internal unsafe void GSSetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GSSetConstantBuffers_23(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal unsafe void GSSetShader([Optional] win32.Graphics.Direct3D11.ID3D11GeometryShader*pShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, uint NumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GSSetShader_24(pThis, pShader, ppClassInstances, NumClassInstances);
            }

            internal void IASetPrimitiveTopology(win32.Graphics.Direct3D11.D3D_PRIMITIVE_TOPOLOGY Topology)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->IASetPrimitiveTopology_25(pThis, Topology);
            }

            internal unsafe void VSSetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->VSSetShaderResources_26(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            internal unsafe void VSSetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->VSSetSamplers_27(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void Begin(win32.Graphics.Direct3D11.ID3D11Asynchronous*pAsync)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->Begin_28(pThis, pAsync);
            }

            internal unsafe void End(win32.Graphics.Direct3D11.ID3D11Asynchronous*pAsync)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->End_29(pThis, pAsync);
            }

            internal unsafe win32.System.Com.HRESULT GetData(win32.Graphics.Direct3D11.ID3D11Asynchronous*pAsync, [Optional] void *pData, uint DataSize, uint GetDataFlags)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->GetData_30(pThis, pAsync, pData, DataSize, GetDataFlags);
            }

            internal unsafe void SetPredication([Optional] win32.Graphics.Direct3D11.ID3D11Predicate*pPredicate, win32.System.SystemServices.BOOL PredicateValue)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->SetPredication_31(pThis, pPredicate, PredicateValue);
            }

            internal unsafe void GSSetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GSSetShaderResources_32(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            internal unsafe void GSSetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GSSetSamplers_33(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void OMSetRenderTargets(uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11RenderTargetView**ppRenderTargetViews, [Optional] win32.Graphics.Direct3D11.ID3D11DepthStencilView*pDepthStencilView)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->OMSetRenderTargets_34(pThis, NumViews, ppRenderTargetViews, pDepthStencilView);
            }

            /// <inheritdoc cref = "OMSetRenderTargetsAndUnorderedAccessViews(uint, win32.Graphics.Direct3D11.ID3D11RenderTargetView**, win32.Graphics.Direct3D11.ID3D11DepthStencilView*, uint, uint, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**, uint *)"/>
            internal unsafe void OMSetRenderTargetsAndUnorderedAccessViews(uint NumRTVs, win32.Graphics.Direct3D11.ID3D11RenderTargetView**ppRenderTargetViews, win32.Graphics.Direct3D11.ID3D11DepthStencilView*pDepthStencilView, uint UAVStartSlot, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**ppUnorderedAccessViews, ReadOnlySpan<uint> pUAVInitialCounts)
            {
                fixed (uint *pUAVInitialCountsLocal = pUAVInitialCounts)
                {
                    this.OMSetRenderTargetsAndUnorderedAccessViews(NumRTVs, ppRenderTargetViews, pDepthStencilView, UAVStartSlot, (uint)pUAVInitialCounts.Length, ppUnorderedAccessViews, pUAVInitialCountsLocal);
                }
            }

            internal unsafe void OMSetRenderTargetsAndUnorderedAccessViews(uint NumRTVs, [Optional] win32.Graphics.Direct3D11.ID3D11RenderTargetView**ppRenderTargetViews, [Optional] win32.Graphics.Direct3D11.ID3D11DepthStencilView*pDepthStencilView, uint UAVStartSlot, uint NumUAVs, [Optional] win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**ppUnorderedAccessViews, [Optional] uint *pUAVInitialCounts)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->OMSetRenderTargetsAndUnorderedAccessViews_35(pThis, NumRTVs, ppRenderTargetViews, pDepthStencilView, UAVStartSlot, NumUAVs, ppUnorderedAccessViews, pUAVInitialCounts);
            }

            /// <inheritdoc cref = "OMSetBlendState(win32.Graphics.Direct3D11.ID3D11BlendState*, float *, uint)"/>
            internal unsafe void OMSetBlendState(win32.Graphics.Direct3D11.ID3D11BlendState*pBlendState, float? BlendFactor, uint SampleMask)
            {
                float BlendFactorLocal = BlendFactor.HasValue ? BlendFactor.Value : default(float);
                this.OMSetBlendState(pBlendState, BlendFactor.HasValue ? &BlendFactorLocal : null, SampleMask);
            }

            internal unsafe void OMSetBlendState([Optional] win32.Graphics.Direct3D11.ID3D11BlendState*pBlendState, [Optional] float *BlendFactor, uint SampleMask)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->OMSetBlendState_36(pThis, pBlendState, BlendFactor, SampleMask);
            }

            internal unsafe void OMSetDepthStencilState([Optional] win32.Graphics.Direct3D11.ID3D11DepthStencilState*pDepthStencilState, uint StencilRef)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->OMSetDepthStencilState_37(pThis, pDepthStencilState, StencilRef);
            }

            /// <inheritdoc cref = "SOSetTargets(uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *)"/>
            internal unsafe void SOSetTargets(win32.Graphics.Direct3D11.ID3D11Buffer**ppSOTargets, ReadOnlySpan<uint> pOffsets)
            {
                fixed (uint *pOffsetsLocal = pOffsets)
                {
                    this.SOSetTargets((uint)pOffsets.Length, ppSOTargets, pOffsetsLocal);
                }
            }

            internal unsafe void SOSetTargets(uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppSOTargets, [Optional] uint *pOffsets)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->SOSetTargets_38(pThis, NumBuffers, ppSOTargets, pOffsets);
            }

            internal void DrawAuto()
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DrawAuto_39(pThis);
            }

            internal unsafe void DrawIndexedInstancedIndirect(win32.Graphics.Direct3D11.ID3D11Buffer*pBufferForArgs, uint AlignedByteOffsetForArgs)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DrawIndexedInstancedIndirect_40(pThis, pBufferForArgs, AlignedByteOffsetForArgs);
            }

            internal unsafe void DrawInstancedIndirect(win32.Graphics.Direct3D11.ID3D11Buffer*pBufferForArgs, uint AlignedByteOffsetForArgs)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DrawInstancedIndirect_41(pThis, pBufferForArgs, AlignedByteOffsetForArgs);
            }

            internal void Dispatch(uint ThreadGroupCountX, uint ThreadGroupCountY, uint ThreadGroupCountZ)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->Dispatch_42(pThis, ThreadGroupCountX, ThreadGroupCountY, ThreadGroupCountZ);
            }

            internal unsafe void DispatchIndirect(win32.Graphics.Direct3D11.ID3D11Buffer*pBufferForArgs, uint AlignedByteOffsetForArgs)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DispatchIndirect_43(pThis, pBufferForArgs, AlignedByteOffsetForArgs);
            }

            internal unsafe void RSSetState([Optional] win32.Graphics.Direct3D11.ID3D11RasterizerState*pRasterizerState)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->RSSetState_44(pThis, pRasterizerState);
            }

            /// <inheritdoc cref = "RSSetViewports(uint, win32.Graphics.Direct3D11.D3D11_VIEWPORT*)"/>
            internal unsafe void RSSetViewports(ReadOnlySpan<win32.Graphics.Direct3D11.D3D11_VIEWPORT> pViewports)
            {
                fixed (win32.Graphics.Direct3D11.D3D11_VIEWPORT*pViewportsLocal = pViewports)
                {
                    this.RSSetViewports((uint)pViewports.Length, pViewportsLocal);
                }
            }

            internal unsafe void RSSetViewports(uint NumViewports, [Optional] win32.Graphics.Direct3D11.D3D11_VIEWPORT*pViewports)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->RSSetViewports_45(pThis, NumViewports, pViewports);
            }

            /// <inheritdoc cref = "RSSetScissorRects(uint, win32.UI.DisplayDevices.RECT*)"/>
            internal unsafe void RSSetScissorRects(ReadOnlySpan<win32.UI.DisplayDevices.RECT> pRects)
            {
                fixed (win32.UI.DisplayDevices.RECT*pRectsLocal = pRects)
                {
                    this.RSSetScissorRects((uint)pRects.Length, pRectsLocal);
                }
            }

            internal unsafe void RSSetScissorRects(uint NumRects, [Optional] win32.UI.DisplayDevices.RECT*pRects)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->RSSetScissorRects_46(pThis, NumRects, pRects);
            }

            /// <inheritdoc cref = "CopySubresourceRegion(win32.Graphics.Direct3D11.ID3D11Resource*, uint, uint, uint, uint, win32.Graphics.Direct3D11.ID3D11Resource*, uint, win32.Graphics.Direct3D11.D3D11_BOX*)"/>
            internal unsafe void CopySubresourceRegion(win32.Graphics.Direct3D11.ID3D11Resource*pDstResource, uint DstSubresource, uint DstX, uint DstY, uint DstZ, win32.Graphics.Direct3D11.ID3D11Resource*pSrcResource, uint SrcSubresource, win32.Graphics.Direct3D11.D3D11_BOX? pSrcBox)
            {
                win32.Graphics.Direct3D11.D3D11_BOX pSrcBoxLocal = pSrcBox.HasValue ? pSrcBox.Value : default(win32.Graphics.Direct3D11.D3D11_BOX);
                this.CopySubresourceRegion(pDstResource, DstSubresource, DstX, DstY, DstZ, pSrcResource, SrcSubresource, pSrcBox.HasValue ? &pSrcBoxLocal : null);
            }

            internal unsafe void CopySubresourceRegion(win32.Graphics.Direct3D11.ID3D11Resource*pDstResource, uint DstSubresource, uint DstX, uint DstY, uint DstZ, win32.Graphics.Direct3D11.ID3D11Resource*pSrcResource, uint SrcSubresource, [Optional] win32.Graphics.Direct3D11.D3D11_BOX*pSrcBox)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CopySubresourceRegion_47(pThis, pDstResource, DstSubresource, DstX, DstY, DstZ, pSrcResource, SrcSubresource, pSrcBox);
            }

            internal unsafe void CopyResource(win32.Graphics.Direct3D11.ID3D11Resource*pDstResource, win32.Graphics.Direct3D11.ID3D11Resource*pSrcResource)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CopyResource_48(pThis, pDstResource, pSrcResource);
            }

            /// <inheritdoc cref = "UpdateSubresource(win32.Graphics.Direct3D11.ID3D11Resource*, uint, win32.Graphics.Direct3D11.D3D11_BOX*, void *, uint, uint)"/>
            internal unsafe void UpdateSubresource(win32.Graphics.Direct3D11.ID3D11Resource*pDstResource, uint DstSubresource, win32.Graphics.Direct3D11.D3D11_BOX? pDstBox, void *pSrcData, uint SrcRowPitch, uint SrcDepthPitch)
            {
                win32.Graphics.Direct3D11.D3D11_BOX pDstBoxLocal = pDstBox.HasValue ? pDstBox.Value : default(win32.Graphics.Direct3D11.D3D11_BOX);
                this.UpdateSubresource(pDstResource, DstSubresource, pDstBox.HasValue ? &pDstBoxLocal : null, pSrcData, SrcRowPitch, SrcDepthPitch);
            }

            internal unsafe void UpdateSubresource(win32.Graphics.Direct3D11.ID3D11Resource*pDstResource, uint DstSubresource, [Optional] win32.Graphics.Direct3D11.D3D11_BOX*pDstBox, void *pSrcData, uint SrcRowPitch, uint SrcDepthPitch)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->UpdateSubresource_49(pThis, pDstResource, DstSubresource, pDstBox, pSrcData, SrcRowPitch, SrcDepthPitch);
            }

            internal unsafe void CopyStructureCount(win32.Graphics.Direct3D11.ID3D11Buffer*pDstBuffer, uint DstAlignedByteOffset, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView*pSrcView)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CopyStructureCount_50(pThis, pDstBuffer, DstAlignedByteOffset, pSrcView);
            }

            /// <inheritdoc cref = "ClearRenderTargetView(win32.Graphics.Direct3D11.ID3D11RenderTargetView*, float *)"/>
            internal unsafe void ClearRenderTargetView(win32.Graphics.Direct3D11.ID3D11RenderTargetView*pRenderTargetView, in float ColorRGBA)
            {
                fixed (float *ColorRGBALocal = &ColorRGBA)
                {
                    this.ClearRenderTargetView(pRenderTargetView, ColorRGBALocal);
                }
            }

            internal unsafe void ClearRenderTargetView(win32.Graphics.Direct3D11.ID3D11RenderTargetView*pRenderTargetView, float *ColorRGBA)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->ClearRenderTargetView_51(pThis, pRenderTargetView, ColorRGBA);
            }

            /// <inheritdoc cref = "ClearUnorderedAccessViewUint(win32.Graphics.Direct3D11.ID3D11UnorderedAccessView*, uint *)"/>
            internal unsafe void ClearUnorderedAccessViewUint(win32.Graphics.Direct3D11.ID3D11UnorderedAccessView*pUnorderedAccessView, in uint Values)
            {
                fixed (uint *ValuesLocal = &Values)
                {
                    this.ClearUnorderedAccessViewUint(pUnorderedAccessView, ValuesLocal);
                }
            }

            internal unsafe void ClearUnorderedAccessViewUint(win32.Graphics.Direct3D11.ID3D11UnorderedAccessView*pUnorderedAccessView, uint *Values)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->ClearUnorderedAccessViewUint_52(pThis, pUnorderedAccessView, Values);
            }

            /// <inheritdoc cref = "ClearUnorderedAccessViewFloat(win32.Graphics.Direct3D11.ID3D11UnorderedAccessView*, float *)"/>
            internal unsafe void ClearUnorderedAccessViewFloat(win32.Graphics.Direct3D11.ID3D11UnorderedAccessView*pUnorderedAccessView, in float Values)
            {
                fixed (float *ValuesLocal = &Values)
                {
                    this.ClearUnorderedAccessViewFloat(pUnorderedAccessView, ValuesLocal);
                }
            }

            internal unsafe void ClearUnorderedAccessViewFloat(win32.Graphics.Direct3D11.ID3D11UnorderedAccessView*pUnorderedAccessView, float *Values)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->ClearUnorderedAccessViewFloat_53(pThis, pUnorderedAccessView, Values);
            }

            internal unsafe void ClearDepthStencilView(win32.Graphics.Direct3D11.ID3D11DepthStencilView*pDepthStencilView, uint ClearFlags, float Depth, byte Stencil)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->ClearDepthStencilView_54(pThis, pDepthStencilView, ClearFlags, Depth, Stencil);
            }

            internal unsafe void GenerateMips(win32.Graphics.Direct3D11.ID3D11ShaderResourceView*pShaderResourceView)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GenerateMips_55(pThis, pShaderResourceView);
            }

            internal unsafe void SetResourceMinLOD(win32.Graphics.Direct3D11.ID3D11Resource*pResource, float MinLOD)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->SetResourceMinLOD_56(pThis, pResource, MinLOD);
            }

            internal unsafe float GetResourceMinLOD(win32.Graphics.Direct3D11.ID3D11Resource*pResource)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->GetResourceMinLOD_57(pThis, pResource);
            }

            internal unsafe void ResolveSubresource(win32.Graphics.Direct3D11.ID3D11Resource*pDstResource, uint DstSubresource, win32.Graphics.Direct3D11.ID3D11Resource*pSrcResource, uint SrcSubresource, win32.Graphics.Dxgi.DXGI_FORMAT Format)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->ResolveSubresource_58(pThis, pDstResource, DstSubresource, pSrcResource, SrcSubresource, Format);
            }

            internal unsafe void ExecuteCommandList(win32.Graphics.Direct3D11.ID3D11CommandList*pCommandList, win32.System.SystemServices.BOOL RestoreContextState)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->ExecuteCommandList_59(pThis, pCommandList, RestoreContextState);
            }

            internal unsafe void HSSetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->HSSetShaderResources_60(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            internal unsafe void HSSetShader([Optional] win32.Graphics.Direct3D11.ID3D11HullShader*pHullShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, uint NumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->HSSetShader_61(pThis, pHullShader, ppClassInstances, NumClassInstances);
            }

            internal unsafe void HSSetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->HSSetSamplers_62(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void HSSetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->HSSetConstantBuffers_63(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal unsafe void DSSetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DSSetShaderResources_64(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            internal unsafe void DSSetShader([Optional] win32.Graphics.Direct3D11.ID3D11DomainShader*pDomainShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, uint NumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DSSetShader_65(pThis, pDomainShader, ppClassInstances, NumClassInstances);
            }

            internal unsafe void DSSetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DSSetSamplers_66(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void DSSetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DSSetConstantBuffers_67(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal unsafe void CSSetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSSetShaderResources_68(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            /// <inheritdoc cref = "CSSetUnorderedAccessViews(uint, uint, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**, uint *)"/>
            internal unsafe void CSSetUnorderedAccessViews(uint StartSlot, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**ppUnorderedAccessViews, ReadOnlySpan<uint> pUAVInitialCounts)
            {
                fixed (uint *pUAVInitialCountsLocal = pUAVInitialCounts)
                {
                    this.CSSetUnorderedAccessViews(StartSlot, (uint)pUAVInitialCounts.Length, ppUnorderedAccessViews, pUAVInitialCountsLocal);
                }
            }

            internal unsafe void CSSetUnorderedAccessViews(uint StartSlot, uint NumUAVs, [Optional] win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**ppUnorderedAccessViews, [Optional] uint *pUAVInitialCounts)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSSetUnorderedAccessViews_69(pThis, StartSlot, NumUAVs, ppUnorderedAccessViews, pUAVInitialCounts);
            }

            internal unsafe void CSSetShader([Optional] win32.Graphics.Direct3D11.ID3D11ComputeShader*pComputeShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, uint NumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSSetShader_70(pThis, pComputeShader, ppClassInstances, NumClassInstances);
            }

            internal unsafe void CSSetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSSetSamplers_71(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void CSSetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSSetConstantBuffers_72(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal unsafe void VSGetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->VSGetConstantBuffers_73(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal unsafe void PSGetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->PSGetShaderResources_74(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            internal unsafe void PSGetShader([Optional] win32.Graphics.Direct3D11.ID3D11PixelShader**ppPixelShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, [Optional] uint *pNumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->PSGetShader_75(pThis, ppPixelShader, ppClassInstances, pNumClassInstances);
            }

            internal unsafe void PSGetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->PSGetSamplers_76(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void VSGetShader([Optional] win32.Graphics.Direct3D11.ID3D11VertexShader**ppVertexShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, [Optional] uint *pNumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->VSGetShader_77(pThis, ppVertexShader, ppClassInstances, pNumClassInstances);
            }

            internal unsafe void PSGetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->PSGetConstantBuffers_78(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal unsafe void IAGetInputLayout([Optional] win32.Graphics.Direct3D11.ID3D11InputLayout**ppInputLayout)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->IAGetInputLayout_79(pThis, ppInputLayout);
            }

            /// <inheritdoc cref = "IAGetVertexBuffers(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void IAGetVertexBuffers(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppVertexBuffers, Span<uint> pStrides, Span<uint> pOffsets)
            {
                fixed (uint *pOffsetsLocal = pOffsets)
                {
                    fixed (uint *pStridesLocal = pStrides)
                    {
                        if (pStrides.Length != pOffsets.Length)
                            throw new ArgumentException();
                        this.IAGetVertexBuffers(StartSlot, (uint)pOffsets.Length, ppVertexBuffers, pStridesLocal, pOffsetsLocal);
                    }
                }
            }

            internal unsafe void IAGetVertexBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppVertexBuffers, [Optional] uint *pStrides, [Optional] uint *pOffsets)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->IAGetVertexBuffers_80(pThis, StartSlot, NumBuffers, ppVertexBuffers, pStrides, pOffsets);
            }

            internal unsafe void IAGetIndexBuffer([Optional] win32.Graphics.Direct3D11.ID3D11Buffer**pIndexBuffer, [Optional] win32.Graphics.Dxgi.DXGI_FORMAT*Format, [Optional] uint *Offset)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->IAGetIndexBuffer_81(pThis, pIndexBuffer, Format, Offset);
            }

            internal unsafe void GSGetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GSGetConstantBuffers_82(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal unsafe void GSGetShader([Optional] win32.Graphics.Direct3D11.ID3D11GeometryShader**ppGeometryShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, [Optional] uint *pNumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GSGetShader_83(pThis, ppGeometryShader, ppClassInstances, pNumClassInstances);
            }

            /// <inheritdoc cref = "IAGetPrimitiveTopology(win32.Graphics.Direct3D11.D3D_PRIMITIVE_TOPOLOGY*)"/>
            internal unsafe void IAGetPrimitiveTopology(out win32.Graphics.Direct3D11.D3D_PRIMITIVE_TOPOLOGY pTopology)
            {
                fixed (win32.Graphics.Direct3D11.D3D_PRIMITIVE_TOPOLOGY*pTopologyLocal = &pTopology)
                {
                    this.IAGetPrimitiveTopology(pTopologyLocal);
                }
            }

            internal unsafe void IAGetPrimitiveTopology(win32.Graphics.Direct3D11.D3D_PRIMITIVE_TOPOLOGY*pTopology)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->IAGetPrimitiveTopology_84(pThis, pTopology);
            }

            internal unsafe void VSGetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->VSGetShaderResources_85(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            internal unsafe void VSGetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->VSGetSamplers_86(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void GetPredication([Optional] win32.Graphics.Direct3D11.ID3D11Predicate**ppPredicate, [Optional] win32.System.SystemServices.BOOL*pPredicateValue)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GetPredication_87(pThis, ppPredicate, pPredicateValue);
            }

            internal unsafe void GSGetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GSGetShaderResources_88(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            internal unsafe void GSGetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GSGetSamplers_89(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void OMGetRenderTargets(uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11RenderTargetView**ppRenderTargetViews, [Optional] win32.Graphics.Direct3D11.ID3D11DepthStencilView**ppDepthStencilView)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->OMGetRenderTargets_90(pThis, NumViews, ppRenderTargetViews, ppDepthStencilView);
            }

            internal unsafe void OMGetRenderTargetsAndUnorderedAccessViews(uint NumRTVs, [Optional] win32.Graphics.Direct3D11.ID3D11RenderTargetView**ppRenderTargetViews, [Optional] win32.Graphics.Direct3D11.ID3D11DepthStencilView**ppDepthStencilView, uint UAVStartSlot, uint NumUAVs, [Optional] win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**ppUnorderedAccessViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->OMGetRenderTargetsAndUnorderedAccessViews_91(pThis, NumRTVs, ppRenderTargetViews, ppDepthStencilView, UAVStartSlot, NumUAVs, ppUnorderedAccessViews);
            }

            internal unsafe void OMGetBlendState([Optional] win32.Graphics.Direct3D11.ID3D11BlendState**ppBlendState, [Optional] float *BlendFactor, [Optional] uint *pSampleMask)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->OMGetBlendState_92(pThis, ppBlendState, BlendFactor, pSampleMask);
            }

            internal unsafe void OMGetDepthStencilState([Optional] win32.Graphics.Direct3D11.ID3D11DepthStencilState**ppDepthStencilState, [Optional] uint *pStencilRef)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->OMGetDepthStencilState_93(pThis, ppDepthStencilState, pStencilRef);
            }

            internal unsafe void SOGetTargets(uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppSOTargets)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->SOGetTargets_94(pThis, NumBuffers, ppSOTargets);
            }

            internal unsafe void RSGetState([Optional] win32.Graphics.Direct3D11.ID3D11RasterizerState**ppRasterizerState)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->RSGetState_95(pThis, ppRasterizerState);
            }

            /// <inheritdoc cref = "RSGetViewports(uint *, win32.Graphics.Direct3D11.D3D11_VIEWPORT*)"/>
            internal unsafe void RSGetViewports(ref uint pNumViewports, win32.Graphics.Direct3D11.D3D11_VIEWPORT*pViewports)
            {
                fixed (uint *pNumViewportsLocal = &pNumViewports)
                {
                    this.RSGetViewports(pNumViewportsLocal, pViewports);
                }
            }

            internal unsafe void RSGetViewports(uint *pNumViewports, [Optional] win32.Graphics.Direct3D11.D3D11_VIEWPORT*pViewports)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->RSGetViewports_96(pThis, pNumViewports, pViewports);
            }

            /// <inheritdoc cref = "RSGetScissorRects(uint *, win32.UI.DisplayDevices.RECT*)"/>
            internal unsafe void RSGetScissorRects(ref uint pNumRects, win32.UI.DisplayDevices.RECT*pRects)
            {
                fixed (uint *pNumRectsLocal = &pNumRects)
                {
                    this.RSGetScissorRects(pNumRectsLocal, pRects);
                }
            }

            internal unsafe void RSGetScissorRects(uint *pNumRects, [Optional] win32.UI.DisplayDevices.RECT*pRects)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->RSGetScissorRects_97(pThis, pNumRects, pRects);
            }

            internal unsafe void HSGetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->HSGetShaderResources_98(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            internal unsafe void HSGetShader([Optional] win32.Graphics.Direct3D11.ID3D11HullShader**ppHullShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, [Optional] uint *pNumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->HSGetShader_99(pThis, ppHullShader, ppClassInstances, pNumClassInstances);
            }

            internal unsafe void HSGetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->HSGetSamplers_100(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void HSGetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->HSGetConstantBuffers_101(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal unsafe void DSGetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DSGetShaderResources_102(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            internal unsafe void DSGetShader([Optional] win32.Graphics.Direct3D11.ID3D11DomainShader**ppDomainShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, [Optional] uint *pNumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DSGetShader_103(pThis, ppDomainShader, ppClassInstances, pNumClassInstances);
            }

            internal unsafe void DSGetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DSGetSamplers_104(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void DSGetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DSGetConstantBuffers_105(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal unsafe void CSGetShaderResources(uint StartSlot, uint NumViews, [Optional] win32.Graphics.Direct3D11.ID3D11ShaderResourceView**ppShaderResourceViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSGetShaderResources_106(pThis, StartSlot, NumViews, ppShaderResourceViews);
            }

            internal unsafe void CSGetUnorderedAccessViews(uint StartSlot, uint NumUAVs, [Optional] win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**ppUnorderedAccessViews)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSGetUnorderedAccessViews_107(pThis, StartSlot, NumUAVs, ppUnorderedAccessViews);
            }

            internal unsafe void CSGetShader([Optional] win32.Graphics.Direct3D11.ID3D11ComputeShader**ppComputeShader, [Optional] win32.Graphics.Direct3D11.ID3D11ClassInstance**ppClassInstances, [Optional] uint *pNumClassInstances)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSGetShader_108(pThis, ppComputeShader, ppClassInstances, pNumClassInstances);
            }

            internal unsafe void CSGetSamplers(uint StartSlot, uint NumSamplers, [Optional] win32.Graphics.Direct3D11.ID3D11SamplerState**ppSamplers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSGetSamplers_109(pThis, StartSlot, NumSamplers, ppSamplers);
            }

            internal unsafe void CSGetConstantBuffers(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSGetConstantBuffers_110(pThis, StartSlot, NumBuffers, ppConstantBuffers);
            }

            internal void ClearState()
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->ClearState_111(pThis);
            }

            internal void Flush()
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->Flush_112(pThis);
            }

            internal new win32.Graphics.Direct3D11.D3D11_DEVICE_CONTEXT_TYPE GetType()
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->GetType_113(pThis);
            }

            internal uint GetContextFlags()
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->GetContextFlags_114(pThis);
            }

            internal unsafe win32.System.Com.HRESULT FinishCommandList(win32.System.SystemServices.BOOL RestoreDeferredContextState, [Optional] win32.Graphics.Direct3D11.ID3D11CommandList**ppCommandList)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    return lpVtbl->FinishCommandList_115(pThis, RestoreDeferredContextState, ppCommandList);
            }

            /// <inheritdoc cref = "CopySubresourceRegion1(win32.Graphics.Direct3D11.ID3D11Resource*, uint, uint, uint, uint, win32.Graphics.Direct3D11.ID3D11Resource*, uint, win32.Graphics.Direct3D11.D3D11_BOX*, uint)"/>
            internal unsafe void CopySubresourceRegion1(win32.Graphics.Direct3D11.ID3D11Resource*pDstResource, uint DstSubresource, uint DstX, uint DstY, uint DstZ, win32.Graphics.Direct3D11.ID3D11Resource*pSrcResource, uint SrcSubresource, win32.Graphics.Direct3D11.D3D11_BOX? pSrcBox, uint CopyFlags)
            {
                win32.Graphics.Direct3D11.D3D11_BOX pSrcBoxLocal = pSrcBox.HasValue ? pSrcBox.Value : default(win32.Graphics.Direct3D11.D3D11_BOX);
                this.CopySubresourceRegion1(pDstResource, DstSubresource, DstX, DstY, DstZ, pSrcResource, SrcSubresource, pSrcBox.HasValue ? &pSrcBoxLocal : null, CopyFlags);
            }

            /// <summary>Copies a region from a source resource to a destination resource.</summary>
            /// <param name = "pDstResource">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11resource">ID3D11Resource</a>*</b></para>
            /// <para>A pointer to the destination resource.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "DstSubresource">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>Destination subresource index.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "DstX">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>The x-coordinate of the upper-left corner of the destination region.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "DstY">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>The y-coordinate of the upper-left corner of the destination region. For a 1D subresource, this must be zero.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "DstZ">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>The z-coordinate of the upper-left corner of the destination region. For a 1D or 2D subresource, this must be zero.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pSrcResource">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11resource">ID3D11Resource</a>*</b></para>
            /// <para>A pointer to the source resource.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "SrcSubresource">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>Source subresource index.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pSrcBox">
            /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/ns-d3d11-d3d11_box">D3D11_BOX</a>*</b></para>
            /// <para>A pointer to a 3D box that defines the region of the source subresource that <b>CopySubresourceRegion1</b> can copy. If <b>NULL</b>, <b>CopySubresourceRegion1</b> copies the entire source subresource. The box must fit within the source resource.</para>
            /// <para>An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, <b>CopySubresourceRegion1</b> doesn't perform a copy operation.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "CopyFlags">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>A <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/ne-d3d11_1-d3d11_copy_flags">D3D11_COPY_FLAGS</a>-typed value that specifies how to perform the copy operation. If you specify zero for no copy option, <b>CopySubresourceRegion1</b> behaves like <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-copysubresourceregion">ID3D11DeviceContext::CopySubresourceRegion</a>. For existing display drivers that can't process these flags, the runtime doesn't use them.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>If the display driver supports overlapping, the source and destination subresources can be identical, and the source and destination regions can overlap each other.  For existing display drivers that don’t support overlapping, the runtime drops calls with identical source and destination subresources, regardless of whether the regions overlap.  To determine whether the display driver supports overlapping, check the <b>CopyWithOverlap</b> member of <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/ns-d3d11-d3d11_feature_data_d3d11_options">D3D11_FEATURE_DATA_D3D11_OPTIONS</a>. This overlapping support enables additional scroll functionality in a call to <a href = "https://docs.microsoft.com/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-present">IDXGISwapChain::Present</a>.</para>
            /// <para><div class = "alert"><b>Note</b>  <b>Applies only to feature level 9_x hardware</b> If you use <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nf-d3d11_1-id3d11devicecontext1-updatesubresource1">ID3D11DeviceContext1::UpdateSubresource1</a> or <b>CopySubresourceRegion1</b> to copy from a staging resource to a default resource, you can corrupt the destination contents. This occurs if you pass a <b>NULL</b> source box and if the source resource has different dimensions from those of the destination resource or if you use destination offsets, (x, y, and z). In this situation, always pass a source box that is the full size of the source resource.</div> <div> </div></para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void CopySubresourceRegion1(win32.Graphics.Direct3D11.ID3D11Resource*pDstResource, uint DstSubresource, uint DstX, uint DstY, uint DstZ, win32.Graphics.Direct3D11.ID3D11Resource*pSrcResource, uint SrcSubresource, [Optional] win32.Graphics.Direct3D11.D3D11_BOX*pSrcBox, uint CopyFlags)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CopySubresourceRegion1_116(pThis, pDstResource, DstSubresource, DstX, DstY, DstZ, pSrcResource, SrcSubresource, pSrcBox, CopyFlags);
            }

            /// <inheritdoc cref = "UpdateSubresource1(win32.Graphics.Direct3D11.ID3D11Resource*, uint, win32.Graphics.Direct3D11.D3D11_BOX*, void *, uint, uint, uint)"/>
            internal unsafe void UpdateSubresource1(win32.Graphics.Direct3D11.ID3D11Resource*pDstResource, uint DstSubresource, win32.Graphics.Direct3D11.D3D11_BOX? pDstBox, void *pSrcData, uint SrcRowPitch, uint SrcDepthPitch, uint CopyFlags)
            {
                win32.Graphics.Direct3D11.D3D11_BOX pDstBoxLocal = pDstBox.HasValue ? pDstBox.Value : default(win32.Graphics.Direct3D11.D3D11_BOX);
                this.UpdateSubresource1(pDstResource, DstSubresource, pDstBox.HasValue ? &pDstBoxLocal : null, pSrcData, SrcRowPitch, SrcDepthPitch, CopyFlags);
            }

            /// <summary>The CPU copies data from memory to a subresource created in non-mappable memory.</summary>
            /// <param name = "pDstResource">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11resource">ID3D11Resource</a>*</b></para>
            /// <para>A pointer to the destination resource.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-updatesubresource1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "DstSubresource">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>A zero-based index that identifies the destination subresource. See <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-d3d11calcsubresource">D3D11CalcSubresource</a> for more details.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-updatesubresource1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pDstBox">
            /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/ns-d3d11-d3d11_box">D3D11_BOX</a>*</b></para>
            /// <para>A pointer to a box that defines the portion of the destination subresource to copy the resource data into. Coordinates are in bytes for buffers and in texels for textures. If <b>NULL</b>, <b>UpdateSubresource1</b> writes the data to the destination subresource with no offset. The dimensions of the source must fit the destination.</para>
            /// <para>An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, <b>UpdateSubresource1</b> doesn't perform an update operation.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-updatesubresource1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pSrcData">
            /// <para>Type: <b>const void*</b></para>
            /// <para>A pointer to the source data in memory.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-updatesubresource1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "SrcRowPitch">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>The size of one row of the source data.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-updatesubresource1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "SrcDepthPitch">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>The size of one depth slice of source data.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-updatesubresource1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "CopyFlags">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>A <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/ne-d3d11_1-d3d11_copy_flags">D3D11_COPY_FLAGS</a>-typed value that specifies how to perform the update operation. If you specify zero for no update option, <b>UpdateSubresource1</b> behaves like <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-updatesubresource">ID3D11DeviceContext::UpdateSubresource</a>. For existing display drivers that can't process these flags, the runtime doesn't use them.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-updatesubresource1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>If you call <b>UpdateSubresource1</b> to update a constant buffer, pass any region, and the driver has not been implemented to Windows 8, the runtime drops the call (except <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3 where the runtime emulates support).  The runtime also drops the call if you update a constant buffer with a partial region whose extent is not aligned to 16-byte granularity (16 bytes being a full constant). When the runtime drops the call, the runtime doesn't call the corresponding device driver interface (DDI).</para>
            /// <para>When you record a call to <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-updatesubresource">UpdateSubresource</a> with an offset <i>pDstBox</i> in a software command list, the offset in <i>pDstBox</i> is incorrectly applied to <i>pSrcData</i> when you play back the command list.  The new-for-Windows 8<b>UpdateSubresource1</b> fixes this issue. In a call to <b>UpdateSubresource1</b>, <i>pDstBox</i> does not affect <i>pSrcData</i>.</para>
            /// <para>For info about various resource types and how <b>UpdateSubresource1</b> might work with each resource type, see <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-resources-intro">Introduction to a Resource in Direct3D 11</a>.</para>
            /// <para><div class = "alert"><b>Note</b>  <b>Applies only to feature level 9_x hardware</b> If you use <b>UpdateSubresource1</b> or <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1">ID3D11DeviceContext1::CopySubresourceRegion1</a> to copy from a staging resource to a default resource, you can corrupt the destination contents. This occurs if you pass a <b>NULL</b> source box and if the source resource has different dimensions from those of the destination resource or if you use destination offsets, (x, y, and z). In this situation, always pass a source box that is the full size of the source resource.</div> <div> </div></para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-updatesubresource1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void UpdateSubresource1(win32.Graphics.Direct3D11.ID3D11Resource*pDstResource, uint DstSubresource, [Optional] win32.Graphics.Direct3D11.D3D11_BOX*pDstBox, void *pSrcData, uint SrcRowPitch, uint SrcDepthPitch, uint CopyFlags)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->UpdateSubresource1_117(pThis, pDstResource, DstSubresource, pDstBox, pSrcData, SrcRowPitch, SrcDepthPitch, CopyFlags);
            }

            /// <summary>Discards a resource from the device context.</summary>
            /// <param name = "pResource">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11resource">ID3D11Resource</a>*</b></para>
            /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11resource">ID3D11Resource</a> interface for the resource to discard. The resource must have been created with usage <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/ne-d3d11-d3d11_usage">D3D11_USAGE_DEFAULT</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/ne-d3d11-d3d11_usage">D3D11_USAGE_DYNAMIC</a>, otherwise the runtime drops the call to <b>DiscardResource</b>; if the debug layer is enabled, the runtime returns an error message.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-discardresource#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para><b>DiscardResource</b> informs the graphics processing unit (GPU) that the existing content in the resource that <i>pResource</i> points to is no longer needed.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-discardresource#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void DiscardResource(win32.Graphics.Direct3D11.ID3D11Resource*pResource)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DiscardResource_118(pThis, pResource);
            }

            /// <summary>Discards a resource view from the device context.</summary>
            /// <param name = "pResourceView">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11view">ID3D11View</a>*</b></para>
            /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11view">ID3D11View</a> interface for the resource view to discard. The resource that underlies the view must have been created with usage <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/ne-d3d11-d3d11_usage">D3D11_USAGE_DEFAULT</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/ne-d3d11-d3d11_usage">D3D11_USAGE_DYNAMIC</a>, otherwise the runtime drops the call to <b>DiscardView</b>; if the debug layer is enabled, the runtime returns an error message.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-discardview#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para><b>DiscardView</b> informs the graphics processing unit (GPU) that the existing content in the resource view that <i>pResourceView</i> points to is no longer needed.  The view can be an SRV, RTV, UAV, or DSV.  <b>DiscardView</b> is a variation on the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nf-d3d11_1-id3d11devicecontext1-discardresource">DiscardResource</a> method.  <b>DiscardView</b> allows you to discard a subset of a resource that is in a view (such as a single miplevel).  More importantly, <b>DiscardView</b> provides a convenience because often views are what are being bound and unbound at the pipeline.  Some pipeline bindings do not have views, such as stream output.  In that situation, <b>DiscardResource</b> can do the job for any resource.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-discardview#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void DiscardView(win32.Graphics.Direct3D11.ID3D11View*pResourceView)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DiscardView_119(pThis, pResourceView);
            }

            /// <inheritdoc cref = "VSSetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void VSSetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, ReadOnlySpan<uint> pFirstConstant, ReadOnlySpan<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.VSSetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Sets the constant buffers that the vertex shader pipeline stage uses.</summary>
            /// <param name = "StartSlot">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-vssetconstantbuffers1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "NumBuffers">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-vssetconstantbuffers1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "ppConstantBuffers">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11buffer">ID3D11Buffer</a>*</b></para>
            /// <para>Array of constant buffers being given to the device.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-vssetconstantbuffers1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pFirstConstant">
            /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
            /// <para>An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-vssetconstantbuffers1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pNumConstants">
            /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
            /// <para>An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096].</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-vssetconstantbuffers1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>The runtime drops the call to <b>VSSetConstantBuffers1</b> if the number of constants to which <i>pNumConstants</i> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]. The runtime also drops the call to <b>VSSetConstantBuffers1</b> on existing drivers that don't support this offsetting.</para>
            /// <para>The runtime will emulate this feature for <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</para>
            /// <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
            /// <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
            /// <para>If <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-vssetconstantbuffers">VSSetConstantBuffers</a> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
            /// <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
            /// <para><h3><a id = "Calling_VSSetConstantBuffers1_with_command_list_emulation"></a><a id = "calling_vssetconstantbuffers1_with_command_list_emulation"></a><a id = "CALLING_VSSETCONSTANTBUFFERS1_WITH_COMMAND_LIST_EMULATION"></a>Calling VSSetConstantBuffers1 with command list emulation</h3> The runtime's <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of <b>VSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers. This behavior occurs when</para>
            /// <para><b>VSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update. This section shows how to work around this</para>
            /// <para>behavior.</para>
            /// <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-vssetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void VSSetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->VSSetConstantBuffers1_120(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <inheritdoc cref = "HSSetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void HSSetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, ReadOnlySpan<uint> pFirstConstant, ReadOnlySpan<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.HSSetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Sets the constant buffers that the hull-shader stage of the pipeline uses.</summary>
            /// <param name = "StartSlot">Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name = "NumBuffers">Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</param>
            /// <param name = "ppConstantBuffers">Array of constant buffers being given to the device.</param>
            /// <param name = "pFirstConstant">An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</param>
            /// <param name = "pNumConstants">An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096].</param>
            /// <remarks>
            /// <para>The runtime drops the call to <b>HSSetConstantBuffers1</b> if the number of constants to which <i>pNumConstants</i> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]. The runtime also drops the call to <b>HSSetConstantBuffers1</b> on existing drivers that don't support this offsetting.</para>
            /// <para>The runtime will emulate this feature for <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</para>
            /// <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
            /// <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
            /// <para>If the <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-hssetconstantbuffers">HSSetConstantBuffers</a> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
            /// <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
            /// <para><h3><a id = "Calling_HSSetConstantBuffers1_with_command_list_emulation"></a><a id = "calling_hssetconstantbuffers1_with_command_list_emulation"></a><a id = "CALLING_HSSETCONSTANTBUFFERS1_WITH_COMMAND_LIST_EMULATION"></a>Calling HSSetConstantBuffers1 with command list emulation</h3> The runtime's <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of <b>HSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers. This behavior occurs when</para>
            /// <para><b>HSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update. This section shows how to work around this</para>
            /// <para>behavior.</para>
            /// <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-hssetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void HSSetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->HSSetConstantBuffers1_121(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <inheritdoc cref = "DSSetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void DSSetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, ReadOnlySpan<uint> pFirstConstant, ReadOnlySpan<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.DSSetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Sets the constant buffers that the domain-shader stage uses.</summary>
            /// <param name = "StartSlot">Index into the zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name = "NumBuffers">Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</param>
            /// <param name = "ppConstantBuffers">Array of constant buffers being given to the device.</param>
            /// <param name = "pFirstConstant">An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</param>
            /// <param name = "pNumConstants">An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096].</param>
            /// <remarks>
            /// <para>The runtime drops the call to <b>DSSetConstantBuffers1</b> if the number of constants to which <i>pNumConstants</i> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]. The runtime also drops the call to <b>DSSetConstantBuffers1</b> on existing drivers that don't support this offsetting.</para>
            /// <para>The runtime will emulate this feature for <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</para>
            /// <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
            /// <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
            /// <para>If <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-dssetconstantbuffers">DSSetConstantBuffers</a> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
            /// <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
            /// <para><h3><a id = "Calling_DSSetConstantBuffers1_with_command_list_emulation"></a><a id = "calling_dssetconstantbuffers1_with_command_list_emulation"></a><a id = "CALLING_DSSETCONSTANTBUFFERS1_WITH_COMMAND_LIST_EMULATION"></a>Calling DSSetConstantBuffers1 with command list emulation</h3> The runtime's <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of <b>DSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers. This behavior occurs when</para>
            /// <para><b>DSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update. This section shows how to work around this</para>
            /// <para>behavior.</para>
            /// <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-dssetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void DSSetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DSSetConstantBuffers1_122(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <inheritdoc cref = "GSSetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void GSSetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, ReadOnlySpan<uint> pFirstConstant, ReadOnlySpan<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.GSSetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Sets the constant buffers that the geometry shader pipeline stage uses.</summary>
            /// <param name = "StartSlot">Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name = "NumBuffers">Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</param>
            /// <param name = "ppConstantBuffers">Array of constant buffers (see <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11buffer">ID3D11Buffer</a>) being given to the device.</param>
            /// <param name = "pFirstConstant">An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</param>
            /// <param name = "pNumConstants">An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096].</param>
            /// <remarks>
            /// <para>The runtime drops the call to <b>GSSetConstantBuffers1</b> if the number of constants to which <i>pNumConstants</i> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]. The runtime also drops the call to <b>GSSetConstantBuffers1</b> on existing drivers that don't support this offsetting.</para>
            /// <para>The runtime will emulate this feature for <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</para>
            /// <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
            /// <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
            /// <para>If <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-gssetconstantbuffers">GSSetConstantBuffers</a> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
            /// <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
            /// <para><h3><a id = "Calling_GSSetConstantBuffers1_with_command_list_emulation"></a><a id = "calling_gssetconstantbuffers1_with_command_list_emulation"></a><a id = "CALLING_GSSETCONSTANTBUFFERS1_WITH_COMMAND_LIST_EMULATION"></a>Calling GSSetConstantBuffers1 with command list emulation</h3> The runtime's <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of <b>GSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers. This behavior occurs when</para>
            /// <para><b>GSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update. This section shows how to work around this</para>
            /// <para>behavior.</para>
            /// <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-gssetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void GSSetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GSSetConstantBuffers1_123(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <inheritdoc cref = "PSSetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void PSSetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, ReadOnlySpan<uint> pFirstConstant, ReadOnlySpan<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.PSSetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Sets the constant buffers that the pixel shader pipeline stage uses, and enables the shader to access other parts of the buffer.</summary>
            /// <param name = "StartSlot">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-pssetconstantbuffers1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "NumBuffers">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-pssetconstantbuffers1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "ppConstantBuffers">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11buffer">ID3D11Buffer</a>*</b></para>
            /// <para>Array of constant buffers being given to the device.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-pssetconstantbuffers1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pFirstConstant">
            /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
            /// <para>An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts. Each offset is measured in shader constants, which are 16 bytes (4*32-bit components). Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-pssetconstantbuffers1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pNumConstants">
            /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
            /// <para>An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096].</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-pssetconstantbuffers1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para>To enable the shader to access other parts of the buffer, call <b>PSSetConstantBuffers1</b> instead of <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-pssetconstantbuffers">PSSetConstantBuffers</a>. <b>PSSetConstantBuffers1</b> has additional parameters <i>pFirstConstant</i> and <i>pNumConstants</i>.</para>
            /// <para>The runtime drops the call to <b>PSSetConstantBuffers1</b> if the numbers of constants to which <i>pNumConstants</i> points is larger than the maximum constant buffer size that is supported by shaders. The maximum constant buffer size that is supported by shaders holds 4096 constants, where each constant has four 32-bit components.</para>
            /// <para>The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the following window (range):</para>
            /// <para>[value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]</para>
            /// <para>That is, the window is the range is from (value in an element of <i>pFirstConstant</i>) to (value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>).</para>
            /// <para>The runtime also drops the call to <b>PSSetConstantBuffers1</b> on existing drivers that do not support this offsetting.</para>
            /// <para>The runtime will emulate this feature for <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3. This feature is always available on new drivers for feature level 10 and higher.</para>
            /// <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
            /// <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
            /// <para>If <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view. You get this same result if you call the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-pssetconstantbuffers">PSSetConstantBuffers</a> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
            /// <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
            /// <para><h3><a id = "Calling_PSSetConstantBuffers1_with_command_list_emulation"></a><a id = "calling_pssetconstantbuffers1_with_command_list_emulation"></a><a id = "CALLING_PSSETCONSTANTBUFFERS1_WITH_COMMAND_LIST_EMULATION"></a>Calling PSSetConstantBuffers1 with command list emulation</h3> The runtime's <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of <b>PSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers. This behavior occurs when <b>PSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update. This section shows how to work around this behavior.</para>
            /// <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-pssetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void PSSetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->PSSetConstantBuffers1_124(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <inheritdoc cref = "CSSetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void CSSetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, ReadOnlySpan<uint> pFirstConstant, ReadOnlySpan<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.CSSetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Sets the constant buffers that the compute-shader stage uses.</summary>
            /// <param name = "StartSlot">Index into the zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name = "NumBuffers">Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</param>
            /// <param name = "ppConstantBuffers">Array of constant buffers (see <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11buffer">ID3D11Buffer</a>) being given to the device.</param>
            /// <param name = "pFirstConstant">An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</param>
            /// <param name = "pNumConstants">An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096].</param>
            /// <remarks>
            /// <para>The runtime drops the call to <b>CSSetConstantBuffers1</b> if the number of constants to which <i>pNumConstants</i> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]. The runtime also drops the call to <b>CSSetConstantBuffers1</b> on existing drivers that don't support this offsetting.</para>
            /// <para>The runtime will emulate this feature for <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</para>
            /// <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
            /// <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
            /// <para>If <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-cssetconstantbuffers">CSSetConstantBuffers</a> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
            /// <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
            /// <para><h3><a id = "Calling_CSSetConstantBuffers1_with_command_list_emulation"></a><a id = "calling_cssetconstantbuffers1_with_command_list_emulation"></a><a id = "CALLING_CSSETCONSTANTBUFFERS1_WITH_COMMAND_LIST_EMULATION"></a>Calling CSSetConstantBuffers1 with command list emulation</h3> The runtime's <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of <b>CSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers. This behavior occurs when</para>
            /// <para><b>CSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update. This section shows how to work around this</para>
            /// <para>behavior.</para>
            /// <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-cssetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void CSSetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSSetConstantBuffers1_125(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <inheritdoc cref = "VSGetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void VSGetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, Span<uint> pFirstConstant, Span<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.VSGetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Gets the constant buffers that the vertex shader pipeline stage uses.</summary>
            /// <param name = "StartSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name = "NumBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</param>
            /// <param name = "ppConstantBuffers">Array of constant buffer interface pointers to be returned by the method.</param>
            /// <param name = "pFirstConstant">A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</param>
            /// <param name = "pNumConstants">A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</param>
            /// <remarks>
            /// <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-vsgetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void VSGetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->VSGetConstantBuffers1_126(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <inheritdoc cref = "HSGetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void HSGetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, Span<uint> pFirstConstant, Span<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.HSGetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Gets the constant buffers that the hull-shader stage uses.</summary>
            /// <param name = "StartSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name = "NumBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</param>
            /// <param name = "ppConstantBuffers">Array of constant buffer interface pointers to be returned by the method.</param>
            /// <param name = "pFirstConstant">A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</param>
            /// <param name = "pNumConstants">A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</param>
            /// <remarks>
            /// <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-hsgetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void HSGetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->HSGetConstantBuffers1_127(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <inheritdoc cref = "DSGetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void DSGetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, Span<uint> pFirstConstant, Span<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.DSGetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Gets the constant buffers that the domain-shader stage uses.</summary>
            /// <param name = "StartSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name = "NumBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</param>
            /// <param name = "ppConstantBuffers">Array of constant buffer interface pointers to be returned by the method.</param>
            /// <param name = "pFirstConstant">A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</param>
            /// <param name = "pNumConstants">A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</param>
            /// <remarks>
            /// <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-dsgetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void DSGetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DSGetConstantBuffers1_128(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <inheritdoc cref = "GSGetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void GSGetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, Span<uint> pFirstConstant, Span<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.GSGetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Gets the constant buffers that the geometry shader pipeline stage uses.</summary>
            /// <param name = "StartSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name = "NumBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</param>
            /// <param name = "ppConstantBuffers">Array of constant buffer interface pointers to be returned by the method.</param>
            /// <param name = "pFirstConstant">A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</param>
            /// <param name = "pNumConstants">A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</param>
            /// <remarks>
            /// <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-gsgetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void GSGetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->GSGetConstantBuffers1_129(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <inheritdoc cref = "PSGetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void PSGetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, Span<uint> pFirstConstant, Span<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.PSGetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Gets the constant buffers that the pixel shader pipeline stage uses.</summary>
            /// <param name = "StartSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name = "NumBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</param>
            /// <param name = "ppConstantBuffers">Array of constant buffer interface pointers to be returned by the method.</param>
            /// <param name = "pFirstConstant">A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</param>
            /// <param name = "pNumConstants">A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</param>
            /// <remarks>
            /// <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-psgetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void PSGetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->PSGetConstantBuffers1_130(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <inheritdoc cref = "CSGetConstantBuffers1(uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *)"/>
            internal unsafe void CSGetConstantBuffers1(uint StartSlot, win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, Span<uint> pFirstConstant, Span<uint> pNumConstants)
            {
                fixed (uint *pNumConstantsLocal = pNumConstants)
                {
                    fixed (uint *pFirstConstantLocal = pFirstConstant)
                    {
                        if (pFirstConstant.Length != pNumConstants.Length)
                            throw new ArgumentException();
                        this.CSGetConstantBuffers1(StartSlot, (uint)pNumConstants.Length, ppConstantBuffers, pFirstConstantLocal, pNumConstantsLocal);
                    }
                }
            }

            /// <summary>Gets the constant buffers that the compute-shader stage uses.</summary>
            /// <param name = "StartSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name = "NumBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</param>
            /// <param name = "ppConstantBuffers">Array of constant buffer interface pointers to be returned by the method.</param>
            /// <param name = "pFirstConstant">A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</param>
            /// <param name = "pNumConstants">A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</param>
            /// <remarks>
            /// <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-csgetconstantbuffers1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void CSGetConstantBuffers1(uint StartSlot, uint NumBuffers, [Optional] win32.Graphics.Direct3D11.ID3D11Buffer**ppConstantBuffers, [Optional] uint *pFirstConstant, [Optional] uint *pNumConstants)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->CSGetConstantBuffers1_131(pThis, StartSlot, NumBuffers, ppConstantBuffers, pFirstConstant, pNumConstants);
            }

            /// <summary>Activates the given context state object and changes the current device behavior to Direct3D 11, Direct3D 10.1, or Direct3D 10.</summary>
            /// <param name = "pState">A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nn-d3d11_1-id3ddevicecontextstate">ID3DDeviceContextState</a> interface for the context state object that was previously created through the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nf-d3d11_1-id3d11device1-createdevicecontextstate">ID3D11Device1::CreateDeviceContextState</a> method. If <b>SwapDeviceContextState</b> is called with <i>pState</i> set to <b>NULL</b>, the call has no effect.</param>
            /// <param name = "ppPreviousState">A pointer to a variable that receives a pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nn-d3d11_1-id3ddevicecontextstate">ID3DDeviceContextState</a> interface for the previously-activated context state object.</param>
            /// <remarks>
            /// <para><b>SwapDeviceContextState</b> changes device behavior. This device behavior depends on the emulated interface that you passed to the <i>EmulatedInterface</i> parameter of the  <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nf-d3d11_1-id3d11device1-createdevicecontextstate">ID3D11Device1::CreateDeviceContextState</a> method when you created the context state object.</para>
            /// <para><b>SwapDeviceContextState</b> is not supported on a deferred context.</para>
            /// <para><b>SwapDeviceContextState</b> disables the incompatible device interfaces <a href = "https://docs.microsoft.com/windows/desktop/api/d3d10/nn-d3d10-id3d10device">ID3D10Device</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/d3d10_1/nn-d3d10_1-id3d10device1">ID3D10Device1</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11device">ID3D11Device</a>, and <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nn-d3d11_1-id3d11device1">ID3D11Device1</a>. When a context state object is active, the runtime disables certain methods on the device and context interfaces. A context state object that is created with <c>__uuidof(ID3D11Device1)</code> or <code>__uuidof(ID3D11Device)</code> turns off most of the Direct3D 10 device interfaces. A context state object that is created with <code>__uuidof(ID3D10Device1)</code> or <code>__uuidof(ID3D10Device)</c> turns off most of the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11devicecontext">ID3D11DeviceContext</a> methods. For more information about this behavior, see <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nf-d3d11_1-id3d11device1-createdevicecontextstate">ID3D11Device1::CreateDeviceContextState</a>.</para>
            /// <para><b>SwapDeviceContextState</b> activates the context state object specified by <i>pState</i>. This means that the device behaviors that are associated with the context state object's feature level and compatible interface are activated on the Direct3D device until the next call to <b>SwapDeviceContextState</b>. In addition, any state that was saved when this context state object was last active is now reactivated, so that the previous state is replaced.</para>
            /// <para><b>SwapDeviceContextState</b> sets <i>ppPreviousState</i> to the most recently activated context state object. The object allows the caller to save and then later restore the previous device state. This behavior is useful in a plug-in architecture such as Direct2D that shares a Direct3D device with its plug-ins. A Direct2D interface can use context state objects to save and restore the application's state.</para>
            /// <para>If the caller did not previously call the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nf-d3d11_1-id3d11device1-createdevicecontextstate">ID3D11Device1::CreateDeviceContextState</a> method to create a previous context state object, <b>SwapDeviceContextState</b> sets <i>ppPreviousState</i> to the default context state object. In either case, usage of <b>SwapDeviceContextState</b> is the same.</para>
            /// <para>The feature level that is specified by the application, and that is chosen by the context state object from the acceptable list that the application supplies to <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nf-d3d11_1-id3d11device1-createdevicecontextstate">ID3D11Device1::CreateDeviceContextState</a>, controls the feature level of the immediate context whenever the context state object is active. Because the Direct3D 11 device is free-threaded, the device methods cannot query the current immediate context feature level. Instead, the device runs at a feature level that is the maximum of all previously created context state objects' feature levels. This means that the device's feature level can increase dynamically.</para>
            /// <para>The feature level of the context state object controls the functionality available from the immediate context. However, to maintain the free-threaded contract of the Direct3D 11 device methods—the resource-creation methods in particular—the upper-bound feature level of all created context state objects controls the set of resources that the device creates.</para>
            /// <para>Because the context state object interface is published by the immediate context, the interface requires the same threading model as the immediate context. Specifically, <b>SwapDeviceContextState</b> is single-threaded with respect to the other immediate context methods and with respect to the equivalent methods of <a href = "https://docs.microsoft.com/windows/desktop/api/d3d10/nn-d3d10-id3d10device">ID3D10Device</a>.</para>
            /// <para>Crucially, because only one of the Direct3D 10 or Direct3D 11 ref-count behaviors can be available at a time, one of the Direct3D 10 and Direct3D 11 interfaces must break its ref-count contract. To avoid this situation, the activation of a context state object turns off the incompatible version interface. Also, if you call a method of an incompatible version interface, the call silently fails if the method has  return type <b>void</b>, returns an <b>HRESULT</b> value of <b>E_INVALIDARG</b>, or sets any out parameter to <b>NULL</b>.</para>
            /// <para>When you switch from Direct3D 11 mode to either Direct3D 10 mode or Direct3D 10.1 mode, the binding behavior of the device changes. Specifically, the final release of a resource induces unbind in Direct3D 10 mode or Direct3D 10.1 mode. During final release an application releases all of the resource's references, including indirect references such as the linkage from view to resource, and the linkage from context state object to any of the context state object's bound resources. Any bound resource to which the application has no reference is unbound and destroyed, in order to maintain the Direct3D 10 behavior.</para>
            /// <para><b>SwapDeviceContextState</b> does not affect any state that <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11videocontext">ID3D11VideoContext</a> sets.</para>
            /// <para>Command lists that are generated by deferred contexts do not hold a reference to context state objects and are not affected by future updates to context state objects.</para>
            /// <para>No asynchronous objects are affected by <b>SwapDeviceContextState</b>. For example, if a query is active before a call to <b>SwapDeviceContextState</b>, it is still active after the call.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-swapdevicecontextstate#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void SwapDeviceContextState(win32.Graphics.Direct3D11.ID3DDeviceContextState*pState, [Optional] win32.Graphics.Direct3D11.ID3DDeviceContextState**ppPreviousState)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->SwapDeviceContextState_132(pThis, pState, ppPreviousState);
            }

            /// <inheritdoc cref = "ClearView(win32.Graphics.Direct3D11.ID3D11View*, float *, win32.UI.DisplayDevices.RECT*, uint)"/>
            internal unsafe void ClearView(win32.Graphics.Direct3D11.ID3D11View*pView, in float Color, ReadOnlySpan<win32.UI.DisplayDevices.RECT> pRect)
            {
                fixed (win32.UI.DisplayDevices.RECT*pRectLocal = pRect)
                {
                    fixed (float *ColorLocal = &Color)
                    {
                        this.ClearView(pView, ColorLocal, pRectLocal, (uint)pRect.Length);
                    }
                }
            }

            /// <summary>Sets all the elements in a resource view to one value.</summary>
            /// <param name = "pView">A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11view">ID3D11View</a> interface that represents the resource view to clear.</param>
            /// <param name = "Color">A 4-component array that represents the color to use to clear the resource view.</param>
            /// <param name = "pRect">An array of <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/d3d11-rect">D3D11_RECT</a> structures for the rectangles in the resource view to clear. If <b>NULL</b>, <b>ClearView</b> clears the entire surface.</param>
            /// <param name = "NumRects">Number of rectangles in the array that the  <i>pRect</i> parameter specifies.</param>
            /// <remarks>
            /// <para><b>ClearView</b> works only on render-target views (RTVs), depth/stencil views (DSVs) on depth-only resources (resources with no stencil component), unordered-access views (UAVs), or any video view of a <a href = "https://docs.microsoft.com/windows/desktop/direct3dhlsl/sm5-object-texture2d">Texture2D</a> surface. The runtime drops invalid calls. Empty rectangles in the <i>pRect</i> array are a no-op. A rectangle is empty if the top value equals the bottom value or the left value equals the right value.</para>
            /// <para><b>ClearView</b> doesn’t support 3D textures.</para>
            /// <para><b>ClearView</b> applies the same color value to all array slices in a view; all rectangles in the <i>pRect</i> array correspond to each array slice.  The <i>pRect</i> array of rectangles is a set of areas to clear on a single surface.  If the view is an array, <b>ClearView</b> clears all the rectangles on each array slice individually.</para>
            /// <para>When you apply rectangles to buffers, set the top value to 0 and the bottom value to 1 and set the left value and right value to describe the extent within the buffer. When the top value equals the bottom value or the left value equals the right value, the rectangle is empty and a no-op is achieved.</para>
            /// <para>The driver converts and clamps color values to the destination format as appropriate per Direct3D conversion rules.  For example, if the format of the view is <a href = "https://docs.microsoft.com/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format">DXGI_FORMAT_R8G8B8A8_UNORM</a>, the driver clamps inputs to 0.0f to 1.0f (+INF -&gt; 1.0f (0XFF)/NaN -&gt; 0.0f).</para>
            /// <para>If the format is integer, such as <a href = "https://docs.microsoft.com/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format">DXGI_FORMAT_R8G8B8A8_UINT</a>, the runtime interprets inputs as integral floats. Therefore, 235.0f maps to 235 (rounds to zero, out of range/INF values clamp to target range, and NaN to 0).</para>
            /// <para>Here are the color mappings:</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-clearview#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void ClearView(win32.Graphics.Direct3D11.ID3D11View*pView, float *Color, [Optional] win32.UI.DisplayDevices.RECT*pRect, uint NumRects)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->ClearView_133(pThis, pView, Color, pRect, NumRects);
            }

            /// <inheritdoc cref = "DiscardView1(win32.Graphics.Direct3D11.ID3D11View*, win32.UI.DisplayDevices.RECT*, uint)"/>
            internal unsafe void DiscardView1(win32.Graphics.Direct3D11.ID3D11View*pResourceView, ReadOnlySpan<win32.UI.DisplayDevices.RECT> pRects)
            {
                fixed (win32.UI.DisplayDevices.RECT*pRectsLocal = pRects)
                {
                    this.DiscardView1(pResourceView, pRectsLocal, (uint)pRects.Length);
                }
            }

            /// <summary>Discards the specified elements in a resource view from the device context.</summary>
            /// <param name = "pResourceView">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11view">ID3D11View</a>*</b></para>
            /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11view">ID3D11View</a> interface for the resource view to discard. The resource that underlies the view must have been created with usage <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/ne-d3d11-d3d11_usage">D3D11_USAGE_DEFAULT</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11/ne-d3d11-d3d11_usage">D3D11_USAGE_DYNAMIC</a>, otherwise the runtime drops the call to <b>DiscardView1</b>; if the debug layer is enabled, the runtime returns an error message.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-discardview1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pRects">
            /// <para>Type: <b>const <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/d3d11-rect">D3D11_RECT</a>*</b></para>
            /// <para>An array of <a href = "https://docs.microsoft.com/windows/desktop/direct3d11/d3d11-rect">D3D11_RECT</a> structures for the rectangles in the resource view to discard. If <b>NULL</b>, <b>DiscardView1</b> discards the entire view and behaves the same as <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nf-d3d11_1-id3d11devicecontext1-discardview">DiscardView</a>.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-discardview1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "NumRects">
            /// <para>Type: <b><a href = "https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
            /// <para>Number of rectangles in the array that the  <i>pRects</i> parameter specifies.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-discardview1#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <remarks>
            /// <para><b>DiscardView1</b> informs the graphics processing unit (GPU) that the existing content in the specified elements in the resource view that <i>pResourceView</i> points to is no longer needed.  The view can be an SRV, RTV, UAV, or DSV.  <b>DiscardView1</b> is a variation on the <a href = "https://docs.microsoft.com/windows/desktop/api/d3d11_1/nf-d3d11_1-id3d11devicecontext1-discardresource">DiscardResource</a> method.  <b>DiscardView1</b> allows you to discard elements of a subset of a resource that is in a view (such as elements of a single miplevel).  More importantly, <b>DiscardView1</b> provides a convenience because often views are what are being bound and unbound at the pipeline.  Some pipeline bindings do not have views, such as stream output.  In that situation, <b>DiscardResource</b> can do the job for any resource.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//d3d11_1/nf-d3d11_1-id3d11devicecontext1-discardview1#">Read more on docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe void DiscardView1(win32.Graphics.Direct3D11.ID3D11View*pResourceView, [Optional] win32.UI.DisplayDevices.RECT*pRects, uint NumRects)
            {
                fixed (ID3D11DeviceContext1*pThis = &this)
                    lpVtbl->DiscardView1_134(pThis, pResourceView, pRects, NumRects);
            }

            private struct Vtbl
            {
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, global::System.Guid*, void **, win32.System.Com.HRESULT>QueryInterface_1;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint>AddRef_2;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint>Release_3;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Device**, void>GetDevice_4;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, global::System.Guid*, uint *, void *, win32.System.Com.HRESULT>GetPrivateData_5;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, global::System.Guid*, uint, void *, win32.System.Com.HRESULT>SetPrivateData_6;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, global::System.Guid*, win32.System.Com.IUnknown*, win32.System.Com.HRESULT>SetPrivateDataInterface_7;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>VSSetConstantBuffers_8;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>PSSetShaderResources_9;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11PixelShader*, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint, void>PSSetShader_10;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>PSSetSamplers_11;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11VertexShader*, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint, void>VSSetShader_12;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, int, void>DrawIndexed_13;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, void>Draw_14;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Resource*, uint, win32.Graphics.Direct3D11.D3D11_MAP, uint, win32.Graphics.Direct3D11.D3D11_MAPPED_SUBRESOURCE*, win32.System.Com.HRESULT>Map_15;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Resource*, uint, void>Unmap_16;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>PSSetConstantBuffers_17;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11InputLayout*, void>IASetInputLayout_18;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>IASetVertexBuffers_19;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Buffer*, win32.Graphics.Dxgi.DXGI_FORMAT, uint, void>IASetIndexBuffer_20;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, uint, int, uint, void>DrawIndexedInstanced_21;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, uint, uint, void>DrawInstanced_22;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>GSSetConstantBuffers_23;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11GeometryShader*, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint, void>GSSetShader_24;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.D3D_PRIMITIVE_TOPOLOGY, void>IASetPrimitiveTopology_25;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>VSSetShaderResources_26;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>VSSetSamplers_27;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Asynchronous*, void>Begin_28;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Asynchronous*, void>End_29;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Asynchronous*, void *, uint, uint, win32.System.Com.HRESULT>GetData_30;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Predicate*, win32.System.SystemServices.BOOL, void>SetPredication_31;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>GSSetShaderResources_32;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>GSSetSamplers_33;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, win32.Graphics.Direct3D11.ID3D11RenderTargetView**, win32.Graphics.Direct3D11.ID3D11DepthStencilView*, void>OMSetRenderTargets_34;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, win32.Graphics.Direct3D11.ID3D11RenderTargetView**, win32.Graphics.Direct3D11.ID3D11DepthStencilView*, uint, uint, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**, uint *, void>OMSetRenderTargetsAndUnorderedAccessViews_35;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11BlendState*, float *, uint, void>OMSetBlendState_36;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11DepthStencilState*, uint, void>OMSetDepthStencilState_37;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, void>SOSetTargets_38;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, void>DrawAuto_39;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Buffer*, uint, void>DrawIndexedInstancedIndirect_40;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Buffer*, uint, void>DrawInstancedIndirect_41;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, uint, void>Dispatch_42;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Buffer*, uint, void>DispatchIndirect_43;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11RasterizerState*, void>RSSetState_44;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, win32.Graphics.Direct3D11.D3D11_VIEWPORT*, void>RSSetViewports_45;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, win32.UI.DisplayDevices.RECT*, void>RSSetScissorRects_46;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Resource*, uint, uint, uint, uint, win32.Graphics.Direct3D11.ID3D11Resource*, uint, win32.Graphics.Direct3D11.D3D11_BOX*, void>CopySubresourceRegion_47;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Resource*, win32.Graphics.Direct3D11.ID3D11Resource*, void>CopyResource_48;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Resource*, uint, win32.Graphics.Direct3D11.D3D11_BOX*, void *, uint, uint, void>UpdateSubresource_49;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Buffer*, uint, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView*, void>CopyStructureCount_50;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11RenderTargetView*, float *, void>ClearRenderTargetView_51;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView*, uint *, void>ClearUnorderedAccessViewUint_52;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView*, float *, void>ClearUnorderedAccessViewFloat_53;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11DepthStencilView*, uint, float, byte, void>ClearDepthStencilView_54;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11ShaderResourceView*, void>GenerateMips_55;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Resource*, float, void>SetResourceMinLOD_56;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Resource*, float>GetResourceMinLOD_57;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Resource*, uint, win32.Graphics.Direct3D11.ID3D11Resource*, uint, win32.Graphics.Dxgi.DXGI_FORMAT, void>ResolveSubresource_58;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11CommandList*, win32.System.SystemServices.BOOL, void>ExecuteCommandList_59;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>HSSetShaderResources_60;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11HullShader*, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint, void>HSSetShader_61;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>HSSetSamplers_62;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>HSSetConstantBuffers_63;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>DSSetShaderResources_64;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11DomainShader*, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint, void>DSSetShader_65;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>DSSetSamplers_66;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>DSSetConstantBuffers_67;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>CSSetShaderResources_68;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**, uint *, void>CSSetUnorderedAccessViews_69;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11ComputeShader*, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint, void>CSSetShader_70;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>CSSetSamplers_71;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>CSSetConstantBuffers_72;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>VSGetConstantBuffers_73;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>PSGetShaderResources_74;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11PixelShader**, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint *, void>PSGetShader_75;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>PSGetSamplers_76;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11VertexShader**, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint *, void>VSGetShader_77;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>PSGetConstantBuffers_78;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11InputLayout**, void>IAGetInputLayout_79;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>IAGetVertexBuffers_80;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Buffer**, win32.Graphics.Dxgi.DXGI_FORMAT*, uint *, void>IAGetIndexBuffer_81;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>GSGetConstantBuffers_82;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11GeometryShader**, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint *, void>GSGetShader_83;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.D3D_PRIMITIVE_TOPOLOGY*, void>IAGetPrimitiveTopology_84;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>VSGetShaderResources_85;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>VSGetSamplers_86;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Predicate**, win32.System.SystemServices.BOOL*, void>GetPredication_87;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>GSGetShaderResources_88;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>GSGetSamplers_89;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, win32.Graphics.Direct3D11.ID3D11RenderTargetView**, win32.Graphics.Direct3D11.ID3D11DepthStencilView**, void>OMGetRenderTargets_90;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, win32.Graphics.Direct3D11.ID3D11RenderTargetView**, win32.Graphics.Direct3D11.ID3D11DepthStencilView**, uint, uint, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**, void>OMGetRenderTargetsAndUnorderedAccessViews_91;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11BlendState**, float *, uint *, void>OMGetBlendState_92;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11DepthStencilState**, uint *, void>OMGetDepthStencilState_93;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>SOGetTargets_94;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11RasterizerState**, void>RSGetState_95;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint *, win32.Graphics.Direct3D11.D3D11_VIEWPORT*, void>RSGetViewports_96;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint *, win32.UI.DisplayDevices.RECT*, void>RSGetScissorRects_97;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>HSGetShaderResources_98;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11HullShader**, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint *, void>HSGetShader_99;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>HSGetSamplers_100;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>HSGetConstantBuffers_101;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>DSGetShaderResources_102;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11DomainShader**, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint *, void>DSGetShader_103;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>DSGetSamplers_104;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>DSGetConstantBuffers_105;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11ShaderResourceView**, void>CSGetShaderResources_106;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11UnorderedAccessView**, void>CSGetUnorderedAccessViews_107;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11ComputeShader**, win32.Graphics.Direct3D11.ID3D11ClassInstance**, uint *, void>CSGetShader_108;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11SamplerState**, void>CSGetSamplers_109;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, void>CSGetConstantBuffers_110;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, void>ClearState_111;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, void>Flush_112;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.D3D11_DEVICE_CONTEXT_TYPE>GetType_113;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint>GetContextFlags_114;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.System.SystemServices.BOOL, win32.Graphics.Direct3D11.ID3D11CommandList**, win32.System.Com.HRESULT>FinishCommandList_115;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Resource*, uint, uint, uint, uint, win32.Graphics.Direct3D11.ID3D11Resource*, uint, win32.Graphics.Direct3D11.D3D11_BOX*, uint, void>CopySubresourceRegion1_116;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Resource*, uint, win32.Graphics.Direct3D11.D3D11_BOX*, void *, uint, uint, uint, void>UpdateSubresource1_117;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11Resource*, void>DiscardResource_118;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11View*, void>DiscardView_119;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>VSSetConstantBuffers1_120;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>HSSetConstantBuffers1_121;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>DSSetConstantBuffers1_122;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>GSSetConstantBuffers1_123;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>PSSetConstantBuffers1_124;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>CSSetConstantBuffers1_125;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>VSGetConstantBuffers1_126;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>HSGetConstantBuffers1_127;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>DSGetConstantBuffers1_128;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>GSGetConstantBuffers1_129;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>PSGetConstantBuffers1_130;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, uint, uint, win32.Graphics.Direct3D11.ID3D11Buffer**, uint *, uint *, void>CSGetConstantBuffers1_131;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3DDeviceContextState*, win32.Graphics.Direct3D11.ID3DDeviceContextState**, void>SwapDeviceContextState_132;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11View*, float *, win32.UI.DisplayDevices.RECT*, uint, void>ClearView_133;
                internal delegate *unmanaged[Stdcall]<ID3D11DeviceContext1*, win32.Graphics.Direct3D11.ID3D11View*, win32.UI.DisplayDevices.RECT*, uint, void>DiscardView1_134;
            }

            private Vtbl*lpVtbl;
        }
    }
}