// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable CS1591, CS1573, CS0465, CS0649, CS8019, CS1570, CS1584, CS1658
namespace Windows.Win32
{
    using global::System;
    using global::System.Diagnostics;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;
    using win32 = global::Windows.Win32;

    internal static partial class Kernel32
    {
        /// <summary>Closes an open object handle.</summary>
        /// <param name = "hObject">A valid handle to an open object.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href = "/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href = "/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-closehandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL CloseHandle(win32.System.SystemServices.HANDLE hObject);
        /// <summary>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.</summary>
        /// <param name = "hLibModule">
        /// <para>A handle to the loaded library module. The <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freelibrary#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freelibrary">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL FreeLibrary(win32.System.SystemServices.HINSTANCE hLibModule);
        /// <summary>Decrements (decreases by one) the reference count of a loaded resource. When the reference count reaches zero, the memory occupied by the resource is freed.</summary>
        /// <param name = "hResData">
        /// <para>Type: <b>HGLOBAL</b></para>
        /// <para>A handle of the resource. It is assumed that <i>hglbResource</i> was created by <a href = "https://docs.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freeresource#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is zero.</para>
        /// <para>If the function fails, the return value is nonzero, which indicates that the resource has not been freed.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freeresource">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool FreeResource(nint hResData);
        /// <inheritdoc cref = "LoadResource(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.HRSRC)"/>
        internal static unsafe nint LoadResource(SafeHandle hModule, win32.System.SystemServices.HRSRC hResInfo)
        {
            bool hModuleAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hModuleLocal;
                if (hModule is object)
                {
                    hModule.DangerousAddRef(ref hModuleAddRef);
                    hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                }
                else
                    hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                nint __result = Kernel32.LoadResource(hModuleLocal, hResInfo);
                return __result;
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Retrieves a handle that can be used to obtain a pointer to the first byte of the specified resource in memory.</summary>
        /// <param name = "hModule">
        /// <para>Type: <b>HMODULE</b></para>
        /// <para>A handle to the module whose executable file contains the resource. If <i>hModule</i> is <b>NULL</b>, the system loads the resource from the module that was used to create the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadresource#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hResInfo">
        /// <para>Type: <b>HRSRC</b></para>
        /// <para>A handle to the resource to be loaded. This handle is returned by the <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-findresourcea">FindResource</a> or <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-findresourceexa">FindResourceEx</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadresource#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HGLOBAL</b></para>
        /// <para>If the function succeeds, the return value is a handle to the data associated with the resource.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadresource">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nint LoadResource(win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.HRSRC hResInfo);
        /// <summary>Retrieves a pointer to the specified resource in memory.</summary>
        /// <param name = "hResData">
        /// <para>Type: **HGLOBAL**</para>
        /// <para>A handle to the resource to be accessed. The [LoadResource function](nf-libloaderapi-loadresource.md) returns this handle. Note that this parameter is listed as an **HGLOBAL** variable only for backward compatibility. Do not pass any value as a parameter other than a successful return value from the **LoadResource** function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-lockresource#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: **LPVOID**</para>
        /// <para>If the loaded resource is available, the return value is a pointer to the first byte of the resource; otherwise, it is **NULL**.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-lockresource">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void *LockResource(nint hResData);
        /// <inheritdoc cref = "SizeofResource(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.HRSRC)"/>
        internal static unsafe uint SizeofResource(SafeHandle hModule, win32.System.SystemServices.HRSRC hResInfo)
        {
            bool hModuleAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hModuleLocal;
                if (hModule is object)
                {
                    hModule.DangerousAddRef(ref hModuleAddRef);
                    hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                }
                else
                    hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                uint __result = Kernel32.SizeofResource(hModuleLocal, hResInfo);
                return __result;
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Retrieves the size, in bytes, of the specified resource.</summary>
        /// <param name = "hModule">
        /// <para>Type: <b>HMODULE</b></para>
        /// <para>A handle to the module whose executable file contains the resource.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-sizeofresource#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hResInfo">
        /// <para>Type: <b>HRSRC</b></para>
        /// <para>A handle to the resource. This handle must be created by using the <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-findresourcea">FindResource</a> or <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-findresourceexa">FindResourceEx</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-sizeofresource#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>If the function succeeds, the return value is the number of bytes in the resource.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-sizeofresource">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint SizeofResource(win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.HRSRC hResInfo);
        /// <inheritdoc cref = "EnumResourceLanguagesEx(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, delegate *unmanaged[Stdcall]{win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, ushort, nint, win32.System.SystemServices.BOOL}, nint, uint, ushort)"/>
        internal static unsafe bool EnumResourceLanguagesEx(SafeHandle hModule, string lpType, string lpName, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, ushort, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam, uint dwFlags, ushort LangId)
        {
            bool hModuleAddRef = false;
            try
            {
                fixed (char *lpNameLocal = lpName)
                {
                    fixed (char *lpTypeLocal = lpType)
                    {
                        win32.System.SystemServices.HINSTANCE hModuleLocal;
                        if (hModule is object)
                        {
                            hModule.DangerousAddRef(ref hModuleAddRef);
                            hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                        }
                        else
                            hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                        bool __result = Kernel32.EnumResourceLanguagesEx(hModuleLocal, lpTypeLocal, lpNameLocal, lpEnumFunc, lParam, dwFlags, LangId);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Enumerates language-specific resources, of the specified type and name, associated with a specified binary module. Extends EnumResourceLanguages by allowing more control over the enumeration.</summary>
        /// <param name = "hModule">
        /// <para>Type: <b>HMODULE</b> The handle to a module to search. Typically this is a <a href = "https://docs.microsoft.com/windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file. If this is a specific .mui file, only that file is searched for resources.</para>
        /// <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcelanguagesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpType">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The type of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <a href = "https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a>(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href = "https://docs.microsoft.com/windows/desktop/menurc/resource-types">Resource Types</a>. For more</para>
        /// <para>information, see the Remarks section below.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcelanguagesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <a href = "https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a>(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcelanguagesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEnumFunc">
        /// <para>Type: <b>ENUMRESLANGPROC</b></para>
        /// <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href = "https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcelanguagesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LONG_PTR</b></para>
        /// <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcelanguagesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b> flags are assumed to be specified.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcelanguagesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "LangId">
        /// <para>Type: <b>LANGID</b></para>
        /// <para>The localization language used to filter the search in the .mui file. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files are included in the search. If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcelanguagesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns <b>TRUE</b> if the function succeeds or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcelanguagesexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumResourceLanguagesExW", SetLastError = true)]
        internal static extern unsafe bool EnumResourceLanguagesEx(win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.PCWSTR lpType, win32.System.SystemServices.PCWSTR lpName, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, ushort, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam, uint dwFlags, ushort LangId);
        /// <inheritdoc cref = "EnumResourceNamesEx(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, delegate *unmanaged[Stdcall]{win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL}, nint, uint, ushort)"/>
        internal static unsafe bool EnumResourceNamesEx(SafeHandle hModule, string lpType, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam, uint dwFlags, ushort LangId)
        {
            bool hModuleAddRef = false;
            try
            {
                fixed (char *lpTypeLocal = lpType)
                {
                    win32.System.SystemServices.HINSTANCE hModuleLocal;
                    if (hModule is object)
                    {
                        hModule.DangerousAddRef(ref hModuleAddRef);
                        hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                    }
                    else
                        hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                    bool __result = Kernel32.EnumResourceNamesEx(hModuleLocal, lpTypeLocal, lpEnumFunc, lParam, dwFlags, LangId);
                    return __result;
                }
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Enumerates resources of a specified type that are associated with a specified binary module. The search can include both an LN file and its associated .mui files, or it can be limited in several ways.</summary>
        /// <param name = "hModule">
        /// <para>Type: <b>HMODULE</b></para>
        /// <para>The handle to a module to search. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
        /// <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpType">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be <a href = "https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a>(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href = "https://msdn.microsoft.com/8d27f79a-8165-4565-a975-f25b2344efdc">Resource Types</a>. For more information, see the Remarks section below.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEnumFunc">
        /// <para>Type: <b>ENUMRESNAMEPROC</b></para>
        /// <para>A pointer to the callback function to be called for each enumerated resource name. For more information, see <a href = "https://docs.microsoft.com/windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LONG_PTR</b></para>
        /// <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The type of file to search. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "LangId">
        /// <para>Type: <b>LANGID</b></para>
        /// <para>The localization language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href = "https://docs.microsoft.com/windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>The function <b>TRUE</b> if successful, or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumResourceNamesExW", SetLastError = true)]
        internal static extern unsafe bool EnumResourceNamesEx(win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.PCWSTR lpType, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam, uint dwFlags, ushort LangId);
        /// <inheritdoc cref = "EnumResourceTypesEx(win32.System.SystemServices.HINSTANCE, delegate *unmanaged[Stdcall]{win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL}, nint, uint, ushort)"/>
        internal static unsafe bool EnumResourceTypesEx(SafeHandle hModule, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam, uint dwFlags, ushort LangId)
        {
            bool hModuleAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hModuleLocal;
                if (hModule is object)
                {
                    hModule.DangerousAddRef(ref hModuleAddRef);
                    hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                }
                else
                    hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                bool __result = Kernel32.EnumResourceTypesEx(hModuleLocal, lpEnumFunc, lParam, dwFlags, LangId);
                return __result;
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Enumerates resource types associated with a specified binary module.</summary>
        /// <param name = "hModule">
        /// <para>Type: <b>HMODULE</b></para>
        /// <para>The handle to a module to be searched. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files can be included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
        /// <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcetypesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEnumFunc">
        /// <para>Type: <b>ENUMRESTYPEPROC</b></para>
        /// <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see <a href = "https://docs.microsoft.com/windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcetypesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LONG_PTR</b></para>
        /// <para>An application-defined value passed to the callback function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcetypesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcetypesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "LangId">
        /// <para>Type: <b>LANGID</b></para>
        /// <para>The language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href = "https://docs.microsoft.com/windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcetypesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcetypesexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumResourceTypesExW", SetLastError = true)]
        internal static extern unsafe bool EnumResourceTypesEx(win32.System.SystemServices.HINSTANCE hModule, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam, uint dwFlags, ushort LangId);
        /// <summary>Retrieves a description string for the language associated with a specified binary Microsoft language identifier.</summary>
        /// <param name = "wLang">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The binary language identifier. For a complete list of the language identifiers, see <a href = "https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">Language Identifiers</a>.</para>
        /// <para>For example, the description string associated with the language identifier 0x040A is "Spanish (Traditional Sort)". If the identifier is unknown, the <i>szLang</i> parameter points to a default string ("Language Neutral").</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verlanguagenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "szLang">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The language specified by the <i>wLang</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verlanguagenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchLang">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The size, in characters, of the buffer pointed to by <i>szLang</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verlanguagenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The return value is the size, in characters, of the string returned in the buffer. This value does not include the terminating null character. If the description string is smaller than or equal to the buffer, the entire description string is in the buffer. If the description string is larger than the buffer, the description string is truncated to the length of the buffer.</para>
        /// <para>If an error occurs, the return value is zero. Unknown language identifiers do not produce errors.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verlanguagenamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "VerLanguageNameW")]
        internal static extern uint VerLanguageName(uint wLang, win32.System.SystemServices.PWSTR szLang, uint cchLang);
        /// <inheritdoc cref = "lstrcmp(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe int lstrcmp(string lpString1, string lpString2)
        {
            fixed (char *lpString2Local = lpString2)
            {
                fixed (char *lpString1Local = lpString1)
                {
                    int __result = Kernel32.lstrcmp(lpString1Local, lpString2Local);
                    return __result;
                }
            }
        }

        /// <summary>Compares two character strings. The comparison is case-sensitive.</summary>
        /// <param name = "lpString1">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The first null-terminated string to be compared.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcmpw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString2">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The second null-terminated string to be compared.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcmpw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the string pointed to by <i>lpString1</i> is less than the string pointed to by <i>lpString2</i>, the return value is negative. If the string pointed to by <i>lpString1</i> is greater than the string pointed to by <i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcmpw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "lstrcmpW")]
        internal static extern int lstrcmp(win32.System.SystemServices.PCWSTR lpString1, win32.System.SystemServices.PCWSTR lpString2);
        /// <inheritdoc cref = "lstrcmpi(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe int lstrcmpi(string lpString1, string lpString2)
        {
            fixed (char *lpString2Local = lpString2)
            {
                fixed (char *lpString1Local = lpString1)
                {
                    int __result = Kernel32.lstrcmpi(lpString1Local, lpString2Local);
                    return __result;
                }
            }
        }

        /// <summary>Compares two character strings. The comparison is not case-sensitive.</summary>
        /// <param name = "lpString1">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The first null-terminated string to be compared.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcmpiw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString2">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The second null-terminated string to be compared.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcmpiw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>If the string pointed to by <i>lpString1</i> is less than the string pointed to by <i>lpString2</i>, the return value is negative. If the string pointed to by <i>lpString1</i> is greater than the string pointed to by <i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcmpiw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "lstrcmpiW")]
        internal static extern int lstrcmpi(win32.System.SystemServices.PCWSTR lpString1, win32.System.SystemServices.PCWSTR lpString2);
        /// <inheritdoc cref = "lstrcpyn(win32.System.SystemServices.PWSTR, win32.System.SystemServices.PCWSTR, int)"/>
        internal static unsafe win32.System.SystemServices.PWSTR lstrcpyn(win32.System.SystemServices.PWSTR lpString1, string lpString2, int iMaxLength)
        {
            fixed (char *lpString2Local = lpString2)
            {
                win32.System.SystemServices.PWSTR __result = Kernel32.lstrcpyn(lpString1, lpString2Local, iMaxLength);
                return __result;
            }
        }

        /// <summary>Copies a specified number of characters from a source string into a buffer.Warning  Do not use.</summary>
        /// <param name = "lpString1">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The destination buffer, which receives the copied characters. The buffer must be large enough to contain the number of <b>TCHAR</b> values specified by <i>iMaxLength</i>, including room for a terminating null character.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcpynw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString2">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The source string from which the function is to copy characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcpynw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "iMaxLength">
        /// <para>Type: <b>int</b></para>
        /// <para>The number of <b>TCHAR</b> values to be copied from the string pointed to by <i>lpString2</i> into the buffer pointed to by <i>lpString1</i>, including a terminating null character.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcpynw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>If the function succeeds, the return value is a pointer to the buffer. The function can succeed even if the source string is greater than <i>iMaxLength</i> characters.</para>
        /// <para>If the function fails, the return value is <b>NULL</b> and <i>lpString1</i> may not be null-terminated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcpynw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "lstrcpynW")]
        internal static extern win32.System.SystemServices.PWSTR lstrcpyn(win32.System.SystemServices.PWSTR lpString1, win32.System.SystemServices.PCWSTR lpString2, int iMaxLength);
        /// <inheritdoc cref = "lstrcpy(win32.System.SystemServices.PWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.SystemServices.PWSTR lstrcpy(win32.System.SystemServices.PWSTR lpString1, string lpString2)
        {
            fixed (char *lpString2Local = lpString2)
            {
                win32.System.SystemServices.PWSTR __result = Kernel32.lstrcpy(lpString1, lpString2Local);
                return __result;
            }
        }

        /// <summary>Copies a string to a buffer.</summary>
        /// <param name = "lpString1">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>A buffer to receive the contents of the string pointed to by the <i>lpString2</i> parameter. The buffer must be large enough to contain the string, including the terminating null character.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcpyw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString2">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The null-terminated string to be copied.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcpyw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>If the function succeeds, the return value is a pointer to the buffer.</para>
        /// <para>If the function fails, the return value is <b>NULL</b> and <i>lpString1</i> may not be null-terminated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcpyw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "lstrcpyW")]
        internal static extern win32.System.SystemServices.PWSTR lstrcpy(win32.System.SystemServices.PWSTR lpString1, win32.System.SystemServices.PCWSTR lpString2);
        /// <inheritdoc cref = "lstrcat(win32.System.SystemServices.PWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.SystemServices.PWSTR lstrcat(win32.System.SystemServices.PWSTR lpString1, string lpString2)
        {
            fixed (char *lpString2Local = lpString2)
            {
                win32.System.SystemServices.PWSTR __result = Kernel32.lstrcat(lpString1, lpString2Local);
                return __result;
            }
        }

        /// <summary>Appends one string to another.Warning  Do not use.</summary>
        /// <param name = "lpString1">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The first null-terminated string. This buffer must be large enough to contain both strings.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcatw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString2">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The null-terminated string to be appended to the string specified in the <i>lpString1</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcatw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>If the function succeeds, the return value is a pointer to the buffer.</para>
        /// <para>If the function fails, the return value is <b>NULL</b> and <i>lpString1</i> may not be null-terminated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcatw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "lstrcatW")]
        internal static extern win32.System.SystemServices.PWSTR lstrcat(win32.System.SystemServices.PWSTR lpString1, win32.System.SystemServices.PCWSTR lpString2);
        /// <inheritdoc cref = "lstrlen(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe int lstrlen(string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                int __result = Kernel32.lstrlen(lpStringLocal);
                return __result;
            }
        }

        /// <summary>Determines the length of the specified string (not including the terminating null character).</summary>
        /// <param name = "lpString">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The null-terminated string to be checked.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrlenw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>int</b></para>
        /// <para>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrlenw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "lstrlenW")]
        internal static extern int lstrlen(win32.System.SystemServices.PCWSTR lpString);
        /// <inheritdoc cref = "EnumResourceTypes(win32.System.SystemServices.HINSTANCE, delegate *unmanaged[Stdcall]{win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL}, nint)"/>
        internal static unsafe bool EnumResourceTypes(SafeHandle hModule, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam)
        {
            bool hModuleAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hModuleLocal;
                if (hModule is object)
                {
                    hModule.DangerousAddRef(ref hModuleAddRef);
                    hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                }
                else
                    hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                bool __result = Kernel32.EnumResourceTypes(hModuleLocal, lpEnumFunc, lParam);
                return __result;
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Enumerates resource types within a binary module.</summary>
        /// <param name = "hModule">
        /// <para>Type: <b>HMODULE</b></para>
        /// <para>A handle to a module to be searched. This handle must be obtained through <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
        /// <para>See Remarks for more information.</para>
        /// <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enumresourcetypesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEnumFunc">
        /// <para>Type: <b>ENUMRESTYPEPROC</b></para>
        /// <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enumresourcetypesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LONG_PTR</b></para>
        /// <para>An application-defined value passed to the callback function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enumresourcetypesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enumresourcetypesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumResourceTypesW", SetLastError = true)]
        internal static extern unsafe bool EnumResourceTypes(win32.System.SystemServices.HINSTANCE hModule, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam);
        /// <inheritdoc cref = "EnumResourceLanguages(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, delegate *unmanaged[Stdcall]{win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, ushort, nint, win32.System.SystemServices.BOOL}, nint)"/>
        internal static unsafe bool EnumResourceLanguages(SafeHandle hModule, string lpType, string lpName, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, ushort, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam)
        {
            bool hModuleAddRef = false;
            try
            {
                fixed (char *lpNameLocal = lpName)
                {
                    fixed (char *lpTypeLocal = lpType)
                    {
                        win32.System.SystemServices.HINSTANCE hModuleLocal;
                        if (hModule is object)
                        {
                            hModule.DangerousAddRef(ref hModuleAddRef);
                            hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                        }
                        else
                            hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                        bool __result = Kernel32.EnumResourceLanguages(hModuleLocal, lpTypeLocal, lpNameLocal, lpEnumFunc, lParam);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</summary>
        /// <param name = "hModule">
        /// <para>Type: <b>HMODULE</b> The handle to a module to be searched. Starting with Windows Vista, if this is a <a href = "https://docs.microsoft.com/windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
        /// <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enumresourcelanguagesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpType">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a>(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href = "https://docs.microsoft.com/windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enumresourcelanguagesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a>(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enumresourcelanguagesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEnumFunc">
        /// <para>Type: <b>ENUMRESLANGPROC</b></para>
        /// <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enumresourcelanguagesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LONG_PTR</b></para>
        /// <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enumresourcelanguagesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enumresourcelanguagesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumResourceLanguagesW", SetLastError = true)]
        internal static extern unsafe bool EnumResourceLanguages(win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.PCWSTR lpType, win32.System.SystemServices.PCWSTR lpName, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, ushort, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam);
        /// <inheritdoc cref = "BeginUpdateResource(win32.System.SystemServices.PCWSTR, bool)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle BeginUpdateResource(string pFileName, bool bDeleteExistingResources)
        {
            fixed (char *pFileNameLocal = pFileName)
            {
                win32.System.SystemServices.HANDLE __result = Kernel32.BeginUpdateResource(pFileNameLocal, bDeleteExistingResources);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Retrieves a handle that can be used by the UpdateResource function to add, delete, or replace resources in a binary module.</summary>
        /// <param name = "pFileName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-beginupdateresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bDeleteExistingResources">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-updateresourcea">UpdateResource</a> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-beginupdateresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>If the function succeeds, the return value is a handle that can be used by the <a href = "/windows/desktop/api/winbase/nf-winbase-updateresourcea">UpdateResource</a> and <a href = "/windows/desktop/api/winbase/nf-winbase-endupdateresourcea">EndUpdateResource</a> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-beginupdateresourcew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "BeginUpdateResourceW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE BeginUpdateResource(win32.System.SystemServices.PCWSTR pFileName, bool bDeleteExistingResources);
        /// <inheritdoc cref = "UpdateResource(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, ushort, void *, uint)"/>
        internal static unsafe bool UpdateResource(SafeHandle hUpdate, string lpType, string lpName, ushort wLanguage, void *lpData, uint cb)
        {
            bool hUpdateAddRef = false;
            try
            {
                fixed (char *lpNameLocal = lpName)
                {
                    fixed (char *lpTypeLocal = lpType)
                    {
                        win32.System.SystemServices.HANDLE hUpdateLocal;
                        if (hUpdate is object)
                        {
                            hUpdate.DangerousAddRef(ref hUpdateAddRef);
                            hUpdateLocal = (win32.System.SystemServices.HANDLE)hUpdate.DangerousGetHandle();
                        }
                        else
                            hUpdateLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.UpdateResource(hUpdateLocal, lpTypeLocal, lpNameLocal, wLanguage, lpData, cb);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hUpdateAddRef)
                    hUpdate.DangerousRelease();
            }
        }

        /// <summary>Adds, deletes, or replaces a resource in a portable executable (PE) file.</summary>
        /// <param name = "hUpdate">
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>A module handle returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-beginupdateresourcea">BeginUpdateResource</a> function, referencing the file to be updated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-updateresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpType">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a>(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
        /// <para>For a list of predefined resource types, see <a href = "https://docs.microsoft.com/windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-updateresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a>(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-updateresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wLanguage">
        /// <para>Type: <b>WORD</b></para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelangid">MAKELANGID</a>  macro.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-updateresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpData">
        /// <para>Type: <b>LPVOID</b></para>
        /// <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadicona">LoadIcon</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadstringa">LoadString</a>, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
        /// <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-updateresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cb">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The size, in bytes, of the resource data at <i>lpData</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-updateresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-updateresourcew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "UpdateResourceW", SetLastError = true)]
        internal static extern unsafe bool UpdateResource(win32.System.SystemServices.HANDLE hUpdate, win32.System.SystemServices.PCWSTR lpType, win32.System.SystemServices.PCWSTR lpName, ushort wLanguage, [Optional] void *lpData, uint cb);
        /// <inheritdoc cref = "EndUpdateResource(win32.System.SystemServices.HANDLE, bool)"/>
        internal static unsafe bool EndUpdateResource(SafeHandle hUpdate, bool fDiscard)
        {
            bool hUpdateAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hUpdateLocal;
                if (hUpdate is object)
                {
                    hUpdate.DangerousAddRef(ref hUpdateAddRef);
                    hUpdateLocal = (win32.System.SystemServices.HANDLE)hUpdate.DangerousGetHandle();
                }
                else
                    hUpdateLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.EndUpdateResource(hUpdateLocal, fDiscard);
                return __result;
            }
            finally
            {
                if (hUpdateAddRef)
                    hUpdate.DangerousRelease();
            }
        }

        /// <summary>Commits or discards changes made prior to a call to UpdateResource.</summary>
        /// <param name = "hUpdate">
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>A module handle returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-beginupdateresourcea">BeginUpdateResource</a> function, and used by <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-updateresourcea">UpdateResource</a>, referencing the file to be updated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-endupdateresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fDiscard">
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-endupdateresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-endupdateresourcew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EndUpdateResourceW", SetLastError = true)]
        internal static extern bool EndUpdateResource(win32.System.SystemServices.HANDLE hUpdate, bool fDiscard);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool AllocConsole();
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool FreeConsole();
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool AttachConsole(uint dwProcessId);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetConsoleCP();
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetConsoleOutputCP();
        /// <inheritdoc cref = "GetConsoleMode(win32.System.SystemServices.HANDLE, win32.System.Console.CONSOLE_MODE*)"/>
        internal static unsafe bool GetConsoleMode(SafeHandle hConsoleHandle, out win32.System.Console.CONSOLE_MODE lpMode)
        {
            bool hConsoleHandleAddRef = false;
            try
            {
                fixed (win32.System.Console.CONSOLE_MODE*lpModeLocal = &lpMode)
                {
                    win32.System.SystemServices.HANDLE hConsoleHandleLocal;
                    if (hConsoleHandle is object)
                    {
                        hConsoleHandle.DangerousAddRef(ref hConsoleHandleAddRef);
                        hConsoleHandleLocal = (win32.System.SystemServices.HANDLE)hConsoleHandle.DangerousGetHandle();
                    }
                    else
                        hConsoleHandleLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetConsoleMode(hConsoleHandleLocal, lpModeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleHandleAddRef)
                    hConsoleHandle.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetConsoleMode(win32.System.SystemServices.HANDLE hConsoleHandle, win32.System.Console.CONSOLE_MODE*lpMode);
        /// <inheritdoc cref = "SetConsoleMode(win32.System.SystemServices.HANDLE, win32.System.Console.CONSOLE_MODE)"/>
        internal static unsafe bool SetConsoleMode(SafeHandle hConsoleHandle, win32.System.Console.CONSOLE_MODE dwMode)
        {
            bool hConsoleHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hConsoleHandleLocal;
                if (hConsoleHandle is object)
                {
                    hConsoleHandle.DangerousAddRef(ref hConsoleHandleAddRef);
                    hConsoleHandleLocal = (win32.System.SystemServices.HANDLE)hConsoleHandle.DangerousGetHandle();
                }
                else
                    hConsoleHandleLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetConsoleMode(hConsoleHandleLocal, dwMode);
                return __result;
            }
            finally
            {
                if (hConsoleHandleAddRef)
                    hConsoleHandle.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SetConsoleMode(win32.System.SystemServices.HANDLE hConsoleHandle, win32.System.Console.CONSOLE_MODE dwMode);
        /// <inheritdoc cref = "GetNumberOfConsoleInputEvents(win32.System.SystemServices.HANDLE, uint *)"/>
        internal static unsafe bool GetNumberOfConsoleInputEvents(SafeHandle hConsoleInput, out uint lpNumberOfEvents)
        {
            bool hConsoleInputAddRef = false;
            try
            {
                fixed (uint *lpNumberOfEventsLocal = &lpNumberOfEvents)
                {
                    win32.System.SystemServices.HANDLE hConsoleInputLocal;
                    if (hConsoleInput is object)
                    {
                        hConsoleInput.DangerousAddRef(ref hConsoleInputAddRef);
                        hConsoleInputLocal = (win32.System.SystemServices.HANDLE)hConsoleInput.DangerousGetHandle();
                    }
                    else
                        hConsoleInputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetNumberOfConsoleInputEvents(hConsoleInputLocal, lpNumberOfEventsLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleInputAddRef)
                    hConsoleInput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetNumberOfConsoleInputEvents(win32.System.SystemServices.HANDLE hConsoleInput, uint *lpNumberOfEvents);
        /// <inheritdoc cref = "ReadConsoleInput(win32.System.SystemServices.HANDLE, win32.System.Console.INPUT_RECORD*, uint, uint *)"/>
        internal static unsafe bool ReadConsoleInput(SafeHandle hConsoleInput, Span<win32.System.Console.INPUT_RECORD> lpBuffer, out uint lpNumberOfEventsRead)
        {
            bool hConsoleInputAddRef = false;
            try
            {
                fixed (uint *lpNumberOfEventsReadLocal = &lpNumberOfEventsRead)
                {
                    fixed (win32.System.Console.INPUT_RECORD*lpBufferLocal = lpBuffer)
                    {
                        win32.System.SystemServices.HANDLE hConsoleInputLocal;
                        if (hConsoleInput is object)
                        {
                            hConsoleInput.DangerousAddRef(ref hConsoleInputAddRef);
                            hConsoleInputLocal = (win32.System.SystemServices.HANDLE)hConsoleInput.DangerousGetHandle();
                        }
                        else
                            hConsoleInputLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.ReadConsoleInput(hConsoleInputLocal, lpBufferLocal, (uint)lpBuffer.Length, lpNumberOfEventsReadLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hConsoleInputAddRef)
                    hConsoleInput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "ReadConsoleInputW")]
        internal static extern unsafe bool ReadConsoleInput(win32.System.SystemServices.HANDLE hConsoleInput, win32.System.Console.INPUT_RECORD*lpBuffer, uint nLength, uint *lpNumberOfEventsRead);
        /// <inheritdoc cref = "PeekConsoleInput(win32.System.SystemServices.HANDLE, win32.System.Console.INPUT_RECORD*, uint, uint *)"/>
        internal static unsafe bool PeekConsoleInput(SafeHandle hConsoleInput, Span<win32.System.Console.INPUT_RECORD> lpBuffer, out uint lpNumberOfEventsRead)
        {
            bool hConsoleInputAddRef = false;
            try
            {
                fixed (uint *lpNumberOfEventsReadLocal = &lpNumberOfEventsRead)
                {
                    fixed (win32.System.Console.INPUT_RECORD*lpBufferLocal = lpBuffer)
                    {
                        win32.System.SystemServices.HANDLE hConsoleInputLocal;
                        if (hConsoleInput is object)
                        {
                            hConsoleInput.DangerousAddRef(ref hConsoleInputAddRef);
                            hConsoleInputLocal = (win32.System.SystemServices.HANDLE)hConsoleInput.DangerousGetHandle();
                        }
                        else
                            hConsoleInputLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.PeekConsoleInput(hConsoleInputLocal, lpBufferLocal, (uint)lpBuffer.Length, lpNumberOfEventsReadLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hConsoleInputAddRef)
                    hConsoleInput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "PeekConsoleInputW")]
        internal static extern unsafe bool PeekConsoleInput(win32.System.SystemServices.HANDLE hConsoleInput, win32.System.Console.INPUT_RECORD*lpBuffer, uint nLength, uint *lpNumberOfEventsRead);
        /// <inheritdoc cref = "ReadConsole(win32.System.SystemServices.HANDLE, void *, uint, uint *, win32.System.Console.CONSOLE_READCONSOLE_CONTROL*)"/>
        internal static unsafe bool ReadConsole(SafeHandle hConsoleInput, void *lpBuffer, uint nNumberOfCharsToRead, out uint lpNumberOfCharsRead, win32.System.Console.CONSOLE_READCONSOLE_CONTROL? pInputControl)
        {
            bool hConsoleInputAddRef = false;
            try
            {
                fixed (uint *lpNumberOfCharsReadLocal = &lpNumberOfCharsRead)
                {
                    win32.System.SystemServices.HANDLE hConsoleInputLocal;
                    if (hConsoleInput is object)
                    {
                        hConsoleInput.DangerousAddRef(ref hConsoleInputAddRef);
                        hConsoleInputLocal = (win32.System.SystemServices.HANDLE)hConsoleInput.DangerousGetHandle();
                    }
                    else
                        hConsoleInputLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.Console.CONSOLE_READCONSOLE_CONTROL pInputControlLocal = pInputControl.HasValue ? pInputControl.Value : default(win32.System.Console.CONSOLE_READCONSOLE_CONTROL);
                    bool __result = Kernel32.ReadConsole(hConsoleInputLocal, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsReadLocal, pInputControl.HasValue ? &pInputControlLocal : null);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleInputAddRef)
                    hConsoleInput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "ReadConsoleW")]
        internal static extern unsafe bool ReadConsole(win32.System.SystemServices.HANDLE hConsoleInput, void *lpBuffer, uint nNumberOfCharsToRead, uint *lpNumberOfCharsRead, [Optional] win32.System.Console.CONSOLE_READCONSOLE_CONTROL*pInputControl);
        /// <inheritdoc cref = "WriteConsole(win32.System.SystemServices.HANDLE, void *, uint, uint *, void *)"/>
        internal static unsafe bool WriteConsole(SafeHandle hConsoleOutput, void *lpBuffer, uint nNumberOfCharsToWrite, uint *lpNumberOfCharsWritten, void *lpReserved)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                if (hConsoleOutput is object)
                {
                    hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                    hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                }
                else
                    hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.WriteConsole(hConsoleOutputLocal, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
                return __result;
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "WriteConsoleW")]
        internal static extern unsafe bool WriteConsole(win32.System.SystemServices.HANDLE hConsoleOutput, void *lpBuffer, uint nNumberOfCharsToWrite, [Optional] uint *lpNumberOfCharsWritten, void *lpReserved);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetConsoleCtrlHandler(delegate *unmanaged[Stdcall]<uint, win32.System.SystemServices.BOOL>HandlerRoutine, bool Add);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void ClosePseudoConsole(win32.System.SystemServices.HPCON hPC);
        /// <inheritdoc cref = "CreatePseudoConsole(win32.System.Console.COORD, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, uint, win32.System.SystemServices.HPCON*)"/>
        internal static unsafe win32.System.Com.HRESULT CreatePseudoConsole(win32.System.Console.COORD size, SafeHandle hInput, SafeHandle hOutput, uint dwFlags, out Kernel32.ClosePseudoConsoleSafeHandle phPC)
        {
            bool hInputAddRef = false;
            bool hOutputAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hInputLocal;
                if (hInput is object)
                {
                    hInput.DangerousAddRef(ref hInputAddRef);
                    hInputLocal = (win32.System.SystemServices.HANDLE)hInput.DangerousGetHandle();
                }
                else
                    hInputLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE hOutputLocal;
                if (hOutput is object)
                {
                    hOutput.DangerousAddRef(ref hOutputAddRef);
                    hOutputLocal = (win32.System.SystemServices.HANDLE)hOutput.DangerousGetHandle();
                }
                else
                    hOutputLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HPCON phPCLocal;
                win32.System.Com.HRESULT __result = Kernel32.CreatePseudoConsole(size, hInputLocal, hOutputLocal, dwFlags, &phPCLocal);
                phPC = new Kernel32.ClosePseudoConsoleSafeHandle(phPCLocal, ownsHandle: true);
                return __result;
            }
            finally
            {
                if (hInputAddRef)
                    hInput.DangerousRelease();
                if (hOutputAddRef)
                    hOutput.DangerousRelease();
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "Kernel32.ClosePseudoConsole"/>.
        /// </summary>
        internal class ClosePseudoConsoleSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal ClosePseudoConsoleSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal ClosePseudoConsoleSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle()
            {
                Kernel32.ClosePseudoConsole((win32.System.SystemServices.HPCON)this.handle);
                return true;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT CreatePseudoConsole(win32.System.Console.COORD size, win32.System.SystemServices.HANDLE hInput, win32.System.SystemServices.HANDLE hOutput, uint dwFlags, win32.System.SystemServices.HPCON*phPC);
        /// <inheritdoc cref = "ResizePseudoConsole(win32.System.SystemServices.HPCON, win32.System.Console.COORD)"/>
        internal static unsafe win32.System.Com.HRESULT ResizePseudoConsole(SafeHandle hPC, win32.System.Console.COORD size)
        {
            bool hPCAddRef = false;
            try
            {
                win32.System.SystemServices.HPCON hPCLocal;
                if (hPC is object)
                {
                    hPC.DangerousAddRef(ref hPCAddRef);
                    hPCLocal = (win32.System.SystemServices.HPCON)hPC.DangerousGetHandle();
                }
                else
                    hPCLocal = default(win32.System.SystemServices.HPCON);
                win32.System.Com.HRESULT __result = Kernel32.ResizePseudoConsole(hPCLocal, size);
                return __result;
            }
            finally
            {
                if (hPCAddRef)
                    hPC.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT ResizePseudoConsole(win32.System.SystemServices.HPCON hPC, win32.System.Console.COORD size);
        /// <inheritdoc cref = "FillConsoleOutputCharacter(win32.System.SystemServices.HANDLE, char, uint, win32.System.Console.COORD, uint *)"/>
        internal static unsafe bool FillConsoleOutputCharacter(SafeHandle hConsoleOutput, char cCharacter, uint nLength, win32.System.Console.COORD dwWriteCoord, out uint lpNumberOfCharsWritten)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (uint *lpNumberOfCharsWrittenLocal = &lpNumberOfCharsWritten)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.FillConsoleOutputCharacter(hConsoleOutputLocal, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWrittenLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FillConsoleOutputCharacterW")]
        internal static extern unsafe bool FillConsoleOutputCharacter(win32.System.SystemServices.HANDLE hConsoleOutput, char cCharacter, uint nLength, win32.System.Console.COORD dwWriteCoord, uint *lpNumberOfCharsWritten);
        /// <inheritdoc cref = "FillConsoleOutputAttribute(win32.System.SystemServices.HANDLE, ushort, uint, win32.System.Console.COORD, uint *)"/>
        internal static unsafe bool FillConsoleOutputAttribute(SafeHandle hConsoleOutput, ushort wAttribute, uint nLength, win32.System.Console.COORD dwWriteCoord, out uint lpNumberOfAttrsWritten)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (uint *lpNumberOfAttrsWrittenLocal = &lpNumberOfAttrsWritten)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.FillConsoleOutputAttribute(hConsoleOutputLocal, wAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWrittenLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool FillConsoleOutputAttribute(win32.System.SystemServices.HANDLE hConsoleOutput, ushort wAttribute, uint nLength, win32.System.Console.COORD dwWriteCoord, uint *lpNumberOfAttrsWritten);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool GenerateConsoleCtrlEvent(uint dwCtrlEvent, uint dwProcessGroupId);
        /// <inheritdoc cref = "CreateConsoleScreenBuffer(uint, uint, win32.System.SystemServices.SECURITY_ATTRIBUTES*, uint, void *)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateConsoleScreenBuffer(uint dwDesiredAccess, uint dwShareMode, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpSecurityAttributes, uint dwFlags, void *lpScreenBufferData)
        {
            win32.System.SystemServices.SECURITY_ATTRIBUTES lpSecurityAttributesLocal = lpSecurityAttributes.HasValue ? lpSecurityAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
            win32.System.SystemServices.HANDLE __result = Kernel32.CreateConsoleScreenBuffer(dwDesiredAccess, dwShareMode, lpSecurityAttributes.HasValue ? &lpSecurityAttributesLocal : null, dwFlags, lpScreenBufferData);
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateConsoleScreenBuffer(uint dwDesiredAccess, uint dwShareMode, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributes, uint dwFlags, void *lpScreenBufferData);
        /// <inheritdoc cref = "SetConsoleActiveScreenBuffer(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool SetConsoleActiveScreenBuffer(SafeHandle hConsoleOutput)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                if (hConsoleOutput is object)
                {
                    hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                    hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                }
                else
                    hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetConsoleActiveScreenBuffer(hConsoleOutputLocal);
                return __result;
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SetConsoleActiveScreenBuffer(win32.System.SystemServices.HANDLE hConsoleOutput);
        /// <inheritdoc cref = "FlushConsoleInputBuffer(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool FlushConsoleInputBuffer(SafeHandle hConsoleInput)
        {
            bool hConsoleInputAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hConsoleInputLocal;
                if (hConsoleInput is object)
                {
                    hConsoleInput.DangerousAddRef(ref hConsoleInputAddRef);
                    hConsoleInputLocal = (win32.System.SystemServices.HANDLE)hConsoleInput.DangerousGetHandle();
                }
                else
                    hConsoleInputLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.FlushConsoleInputBuffer(hConsoleInputLocal);
                return __result;
            }
            finally
            {
                if (hConsoleInputAddRef)
                    hConsoleInput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool FlushConsoleInputBuffer(win32.System.SystemServices.HANDLE hConsoleInput);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SetConsoleCP(uint wCodePageID);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SetConsoleOutputCP(uint wCodePageID);
        /// <inheritdoc cref = "GetConsoleCursorInfo(win32.System.SystemServices.HANDLE, win32.System.Console.CONSOLE_CURSOR_INFO*)"/>
        internal static unsafe bool GetConsoleCursorInfo(SafeHandle hConsoleOutput, out win32.System.Console.CONSOLE_CURSOR_INFO lpConsoleCursorInfo)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.CONSOLE_CURSOR_INFO*lpConsoleCursorInfoLocal = &lpConsoleCursorInfo)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetConsoleCursorInfo(hConsoleOutputLocal, lpConsoleCursorInfoLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetConsoleCursorInfo(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.Console.CONSOLE_CURSOR_INFO*lpConsoleCursorInfo);
        /// <inheritdoc cref = "SetConsoleCursorInfo(win32.System.SystemServices.HANDLE, win32.System.Console.CONSOLE_CURSOR_INFO*)"/>
        internal static unsafe bool SetConsoleCursorInfo(SafeHandle hConsoleOutput, in win32.System.Console.CONSOLE_CURSOR_INFO lpConsoleCursorInfo)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.CONSOLE_CURSOR_INFO*lpConsoleCursorInfoLocal = &lpConsoleCursorInfo)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetConsoleCursorInfo(hConsoleOutputLocal, lpConsoleCursorInfoLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetConsoleCursorInfo(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.Console.CONSOLE_CURSOR_INFO*lpConsoleCursorInfo);
        /// <inheritdoc cref = "GetConsoleScreenBufferInfo(win32.System.SystemServices.HANDLE, win32.System.Console.CONSOLE_SCREEN_BUFFER_INFO*)"/>
        internal static unsafe bool GetConsoleScreenBufferInfo(SafeHandle hConsoleOutput, out win32.System.Console.CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.CONSOLE_SCREEN_BUFFER_INFO*lpConsoleScreenBufferInfoLocal = &lpConsoleScreenBufferInfo)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetConsoleScreenBufferInfo(hConsoleOutputLocal, lpConsoleScreenBufferInfoLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetConsoleScreenBufferInfo(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.Console.CONSOLE_SCREEN_BUFFER_INFO*lpConsoleScreenBufferInfo);
        /// <inheritdoc cref = "GetConsoleScreenBufferInfoEx(win32.System.SystemServices.HANDLE, win32.System.Console.CONSOLE_SCREEN_BUFFER_INFOEX*)"/>
        internal static unsafe bool GetConsoleScreenBufferInfoEx(SafeHandle hConsoleOutput, ref win32.System.Console.CONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.CONSOLE_SCREEN_BUFFER_INFOEX*lpConsoleScreenBufferInfoExLocal = &lpConsoleScreenBufferInfoEx)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetConsoleScreenBufferInfoEx(hConsoleOutputLocal, lpConsoleScreenBufferInfoExLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetConsoleScreenBufferInfoEx(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.Console.CONSOLE_SCREEN_BUFFER_INFOEX*lpConsoleScreenBufferInfoEx);
        /// <inheritdoc cref = "SetConsoleScreenBufferInfoEx(win32.System.SystemServices.HANDLE, win32.System.Console.CONSOLE_SCREEN_BUFFER_INFOEX*)"/>
        internal static unsafe bool SetConsoleScreenBufferInfoEx(SafeHandle hConsoleOutput, in win32.System.Console.CONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.CONSOLE_SCREEN_BUFFER_INFOEX*lpConsoleScreenBufferInfoExLocal = &lpConsoleScreenBufferInfoEx)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetConsoleScreenBufferInfoEx(hConsoleOutputLocal, lpConsoleScreenBufferInfoExLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetConsoleScreenBufferInfoEx(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.Console.CONSOLE_SCREEN_BUFFER_INFOEX*lpConsoleScreenBufferInfoEx);
        /// <inheritdoc cref = "SetConsoleScreenBufferSize(win32.System.SystemServices.HANDLE, win32.System.Console.COORD)"/>
        internal static unsafe bool SetConsoleScreenBufferSize(SafeHandle hConsoleOutput, win32.System.Console.COORD dwSize)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                if (hConsoleOutput is object)
                {
                    hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                    hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                }
                else
                    hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetConsoleScreenBufferSize(hConsoleOutputLocal, dwSize);
                return __result;
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SetConsoleScreenBufferSize(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.Console.COORD dwSize);
        /// <inheritdoc cref = "SetConsoleCursorPosition(win32.System.SystemServices.HANDLE, win32.System.Console.COORD)"/>
        internal static unsafe bool SetConsoleCursorPosition(SafeHandle hConsoleOutput, win32.System.Console.COORD dwCursorPosition)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                if (hConsoleOutput is object)
                {
                    hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                    hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                }
                else
                    hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetConsoleCursorPosition(hConsoleOutputLocal, dwCursorPosition);
                return __result;
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SetConsoleCursorPosition(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.Console.COORD dwCursorPosition);
        /// <inheritdoc cref = "GetLargestConsoleWindowSize(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe win32.System.Console.COORD GetLargestConsoleWindowSize(SafeHandle hConsoleOutput)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                if (hConsoleOutput is object)
                {
                    hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                    hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                }
                else
                    hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.Console.COORD __result = Kernel32.GetLargestConsoleWindowSize(hConsoleOutputLocal);
                return __result;
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Console.COORD GetLargestConsoleWindowSize(win32.System.SystemServices.HANDLE hConsoleOutput);
        /// <inheritdoc cref = "SetConsoleTextAttribute(win32.System.SystemServices.HANDLE, ushort)"/>
        internal static unsafe bool SetConsoleTextAttribute(SafeHandle hConsoleOutput, ushort wAttributes)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                if (hConsoleOutput is object)
                {
                    hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                    hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                }
                else
                    hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetConsoleTextAttribute(hConsoleOutputLocal, wAttributes);
                return __result;
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SetConsoleTextAttribute(win32.System.SystemServices.HANDLE hConsoleOutput, ushort wAttributes);
        /// <inheritdoc cref = "SetConsoleWindowInfo(win32.System.SystemServices.HANDLE, bool, win32.System.Console.SMALL_RECT*)"/>
        internal static unsafe bool SetConsoleWindowInfo(SafeHandle hConsoleOutput, bool bAbsolute, in win32.System.Console.SMALL_RECT lpConsoleWindow)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.SMALL_RECT*lpConsoleWindowLocal = &lpConsoleWindow)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetConsoleWindowInfo(hConsoleOutputLocal, bAbsolute, lpConsoleWindowLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetConsoleWindowInfo(win32.System.SystemServices.HANDLE hConsoleOutput, bool bAbsolute, win32.System.Console.SMALL_RECT*lpConsoleWindow);
        /// <inheritdoc cref = "WriteConsoleOutputCharacter(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PCWSTR, uint, win32.System.Console.COORD, uint *)"/>
        internal static unsafe bool WriteConsoleOutputCharacter(SafeHandle hConsoleOutput, string lpCharacter, uint nLength, win32.System.Console.COORD dwWriteCoord, out uint lpNumberOfCharsWritten)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (uint *lpNumberOfCharsWrittenLocal = &lpNumberOfCharsWritten)
                {
                    fixed (char *lpCharacterLocal = lpCharacter)
                    {
                        win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                        if (hConsoleOutput is object)
                        {
                            hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                            hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                        }
                        else
                            hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.WriteConsoleOutputCharacter(hConsoleOutputLocal, lpCharacterLocal, nLength, dwWriteCoord, lpNumberOfCharsWrittenLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "WriteConsoleOutputCharacterW")]
        internal static extern unsafe bool WriteConsoleOutputCharacter(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.SystemServices.PCWSTR lpCharacter, uint nLength, win32.System.Console.COORD dwWriteCoord, uint *lpNumberOfCharsWritten);
        /// <inheritdoc cref = "WriteConsoleOutputAttribute(win32.System.SystemServices.HANDLE, ushort *, uint, win32.System.Console.COORD, uint *)"/>
        internal static unsafe bool WriteConsoleOutputAttribute(SafeHandle hConsoleOutput, ReadOnlySpan<ushort> lpAttribute, win32.System.Console.COORD dwWriteCoord, out uint lpNumberOfAttrsWritten)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (uint *lpNumberOfAttrsWrittenLocal = &lpNumberOfAttrsWritten)
                {
                    fixed (ushort *lpAttributeLocal = lpAttribute)
                    {
                        win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                        if (hConsoleOutput is object)
                        {
                            hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                            hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                        }
                        else
                            hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.WriteConsoleOutputAttribute(hConsoleOutputLocal, lpAttributeLocal, (uint)lpAttribute.Length, dwWriteCoord, lpNumberOfAttrsWrittenLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool WriteConsoleOutputAttribute(win32.System.SystemServices.HANDLE hConsoleOutput, ushort *lpAttribute, uint nLength, win32.System.Console.COORD dwWriteCoord, uint *lpNumberOfAttrsWritten);
        /// <inheritdoc cref = "ReadConsoleOutputCharacter(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PWSTR, uint, win32.System.Console.COORD, uint *)"/>
        internal static unsafe bool ReadConsoleOutputCharacter(SafeHandle hConsoleOutput, win32.System.SystemServices.PWSTR lpCharacter, uint nLength, win32.System.Console.COORD dwReadCoord, out uint lpNumberOfCharsRead)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (uint *lpNumberOfCharsReadLocal = &lpNumberOfCharsRead)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.ReadConsoleOutputCharacter(hConsoleOutputLocal, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsReadLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "ReadConsoleOutputCharacterW")]
        internal static extern unsafe bool ReadConsoleOutputCharacter(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.SystemServices.PWSTR lpCharacter, uint nLength, win32.System.Console.COORD dwReadCoord, uint *lpNumberOfCharsRead);
        /// <inheritdoc cref = "ReadConsoleOutputAttribute(win32.System.SystemServices.HANDLE, ushort *, uint, win32.System.Console.COORD, uint *)"/>
        internal static unsafe bool ReadConsoleOutputAttribute(SafeHandle hConsoleOutput, Span<ushort> lpAttribute, win32.System.Console.COORD dwReadCoord, out uint lpNumberOfAttrsRead)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (uint *lpNumberOfAttrsReadLocal = &lpNumberOfAttrsRead)
                {
                    fixed (ushort *lpAttributeLocal = lpAttribute)
                    {
                        win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                        if (hConsoleOutput is object)
                        {
                            hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                            hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                        }
                        else
                            hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.ReadConsoleOutputAttribute(hConsoleOutputLocal, lpAttributeLocal, (uint)lpAttribute.Length, dwReadCoord, lpNumberOfAttrsReadLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool ReadConsoleOutputAttribute(win32.System.SystemServices.HANDLE hConsoleOutput, ushort *lpAttribute, uint nLength, win32.System.Console.COORD dwReadCoord, uint *lpNumberOfAttrsRead);
        /// <inheritdoc cref = "WriteConsoleInput(win32.System.SystemServices.HANDLE, win32.System.Console.INPUT_RECORD*, uint, uint *)"/>
        internal static unsafe bool WriteConsoleInput(SafeHandle hConsoleInput, ReadOnlySpan<win32.System.Console.INPUT_RECORD> lpBuffer, out uint lpNumberOfEventsWritten)
        {
            bool hConsoleInputAddRef = false;
            try
            {
                fixed (uint *lpNumberOfEventsWrittenLocal = &lpNumberOfEventsWritten)
                {
                    fixed (win32.System.Console.INPUT_RECORD*lpBufferLocal = lpBuffer)
                    {
                        win32.System.SystemServices.HANDLE hConsoleInputLocal;
                        if (hConsoleInput is object)
                        {
                            hConsoleInput.DangerousAddRef(ref hConsoleInputAddRef);
                            hConsoleInputLocal = (win32.System.SystemServices.HANDLE)hConsoleInput.DangerousGetHandle();
                        }
                        else
                            hConsoleInputLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.WriteConsoleInput(hConsoleInputLocal, lpBufferLocal, (uint)lpBuffer.Length, lpNumberOfEventsWrittenLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hConsoleInputAddRef)
                    hConsoleInput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "WriteConsoleInputW")]
        internal static extern unsafe bool WriteConsoleInput(win32.System.SystemServices.HANDLE hConsoleInput, win32.System.Console.INPUT_RECORD*lpBuffer, uint nLength, uint *lpNumberOfEventsWritten);
        /// <inheritdoc cref = "ScrollConsoleScreenBuffer(win32.System.SystemServices.HANDLE, win32.System.Console.SMALL_RECT*, win32.System.Console.SMALL_RECT*, win32.System.Console.COORD, win32.System.Console.CHAR_INFO*)"/>
        internal static unsafe bool ScrollConsoleScreenBuffer(SafeHandle hConsoleOutput, in win32.System.Console.SMALL_RECT lpScrollRectangle, win32.System.Console.SMALL_RECT? lpClipRectangle, win32.System.Console.COORD dwDestinationOrigin, in win32.System.Console.CHAR_INFO lpFill)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.CHAR_INFO*lpFillLocal = &lpFill)
                {
                    fixed (win32.System.Console.SMALL_RECT*lpScrollRectangleLocal = &lpScrollRectangle)
                    {
                        win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                        if (hConsoleOutput is object)
                        {
                            hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                            hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                        }
                        else
                            hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                        win32.System.Console.SMALL_RECT lpClipRectangleLocal = lpClipRectangle.HasValue ? lpClipRectangle.Value : default(win32.System.Console.SMALL_RECT);
                        bool __result = Kernel32.ScrollConsoleScreenBuffer(hConsoleOutputLocal, lpScrollRectangleLocal, lpClipRectangle.HasValue ? &lpClipRectangleLocal : null, dwDestinationOrigin, lpFillLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "ScrollConsoleScreenBufferW")]
        internal static extern unsafe bool ScrollConsoleScreenBuffer(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.Console.SMALL_RECT*lpScrollRectangle, [Optional] win32.System.Console.SMALL_RECT*lpClipRectangle, win32.System.Console.COORD dwDestinationOrigin, win32.System.Console.CHAR_INFO*lpFill);
        /// <inheritdoc cref = "WriteConsoleOutput(win32.System.SystemServices.HANDLE, win32.System.Console.CHAR_INFO*, win32.System.Console.COORD, win32.System.Console.COORD, win32.System.Console.SMALL_RECT*)"/>
        internal static unsafe bool WriteConsoleOutput(SafeHandle hConsoleOutput, in win32.System.Console.CHAR_INFO lpBuffer, win32.System.Console.COORD dwBufferSize, win32.System.Console.COORD dwBufferCoord, ref win32.System.Console.SMALL_RECT lpWriteRegion)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.SMALL_RECT*lpWriteRegionLocal = &lpWriteRegion)
                {
                    fixed (win32.System.Console.CHAR_INFO*lpBufferLocal = &lpBuffer)
                    {
                        win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                        if (hConsoleOutput is object)
                        {
                            hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                            hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                        }
                        else
                            hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.WriteConsoleOutput(hConsoleOutputLocal, lpBufferLocal, dwBufferSize, dwBufferCoord, lpWriteRegionLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "WriteConsoleOutputW")]
        internal static extern unsafe bool WriteConsoleOutput(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.Console.CHAR_INFO*lpBuffer, win32.System.Console.COORD dwBufferSize, win32.System.Console.COORD dwBufferCoord, win32.System.Console.SMALL_RECT*lpWriteRegion);
        /// <inheritdoc cref = "ReadConsoleOutput(win32.System.SystemServices.HANDLE, win32.System.Console.CHAR_INFO*, win32.System.Console.COORD, win32.System.Console.COORD, win32.System.Console.SMALL_RECT*)"/>
        internal static unsafe bool ReadConsoleOutput(SafeHandle hConsoleOutput, out win32.System.Console.CHAR_INFO lpBuffer, win32.System.Console.COORD dwBufferSize, win32.System.Console.COORD dwBufferCoord, ref win32.System.Console.SMALL_RECT lpReadRegion)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.SMALL_RECT*lpReadRegionLocal = &lpReadRegion)
                {
                    fixed (win32.System.Console.CHAR_INFO*lpBufferLocal = &lpBuffer)
                    {
                        win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                        if (hConsoleOutput is object)
                        {
                            hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                            hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                        }
                        else
                            hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.ReadConsoleOutput(hConsoleOutputLocal, lpBufferLocal, dwBufferSize, dwBufferCoord, lpReadRegionLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "ReadConsoleOutputW")]
        internal static extern unsafe bool ReadConsoleOutput(win32.System.SystemServices.HANDLE hConsoleOutput, win32.System.Console.CHAR_INFO*lpBuffer, win32.System.Console.COORD dwBufferSize, win32.System.Console.COORD dwBufferCoord, win32.System.Console.SMALL_RECT*lpReadRegion);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetConsoleTitleW")]
        internal static extern uint GetConsoleTitle(win32.System.SystemServices.PWSTR lpConsoleTitle, uint nSize);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetConsoleOriginalTitleW")]
        internal static extern uint GetConsoleOriginalTitle(win32.System.SystemServices.PWSTR lpConsoleTitle, uint nSize);
        /// <inheritdoc cref = "SetConsoleTitle(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetConsoleTitle(string lpConsoleTitle)
        {
            fixed (char *lpConsoleTitleLocal = lpConsoleTitle)
            {
                bool __result = Kernel32.SetConsoleTitle(lpConsoleTitleLocal);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetConsoleTitleW")]
        internal static extern bool SetConsoleTitle(win32.System.SystemServices.PCWSTR lpConsoleTitle);
        /// <inheritdoc cref = "GetNumberOfConsoleMouseButtons(uint *)"/>
        internal static unsafe bool GetNumberOfConsoleMouseButtons(out uint lpNumberOfMouseButtons)
        {
            fixed (uint *lpNumberOfMouseButtonsLocal = &lpNumberOfMouseButtons)
            {
                bool __result = Kernel32.GetNumberOfConsoleMouseButtons(lpNumberOfMouseButtonsLocal);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetNumberOfConsoleMouseButtons(uint *lpNumberOfMouseButtons);
        /// <inheritdoc cref = "GetConsoleFontSize(win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe win32.System.Console.COORD GetConsoleFontSize(SafeHandle hConsoleOutput, uint nFont)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                if (hConsoleOutput is object)
                {
                    hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                    hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                }
                else
                    hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.Console.COORD __result = Kernel32.GetConsoleFontSize(hConsoleOutputLocal, nFont);
                return __result;
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Console.COORD GetConsoleFontSize(win32.System.SystemServices.HANDLE hConsoleOutput, uint nFont);
        /// <inheritdoc cref = "GetCurrentConsoleFont(win32.System.SystemServices.HANDLE, bool, win32.System.Console.CONSOLE_FONT_INFO*)"/>
        internal static unsafe bool GetCurrentConsoleFont(SafeHandle hConsoleOutput, bool bMaximumWindow, out win32.System.Console.CONSOLE_FONT_INFO lpConsoleCurrentFont)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.CONSOLE_FONT_INFO*lpConsoleCurrentFontLocal = &lpConsoleCurrentFont)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetCurrentConsoleFont(hConsoleOutputLocal, bMaximumWindow, lpConsoleCurrentFontLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetCurrentConsoleFont(win32.System.SystemServices.HANDLE hConsoleOutput, bool bMaximumWindow, win32.System.Console.CONSOLE_FONT_INFO*lpConsoleCurrentFont);
        /// <inheritdoc cref = "GetCurrentConsoleFontEx(win32.System.SystemServices.HANDLE, bool, win32.System.Console.CONSOLE_FONT_INFOEX*)"/>
        internal static unsafe bool GetCurrentConsoleFontEx(SafeHandle hConsoleOutput, bool bMaximumWindow, out win32.System.Console.CONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.CONSOLE_FONT_INFOEX*lpConsoleCurrentFontExLocal = &lpConsoleCurrentFontEx)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetCurrentConsoleFontEx(hConsoleOutputLocal, bMaximumWindow, lpConsoleCurrentFontExLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetCurrentConsoleFontEx(win32.System.SystemServices.HANDLE hConsoleOutput, bool bMaximumWindow, win32.System.Console.CONSOLE_FONT_INFOEX*lpConsoleCurrentFontEx);
        /// <inheritdoc cref = "SetCurrentConsoleFontEx(win32.System.SystemServices.HANDLE, bool, win32.System.Console.CONSOLE_FONT_INFOEX*)"/>
        internal static unsafe bool SetCurrentConsoleFontEx(SafeHandle hConsoleOutput, bool bMaximumWindow, in win32.System.Console.CONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                fixed (win32.System.Console.CONSOLE_FONT_INFOEX*lpConsoleCurrentFontExLocal = &lpConsoleCurrentFontEx)
                {
                    win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                    if (hConsoleOutput is object)
                    {
                        hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                        hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                    }
                    else
                        hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetCurrentConsoleFontEx(hConsoleOutputLocal, bMaximumWindow, lpConsoleCurrentFontExLocal);
                    return __result;
                }
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetCurrentConsoleFontEx(win32.System.SystemServices.HANDLE hConsoleOutput, bool bMaximumWindow, win32.System.Console.CONSOLE_FONT_INFOEX*lpConsoleCurrentFontEx);
        /// <inheritdoc cref = "GetConsoleSelectionInfo(win32.System.Console.CONSOLE_SELECTION_INFO*)"/>
        internal static unsafe bool GetConsoleSelectionInfo(out win32.System.Console.CONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
        {
            fixed (win32.System.Console.CONSOLE_SELECTION_INFO*lpConsoleSelectionInfoLocal = &lpConsoleSelectionInfo)
            {
                bool __result = Kernel32.GetConsoleSelectionInfo(lpConsoleSelectionInfoLocal);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetConsoleSelectionInfo(win32.System.Console.CONSOLE_SELECTION_INFO*lpConsoleSelectionInfo);
        /// <inheritdoc cref = "GetConsoleHistoryInfo(win32.System.Console.CONSOLE_HISTORY_INFO*)"/>
        internal static unsafe bool GetConsoleHistoryInfo(out win32.System.Console.CONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
        {
            fixed (win32.System.Console.CONSOLE_HISTORY_INFO*lpConsoleHistoryInfoLocal = &lpConsoleHistoryInfo)
            {
                bool __result = Kernel32.GetConsoleHistoryInfo(lpConsoleHistoryInfoLocal);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetConsoleHistoryInfo(win32.System.Console.CONSOLE_HISTORY_INFO*lpConsoleHistoryInfo);
        /// <inheritdoc cref = "SetConsoleHistoryInfo(win32.System.Console.CONSOLE_HISTORY_INFO*)"/>
        internal static unsafe bool SetConsoleHistoryInfo(in win32.System.Console.CONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
        {
            fixed (win32.System.Console.CONSOLE_HISTORY_INFO*lpConsoleHistoryInfoLocal = &lpConsoleHistoryInfo)
            {
                bool __result = Kernel32.SetConsoleHistoryInfo(lpConsoleHistoryInfoLocal);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetConsoleHistoryInfo(win32.System.Console.CONSOLE_HISTORY_INFO*lpConsoleHistoryInfo);
        /// <inheritdoc cref = "GetConsoleDisplayMode(uint *)"/>
        internal static unsafe bool GetConsoleDisplayMode(out uint lpModeFlags)
        {
            fixed (uint *lpModeFlagsLocal = &lpModeFlags)
            {
                bool __result = Kernel32.GetConsoleDisplayMode(lpModeFlagsLocal);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetConsoleDisplayMode(uint *lpModeFlags);
        /// <inheritdoc cref = "SetConsoleDisplayMode(win32.System.SystemServices.HANDLE, uint, win32.System.Console.COORD*)"/>
        internal static unsafe bool SetConsoleDisplayMode(SafeHandle hConsoleOutput, uint dwFlags, win32.System.Console.COORD*lpNewScreenBufferDimensions)
        {
            bool hConsoleOutputAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hConsoleOutputLocal;
                if (hConsoleOutput is object)
                {
                    hConsoleOutput.DangerousAddRef(ref hConsoleOutputAddRef);
                    hConsoleOutputLocal = (win32.System.SystemServices.HANDLE)hConsoleOutput.DangerousGetHandle();
                }
                else
                    hConsoleOutputLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetConsoleDisplayMode(hConsoleOutputLocal, dwFlags, lpNewScreenBufferDimensions);
                return __result;
            }
            finally
            {
                if (hConsoleOutputAddRef)
                    hConsoleOutput.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetConsoleDisplayMode(win32.System.SystemServices.HANDLE hConsoleOutput, uint dwFlags, [Optional] win32.System.Console.COORD*lpNewScreenBufferDimensions);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.UI.WindowsAndMessaging.HWND GetConsoleWindow();
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "AddConsoleAliasW")]
        internal static extern bool AddConsoleAlias(win32.System.SystemServices.PWSTR Source, win32.System.SystemServices.PWSTR Target, win32.System.SystemServices.PWSTR ExeName);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetConsoleAliasW")]
        internal static extern uint GetConsoleAlias(win32.System.SystemServices.PWSTR Source, win32.System.SystemServices.PWSTR TargetBuffer, uint TargetBufferLength, win32.System.SystemServices.PWSTR ExeName);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetConsoleAliasesLengthW")]
        internal static extern uint GetConsoleAliasesLength(win32.System.SystemServices.PWSTR ExeName);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetConsoleAliasExesLengthW")]
        internal static extern uint GetConsoleAliasExesLength();
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetConsoleAliasesW")]
        internal static extern uint GetConsoleAliases(win32.System.SystemServices.PWSTR AliasBuffer, uint AliasBufferLength, win32.System.SystemServices.PWSTR ExeName);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetConsoleAliasExesW")]
        internal static extern uint GetConsoleAliasExes(win32.System.SystemServices.PWSTR ExeNameBuffer, uint ExeNameBufferLength);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "ExpungeConsoleCommandHistoryW")]
        internal static extern void ExpungeConsoleCommandHistory(win32.System.SystemServices.PWSTR ExeName);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetConsoleNumberOfCommandsW")]
        internal static extern bool SetConsoleNumberOfCommands(uint Number, win32.System.SystemServices.PWSTR ExeName);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetConsoleCommandHistoryLengthW")]
        internal static extern uint GetConsoleCommandHistoryLength(win32.System.SystemServices.PWSTR ExeName);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetConsoleCommandHistoryW")]
        internal static extern uint GetConsoleCommandHistory(win32.System.SystemServices.PWSTR Commands, uint CommandBufferLength, win32.System.SystemServices.PWSTR ExeName);
        /// <inheritdoc cref = "GetConsoleProcessList(uint *, uint)"/>
        internal static unsafe uint GetConsoleProcessList(Span<uint> lpdwProcessList)
        {
            fixed (uint *lpdwProcessListLocal = lpdwProcessList)
            {
                uint __result = Kernel32.GetConsoleProcessList(lpdwProcessListLocal, (uint)lpdwProcessList.Length);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint GetConsoleProcessList(uint *lpdwProcessList, uint dwProcessCount);
        /// <inheritdoc cref = "IsProcessInJob(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, bool *)"/>
        internal static unsafe bool IsProcessInJob(SafeHandle ProcessHandle, SafeHandle JobHandle, out bool Result)
        {
            bool ProcessHandleAddRef = false;
            bool JobHandleAddRef = false;
            try
            {
                fixed (bool *ResultLocal = &Result)
                {
                    win32.System.SystemServices.HANDLE ProcessHandleLocal;
                    if (ProcessHandle is object)
                    {
                        ProcessHandle.DangerousAddRef(ref ProcessHandleAddRef);
                        ProcessHandleLocal = (win32.System.SystemServices.HANDLE)ProcessHandle.DangerousGetHandle();
                    }
                    else
                        ProcessHandleLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.HANDLE JobHandleLocal;
                    if (JobHandle is object)
                    {
                        JobHandle.DangerousAddRef(ref JobHandleAddRef);
                        JobHandleLocal = (win32.System.SystemServices.HANDLE)JobHandle.DangerousGetHandle();
                    }
                    else
                        JobHandleLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.IsProcessInJob(ProcessHandleLocal, JobHandleLocal, ResultLocal);
                    return __result;
                }
            }
            finally
            {
                if (ProcessHandleAddRef)
                    ProcessHandle.DangerousRelease();
                if (JobHandleAddRef)
                    JobHandle.DangerousRelease();
            }
        }

        /// <summary>Determines whether the process is running in the specified job.</summary>
        /// <param name = "ProcessHandle">
        /// <para>A handle to the process to be tested. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the PROCESS_QUERY_INFORMATION access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi/nf-jobapi-isprocessinjob#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "JobHandle">
        /// <para>A handle to the job. If this parameter is NULL, the function tests if the process is running under any job.</para>
        /// <para>If this parameter is not NULL, the handle must have the JOB_OBJECT_QUERY access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/job-object-security-and-access-rights">Job Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi/nf-jobapi-isprocessinjob#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Result">A pointer to a value that receives TRUE if the process is running in the job, and FALSE otherwise.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi/nf-jobapi-isprocessinjob">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool IsProcessInJob(win32.System.SystemServices.HANDLE ProcessHandle, win32.System.SystemServices.HANDLE JobHandle, bool *Result);
        /// <inheritdoc cref = "CreateJobObject(win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateJobObject(win32.System.SystemServices.SECURITY_ATTRIBUTES? lpJobAttributes, string lpName)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpJobAttributesLocal = lpJobAttributes.HasValue ? lpJobAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateJobObject(lpJobAttributes.HasValue ? &lpJobAttributesLocal : null, lpNameLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates or opens a job object.</summary>
        /// <param name = "lpJobAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security descriptor for the job object and determines whether child processes can inherit the returned handle. If <i>lpJobAttributes</i> is <b>NULL</b>, the job object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a job object come from the primary or impersonation token of the creator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-createjobobjectw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>The name of the job. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case-sensitive.</para>
        /// <para>If <i>lpName</i> is <b>NULL</b>, the job is created without a name.</para>
        /// <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
        /// <para>The object can be created in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><b>Terminal Services:  </b>The name can have a "Global\\" or "Local\\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-createjobobjectw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the job object. The handle has the <b>JOB_OBJECT_ALL_ACCESS</b> access right. If the object existed before the function call, the function returns a handle to the existing job object and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-createjobobjectw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateJobObjectW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateJobObject([Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpJobAttributes, win32.System.SystemServices.PCWSTR lpName);
        /// <summary>Frees memory that a function related to job objects allocated. Functions related to job objects that allocate memory include QueryIoRateControlInformationJobObject.</summary>
        /// <param name = "Buffer">A pointer to the buffer of allocated memory that you want to free.</param>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-freememoryjobobject">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void FreeMemoryJobObject(void *Buffer);
        /// <inheritdoc cref = "OpenJobObject(uint, bool, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle OpenJobObject(uint dwDesiredAccess, bool bInheritHandle, string lpName)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.HANDLE __result = Kernel32.OpenJobObject(dwDesiredAccess, bInheritHandle, lpNameLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Opens an existing job object.</summary>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the job object. This parameter can be one or more of the <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/job-object-security-and-access-rights">job object access rights</a>. This access right is checked against any security descriptor for the object.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-openjobobjectw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInheritHandle">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name = "lpName">
        /// <para>The name of the job to be opened. Name comparisons are case sensitive.</para>
        /// <para>This function can open objects in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><b>Terminal Services:  </b>The name can have a "Global\\" or "Local\\" prefix to explicitly open the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-openjobobjectw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the job. The handle provides the requested access to the job.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-openjobobjectw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "OpenJobObjectW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE OpenJobObject(uint dwDesiredAccess, bool bInheritHandle, win32.System.SystemServices.PCWSTR lpName);
        /// <inheritdoc cref = "AssignProcessToJobObject(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool AssignProcessToJobObject(SafeHandle hJob, SafeHandle hProcess)
        {
            bool hJobAddRef = false;
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hJobLocal;
                if (hJob is object)
                {
                    hJob.DangerousAddRef(ref hJobAddRef);
                    hJobLocal = (win32.System.SystemServices.HANDLE)hJob.DangerousGetHandle();
                }
                else
                    hJobLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.AssignProcessToJobObject(hJobLocal, hProcessLocal);
                return __result;
            }
            finally
            {
                if (hJobAddRef)
                    hJob.DangerousRelease();
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Assigns a process to an existing job object.</summary>
        /// <param name = "hJob">
        /// <para>A handle to the job object to which the process will be associated. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createjobobjecta">CreateJobObject</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openjobobjecta">OpenJobObject</a> function returns this handle. The handle must have the JOB_OBJECT_ASSIGN_PROCESS access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/job-object-security-and-access-rights">Job Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-assignprocesstojobobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hProcess">
        /// <para>A handle to the process to associate with the job object. The handle must have the PROCESS_SET_QUOTA and PROCESS_TERMINATE access rights. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para>If the process is already associated with a job, the job specified by <i>hJob</i> must be empty or it must be in the hierarchy of nested jobs to which the process already belongs, and it cannot have UI limits set (<a href = "https://docs.microsoft.com/windows/desktop/api/jobapi2/nf-jobapi2-setinformationjobobject">SetInformationJobObject</a> with <b>JobObjectBasicUIRestrictions</b>). For more information, see Remarks.</para>
        /// <para><b>Windows 7, Windows Server 2008 R2, Windows XP with SP3, Windows Server 2008, Windows Vista and Windows Server 2003:  </b>The process must not already be assigned to a job; if it is, the function fails with ERROR_ACCESS_DENIED. This behavior changed starting in Windows 8 and Windows Server 2012.</para>
        /// <para><b>Terminal Services:  </b>All processes within a job must run within the same session as the job.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-assignprocesstojobobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-assignprocesstojobobject">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool AssignProcessToJobObject(win32.System.SystemServices.HANDLE hJob, win32.System.SystemServices.HANDLE hProcess);
        /// <inheritdoc cref = "TerminateJobObject(win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe bool TerminateJobObject(SafeHandle hJob, uint uExitCode)
        {
            bool hJobAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hJobLocal;
                if (hJob is object)
                {
                    hJob.DangerousAddRef(ref hJobAddRef);
                    hJobLocal = (win32.System.SystemServices.HANDLE)hJob.DangerousGetHandle();
                }
                else
                    hJobLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.TerminateJobObject(hJobLocal, uExitCode);
                return __result;
            }
            finally
            {
                if (hJobAddRef)
                    hJob.DangerousRelease();
            }
        }

        /// <summary>Terminates all processes currently associated with the job.</summary>
        /// <param name = "hJob">
        /// <para>A handle to the job whose processes will be terminated. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createjobobjecta">CreateJobObject</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openjobobjecta">OpenJobObject</a> function returns this handle. This handle must have the JOB_OBJECT_TERMINATE access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/job-object-security-and-access-rights">Job Object Security and Access Rights</a>.</para>
        /// <para>The handle for each process in the job object must have the PROCESS_TERMINATE access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-terminatejobobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uExitCode">
        /// <para>The exit code to be used by all processes and threads in the job object. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getexitcodeprocess">GetExitCodeProcess</a> function to retrieve each process's exit value. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getexitcodethread">GetExitCodeThread</a> function to retrieve each thread's exit value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-terminatejobobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-terminatejobobject">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool TerminateJobObject(win32.System.SystemServices.HANDLE hJob, uint uExitCode);
        /// <inheritdoc cref = "SetInformationJobObject(win32.System.SystemServices.HANDLE, win32.System.SystemServices.JOBOBJECTINFOCLASS, void *, uint)"/>
        internal static unsafe bool SetInformationJobObject(SafeHandle hJob, win32.System.SystemServices.JOBOBJECTINFOCLASS JobObjectInformationClass, void *lpJobObjectInformation, uint cbJobObjectInformationLength)
        {
            bool hJobAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hJobLocal;
                if (hJob is object)
                {
                    hJob.DangerousAddRef(ref hJobAddRef);
                    hJobLocal = (win32.System.SystemServices.HANDLE)hJob.DangerousGetHandle();
                }
                else
                    hJobLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetInformationJobObject(hJobLocal, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength);
                return __result;
            }
            finally
            {
                if (hJobAddRef)
                    hJob.DangerousRelease();
            }
        }

        /// <summary>Sets limits for a job object.</summary>
        /// <param name = "hJob">
        /// <para>A handle to the job whose limits are being set. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createjobobjecta">CreateJobObject</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openjobobjecta">OpenJobObject</a> function returns this handle. The handle must have the <b>JOB_OBJECT_SET_ATTRIBUTES</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/job-object-security-and-access-rights">Job Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-setinformationjobobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "JobObjectInformationClass"></param>
        /// <param name = "lpJobObjectInformation">The limits or job state to be set for the job. The format of this data depends on the value of <i>JobObjectInfoClass</i>.</param>
        /// <param name = "cbJobObjectInformationLength">The size of the job information being set, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-setinformationjobobject">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetInformationJobObject(win32.System.SystemServices.HANDLE hJob, win32.System.SystemServices.JOBOBJECTINFOCLASS JobObjectInformationClass, void *lpJobObjectInformation, uint cbJobObjectInformationLength);
        /// <inheritdoc cref = "SetIoRateControlInformationJobObject(win32.System.SystemServices.HANDLE, win32.System.JobObjects.JOBOBJECT_IO_RATE_CONTROL_INFORMATION*)"/>
        internal static unsafe uint SetIoRateControlInformationJobObject(SafeHandle hJob, in win32.System.JobObjects.JOBOBJECT_IO_RATE_CONTROL_INFORMATION IoRateControlInfo)
        {
            bool hJobAddRef = false;
            try
            {
                fixed (win32.System.JobObjects.JOBOBJECT_IO_RATE_CONTROL_INFORMATION*IoRateControlInfoLocal = &IoRateControlInfo)
                {
                    win32.System.SystemServices.HANDLE hJobLocal;
                    if (hJob is object)
                    {
                        hJob.DangerousAddRef(ref hJobAddRef);
                        hJobLocal = (win32.System.SystemServices.HANDLE)hJob.DangerousGetHandle();
                    }
                    else
                        hJobLocal = default(win32.System.SystemServices.HANDLE);
                    uint __result = Kernel32.SetIoRateControlInformationJobObject(hJobLocal, IoRateControlInfoLocal);
                    return __result;
                }
            }
            finally
            {
                if (hJobAddRef)
                    hJob.DangerousRelease();
            }
        }

        /// <summary>Sets I/O limits on a job object.</summary>
        /// <param name = "hJob">A handle to the job on which to set I/O limits. Get this handle from the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createjobobjecta">CreateJobObject</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openjobobjecta">OpenJobObject</a> function. The handle must have the <b>JOB_OBJECT_SET_ATTRIBUTES</b> access right. For more information about access rights, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/job-object-security-and-access-rights">Job Object Security and Access Rights</a>.</param>
        /// <param name = "IoRateControlInfo">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/jobapi2/ns-jobapi2-jobobject_io_rate_control_information">JOBOBJECT_IO_RATE_CONTROL_INFORMATION</a> structure that specifies the I/O limits to set for the job.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-setioratecontrolinformationjobobject">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint SetIoRateControlInformationJobObject(win32.System.SystemServices.HANDLE hJob, win32.System.JobObjects.JOBOBJECT_IO_RATE_CONTROL_INFORMATION*IoRateControlInfo);
        /// <inheritdoc cref = "QueryInformationJobObject(win32.System.SystemServices.HANDLE, win32.System.SystemServices.JOBOBJECTINFOCLASS, void *, uint, uint *)"/>
        internal static unsafe bool QueryInformationJobObject(SafeHandle hJob, win32.System.SystemServices.JOBOBJECTINFOCLASS JobObjectInformationClass, void *lpJobObjectInformation, uint cbJobObjectInformationLength, uint *lpReturnLength)
        {
            bool hJobAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hJobLocal;
                if (hJob is object)
                {
                    hJob.DangerousAddRef(ref hJobAddRef);
                    hJobLocal = (win32.System.SystemServices.HANDLE)hJob.DangerousGetHandle();
                }
                else
                    hJobLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.QueryInformationJobObject(hJobLocal, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength, lpReturnLength);
                return __result;
            }
            finally
            {
                if (hJobAddRef)
                    hJob.DangerousRelease();
            }
        }

        /// <summary>Retrieves limit and job state information from the job object.</summary>
        /// <param name = "hJob">
        /// <para>A handle to the job whose information is being queried. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createjobobjecta">CreateJobObject</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openjobobjecta">OpenJobObject</a> function returns this handle. The handle must have the <b>JOB_OBJECT_QUERY</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/job-object-security-and-access-rights">Job Object Security and Access Rights</a>.</para>
        /// <para>If this value is NULL and the calling process is associated with a job, the job associated with the calling process is used. If the job is nested, the immediate job of the calling process is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-queryinformationjobobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "JobObjectInformationClass"></param>
        /// <param name = "lpJobObjectInformation">The limit or job state information. The format of this data depends on the value of the <i>JobObjectInfoClass</i> parameter.</param>
        /// <param name = "cbJobObjectInformationLength">The count of the job information being queried, in bytes. This value depends on the value of the <i>JobObjectInfoClass</i> parameter.</param>
        /// <param name = "lpReturnLength">A pointer to a variable that receives the length of data written to the structure pointed to by the <i>lpJobObjectInfo</i> parameter. Specify <b>NULL</b>  to not receive this information.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-queryinformationjobobject">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool QueryInformationJobObject(win32.System.SystemServices.HANDLE hJob, win32.System.SystemServices.JOBOBJECTINFOCLASS JobObjectInformationClass, void *lpJobObjectInformation, uint cbJobObjectInformationLength, [Optional] uint *lpReturnLength);
        /// <inheritdoc cref = "QueryIoRateControlInformationJobObject(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PCWSTR, win32.System.JobObjects.JOBOBJECT_IO_RATE_CONTROL_INFORMATION**, uint *)"/>
        internal static unsafe uint QueryIoRateControlInformationJobObject(SafeHandle hJob, string VolumeName, out win32.System.JobObjects.JOBOBJECT_IO_RATE_CONTROL_INFORMATION*InfoBlocks, out uint InfoBlockCount)
        {
            bool hJobAddRef = false;
            try
            {
                fixed (uint *InfoBlockCountLocal = &InfoBlockCount)
                {
                    fixed (win32.System.JobObjects.JOBOBJECT_IO_RATE_CONTROL_INFORMATION**InfoBlocksLocal = &InfoBlocks)
                    {
                        fixed (char *VolumeNameLocal = VolumeName)
                        {
                            win32.System.SystemServices.HANDLE hJobLocal;
                            if (hJob is object)
                            {
                                hJob.DangerousAddRef(ref hJobAddRef);
                                hJobLocal = (win32.System.SystemServices.HANDLE)hJob.DangerousGetHandle();
                            }
                            else
                                hJobLocal = default(win32.System.SystemServices.HANDLE);
                            uint __result = Kernel32.QueryIoRateControlInformationJobObject(hJobLocal, VolumeNameLocal, InfoBlocksLocal, InfoBlockCountLocal);
                            return __result;
                        }
                    }
                }
            }
            finally
            {
                if (hJobAddRef)
                    hJob.DangerousRelease();
            }
        }

        /// <summary>Gets information about the control of the I/O rate for a job object.</summary>
        /// <param name = "hJob">
        /// <para>A handle to the job to query for information. Get this handle from the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createjobobjecta">CreateJobObject</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openjobobjecta">OpenJobObject</a> function. The handle must have the <b>JOB_OBJECT_QUERY</b> access right. For more information about access rights, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/job-object-security-and-access-rights">Job Object Security and Access Rights</a>.</para>
        /// <para>If this value is NULL and the process that calls <b>QueryIoRateControlInformationJobObject</b> is associated with a job, the function uses job that is associated with the process. If the job is nested within another job, the function uses the immediate job for the process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-queryioratecontrolinformationjobobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "VolumeName">The name of the volume to query. If this value is NULL, the function gets the information about I/O rate control for the job for all of the volumes for the system.</param>
        /// <param name = "InfoBlocks">A pointer to array of <a href = "https://docs.microsoft.com/windows/desktop/api/jobapi2/ns-jobapi2-jobobject_io_rate_control_information">JOBOBJECT_IO_RATE_CONTROL_INFORMATION</a> structures that contain the information about I/O rate control for the job. Your code must free the memory for this array by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/jobapi2/nf-jobapi2-freememoryjobobject">FreeMemoryJobObject</a> function with the address of the array.</param>
        /// <param name = "InfoBlockCount">The number of <a href = "https://docs.microsoft.com/windows/desktop/api/jobapi2/ns-jobapi2-jobobject_io_rate_control_information">JOBOBJECT_IO_RATE_CONTROL_INFORMATION</a> structures that the function allocated in the array to which the <i>InfoBlocks</i> parameter points.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//jobapi2/nf-jobapi2-queryioratecontrolinformationjobobject">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint QueryIoRateControlInformationJobObject(win32.System.SystemServices.HANDLE hJob, win32.System.SystemServices.PCWSTR VolumeName, win32.System.JobObjects.JOBOBJECT_IO_RATE_CONTROL_INFORMATION**InfoBlocks, uint *InfoBlockCount);
        /// <inheritdoc cref = "RtlRaiseException(win32.System.Diagnostics.Debug.EXCEPTION_RECORD*)"/>
        internal static unsafe void RtlRaiseException(in win32.System.Diagnostics.Debug.EXCEPTION_RECORD ExceptionRecord)
        {
            fixed (win32.System.Diagnostics.Debug.EXCEPTION_RECORD*ExceptionRecordLocal = &ExceptionRecord)
            {
                Kernel32.RtlRaiseException(ExceptionRecordLocal);
            }
        }

        /// <summary>Raises an exception.</summary>
        /// <param name = "ExceptionRecord">
        /// <para>Address of an <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-exception_record">EXCEPTION_RECORD</a> structure that describes the exception, and the parameters of the exception, that is raised. Raising a software exception captures the machine state of the current thread in a context record. The <b>ExceptionAddress</b> member of the exception record is set to the caller's return address.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//rtlsupportapi/nf-rtlsupportapi-rtlraiseexception#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>This function does not return a value.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//rtlsupportapi/nf-rtlsupportapi-rtlraiseexception">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void RtlRaiseException(win32.System.Diagnostics.Debug.EXCEPTION_RECORD*ExceptionRecord);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe nuint RtlCompareMemory(void *Source1, void *Source2, nuint Length);
        /// <summary>Closes an open namespace handle.</summary>
        /// <param name = "Handle">The namespace handle. This handle is created by <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createprivatenamespacea">CreatePrivateNamespace</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openprivatenamespacea">OpenPrivateNamespace</a>.</param>
        /// <param name = "Flags">If this parameter is <b>PRIVATE_NAMESPACE_FLAG_DESTROY</b> (0x00000001), the namespace is destroyed.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namespaceapi/nf-namespaceapi-closeprivatenamespace">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern byte ClosePrivateNamespace(win32.System.SystemServices.NamespaceHandle Handle, uint Flags);
        /// <inheritdoc cref = "CreatePrivateNamespace(win32.System.SystemServices.SECURITY_ATTRIBUTES*, void *, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.SystemServices.NamespaceHandle CreatePrivateNamespace(win32.System.SystemServices.SECURITY_ATTRIBUTES? lpPrivateNamespaceAttributes, void *lpBoundaryDescriptor, string lpAliasPrefix)
        {
            fixed (char *lpAliasPrefixLocal = lpAliasPrefix)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpPrivateNamespaceAttributesLocal = lpPrivateNamespaceAttributes.HasValue ? lpPrivateNamespaceAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.NamespaceHandle __result = Kernel32.CreatePrivateNamespace(lpPrivateNamespaceAttributes.HasValue ? &lpPrivateNamespaceAttributesLocal : null, lpBoundaryDescriptor, lpAliasPrefixLocal);
                return __result;
            }
        }

        /// <summary>Creates a private namespace.</summary>
        /// <param name = "lpPrivateNamespaceAttributes">A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security attributes of the namespace object.</param>
        /// <param name = "lpBoundaryDescriptor">A descriptor that defines how the namespace is to be isolated. The caller must be within this boundary. The <a href = "https://docs.microsoft.com/windows/desktop/api/namespaceapi/nf-namespaceapi-createboundarydescriptorw">CreateBoundaryDescriptor</a> function creates a boundary descriptor.</param>
        /// <param name = "lpAliasPrefix">
        /// <para>The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>&#92;<i>objectname</i>.</para>
        /// <para>The system supports multiple private namespaces with the same name, as long as they define different boundaries.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namespaceapi/nf-namespaceapi-createprivatenamespacew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns a handle to the new namespace.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namespaceapi/nf-namespaceapi-createprivatenamespacew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreatePrivateNamespaceW")]
        internal static extern unsafe win32.System.SystemServices.NamespaceHandle CreatePrivateNamespace([Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpPrivateNamespaceAttributes, void *lpBoundaryDescriptor, win32.System.SystemServices.PCWSTR lpAliasPrefix);
        /// <inheritdoc cref = "OpenPrivateNamespace(void *, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.SystemServices.NamespaceHandle OpenPrivateNamespace(void *lpBoundaryDescriptor, string lpAliasPrefix)
        {
            fixed (char *lpAliasPrefixLocal = lpAliasPrefix)
            {
                win32.System.SystemServices.NamespaceHandle __result = Kernel32.OpenPrivateNamespace(lpBoundaryDescriptor, lpAliasPrefixLocal);
                return __result;
            }
        }

        /// <summary>Opens a private namespace.</summary>
        /// <param name = "lpBoundaryDescriptor">A descriptor that defines how the namespace is to be isolated. The <a href = "https://docs.microsoft.com/windows/desktop/api/namespaceapi/nf-namespaceapi-createboundarydescriptorw">CreateBoundaryDescriptor</a> function creates a boundary descriptor.</param>
        /// <param name = "lpAliasPrefix">The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>&#92;<i>objectname</i>.</param>
        /// <returns>The function returns the handle to the existing namespace.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namespaceapi/nf-namespaceapi-openprivatenamespacew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "OpenPrivateNamespaceW")]
        internal static extern unsafe win32.System.SystemServices.NamespaceHandle OpenPrivateNamespace(void *lpBoundaryDescriptor, win32.System.SystemServices.PCWSTR lpAliasPrefix);
        /// <summary>Deletes the specified boundary descriptor.</summary>
        /// <param name = "BoundaryDescriptor">A handle to the boundary descriptor. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createboundarydescriptora">CreateBoundaryDescriptor</a> function returns this handle.</param>
        /// <remarks>
        /// <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namespaceapi/nf-namespaceapi-deleteboundarydescriptor#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void DeleteBoundaryDescriptor(win32.System.SystemServices.BoundaryDescriptorHandle BoundaryDescriptor);
        /// <inheritdoc cref = "CreateBoundaryDescriptor(win32.System.SystemServices.PCWSTR, uint)"/>
        internal static unsafe Kernel32.DeleteBoundaryDescriptorSafeHandle CreateBoundaryDescriptor(string Name, uint Flags)
        {
            fixed (char *NameLocal = Name)
            {
                win32.System.SystemServices.BoundaryDescriptorHandle __result = Kernel32.CreateBoundaryDescriptor(NameLocal, Flags);
                return new Kernel32.DeleteBoundaryDescriptorSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "Kernel32.DeleteBoundaryDescriptor"/>.
        /// </summary>
        internal class DeleteBoundaryDescriptorSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal DeleteBoundaryDescriptorSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal DeleteBoundaryDescriptorSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle()
            {
                Kernel32.DeleteBoundaryDescriptor((win32.System.SystemServices.BoundaryDescriptorHandle)this.handle);
                return true;
            }
        }

        /// <summary>Creates a boundary descriptor.</summary>
        /// <param name = "Name">The name of the boundary descriptor.</param>
        /// <param name = "Flags">This parameter is reserved for future use.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the boundary descriptor.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namespaceapi/nf-namespaceapi-createboundarydescriptorw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateBoundaryDescriptorW")]
        internal static extern win32.System.SystemServices.BoundaryDescriptorHandle CreateBoundaryDescriptor(win32.System.SystemServices.PCWSTR Name, uint Flags);
        /// <inheritdoc cref = "AddSIDToBoundaryDescriptor(win32.System.SystemServices.HANDLE*, win32.Security.PSID)"/>
        internal static unsafe bool AddSIDToBoundaryDescriptor(ref win32.System.SystemServices.HANDLE BoundaryDescriptor, win32.Security.PSID RequiredSid)
        {
            fixed (win32.System.SystemServices.HANDLE*BoundaryDescriptorLocal = &BoundaryDescriptor)
            {
                bool __result = Kernel32.AddSIDToBoundaryDescriptor(BoundaryDescriptorLocal, RequiredSid);
                return __result;
            }
        }

        /// <summary>Adds a security identifier (SID) to the specified boundary descriptor.</summary>
        /// <param name = "BoundaryDescriptor">A handle to the boundary descriptor. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createboundarydescriptora">CreateBoundaryDescriptor</a> function returns this handle.</param>
        /// <param name = "RequiredSid">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-sid">SID</a> structure.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namespaceapi/nf-namespaceapi-addsidtoboundarydescriptor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool AddSIDToBoundaryDescriptor(win32.System.SystemServices.HANDLE*BoundaryDescriptor, win32.Security.PSID RequiredSid);
        /// <inheritdoc cref = "GetNumaHighestNodeNumber(uint *)"/>
        internal static unsafe bool GetNumaHighestNodeNumber(out uint HighestNodeNumber)
        {
            fixed (uint *HighestNodeNumberLocal = &HighestNodeNumber)
            {
                bool __result = Kernel32.GetNumaHighestNodeNumber(HighestNodeNumberLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the node that currently has the highest number.</summary>
        /// <param name = "HighestNodeNumber">The number of the highest node.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//systemtopologyapi/nf-systemtopologyapi-getnumahighestnodenumber">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNumaHighestNodeNumber(uint *HighestNodeNumber);
        /// <inheritdoc cref = "GetNumaNodeProcessorMaskEx(ushort, win32.System.Kernel.GROUP_AFFINITY*)"/>
        internal static unsafe bool GetNumaNodeProcessorMaskEx(ushort Node, out win32.System.Kernel.GROUP_AFFINITY ProcessorMask)
        {
            fixed (win32.System.Kernel.GROUP_AFFINITY*ProcessorMaskLocal = &ProcessorMask)
            {
                bool __result = Kernel32.GetNumaNodeProcessorMaskEx(Node, ProcessorMaskLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the processor mask for a node regardless of the processor group the node belongs to.</summary>
        /// <param name = "Node">The node number.</param>
        /// <param name = "ProcessorMask">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-group_affinity">GROUP_AFFINITY</a> structure that receives the processor mask for the specified node. A processor mask is a bit vector in which each bit represents a processor and whether it is in the node.</para>
        /// <para>If the specified node has no processors configured, the <b>Mask</b> member is zero and the <b>Group</b> member is undefined.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//systemtopologyapi/nf-systemtopologyapi-getnumanodeprocessormaskex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//systemtopologyapi/nf-systemtopologyapi-getnumanodeprocessormaskex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetNumaNodeProcessorMaskEx(ushort Node, win32.System.Kernel.GROUP_AFFINITY*ProcessorMask);
        /// <inheritdoc cref = "GetNumaProximityNodeEx(uint, ushort *)"/>
        internal static unsafe bool GetNumaProximityNodeEx(uint ProximityId, out ushort NodeNumber)
        {
            fixed (ushort *NodeNumberLocal = &NodeNumber)
            {
                bool __result = Kernel32.GetNumaProximityNodeEx(ProximityId, NodeNumberLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the NUMA node number that corresponds to the specified proximity identifier as a USHORT value.</summary>
        /// <param name = "ProximityId">The proximity identifier of the node.</param>
        /// <param name = "NodeNumber">Points to a variable to receive the node number for the specified proximity identifier.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//systemtopologyapi/nf-systemtopologyapi-getnumaproximitynodeex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetNumaProximityNodeEx(uint ProximityId, ushort *NodeNumber);
        /// <inheritdoc cref = "GetProcessGroupAffinity(win32.System.SystemServices.HANDLE, ushort *, ushort *)"/>
        internal static unsafe bool GetProcessGroupAffinity(SafeHandle hProcess, ref ushort GroupCount, ushort *GroupArray)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (ushort *GroupCountLocal = &GroupCount)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetProcessGroupAffinity(hProcessLocal, GroupCountLocal, GroupArray);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the processor group affinity of the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process.</para>
        /// <para>This handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processtopologyapi/nf-processtopologyapi-getprocessgroupaffinity#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "GroupCount">On input, specifies the number of elements in <i>GroupArray</i> array. On output, specifies the number of processor groups written to the array. If the array is too small, the function fails with ERROR_INSUFFICIENT_BUFFER and sets the <i>GroupCount</i> parameter to the number of elements required.</param>
        /// <param name = "GroupArray">An array of processor group numbers. A group number is included in the array if a thread in the process is assigned to a processor in the group.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use <a href = "/windows/desktop/api/adshlp/nf-adshlp-adsgetlasterror">GetLastError</a>.</para>
        /// <para>If the error value is ERROR_INSUFFICIENT_BUFFER, the <i>GroupCount</i> parameter contains the required buffer size in number of elements.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processtopologyapi/nf-processtopologyapi-getprocessgroupaffinity">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetProcessGroupAffinity(win32.System.SystemServices.HANDLE hProcess, ushort *GroupCount, ushort *GroupArray);
        /// <inheritdoc cref = "GetThreadGroupAffinity(win32.System.SystemServices.HANDLE, win32.System.Kernel.GROUP_AFFINITY*)"/>
        internal static unsafe bool GetThreadGroupAffinity(SafeHandle hThread, out win32.System.Kernel.GROUP_AFFINITY GroupAffinity)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (win32.System.Kernel.GROUP_AFFINITY*GroupAffinityLocal = &GroupAffinity)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetThreadGroupAffinity(hThreadLocal, GroupAffinityLocal);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Retrieves the processor group affinity of the specified thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread for which the processor group affinity is desired.</para>
        /// <para>The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processtopologyapi/nf-processtopologyapi-getthreadgroupaffinity#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "GroupAffinity">A pointer to a GROUP_AFFINITY structure to receive the group affinity of the thread.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use <a href = "/windows/desktop/api/adshlp/nf-adshlp-adsgetlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processtopologyapi/nf-processtopologyapi-getthreadgroupaffinity">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetThreadGroupAffinity(win32.System.SystemServices.HANDLE hThread, win32.System.Kernel.GROUP_AFFINITY*GroupAffinity);
        /// <inheritdoc cref = "SetThreadGroupAffinity(win32.System.SystemServices.HANDLE, win32.System.Kernel.GROUP_AFFINITY*, win32.System.Kernel.GROUP_AFFINITY*)"/>
        internal static unsafe bool SetThreadGroupAffinity(SafeHandle hThread, in win32.System.Kernel.GROUP_AFFINITY GroupAffinity, win32.System.Kernel.GROUP_AFFINITY*PreviousGroupAffinity)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (win32.System.Kernel.GROUP_AFFINITY*GroupAffinityLocal = &GroupAffinity)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetThreadGroupAffinity(hThreadLocal, GroupAffinityLocal, PreviousGroupAffinity);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Sets the processor group affinity for the specified thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread.</para>
        /// <para>The handle must have the THREAD_SET_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processtopologyapi/nf-processtopologyapi-setthreadgroupaffinity#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "GroupAffinity">A <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-group_affinity">GROUP_AFFINITY</a> structure that specifies the processor group affinity to be used for the specified thread.</param>
        /// <param name = "PreviousGroupAffinity">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-group_affinity">GROUP_AFFINITY</a> structure to receive the thread's previous group affinity. This parameter can be NULL.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use <a href = "/windows/desktop/api/adshlp/nf-adshlp-adsgetlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processtopologyapi/nf-processtopologyapi-setthreadgroupaffinity">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetThreadGroupAffinity(win32.System.SystemServices.HANDLE hThread, win32.System.Kernel.GROUP_AFFINITY*GroupAffinity, [Optional] win32.System.Kernel.GROUP_AFFINITY*PreviousGroupAffinity);
        /// <inheritdoc cref = "CreatePipe(win32.System.SystemServices.HANDLE*, win32.System.SystemServices.HANDLE*, win32.System.SystemServices.SECURITY_ATTRIBUTES*, uint)"/>
        internal static unsafe bool CreatePipe(out Microsoft.Win32.SafeHandles.SafeFileHandle hReadPipe, out Microsoft.Win32.SafeHandles.SafeFileHandle hWritePipe, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpPipeAttributes, uint nSize)
        {
            win32.System.SystemServices.HANDLE hReadPipeLocal;
            win32.System.SystemServices.HANDLE hWritePipeLocal;
            win32.System.SystemServices.SECURITY_ATTRIBUTES lpPipeAttributesLocal = lpPipeAttributes.HasValue ? lpPipeAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
            bool __result = Kernel32.CreatePipe(&hReadPipeLocal, &hWritePipeLocal, lpPipeAttributes.HasValue ? &lpPipeAttributesLocal : null, nSize);
            hReadPipe = new Microsoft.Win32.SafeHandles.SafeFileHandle(hReadPipeLocal, ownsHandle: true);
            hWritePipe = new Microsoft.Win32.SafeHandles.SafeFileHandle(hWritePipeLocal, ownsHandle: true);
            return __result;
        }

        /// <summary>Creates an anonymous pipe, and returns handles to the read and write ends of the pipe.</summary>
        /// <param name = "hReadPipe">A pointer to a variable that receives the read handle for the pipe.</param>
        /// <param name = "hWritePipe">A pointer to a variable that receives the write handle for the pipe.</param>
        /// <param name = "lpPipeAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle can be inherited by child processes. If <i>lpPipeAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new pipe. If <i>lpPipeAttributes</i> is <b>NULL</b>, the pipe gets a default security descriptor. The ACLs in the default security descriptor for a pipe come from the primary or impersonation token of the creator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-createpipe#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nSize">The size of the buffer for the pipe, in bytes. The size is only a suggestion; the system uses the value to calculate an appropriate buffering mechanism. If this parameter is zero, the system uses the default buffer size.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-createpipe">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool CreatePipe(win32.System.SystemServices.HANDLE*hReadPipe, win32.System.SystemServices.HANDLE*hWritePipe, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpPipeAttributes, uint nSize);
        /// <inheritdoc cref = "ConnectNamedPipe(win32.System.SystemServices.HANDLE, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool ConnectNamedPipe(SafeHandle hNamedPipe, win32.System.SystemServices.OVERLAPPED*lpOverlapped)
        {
            bool hNamedPipeAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hNamedPipeLocal;
                if (hNamedPipe is object)
                {
                    hNamedPipe.DangerousAddRef(ref hNamedPipeAddRef);
                    hNamedPipeLocal = (win32.System.SystemServices.HANDLE)hNamedPipe.DangerousGetHandle();
                }
                else
                    hNamedPipeLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.ConnectNamedPipe(hNamedPipeLocal, lpOverlapped);
                return __result;
            }
            finally
            {
                if (hNamedPipeAddRef)
                    hNamedPipe.DangerousRelease();
            }
        }

        /// <summary>Enables a named pipe server process to wait for a client process to connect to an instance of a named pipe.</summary>
        /// <param name = "hNamedPipe">
        /// <para>A handle to the server end of a named pipe instance. This handle is returned by the <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-connectnamedpipe#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.</para>
        /// <para>If <i>hNamedPipe</i> was opened with FILE_FLAG_OVERLAPPED, the <i>lpOverlapped</i> parameter must not be <b>NULL</b>. It must point to a valid <a href = "https://docs.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. If <i>hNamedPipe</i> was opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is <b>NULL</b>, the function can incorrectly report that the connect operation is complete.</para>
        /// <para>If <i>hNamedPipe</i> was created with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is not <b>NULL</b>, the <a href = "https://docs.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure should  contain a handle to a manual-reset event object (which the server can create by using the <a href = "https://docs.microsoft.com/windows/win32/api/synchapi/nf-synchapi-createeventa">CreateEvent</a> function).</para>
        /// <para>If <i>hNamedPipe</i> was not opened with FILE_FLAG_OVERLAPPED, the function does not return until a client is connected or an error occurs. Successful synchronous operations result in the function returning a nonzero value if a client connects after the function is called.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-connectnamedpipe#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the operation is synchronous, <b>ConnectNamedPipe</b> does not return until the operation has completed. If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the operation is asynchronous, <b>ConnectNamedPipe</b> returns immediately. If the operation is still pending, the return value is zero and <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_IO_PENDING. (You can use the <a href = "/windows/win32/api/winbase/nf-winbase-hasoverlappediocompleted">HasOverlappedIoCompleted</a> macro to determine when the operation has finished.) If the function fails, the return value is zero and <b>GetLastError</b> returns a value other than ERROR_IO_PENDING or ERROR_PIPE_CONNECTED.</para>
        /// <para>If a client connects before the function is called, the function returns zero and <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_PIPE_CONNECTED. This can happen if a client connects in the interval between the call to <a href = "/windows/win32/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> and the call to <b>ConnectNamedPipe</b>. In this situation, there is a good connection between client and server, even though the function returns zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-connectnamedpipe">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ConnectNamedPipe(win32.System.SystemServices.HANDLE hNamedPipe, [Optional] win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <inheritdoc cref = "DisconnectNamedPipe(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool DisconnectNamedPipe(SafeHandle hNamedPipe)
        {
            bool hNamedPipeAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hNamedPipeLocal;
                if (hNamedPipe is object)
                {
                    hNamedPipe.DangerousAddRef(ref hNamedPipeAddRef);
                    hNamedPipeLocal = (win32.System.SystemServices.HANDLE)hNamedPipe.DangerousGetHandle();
                }
                else
                    hNamedPipeLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.DisconnectNamedPipe(hNamedPipeLocal);
                return __result;
            }
            finally
            {
                if (hNamedPipeAddRef)
                    hNamedPipe.DangerousRelease();
            }
        }

        /// <summary>Disconnects the server end of a named pipe instance from a client process.</summary>
        /// <param name = "hNamedPipe">
        /// <para>A handle to an instance of a named pipe. This handle must be created by the <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-disconnectnamedpipe#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-disconnectnamedpipe">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DisconnectNamedPipe(win32.System.SystemServices.HANDLE hNamedPipe);
        /// <inheritdoc cref = "SetNamedPipeHandleState(win32.System.SystemServices.HANDLE, uint *, uint *, uint *)"/>
        internal static unsafe bool SetNamedPipeHandleState(SafeHandle hNamedPipe, uint? lpMode, uint? lpMaxCollectionCount, uint? lpCollectDataTimeout)
        {
            bool hNamedPipeAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hNamedPipeLocal;
                if (hNamedPipe is object)
                {
                    hNamedPipe.DangerousAddRef(ref hNamedPipeAddRef);
                    hNamedPipeLocal = (win32.System.SystemServices.HANDLE)hNamedPipe.DangerousGetHandle();
                }
                else
                    hNamedPipeLocal = default(win32.System.SystemServices.HANDLE);
                uint lpModeLocal = lpMode.HasValue ? lpMode.Value : default(uint);
                uint lpMaxCollectionCountLocal = lpMaxCollectionCount.HasValue ? lpMaxCollectionCount.Value : default(uint);
                uint lpCollectDataTimeoutLocal = lpCollectDataTimeout.HasValue ? lpCollectDataTimeout.Value : default(uint);
                bool __result = Kernel32.SetNamedPipeHandleState(hNamedPipeLocal, lpMode.HasValue ? &lpModeLocal : null, lpMaxCollectionCount.HasValue ? &lpMaxCollectionCountLocal : null, lpCollectDataTimeout.HasValue ? &lpCollectDataTimeoutLocal : null);
                return __result;
            }
            finally
            {
                if (hNamedPipeAddRef)
                    hNamedPipe.DangerousRelease();
            }
        }

        /// <summary>Sets the read mode and the blocking mode of the specified named pipe. If the specified handle is to the client end of a named pipe and if the named pipe server process is on a remote computer, the function can also be used to control local buffering.</summary>
        /// <param name = "hNamedPipe">
        /// <para>A handle to the named pipe instance. This parameter can be a handle to the server end of the pipe, as returned by the <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function, or to the client end of the pipe, as returned by the <a href = "https://docs.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew">CreateFile</a> function. The handle must have GENERIC_WRITE access to the named pipe for a write-only or read/write pipe, or it must have GENERIC_READ and FILE_WRITE_ATTRIBUTES access for a read-only pipe.</para>
        /// <para>This parameter can also be a handle to an anonymous pipe, as returned by the <a href = "https://docs.microsoft.com/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe">CreatePipe</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-setnamedpipehandlestate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMode">
        /// <para>The new pipe mode. The mode is a combination of a read-mode flag and a wait-mode flag. This parameter can be <b>NULL</b> if the mode is not being set. Specify one of the following modes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-setnamedpipehandlestate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMaxCollectionCount">The maximum number of bytes collected on the client computer before transmission to the server. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same machine. This parameter is ignored if the client process specifies the FILE_FLAG_WRITE_THROUGH flag in the <a href = "https://docs.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew">CreateFile</a> function when the handle was created. This parameter can be <b>NULL</b> if the collection count is not being set.</param>
        /// <param name = "lpCollectDataTimeout">
        /// <para>The maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the network. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter is ignored if the client process specified the FILE_FLAG_WRITE_THROUGH flag in the <a href = "https://docs.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew">CreateFile</a> function when the handle was created. This parameter can be <b>NULL</b> if the collection count is not being set.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-setnamedpipehandlestate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-setnamedpipehandlestate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetNamedPipeHandleState(win32.System.SystemServices.HANDLE hNamedPipe, [Optional] uint *lpMode, [Optional] uint *lpMaxCollectionCount, [Optional] uint *lpCollectDataTimeout);
        /// <inheritdoc cref = "PeekNamedPipe(win32.System.SystemServices.HANDLE, void *, uint, uint *, uint *, uint *)"/>
        internal static unsafe bool PeekNamedPipe(SafeHandle hNamedPipe, void *lpBuffer, uint nBufferSize, uint *lpBytesRead, uint *lpTotalBytesAvail, uint *lpBytesLeftThisMessage)
        {
            bool hNamedPipeAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hNamedPipeLocal;
                if (hNamedPipe is object)
                {
                    hNamedPipe.DangerousAddRef(ref hNamedPipeAddRef);
                    hNamedPipeLocal = (win32.System.SystemServices.HANDLE)hNamedPipe.DangerousGetHandle();
                }
                else
                    hNamedPipeLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.PeekNamedPipe(hNamedPipeLocal, lpBuffer, nBufferSize, lpBytesRead, lpTotalBytesAvail, lpBytesLeftThisMessage);
                return __result;
            }
            finally
            {
                if (hNamedPipeAddRef)
                    hNamedPipe.DangerousRelease();
            }
        }

        /// <summary>Copies data from a named or anonymous pipe into a buffer without removing it from the pipe.</summary>
        /// <param name = "hNamedPipe">
        /// <para>A handle to the pipe. This parameter can be a handle to a named pipe instance, as returned by the <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> or <a href = "https://docs.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew">CreateFile</a> function, or it can be a handle to the read end of an anonymous pipe, as returned by the <a href = "https://docs.microsoft.com/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe">CreatePipe</a> function. The handle must have GENERIC_READ access to the pipe.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-peeknamedpipe#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">A pointer to a buffer that receives data read from the pipe. This parameter can be <b>NULL</b> if no data is to be read.</param>
        /// <param name = "nBufferSize">The size of the buffer specified by the <i>lpBuffer</i> parameter, in bytes. This parameter is ignored if <i>lpBuffer</i> is <b>NULL</b>.</param>
        /// <param name = "lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe. This parameter can be <b>NULL</b> if no data is to be read.</param>
        /// <param name = "lpTotalBytesAvail">A pointer to a variable that receives the total number of bytes available to be read from the pipe. This parameter can be <b>NULL</b> if no data is to be read.</param>
        /// <param name = "lpBytesLeftThisMessage">A pointer to a variable that receives the number of bytes remaining in this message. This parameter will be zero for byte-type named pipes or for anonymous pipes. This parameter can be <b>NULL</b> if no data is to be read.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-peeknamedpipe">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool PeekNamedPipe(win32.System.SystemServices.HANDLE hNamedPipe, [Optional] void *lpBuffer, uint nBufferSize, [Optional] uint *lpBytesRead, [Optional] uint *lpTotalBytesAvail, [Optional] uint *lpBytesLeftThisMessage);
        /// <inheritdoc cref = "TransactNamedPipe(win32.System.SystemServices.HANDLE, void *, uint, void *, uint, uint *, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool TransactNamedPipe(SafeHandle hNamedPipe, void *lpInBuffer, uint nInBufferSize, void *lpOutBuffer, uint nOutBufferSize, out uint lpBytesRead, win32.System.SystemServices.OVERLAPPED*lpOverlapped)
        {
            bool hNamedPipeAddRef = false;
            try
            {
                fixed (uint *lpBytesReadLocal = &lpBytesRead)
                {
                    win32.System.SystemServices.HANDLE hNamedPipeLocal;
                    if (hNamedPipe is object)
                    {
                        hNamedPipe.DangerousAddRef(ref hNamedPipeAddRef);
                        hNamedPipeLocal = (win32.System.SystemServices.HANDLE)hNamedPipe.DangerousGetHandle();
                    }
                    else
                        hNamedPipeLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.TransactNamedPipe(hNamedPipeLocal, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReadLocal, lpOverlapped);
                    return __result;
                }
            }
            finally
            {
                if (hNamedPipeAddRef)
                    hNamedPipe.DangerousRelease();
            }
        }

        /// <summary>Combines the functions that write a message to and read a message from the specified named pipe into a single network operation.</summary>
        /// <param name = "hNamedPipe">
        /// <para>A handle to the named pipe returned by the <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> or <a href = "https://docs.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew">CreateFile</a> function.</para>
        /// <para>This parameter can also be a handle to an anonymous pipe, as returned by the <a href = "https://docs.microsoft.com/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe">CreatePipe</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-transactnamedpipe#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpInBuffer">A pointer to the buffer containing the data to be written to the pipe.</param>
        /// <param name = "nInBufferSize">The size of the input buffer, in bytes.</param>
        /// <param name = "lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
        /// <param name = "nOutBufferSize">The size of the output buffer, in bytes.</param>
        /// <param name = "lpBytesRead">
        /// <para>A pointer to the variable that receives the number of bytes read from the pipe.</para>
        /// <para>If <i>lpOverlapped</i> is <b>NULL</b>, <i>lpBytesRead</i> cannot be <b>NULL</b>.</para>
        /// <para>If <i>lpOverlapped</i> is not <b>NULL</b>, <i>lpBytesRead</i> can be <b>NULL</b>. If this is an overlapped read operation, you can get the number of bytes read by calling <a href = "https://docs.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a>. If <i>hNamedPipe</i> is associated with an I/O completion port, you can get the number of bytes read by calling <a href = "https://docs.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-transactnamedpipe#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. This structure is required if <i>hNamedPipe</i> was opened with FILE_FLAG_OVERLAPPED.</para>
        /// <para>If <i>hNamedPipe</i> was opened with FILE_FLAG_OVERLAPPED, the <i>lpOverlapped</i> parameter must not be <b>NULL</b>. It must point to a valid <a href = "https://docs.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. If <i>hNamedPipe</i> was created with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is <b>NULL</b>, the function can incorrectly report that the operation is complete.</para>
        /// <para>If <i>hNamedPipe</i> was opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is not <b>NULL</b>, <b>TransactNamedPipe</b> is executed as an overlapped operation. The <a href = "https://docs.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure should contain a manual-reset event object (which can be created by using the <a href = "https://docs.microsoft.com/windows/win32/api/synchapi/nf-synchapi-createeventa">CreateEvent</a> function). If the operation cannot be completed immediately, <b>TransactNamedPipe</b> returns <b>FALSE</b> and <a href = "https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_IO_PENDING. In this situation, the event object is set to the nonsignaled state before <b>TransactNamedPipe</b> returns, and it is set to the signaled state when the transaction has finished. Also, you can  be notified when an overlapped operation completes by using the <a href = "https://docs.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> or <a href = "https://docs.microsoft.com/windows/win32/FileIO/getqueuedcompletionstatusex-func">GetQueuedCompletionStatusEx</a> functions.  In this case, you do not need to assign the manual-reset event in the <b>OVERLAPPED</b> structure, and the completion happens against <i>hNamedPipe</i> in the same way as an asynchronous read or write operation. For more information about overlapped operations, see <a href = "https://docs.microsoft.com/windows/win32/ipc/pipes">Pipes</a>.</para>
        /// <para>If <i>hNamedPipe</i> was not opened with FILE_FLAG_OVERLAPPED, <b>TransactNamedPipe</b> does not return until the operation is complete.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-transactnamedpipe#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the message to be read is longer than the buffer specified by the <i>nOutBufferSize</i> parameter, <b>TransactNamedPipe</b> returns <b>FALSE</b> and the <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns ERROR_MORE_DATA. The remainder of the message can be read by a subsequent call to <a href = "/windows/win32/api/fileapi/nf-fileapi-readfile">ReadFile</a>, <a href = "/windows/win32/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a>, or <a href = "/windows/win32/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe">PeekNamedPipe</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-transactnamedpipe">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool TransactNamedPipe(win32.System.SystemServices.HANDLE hNamedPipe, [Optional] void *lpInBuffer, uint nInBufferSize, [Optional] void *lpOutBuffer, uint nOutBufferSize, uint *lpBytesRead, [Optional] win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <inheritdoc cref = "CreateNamedPipe(win32.System.SystemServices.PCWSTR, uint, uint, uint, uint, uint, uint, win32.System.SystemServices.SECURITY_ATTRIBUTES*)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateNamedPipe(string lpName, uint dwOpenMode, uint dwPipeMode, uint nMaxInstances, uint nOutBufferSize, uint nInBufferSize, uint nDefaultTimeOut, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpSecurityAttributes)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpSecurityAttributesLocal = lpSecurityAttributes.HasValue ? lpSecurityAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateNamedPipe(lpNameLocal, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes.HasValue ? &lpSecurityAttributesLocal : null);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates an instance of a named pipe and returns a handle for subsequent pipe operations.</summary>
        /// <param name = "lpName">
        /// <para>The unique pipe name. This string must have the following form:</para>
        /// <para>\\\\.\\pipe&#92;<i>pipename</i></para>
        /// <para>The pipename part of the name can include any character other than a backslash, including numbers and special characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-createnamedpipew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwOpenMode">
        /// <para>The open mode.</para>
        /// <para>The function fails if <i>dwOpenMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
        /// <para>This parameter must specify one of the following pipe access modes. The same mode must be specified for each instance of the pipe.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-createnamedpipew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwPipeMode">
        /// <para>The pipe mode.</para>
        /// <para>The function fails if <i>dwPipeMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
        /// <para>One of the following type modes can be specified. The same type mode must be specified for each instance of the pipe.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-createnamedpipew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nMaxInstances">
        /// <para>The maximum number of instances that can be created for this pipe. The first instance of the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable values are in the range 1 through <b>PIPE_UNLIMITED_INSTANCES</b> (255).</para>
        /// <para>If this parameter is <b>PIPE_UNLIMITED_INSTANCES</b>, the number of pipe instances that can be created is limited only by the availability of system resources. If <i>nMaxInstances</i> is greater than <b>PIPE_UNLIMITED_INSTANCES</b>, the return value is <b>INVALID_HANDLE_VALUE</b> and <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_PARAMETER</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-createnamedpipew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nOutBufferSize">The number of bytes to reserve for the output buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</param>
        /// <param name = "nInBufferSize">The number of bytes to reserve for the input buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</param>
        /// <param name = "nDefaultTimeOut">
        /// <para>The default time-out value, in milliseconds, if the <a href = "https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-waitnamedpipew">WaitNamedPipe</a> function specifies <b>NMPWAIT_USE_DEFAULT_WAIT</b>. Each instance of a named pipe must specify the same value.</para>
        /// <para>A value of zero will result in a default time-out of 50 milliseconds.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-createnamedpipew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSecurityAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new named pipe and determines whether child processes can inherit the returned handle. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the named pipe gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem account, administrators, and the creator owner. They also grant read access to members of the Everyone group and the anonymous account.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-createnamedpipew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the server end of a named pipe instance.</para>
        /// <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-createnamedpipew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateNamedPipeW")]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateNamedPipe(win32.System.SystemServices.PCWSTR lpName, uint dwOpenMode, uint dwPipeMode, uint nMaxInstances, uint nOutBufferSize, uint nInBufferSize, uint nDefaultTimeOut, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributes);
        /// <inheritdoc cref = "WaitNamedPipe(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.WAIT_NAMED_PIPE_TIME_OUT_FLAGS)"/>
        internal static unsafe bool WaitNamedPipe(string lpNamedPipeName, win32.System.SystemServices.WAIT_NAMED_PIPE_TIME_OUT_FLAGS nTimeOut)
        {
            fixed (char *lpNamedPipeNameLocal = lpNamedPipeName)
            {
                bool __result = Kernel32.WaitNamedPipe(lpNamedPipeNameLocal, nTimeOut);
                return __result;
            }
        }

        /// <summary>Waits until either a time-out interval elapses or an instance of the specified named pipe is available for connection (that is, the pipe's server process has a pending ConnectNamedPipe operation on the pipe).</summary>
        /// <param name = "lpNamedPipeName">
        /// <para>The name of the named pipe. The string must include the name of the computer on which the server process is executing. A period may be used for the <i>servername</i> if the pipe is local. The following pipe name format is used:</para>
        /// <para>&#92; &#92;<i>servername</i>\pipe&#92;<i>pipename</i></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-waitnamedpipew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nTimeOut"></param>
        /// <returns>
        /// <para>If an instance of the pipe is available before the time-out interval elapses, the return value is nonzero.</para>
        /// <para>If an instance of the pipe is not available before the time-out interval elapses, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-waitnamedpipew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "WaitNamedPipeW")]
        internal static extern bool WaitNamedPipe(win32.System.SystemServices.PCWSTR lpNamedPipeName, win32.System.SystemServices.WAIT_NAMED_PIPE_TIME_OUT_FLAGS nTimeOut);
        /// <inheritdoc cref = "GetNamedPipeClientComputerName(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe bool GetNamedPipeClientComputerName(SafeHandle Pipe, win32.System.SystemServices.PWSTR ClientComputerName, uint ClientComputerNameLength)
        {
            bool PipeAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE PipeLocal;
                if (Pipe is object)
                {
                    Pipe.DangerousAddRef(ref PipeAddRef);
                    PipeLocal = (win32.System.SystemServices.HANDLE)Pipe.DangerousGetHandle();
                }
                else
                    PipeLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.GetNamedPipeClientComputerName(PipeLocal, ClientComputerName, ClientComputerNameLength);
                return __result;
            }
            finally
            {
                if (PipeAddRef)
                    Pipe.DangerousRelease();
            }
        }

        /// <summary>Retrieves the client computer name for the specified named pipe.</summary>
        /// <param name = "Pipe">
        /// <para>A handle to an instance of a named pipe. This handle must be created by the <a href = "https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-createnamedpipew">CreateNamedPipe</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-getnamedpipeclientcomputernamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ClientComputerName">The computer name.</param>
        /// <param name = "ClientComputerNameLength">The size of the <i>ClientComputerName</i> buffer, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-getnamedpipeclientcomputernamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetNamedPipeClientComputerNameW")]
        internal static extern bool GetNamedPipeClientComputerName(win32.System.SystemServices.HANDLE Pipe, win32.System.SystemServices.PWSTR ClientComputerName, uint ClientComputerNameLength);
        /// <inheritdoc cref = "GetNamedPipeInfo(win32.System.SystemServices.HANDLE, win32.System.SystemServices.NAMED_PIPE_INFO_FLAGS*, uint *, uint *, uint *)"/>
        internal static unsafe bool GetNamedPipeInfo(SafeHandle hNamedPipe, win32.System.SystemServices.NAMED_PIPE_INFO_FLAGS*lpFlags, uint *lpOutBufferSize, uint *lpInBufferSize, uint *lpMaxInstances)
        {
            bool hNamedPipeAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hNamedPipeLocal;
                if (hNamedPipe is object)
                {
                    hNamedPipe.DangerousAddRef(ref hNamedPipeAddRef);
                    hNamedPipeLocal = (win32.System.SystemServices.HANDLE)hNamedPipe.DangerousGetHandle();
                }
                else
                    hNamedPipeLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.GetNamedPipeInfo(hNamedPipeLocal, lpFlags, lpOutBufferSize, lpInBufferSize, lpMaxInstances);
                return __result;
            }
            finally
            {
                if (hNamedPipeAddRef)
                    hNamedPipe.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the specified named pipe.</summary>
        /// <param name = "hNamedPipe">
        /// <para>A handle to the named pipe instance. The handle must have GENERIC_READ access to the named pipe for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe.</para>
        /// <para>This parameter can also be a handle to an anonymous pipe, as returned by the <a href = "https://docs.microsoft.com/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe">CreatePipe</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-getnamedpipeinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFlags"></param>
        /// <param name = "lpOutBufferSize">A pointer to a variable that receives the size of the buffer for outgoing data, in bytes. If the buffer size is zero, the buffer is allocated as needed. This parameter can be <b>NULL</b> if this information is not required.</param>
        /// <param name = "lpInBufferSize">A pointer to a variable that receives the size of the buffer for incoming data, in bytes. If the buffer size is zero, the buffer is allocated as needed. This parameter can be <b>NULL</b> if this information is not required.</param>
        /// <param name = "lpMaxInstances">A pointer to a variable that receives the maximum number of pipe instances that can be created. If the variable is set to PIPE_UNLIMITED_INSTANCES (255), the number of pipe instances that can be created is limited only by the availability of system resources. This parameter can be <b>NULL</b> if this information is not required.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-getnamedpipeinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNamedPipeInfo(win32.System.SystemServices.HANDLE hNamedPipe, [Optional] win32.System.SystemServices.NAMED_PIPE_INFO_FLAGS*lpFlags, [Optional] uint *lpOutBufferSize, [Optional] uint *lpInBufferSize, [Optional] uint *lpMaxInstances);
        /// <inheritdoc cref = "GetNamedPipeHandleState(win32.System.SystemServices.HANDLE, win32.System.SystemServices.NAMED_PIPE_HANDLE_STATE*, uint *, uint *, uint *, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe bool GetNamedPipeHandleState(SafeHandle hNamedPipe, win32.System.SystemServices.NAMED_PIPE_HANDLE_STATE*lpState, uint *lpCurInstances, uint *lpMaxCollectionCount, uint *lpCollectDataTimeout, win32.System.SystemServices.PWSTR lpUserName, uint nMaxUserNameSize)
        {
            bool hNamedPipeAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hNamedPipeLocal;
                if (hNamedPipe is object)
                {
                    hNamedPipe.DangerousAddRef(ref hNamedPipeAddRef);
                    hNamedPipeLocal = (win32.System.SystemServices.HANDLE)hNamedPipe.DangerousGetHandle();
                }
                else
                    hNamedPipeLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.GetNamedPipeHandleState(hNamedPipeLocal, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
                return __result;
            }
            finally
            {
                if (hNamedPipeAddRef)
                    hNamedPipe.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about a specified named pipe.</summary>
        /// <param name = "hNamedPipe">
        /// <para>A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe.</para>
        /// <para>This parameter can also be a handle to an anonymous pipe, as returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-createpipe">CreatePipe</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-getnamedpipehandlestatew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpState"></param>
        /// <param name = "lpCurInstances">A pointer to a variable that receives the number of current pipe instances. This parameter can be <b>NULL</b> if this information is not required.</param>
        /// <param name = "lpMaxCollectionCount">A pointer to a variable that receives the maximum number of bytes to be collected on the client's computer before transmission to the server. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</param>
        /// <param name = "lpCollectDataTimeout">A pointer to a variable that receives the maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the network. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</param>
        /// <param name = "lpUserName">
        /// <para>A pointer to a buffer that receives the user name string associated with the client application. The server can only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.</para>
        /// <para>This parameter must be <b>NULL</b> if the specified pipe handle is to the client end of a named pipe. This parameter can be <b>NULL</b> if this information is not required.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-getnamedpipehandlestatew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nMaxUserNameSize">The size of the buffer specified by the <i>lpUserName</i> parameter, in <b>TCHARs</b>. This parameter is ignored if <i>lpUserName</i> is <b>NULL</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-getnamedpipehandlestatew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetNamedPipeHandleStateW")]
        internal static extern unsafe bool GetNamedPipeHandleState(win32.System.SystemServices.HANDLE hNamedPipe, [Optional] win32.System.SystemServices.NAMED_PIPE_HANDLE_STATE*lpState, [Optional] uint *lpCurInstances, [Optional] uint *lpMaxCollectionCount, [Optional] uint *lpCollectDataTimeout, win32.System.SystemServices.PWSTR lpUserName, uint nMaxUserNameSize);
        /// <inheritdoc cref = "CallNamedPipe(win32.System.SystemServices.PCWSTR, void *, uint, void *, uint, uint *, uint)"/>
        internal static unsafe bool CallNamedPipe(string lpNamedPipeName, void *lpInBuffer, uint nInBufferSize, void *lpOutBuffer, uint nOutBufferSize, out uint lpBytesRead, uint nTimeOut)
        {
            fixed (uint *lpBytesReadLocal = &lpBytesRead)
            {
                fixed (char *lpNamedPipeNameLocal = lpNamedPipeName)
                {
                    bool __result = Kernel32.CallNamedPipe(lpNamedPipeNameLocal, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReadLocal, nTimeOut);
                    return __result;
                }
            }
        }

        /// <summary>Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads from the pipe, and then closes the pipe.</summary>
        /// <param name = "lpNamedPipeName">The pipe name.</param>
        /// <param name = "lpInBuffer">The data to be written to the pipe.</param>
        /// <param name = "nInBufferSize">The size of the write buffer, in bytes.</param>
        /// <param name = "lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
        /// <param name = "nOutBufferSize">The size of the read buffer, in bytes.</param>
        /// <param name = "lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
        /// <param name = "nTimeOut">
        /// <para>The number of milliseconds to wait for the named pipe to be available. In addition to numeric values, the following special values can be specified.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-callnamedpipew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the message written to the pipe by the server process is longer than <i>nOutBufferSize</i>, <b>CallNamedPipe</b> returns <b>FALSE</b>, and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_MORE_DATA. The remainder of the message is discarded, because <b>CallNamedPipe</b> closes the handle to the pipe before returning.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//namedpipeapi/nf-namedpipeapi-callnamedpipew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CallNamedPipeW")]
        internal static extern unsafe bool CallNamedPipe(win32.System.SystemServices.PCWSTR lpNamedPipeName, [Optional] void *lpInBuffer, uint nInBufferSize, [Optional] void *lpOutBuffer, uint nOutBufferSize, uint *lpBytesRead, uint nTimeOut);
        /// <inheritdoc cref = "DisableThreadLibraryCalls(win32.System.SystemServices.HINSTANCE)"/>
        internal static unsafe bool DisableThreadLibraryCalls(SafeHandle hLibModule)
        {
            bool hLibModuleAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hLibModuleLocal;
                if (hLibModule is object)
                {
                    hLibModule.DangerousAddRef(ref hLibModuleAddRef);
                    hLibModuleLocal = (win32.System.SystemServices.HINSTANCE)hLibModule.DangerousGetHandle();
                }
                else
                    hLibModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                bool __result = Kernel32.DisableThreadLibraryCalls(hLibModuleLocal);
                return __result;
            }
            finally
            {
                if (hLibModuleAddRef)
                    hLibModule.DangerousRelease();
            }
        }

        /// <summary>Disables the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications for the specified dynamic-link library (DLL).</summary>
        /// <param name = "hLibModule">
        /// <para>A handle to the DLL module for which the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications are to be disabled. The <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>,  or <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> function returns this handle. Note that you cannot call <b>GetModuleHandle</b> with NULL because this returns the base address of the executable image, not the DLL image.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-disablethreadlibrarycalls#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. The <b>DisableThreadLibraryCalls</b> function fails if the DLL specified by <i>hModule</i> has active static thread local storage, or if <i>hModule</i> is an invalid module handle. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-disablethreadlibrarycalls">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DisableThreadLibraryCalls(win32.System.SystemServices.HINSTANCE hLibModule);
        /// <inheritdoc cref = "FindResourceEx(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, ushort)"/>
        internal static unsafe win32.System.SystemServices.HRSRC FindResourceEx(SafeHandle hModule, string lpType, string lpName, ushort wLanguage)
        {
            bool hModuleAddRef = false;
            try
            {
                fixed (char *lpNameLocal = lpName)
                {
                    fixed (char *lpTypeLocal = lpType)
                    {
                        win32.System.SystemServices.HINSTANCE hModuleLocal;
                        if (hModule is object)
                        {
                            hModule.DangerousAddRef(ref hModuleAddRef);
                            hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                        }
                        else
                            hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                        win32.System.SystemServices.HRSRC __result = Kernel32.FindResourceEx(hModuleLocal, lpTypeLocal, lpNameLocal, wLanguage);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Determines the location of the resource with the specified type, name, and language in the specified module.</summary>
        /// <param name = "hModule">
        /// <para>Type: <b>HMODULE</b></para>
        /// <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findresourceexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpType">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The resource type. Alternately, rather than a pointer, this parameter can be <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcew">MAKEINTRESOURCE</a>(ID), where ID is the integer identifier of the given resource type. For standard resource types, see <a href = "https://docs.microsoft.com/windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findresourceexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcew">MAKEINTRESOURCE</a>(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findresourceexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wLanguage">
        /// <para>Type: <b>WORD</b></para>
        /// <para>The language of the resource. If this parameter is <c>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</c>, the current language associated with the calling thread is used.</para>
        /// <para>To specify a language other than the current language, use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelangid">MAKELANGID</a> macro to create this parameter. For more information, see <b>MAKELANGID</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findresourceexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HRSRC</b></para>
        /// <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <a href = "/windows/desktop/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a> function.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findresourceexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindResourceExW")]
        internal static extern win32.System.SystemServices.HRSRC FindResourceEx(win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.PCWSTR lpType, win32.System.SystemServices.PCWSTR lpName, ushort wLanguage);
        /// <inheritdoc cref = "FreeLibraryAndExitThread(win32.System.SystemServices.HINSTANCE, uint)"/>
        internal static unsafe void FreeLibraryAndExitThread(SafeHandle hLibModule, uint dwExitCode)
        {
            bool hLibModuleAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hLibModuleLocal;
                if (hLibModule is object)
                {
                    hLibModule.DangerousAddRef(ref hLibModuleAddRef);
                    hLibModuleLocal = (win32.System.SystemServices.HINSTANCE)hLibModule.DangerousGetHandle();
                }
                else
                    hLibModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                Kernel32.FreeLibraryAndExitThread(hLibModuleLocal, dwExitCode);
            }
            finally
            {
                if (hLibModuleAddRef)
                    hLibModule.DangerousRelease();
            }
        }

        /// <summary>Decrements the reference count of a loaded dynamic-link library (DLL) by one, then calls ExitThread to terminate the calling thread.</summary>
        /// <param name = "hLibModule">
        /// <para>A handle to the DLL module whose reference count the function decrements. The <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
        /// <para>Do not call this function with a handle returned by either the <b>GetModuleHandleEx</b> function (with the GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT flag) or the <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> function, as they do not maintain a reference count for the module.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freelibraryandexitthread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwExitCode">The exit code for the calling thread.</param>
        /// <remarks>
        /// <para>The <b>FreeLibraryAndExitThread</b> function allows threads that are executing within a DLL to safely free the DLL in which they are executing and terminate themselves. If they were to call <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibrary">FreeLibrary</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a> separately, a race condition would exist. The library could be unloaded before <b>ExitThread</b> is called.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freelibraryandexitthread#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void FreeLibraryAndExitThread(win32.System.SystemServices.HINSTANCE hLibModule, uint dwExitCode);
        /// <inheritdoc cref = "GetModuleFileName(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint GetModuleFileName(SafeHandle hModule, win32.System.SystemServices.PWSTR lpFilename, uint nSize)
        {
            bool hModuleAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hModuleLocal;
                if (hModule is object)
                {
                    hModule.DangerousAddRef(ref hModuleAddRef);
                    hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                }
                else
                    hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                uint __result = Kernel32.GetModuleFileName(hModuleLocal, lpFilename, nSize);
                return __result;
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.</summary>
        /// <param name = "hModule">
        /// <para>A handle to the loaded module whose path is being requested. If this parameter is <b>NULL</b>, <b>GetModuleFileName</b> retrieves the path of the executable file of the current process.</para>
        /// <para>The <b>GetModuleFileName</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulefilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFilename">
        /// <para>A pointer to a buffer that receives the fully qualified path of the module. If the length of the path is less than the size that the <i>nSize</i> parameter specifies, the function succeeds and the path is returned as a null-terminated string.</para>
        /// <para>If the length of the path exceeds the size that  the <i>nSize</i> parameter specifies, the function succeeds and the string is truncated to <i>nSize</i>  characters including the terminating null character.</para>
        /// <para><b>Windows XP:  </b>The string is truncated to <i>nSize</i> characters and is not null-terminated.</para>
        /// <para>The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and can use the prefix "\\?\". For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulefilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nSize">The size of the <i>lpFilename</i> buffer, in <b>TCHARs</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating null character. If the buffer is too small to hold the module name, the string is truncated to <i>nSize</i> characters including the terminating null character, the function returns <i>nSize</i>, and the function sets the last error to <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
        /// <para><b>Windows XP:  </b>If the buffer is too small to hold the module name, the function returns <i>nSize</i>. The last error code remains <b>ERROR_SUCCESS</b>. If <i>nSize</i> is zero, the return value is zero and the last error code is <b>ERROR_SUCCESS</b>.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulefilenamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetModuleFileNameW", SetLastError = true)]
        internal static extern uint GetModuleFileName(win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.PWSTR lpFilename, uint nSize);
        /// <inheritdoc cref = "GetModuleHandle(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Kernel32.FreeLibrarySafeHandle GetModuleHandle(string lpModuleName)
        {
            fixed (char *lpModuleNameLocal = lpModuleName)
            {
                win32.System.SystemServices.HINSTANCE __result = Kernel32.GetModuleHandle(lpModuleNameLocal);
                return new Kernel32.FreeLibrarySafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "Kernel32.FreeLibrary"/>.
        /// </summary>
        internal class FreeLibrarySafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal FreeLibrarySafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal FreeLibrarySafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => Kernel32.FreeLibrary((win32.System.SystemServices.HINSTANCE)this.handle);
        }

        /// <summary>Retrieves a module handle for the specified module. The module must have been loaded by the calling process.</summary>
        /// <param name = "lpModuleName">
        /// <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
        /// <para>If this parameter is NULL, <b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file).</para>
        /// <para>The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulehandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the specified module.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulehandlew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetModuleHandleW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HINSTANCE GetModuleHandle(win32.System.SystemServices.PCWSTR lpModuleName);
        /// <inheritdoc cref = "GetModuleHandleEx(uint, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.HINSTANCE*)"/>
        internal static unsafe bool GetModuleHandleEx(uint dwFlags, string lpModuleName, out Kernel32.FreeLibrarySafeHandle phModule)
        {
            fixed (char *lpModuleNameLocal = lpModuleName)
            {
                win32.System.SystemServices.HINSTANCE phModuleLocal;
                bool __result = Kernel32.GetModuleHandleEx(dwFlags, lpModuleNameLocal, &phModuleLocal);
                phModule = new Kernel32.FreeLibrarySafeHandle(phModuleLocal, ownsHandle: true);
                return __result;
            }
        }

        /// <summary>Retrieves a module handle for the specified module and increments the module's reference count unless GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT is specified. The module must have been loaded by the calling process.</summary>
        /// <param name = "dwFlags"></param>
        /// <param name = "lpModuleName">
        /// <para>The name of the loaded module (either a .dll or .exe file), or an address in the module (if <i>dwFlags</i> is GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS).</para>
        /// <para>For a module name, if the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
        /// <para>If this parameter is NULL, the function returns a handle to the file used to create the calling process (.exe file).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulehandleexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "phModule">
        /// <para>A handle to the specified module. If the function fails, this parameter is NULL.</para>
        /// <para>The <b>GetModuleHandleEx</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulehandleexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, see <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulehandleexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetModuleHandleExW", SetLastError = true)]
        internal static extern unsafe bool GetModuleHandleEx(uint dwFlags, win32.System.SystemServices.PCWSTR lpModuleName, win32.System.SystemServices.HINSTANCE*phModule);
        /// <inheritdoc cref = "GetProcAddress(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCSTR)"/>
        internal static unsafe delegate *unmanaged[Stdcall]<nint>GetProcAddress(SafeHandle hModule, win32.System.SystemServices.PCSTR lpProcName)
        {
            bool hModuleAddRef = false;
            try
            {
                win32.System.SystemServices.HINSTANCE hModuleLocal;
                if (hModule is object)
                {
                    hModule.DangerousAddRef(ref hModuleAddRef);
                    hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                }
                else
                    hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                delegate *unmanaged[Stdcall]<nint>__result = Kernel32.GetProcAddress(hModuleLocal, lpProcName);
                return __result;
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).</summary>
        /// <param name = "hModule">
        /// <para>A handle to the DLL module that contains the function or variable. The <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-loadpackagedlibrary">LoadPackagedLibrary</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> function returns this handle.</para>
        /// <para>The <b>GetProcAddress</b> function does not retrieve addresses from modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getprocaddress#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpProcName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the address of the exported function or variable.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getprocaddress">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe delegate *unmanaged[Stdcall]<nint>GetProcAddress(win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.PCSTR lpProcName);
        /// <inheritdoc cref = "LoadLibraryEx(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.HANDLE, win32.System.SystemServices.LOAD_LIBRARY_FLAGS)"/>
        internal static unsafe Kernel32.FreeLibrarySafeHandle LoadLibraryEx(string lpLibFileName, SafeHandle hFile, win32.System.SystemServices.LOAD_LIBRARY_FLAGS dwFlags)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (char *lpLibFileNameLocal = lpLibFileName)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.HINSTANCE __result = Kernel32.LoadLibraryEx(lpLibFileNameLocal, hFileLocal, dwFlags);
                    return new Kernel32.FreeLibrarySafeHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Loads the specified module into the address space of the calling process.</summary>
        /// <param name = "lpLibFileName">
        /// <para>A string that specifies the file name of the module to load. This name is not related to the name stored in a library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file.</para>
        /// <para>The module can be a library module (a .dll file) or an executable module (an .exe file). If the specified module is an executable module, static imports are not loaded; instead, the module is loaded as if <b>DONT_RESOLVE_DLL_REFERENCES</b> was specified. See the <i>dwFlags</i> parameter for more information.</para>
        /// <para>If the string specifies a module name without a path and the file name extension is omitted, and the module name does not contain any point character (.), then the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.</para>
        /// <para>If the string specifies a fully qualified path, the function searches only that path for the module. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
        /// <para>If the string specifies a module name without a path and more than one loaded module has the same base name and extension, the function returns a handle to the module that was loaded first.</para>
        /// <para>If the string specifies a module name without a path and a module of the same name is not already loaded, or if the string specifies a module name with a relative path, the function searches for the specified module. The function also searches for modules if loading the specified module causes the system to load other associated modules (that is, if the module has dependencies). The directories that are searched and the order in which they are searched depend on the specified path and the <i>dwFlags</i> parameter. For more information, see Remarks.</para>
        /// <para>If the function cannot find the  module or one of its dependencies, the function fails.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadlibraryexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hFile">This parameter is reserved for future use. It must be <b>NULL</b>.</param>
        /// <param name = "dwFlags">
        /// <para>The action to be taken when loading the module. If no flags are specified, the behavior of this function is identical to that of the <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function. This</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadlibraryexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the loaded module.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadlibraryexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "LoadLibraryExW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HINSTANCE LoadLibraryEx(win32.System.SystemServices.PCWSTR lpLibFileName, win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.LOAD_LIBRARY_FLAGS dwFlags);
        /// <inheritdoc cref = "AddDllDirectory(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe void *AddDllDirectory(string NewDirectory)
        {
            fixed (char *NewDirectoryLocal = NewDirectory)
            {
                void *__result = Kernel32.AddDllDirectory(NewDirectoryLocal);
                return __result;
            }
        }

        /// <summary>Adds a directory to the process DLL search path.</summary>
        /// <param name = "NewDirectory">
        /// <para>An absolute path to the directory to add to the search path. For example, to add the directory Dir2 to the process DLL search path, specify \Dir2. For more information about paths, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-adddlldirectory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is an opaque pointer that can be passed to <a href = "/windows/desktop/api/libloaderapi/nf-libloaderapi-removedlldirectory">RemoveDllDirectory</a> to remove the DLL from the process DLL search path.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-adddlldirectory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *AddDllDirectory(win32.System.SystemServices.PCWSTR NewDirectory);
        /// <summary>Removes a directory that was added to the process DLL search path by using AddDllDirectory.</summary>
        /// <param name = "Cookie">
        /// <para>The cookie returned by <a href = "https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-adddlldirectory">AddDllDirectory</a> when the directory was added to the search path.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-removedlldirectory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-removedlldirectory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool RemoveDllDirectory(void *Cookie);
        /// <summary>Specifies a default set of directories to search when the calling process loads a DLL. This search path is used when LoadLibraryEx is called with no LOAD_LIBRARY_SEARCH flags.</summary>
        /// <param name = "DirectoryFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-setdefaultdlldirectories">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetDefaultDllDirectories(win32.System.SystemServices.LOAD_LIBRARY_FLAGS DirectoryFlags);
        /// <inheritdoc cref = "FindResource(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.SystemServices.HRSRC FindResource(SafeHandle hModule, string lpName, string lpType)
        {
            bool hModuleAddRef = false;
            try
            {
                fixed (char *lpTypeLocal = lpType)
                {
                    fixed (char *lpNameLocal = lpName)
                    {
                        win32.System.SystemServices.HINSTANCE hModuleLocal;
                        if (hModule is object)
                        {
                            hModule.DangerousAddRef(ref hModuleAddRef);
                            hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                        }
                        else
                            hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                        win32.System.SystemServices.HRSRC __result = Kernel32.FindResource(hModuleLocal, lpNameLocal, lpTypeLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Determines the location of a resource with the specified type and name in the specified module.</summary>
        /// <param name = "hModule">
        /// <para>Type: <b>HMODULE</b></para>
        /// <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a>(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpType">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The resource type. Alternately, rather than a pointer, this parameter can be <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcew">MAKEINTRESOURCE</a>(ID), where ID is the integer identifier of the given</para>
        /// <para>resource type. For standard resource types, see <a href = "https://docs.microsoft.com/windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findresourcew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HRSRC</b></para>
        /// <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <a href = "/windows/desktop/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a> function.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findresourcew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindResourceW")]
        internal static extern win32.System.SystemServices.HRSRC FindResource(win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.PCWSTR lpName, win32.System.SystemServices.PCWSTR lpType);
        /// <inheritdoc cref = "LoadLibrary(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Kernel32.FreeLibrarySafeHandle LoadLibrary(string lpLibFileName)
        {
            fixed (char *lpLibFileNameLocal = lpLibFileName)
            {
                win32.System.SystemServices.HINSTANCE __result = Kernel32.LoadLibrary(lpLibFileNameLocal);
                return new Kernel32.FreeLibrarySafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Loads the specified module into the address space of the calling process.</summary>
        /// <param name = "lpLibFileName">
        /// <para>The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file). The name specified is the file name of the module and is not related to the name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file.</para>
        /// <para>If the string specifies a full path, the function searches only that path for the module.</para>
        /// <para>If the string specifies a relative path or a module name without a path, the function uses a standard search strategy to find the module; for more information, see the Remarks.</para>
        /// <para>If the function cannot find the  module, the function fails. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>.</para>
        /// <para>If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadlibraryw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the module.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadlibraryw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "LoadLibraryW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HINSTANCE LoadLibrary(win32.System.SystemServices.PCWSTR lpLibFileName);
        /// <inheritdoc cref = "EnumResourceNames(win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, delegate *unmanaged[Stdcall]{win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL}, nint)"/>
        internal static unsafe bool EnumResourceNames(SafeHandle hModule, string lpType, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam)
        {
            bool hModuleAddRef = false;
            try
            {
                fixed (char *lpTypeLocal = lpType)
                {
                    win32.System.SystemServices.HINSTANCE hModuleLocal;
                    if (hModule is object)
                    {
                        hModule.DangerousAddRef(ref hModuleAddRef);
                        hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                    }
                    else
                        hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                    bool __result = Kernel32.EnumResourceNames(hModuleLocal, lpTypeLocal, lpEnumFunc, lParam);
                    return __result;
                }
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Enumerates resources of a specified type within a binary module.</summary>
        /// <param name = "hModule">
        /// <para>Type: **HMODULE**</para>
        /// <para>A handle to a module to be searched. Starting with Windows Vista, if this is an LN file, then appropriate .mui files (if any exist) are included in the search.</para>
        /// <para>If this parameter is **NULL**, that is equivalent to passing in a handle to the module used to create the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpType">
        /// <para>Type: **LPCTSTR**</para>
        /// <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be [MAKEINTRESOURCE](/windows/desktop/api/winuser/nf-winuser-makeintresourcea)(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see [Resource Types](/windows/win32/menurc/resource-types). For more information, see the [Remarks](#remarks) section below.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEnumFunc">
        /// <para>Type: **ENUMRESNAMEPROC**</para>
        /// <para>A pointer to the callback function to be called for each enumerated resource name or ID. For more information, see [ENUMRESNAMEPROC](/windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameprocw).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: **LONG_PTR**</para>
        /// <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: **BOOL**</para>
        /// <para>The return value is **TRUE** if the function succeeds or **FALSE** if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call [GetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-enumresourcenamesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumResourceNamesW")]
        internal static extern unsafe bool EnumResourceNames(win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.PCWSTR lpType, delegate *unmanaged[Stdcall]<win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL>lpEnumFunc, nint lParam);
        /// <inheritdoc cref = "DeviceIoControl(win32.System.SystemServices.HANDLE, uint, void *, uint, void *, uint, uint *, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool DeviceIoControl(SafeHandle hDevice, uint dwIoControlCode, void *lpInBuffer, uint nInBufferSize, void *lpOutBuffer, uint nOutBufferSize, uint *lpBytesReturned, win32.System.SystemServices.OVERLAPPED*lpOverlapped)
        {
            bool hDeviceAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDeviceLocal;
                if (hDevice is object)
                {
                    hDevice.DangerousAddRef(ref hDeviceAddRef);
                    hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                }
                else
                    hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.DeviceIoControl(hDeviceLocal, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
                return __result;
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.</summary>
        /// <param name = "hDevice">
        /// <para>A handle to the device on which the operation is to be performed. The device is typically a volume, directory, file, or stream. To retrieve a device handle, use the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function. For more information, see Remarks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwIoControlCode">
        /// <para>The control code for the operation. This value identifies the specific operation to be performed and the type of device on which to perform it.</para>
        /// <para>For a list of the control codes, see Remarks. The documentation for each control code provides usage details for the <i>lpInBuffer</i>, <i>nInBufferSize</i>, <i>lpOutBuffer</i>, and <i>nOutBufferSize</i> parameters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpInBuffer">
        /// <para>A pointer to the input buffer that contains the data required to perform the operation. The format of this data depends on the value of the <i>dwIoControlCode</i> parameter.</para>
        /// <para>This parameter can be <b>NULL</b> if <i>dwIoControlCode</i> specifies an operation that does not require input data.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nInBufferSize">The size of the input buffer, in bytes.</param>
        /// <param name = "lpOutBuffer">
        /// <para>A pointer to the output buffer that is to receive the data returned by the operation. The format of this data depends on the value of the <i>dwIoControlCode</i> parameter.</para>
        /// <para>This parameter can be <b>NULL</b> if <i>dwIoControlCode</i> specifies an operation that does not return data.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nOutBufferSize">The size of the output buffer, in bytes.</param>
        /// <param name = "lpBytesReturned">
        /// <para>A pointer to a variable that receives the size of the data stored in the output buffer, in bytes.</para>
        /// <para>If the output buffer is too small to receive any data,  the call fails, <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INSUFFICIENT_BUFFER</b>, and <i>lpBytesReturned</i> is zero.</para>
        /// <para>If the output buffer is too small to hold all of the data but can hold some entries, some drivers will return as much data as fits. In this case, the call fails, <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_MORE_DATA</b>, and <i>lpBytesReturned</i> indicates the amount of data received. Your application should call <b>DeviceIoControl</b> again with the same operation, specifying a new starting point.</para>
        /// <para>If <i>lpOverlapped</i> is <b>NULL</b>, <i>lpBytesReturned</i> cannot be <b>NULL</b>. Even when an operation returns no output data and <i>lpOutBuffer</i> is <b>NULL</b>, <b>DeviceIoControl</b> makes use of <i>lpBytesReturned</i>. After such an operation, the value of <i>lpBytesReturned</i> is meaningless.</para>
        /// <para>If <i>lpOverlapped</i> is not <b>NULL</b>, <i>lpBytesReturned</i> can be <b>NULL</b>. If this parameter is not <b>NULL</b> and the operation returns data, <i>lpBytesReturned</i> is meaningless until the overlapped operation has completed. To retrieve the number of bytes returned, call <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a>. If <i>hDevice</i> is associated with an I/O completion port, you can retrieve the number of bytes returned by calling <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.</para>
        /// <para>If <i>hDevice</i> was opened without specifying <b>FILE_FLAG_OVERLAPPED</b>, <i>lpOverlapped</i> is ignored.</para>
        /// <para>If <i>hDevice</i> was opened with the <b>FILE_FLAG_OVERLAPPED</b> flag, the operation is performed as an overlapped (asynchronous) operation. In this case, <i>lpOverlapped</i> must point to a valid <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that contains a handle to an event object. Otherwise, the function fails in unpredictable ways.</para>
        /// <para>For overlapped operations, <b>DeviceIoControl</b> returns immediately, and the event object is signaled when the operation has been completed. Otherwise, the function does not return until the operation has been completed or an error occurs.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the operation completes successfully, the return value is nonzero.</para>
        /// <para>If the operation fails or is pending, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-deviceiocontrol">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool DeviceIoControl(win32.System.SystemServices.HANDLE hDevice, uint dwIoControlCode, [Optional] void *lpInBuffer, uint nInBufferSize, [Optional] void *lpOutBuffer, uint nOutBufferSize, [Optional] uint *lpBytesReturned, [Optional] win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <inheritdoc cref = "GetOverlappedResult(win32.System.SystemServices.HANDLE, win32.System.SystemServices.OVERLAPPED*, uint *, bool)"/>
        internal static unsafe bool GetOverlappedResult(SafeHandle hFile, in win32.System.SystemServices.OVERLAPPED lpOverlapped, out uint lpNumberOfBytesTransferred, bool bWait)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (uint *lpNumberOfBytesTransferredLocal = &lpNumberOfBytesTransferred)
                {
                    fixed (win32.System.SystemServices.OVERLAPPED*lpOverlappedLocal = &lpOverlapped)
                    {
                        win32.System.SystemServices.HANDLE hFileLocal;
                        if (hFile is object)
                        {
                            hFile.DangerousAddRef(ref hFileAddRef);
                            hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                        }
                        else
                            hFileLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.GetOverlappedResult(hFileLocal, lpOverlappedLocal, lpNumberOfBytesTransferredLocal, bWait);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file, named pipe, or communications device. This is the same handle that was specified when the overlapped operation was started by a call to any of the following functions:</para>
        /// <para>- [ReadFile](../fileapi/nf-fileapi-readfile.md) - [WriteFile](../fileapi/nf-fileapi-writefile.md) - [ConnectNamedPipe](../namedpipeapi/nf-namedpipeapi-connectnamedpipe.md) - [TransactNamedPipe](../namedpipeapi/nf-namedpipeapi-transactnamedpipe.md) - [DeviceIoControl](./nf-ioapiset-deviceiocontrol.md) - [WaitCommEvent](../winbase/nf-winbase-waitcommevent.md) - [ReadDirectoryChangesW](../winbase/nf-winbase-readdirectorychangesw.md) - [LockFileEx](../fileapi/nf-fileapi-lockfileex.md) - [ReadDirectoryChangesW](../winbase/nf-winbase-readdirectorychangesw.md)</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getoverlappedresult#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that was specified when the overlapped operation was started.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getoverlappedresult#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNumberOfBytesTransferred">
        /// <para>A pointer to a variable that receives the number of bytes that were actually transferred by a read or write operation. For a <a href = "https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe">TransactNamedPipe</a> operation, this is the number of bytes that were read from the pipe. For a <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> operation, this is the number of bytes of output data returned by the device driver. For a <a href = "https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe">ConnectNamedPipe</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-waitcommevent">WaitCommEvent</a> operation, this value is undefined.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getoverlappedresult#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bWait">
        /// <para>If this parameter is <b>TRUE</b>, and the <b>Internal</b> member of the <i>lpOverlapped</i> structure is <b>STATUS_PENDING</b>, the function does not return until the operation has been completed. If this parameter is <b>FALSE</b> and the operation is still pending, the function returns <b>FALSE</b> and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_IO_INCOMPLETE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getoverlappedresult#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getoverlappedresult">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetOverlappedResult(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.OVERLAPPED*lpOverlapped, uint *lpNumberOfBytesTransferred, bool bWait);
        /// <inheritdoc cref = "GetOverlappedResultEx(win32.System.SystemServices.HANDLE, win32.System.SystemServices.OVERLAPPED*, uint *, uint, bool)"/>
        internal static unsafe bool GetOverlappedResultEx(SafeHandle hFile, in win32.System.SystemServices.OVERLAPPED lpOverlapped, out uint lpNumberOfBytesTransferred, uint dwMilliseconds, bool bAlertable)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (uint *lpNumberOfBytesTransferredLocal = &lpNumberOfBytesTransferred)
                {
                    fixed (win32.System.SystemServices.OVERLAPPED*lpOverlappedLocal = &lpOverlapped)
                    {
                        win32.System.SystemServices.HANDLE hFileLocal;
                        if (hFile is object)
                        {
                            hFile.DangerousAddRef(ref hFileAddRef);
                            hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                        }
                        else
                            hFileLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.GetOverlappedResultEx(hFileLocal, lpOverlappedLocal, lpNumberOfBytesTransferredLocal, dwMilliseconds, bAlertable);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device within the specified time-out interval. The calling thread can perform an alertable wait.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file, named pipe, or communications device. This is the same handle that was specified when the overlapped operation was started by a call to the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-readfile">ReadFile</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe">ConnectNamedPipe</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe">TransactNamedPipe</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-waitcommevent">WaitCommEvent</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getoverlappedresultex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that was specified when the overlapped operation was started.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getoverlappedresultex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNumberOfBytesTransferred">
        /// <para>A pointer to a variable that receives the number of bytes that were actually transferred by a read or write operation. For a <a href = "https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe">TransactNamedPipe</a> operation, this is the number of bytes that were read from the pipe. For a <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> operation, this is the number of bytes of output data returned by the device driver. For a <a href = "https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe">ConnectNamedPipe</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-waitcommevent">WaitCommEvent</a> operation, this value is undefined.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getoverlappedresultex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMilliseconds">
        /// <para>The time-out interval, in milliseconds.</para>
        /// <para>If <i>dwMilliseconds</i> is zero and the operation is still in progress, the function  returns immediately and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_IO_INCOMPLETE</b>.</para>
        /// <para>If <i>dwMilliseconds</i> is nonzero and the operation is still in progress, the function waits until the object is signaled, an I/O completion routine or APC is queued, or the interval elapses before returning. Use <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information.</para>
        /// <para>If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function returns only when the object is signaled or an I/O completion routine or APC is queued.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getoverlappedresultex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bAlertable">
        /// <para>If this parameter is <b>TRUE</b> and the calling thread is in the waiting state, the function returns when the system queues an I/O completion routine or APC. The calling thread then runs the routine or function. Otherwise, the function does not return, and the completion routine or APC function is not executed.</para>
        /// <para>A completion routine is queued when the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefileex">WriteFileEx</a> function in which it was specified has completed. The function returns and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b>, and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-queueuserapc">QueueUserAPC</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getoverlappedresultex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Common error codes include the following:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getoverlappedresultex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetOverlappedResultEx(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.OVERLAPPED*lpOverlapped, uint *lpNumberOfBytesTransferred, uint dwMilliseconds, bool bAlertable);
        /// <inheritdoc cref = "IsWow64Process(win32.System.SystemServices.HANDLE, bool *)"/>
        internal static unsafe bool IsWow64Process(SafeHandle hProcess, out bool Wow64Process)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (bool *Wow64ProcessLocal = &Wow64Process)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.IsWow64Process(hProcessLocal, Wow64ProcessLocal);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Determines whether the specified process is running under WOW64 or an Intel64 of x64 processor.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the PROCESS_QUERY_INFORMATION access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-iswow64process#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Wow64Process">A pointer to a value that is set to TRUE if the process is running under WOW64 on an Intel64 or x64 processor. If the process is running under 32-bit Windows, the value is set to FALSE. If the process is a 32-bit application running under 64-bit Windows 10 on ARM, the value is set to FALSE. If the process is a 64-bit application running under 64-bit Windows, the value is also set to FALSE.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-iswow64process">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool IsWow64Process(win32.System.SystemServices.HANDLE hProcess, bool *Wow64Process);
        /// <inheritdoc cref = "IsWow64Process2(win32.System.SystemServices.HANDLE, ushort *, ushort *)"/>
        internal static unsafe bool IsWow64Process2(SafeHandle hProcess, out ushort pProcessMachine, ushort *pNativeMachine)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (ushort *pProcessMachineLocal = &pProcessMachine)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.IsWow64Process2(hProcessLocal, pProcessMachineLocal, pNativeMachine);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Determines whether the specified process is running under WOW64; also returns additional machine process and architecture information.</summary>
        /// <param name = "hProcess">A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
        /// <param name = "pProcessMachine">On success, returns a pointer to an <a href = "https://docs.microsoft.com/windows/desktop/SysInfo/image-file-machine-constants">IMAGE_FILE_MACHINE_*</a> value. The value will be  <b>IMAGE_FILE_MACHINE_UNKNOWN</b> if the target process is not a <a href = "https://docs.microsoft.com/windows/desktop/WinProg64/running-32-bit-applications">WOW64</a> process; otherwise, it will identify the type of WoW process.</param>
        /// <param name = "pNativeMachine">On success, returns a pointer to a possible <a href = "https://docs.microsoft.com/windows/desktop/SysInfo/image-file-machine-constants">IMAGE_FILE_MACHINE_*</a> value identifying the native architecture of host system.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-iswow64process2">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool IsWow64Process2(win32.System.SystemServices.HANDLE hProcess, ushort *pProcessMachine, [Optional] ushort *pNativeMachine);
        /// <inheritdoc cref = "GlobalMemoryStatus(win32.System.SystemServices.MEMORYSTATUS*)"/>
        internal static unsafe void GlobalMemoryStatus(out win32.System.SystemServices.MEMORYSTATUS lpBuffer)
        {
            fixed (win32.System.SystemServices.MEMORYSTATUS*lpBufferLocal = &lpBuffer)
            {
                Kernel32.GlobalMemoryStatus(lpBufferLocal);
            }
        }

        /// <summary>Retrieves information about the system's current usage of both physical and virtual memory.</summary>
        /// <param name = "lpBuffer">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-memorystatus">MEMORYSTATUS</a> structure. The <b>GlobalMemoryStatus</b> function stores information about current memory availability into this structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalmemorystatus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>On computers with more than 4 GB of memory, the <b>GlobalMemoryStatus</b> function can return incorrect information, reporting a value of –1 to indicate an overflow. For this reason, applications should use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex">GlobalMemoryStatusEx</a> function instead.</para>
        /// <para>On Intel x86 computers with more than 2 GB and less than 4 GB of memory, the <b>GlobalMemoryStatus</b> function will always return 2 GB in the <b>dwTotalPhys</b> member of the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-memorystatus">MEMORYSTATUS</a> structure. Similarly, if the total available memory is between 2 and 4 GB, the <b>dwAvailPhys</b> member of the <b>MEMORYSTATUS</b> structure will be rounded down to 2 GB. If the executable is linked using the <b>/LARGEADDRESSAWARE</b> linker option, then the <b>GlobalMemoryStatus</b> function will return the correct amount of physical memory in both members.</para>
        /// <para>The information returned by the <b>GlobalMemoryStatus</b> function is volatile. There is no guarantee that two sequential calls to this function will return the same information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalmemorystatus#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void GlobalMemoryStatus(win32.System.SystemServices.MEMORYSTATUS*lpBuffer);
        /// <inheritdoc cref = "GetProcessAffinityMask(win32.System.SystemServices.HANDLE, nuint*, nuint*)"/>
        internal static unsafe bool GetProcessAffinityMask(SafeHandle hProcess, out nuint lpProcessAffinityMask, out nuint lpSystemAffinityMask)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (nuint*lpSystemAffinityMaskLocal = &lpSystemAffinityMask)
                {
                    fixed (nuint*lpProcessAffinityMaskLocal = &lpProcessAffinityMask)
                    {
                        win32.System.SystemServices.HANDLE hProcessLocal;
                        if (hProcess is object)
                        {
                            hProcess.DangerousAddRef(ref hProcessAddRef);
                            hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                        }
                        else
                            hProcessLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.GetProcessAffinityMask(hProcessLocal, lpProcessAffinityMaskLocal, lpSystemAffinityMaskLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the process affinity mask for the specified process and the system affinity mask for the system.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process whose affinity mask is desired.</para>
        /// <para>This handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprocessaffinitymask#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpProcessAffinityMask">A pointer to a variable that receives the affinity mask for the specified process.</param>
        /// <param name = "lpSystemAffinityMask">A pointer to a variable that receives the affinity mask for the system.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero and the function sets the variables pointed to by <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i> to the appropriate affinity masks.</para>
        /// <para>On a system with more than 64 processors, if the threads of the calling process are in a single <a href = "/windows/desktop/ProcThread/processor-groups">processor group</a>, the function sets the variables pointed to by <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i> to the process affinity mask and the processor mask of active logical processors for that group. If the calling process contains threads in multiple groups, the function returns zero for both affinity masks.</para>
        /// <para>If the function fails, the return value is zero, and the values of the variables pointed to by <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i> are undefined. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprocessaffinitymask">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessAffinityMask(win32.System.SystemServices.HANDLE hProcess, nuint*lpProcessAffinityMask, nuint*lpSystemAffinityMask);
        /// <inheritdoc cref = "SetProcessAffinityMask(win32.System.SystemServices.HANDLE, nuint)"/>
        internal static unsafe bool SetProcessAffinityMask(SafeHandle hProcess, nuint dwProcessAffinityMask)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetProcessAffinityMask(hProcessLocal, dwProcessAffinityMask);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Sets a processor affinity mask for the threads of the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process whose affinity mask is to be set. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setprocessaffinitymask#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwProcessAffinityMask">
        /// <para>The affinity mask for the threads of the process.</para>
        /// <para>On a system with more than 64 processors, the affinity mask must specify processors in a single <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/processor-groups">processor group</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setprocessaffinitymask#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the process affinity mask requests a processor that is not configured in the system, the last error code is <b>ERROR_INVALID_PARAMETER</b>.</para>
        /// <para>On a system with more than 64 processors, if the calling process contains threads in more than one processor group, the last error code is <b>ERROR_INVALID_PARAMETER</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setprocessaffinitymask">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetProcessAffinityMask(win32.System.SystemServices.HANDLE hProcess, nuint dwProcessAffinityMask);
        /// <inheritdoc cref = "GetProcessIoCounters(win32.System.SystemServices.HANDLE, win32.System.SystemServices.IO_COUNTERS*)"/>
        internal static unsafe bool GetProcessIoCounters(SafeHandle hProcess, out win32.System.SystemServices.IO_COUNTERS lpIoCounters)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.IO_COUNTERS*lpIoCountersLocal = &lpIoCounters)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetProcessIoCounters(hProcessLocal, lpIoCountersLocal);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves accounting information for all I/O operations performed by the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprocessiocounters#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpIoCounters">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-io_counters">IO_COUNTERS</a> structure that receives the I/O accounting information for the process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprocessiocounters#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprocessiocounters">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessIoCounters(win32.System.SystemServices.HANDLE hProcess, win32.System.SystemServices.IO_COUNTERS*lpIoCounters);
        /// <inheritdoc cref = "GetProcessWorkingSetSize(win32.System.SystemServices.HANDLE, nuint*, nuint*)"/>
        internal static unsafe bool GetProcessWorkingSetSize(SafeHandle hProcess, out nuint lpMinimumWorkingSetSize, out nuint lpMaximumWorkingSetSize)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (nuint*lpMaximumWorkingSetSizeLocal = &lpMaximumWorkingSetSize)
                {
                    fixed (nuint*lpMinimumWorkingSetSizeLocal = &lpMinimumWorkingSetSize)
                    {
                        win32.System.SystemServices.HANDLE hProcessLocal;
                        if (hProcess is object)
                        {
                            hProcess.DangerousAddRef(ref hProcessAddRef);
                            hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                        }
                        else
                            hProcessLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.GetProcessWorkingSetSize(hProcessLocal, lpMinimumWorkingSetSizeLocal, lpMaximumWorkingSetSizeLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the minimum and maximum working set sizes of the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process whose working set sizes will be obtained. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprocessworkingsetsize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMinimumWorkingSetSize">A pointer to a variable that receives the minimum working set size of the specified process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</param>
        /// <param name = "lpMaximumWorkingSetSize">A pointer to a variable that receives the maximum working set size of the specified process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active when memory is in short supply.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprocessworkingsetsize">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessWorkingSetSize(win32.System.SystemServices.HANDLE hProcess, nuint*lpMinimumWorkingSetSize, nuint*lpMaximumWorkingSetSize);
        /// <inheritdoc cref = "SetProcessWorkingSetSize(win32.System.SystemServices.HANDLE, nuint, nuint)"/>
        internal static unsafe bool SetProcessWorkingSetSize(SafeHandle hProcess, nuint dwMinimumWorkingSetSize, nuint dwMaximumWorkingSetSize)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetProcessWorkingSetSize(hProcessLocal, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Sets the minimum and maximum working set sizes for the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process whose working set sizes is to be set.</para>
        /// <para>The handle must have the <b>PROCESS_SET_QUOTA</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setprocessworkingsetsize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMinimumWorkingSetSize">
        /// <para>The minimum working set size for the process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</para>
        /// <para>This parameter must be greater than zero but less than or equal to the maximum working set size. The default size is 50 pages (for example, this is 204,800 bytes on systems with a 4K page size). If the value is greater than zero but less than 20 pages, the minimum value is set to 20 pages.</para>
        /// <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setprocessworkingsetsize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMaximumWorkingSetSize">
        /// <para>The maximum working set size for the process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active and available memory is low.</para>
        /// <para>This parameter must be greater than or equal to 13 pages (for example, 53,248 on systems with a 4K page size), and less than the system-wide maximum (number of available pages minus 512 pages). The default size is 345 pages (for example, this is 1,413,120 bytes on systems with a 4K page size).</para>
        /// <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setprocessworkingsetsize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. Call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to obtain extended error information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setprocessworkingsetsize">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetProcessWorkingSetSize(win32.System.SystemServices.HANDLE hProcess, nuint dwMinimumWorkingSetSize, nuint dwMaximumWorkingSetSize);
        /// <summary>Schedules a fiber. The function must be called on a fiber.</summary>
        /// <param name = "lpFiber">The address of the fiber to be scheduled.</param>
        /// <remarks>
        /// <para>You create fibers with the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfiber">CreateFiber</a> function. Before you can schedule fibers associated with a thread, you must call <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-convertthreadtofiber">ConvertThreadToFiber</a> to set up an area in which to save the fiber state information. The thread is now the currently executing fiber.</para>
        /// <para>The <b>SwitchToFiber</b> function saves the state information of the current fiber and restores the state of the specified fiber. You can call <b>SwitchToFiber</b> with the address of a fiber created by a different thread. To do this, you must have the address returned to the other thread when it called <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfiber">CreateFiber</a> and you must use proper synchronization.</para>
        /// <para>Avoid making the following call:</para>
        /// <para><pre class = "syntax"xml: space = "preserve"><c>SwitchToFiber( GetCurrentFiber() );</c></pre> This call can cause unpredictable problems.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-switchtofiber#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void SwitchToFiber(void *lpFiber);
        /// <summary>Deletes an existing fiber.</summary>
        /// <param name = "lpFiber">The address of the fiber to be deleted.</param>
        /// <remarks>
        /// <para>The <b>DeleteFiber</b> function deletes all data associated with the fiber. This data includes the stack, a subset of the registers, and the fiber data.</para>
        /// <para>If the currently running fiber calls <b>DeleteFiber</b>, its thread calls <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a> and terminates. However, if a currently running fiber is deleted by another fiber, the thread running the deleted fiber is likely to terminate abnormally because the fiber stack has been freed.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deletefiber#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void DeleteFiber(void *lpFiber);
        /// <summary>Converts the current fiber into a thread.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-convertfibertothread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ConvertFiberToThread();
        /// <summary>Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address, typically the fiber function. This function does not schedule the fiber.</summary>
        /// <param name = "dwStackCommitSize">The initial commit size of the stack, in bytes. If this parameter is zero, the new fiber uses the default commit stack size for the executable. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</param>
        /// <param name = "dwStackReserveSize">The initial reserve size of the stack, in bytes. If this parameter is zero, the new fiber uses the default reserved stack size for the executable. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</param>
        /// <param name = "dwFlags">
        /// <para>If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a fiber uses floating-point arithmetic. If this parameter is <b>FIBER_FLAG_FLOAT_SWITCH</b>, the floating-point state is switched for the fiber.</para>
        /// <para><b>Windows XP:  </b>The <b>FIBER_FLAG_FLOAT_SWITCH</b> flag is not supported.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiberex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpStartAddress">
        /// <para>A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-switchtofiber">SwitchToFiber</a> function with this address. For more information on the fiber callback function, see <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pfiber_start_routine">FiberProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiberex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpParameter">
        /// <para>A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-getfiberdata">GetFiberData</a> macro.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiberex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the address of the fiber.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiberex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *CreateFiberEx(nuint dwStackCommitSize, nuint dwStackReserveSize, uint dwFlags, delegate *unmanaged[Stdcall]<void *, void>lpStartAddress, [Optional] void *lpParameter);
        /// <summary>Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other fibers.</summary>
        /// <param name = "lpParameter">
        /// <para>A  pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-getfiberdata">GetFiberData</a> macro.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-convertthreadtofiberex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a fiber uses floating-point arithmetic. If this parameter is FIBER_FLAG_FLOAT_SWITCH, the floating-point state is switched for the fiber.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the address of the fiber.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-convertthreadtofiberex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *ConvertThreadToFiberEx([Optional] void *lpParameter, uint dwFlags);
        /// <summary>Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address, typically the fiber function. This function does not schedule the fiber.</summary>
        /// <param name = "dwStackSize">The initial committed size of the stack, in bytes. If this parameter is zero, the new fiber uses the default commit stack size for the executable. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</param>
        /// <param name = "lpStartAddress">
        /// <para>A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-switchtofiber">SwitchToFiber</a> function with this address. For more information of the fiber callback function, see <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pfiber_start_routine">FiberProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiber#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpParameter">
        /// <para>A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-getfiberdata">GetFiberData</a> macro.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiber#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the address of the fiber.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiber">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *CreateFiber(nuint dwStackSize, delegate *unmanaged[Stdcall]<void *, void>lpStartAddress, [Optional] void *lpParameter);
        /// <summary>Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other fibers.</summary>
        /// <param name = "lpParameter">
        /// <para>A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-getfiberdata">GetFiberData</a> macro.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-convertthreadtofiber#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the address of the fiber.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-convertthreadtofiber">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *ConvertThreadToFiber([Optional] void *lpParameter);
        /// <inheritdoc cref = "CreateUmsCompletionList(void **)"/>
        internal static unsafe bool CreateUmsCompletionList(out void *UmsCompletionList)
        {
            fixed (void **UmsCompletionListLocal = &UmsCompletionList)
            {
                bool __result = Kernel32.CreateUmsCompletionList(UmsCompletionListLocal);
                return __result;
            }
        }

        /// <summary>Creates a user-mode scheduling (UMS) completion list.</summary>
        /// <param name = "UmsCompletionList">
        /// <para>A <b>PUMS_COMPLETION_LIST</b> variable. On output, this parameter receives a pointer to an empty UMS completion list.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createumscompletionlist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error values include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createumscompletionlist">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool CreateUmsCompletionList(void **UmsCompletionList);
        /// <inheritdoc cref = "DequeueUmsCompletionListItems(void *, uint, void **)"/>
        internal static unsafe bool DequeueUmsCompletionListItems(void *UmsCompletionList, uint WaitTimeOut, out void *UmsThreadList)
        {
            fixed (void **UmsThreadListLocal = &UmsThreadList)
            {
                bool __result = Kernel32.DequeueUmsCompletionListItems(UmsCompletionList, WaitTimeOut, UmsThreadListLocal);
                return __result;
            }
        }

        /// <summary>Retrieves user-mode scheduling (UMS) worker threads from the specified UMS completion list.</summary>
        /// <param name = "UmsCompletionList">A pointer to the completion list from which to retrieve worker threads.</param>
        /// <param name = "WaitTimeOut">
        /// <para>The time-out interval for the retrieval operation, in milliseconds. The function returns if the interval elapses, even if no worker threads are queued to the completion list.</para>
        /// <para>If the <i>WaitTimeOut</i> parameter is zero, the completion list is checked for available worker threads without waiting for worker threads to become available. If the <i>WaitTimeOut</i> parameter is INFINITE, the function's time-out interval never elapses. This is not recommended, however, because it causes the function to block until one or more worker threads become available.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-dequeueumscompletionlistitems#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "UmsThreadList">
        /// <para>A pointer to a UMS_CONTEXT variable. On output, this parameter receives a pointer to the first UMS thread context in a list of UMS thread contexts.</para>
        /// <para>If no worker threads are available before the time-out specified by the <i>WaitTimeOut</i> parameter, this parameter is set to NULL.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-dequeueumscompletionlistitems#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error values include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-dequeueumscompletionlistitems">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool DequeueUmsCompletionListItems(void *UmsCompletionList, uint WaitTimeOut, void **UmsThreadList);
        /// <inheritdoc cref = "GetUmsCompletionListEvent(void *, win32.System.SystemServices.HANDLE*)"/>
        internal static unsafe bool GetUmsCompletionListEvent(void *UmsCompletionList, ref win32.System.SystemServices.HANDLE UmsCompletionEvent)
        {
            fixed (win32.System.SystemServices.HANDLE*UmsCompletionEventLocal = &UmsCompletionEvent)
            {
                bool __result = Kernel32.GetUmsCompletionListEvent(UmsCompletionList, UmsCompletionEventLocal);
                return __result;
            }
        }

        /// <summary>Retrieves a handle to the event associated with the specified user-mode scheduling (UMS) completion list.</summary>
        /// <param name = "UmsCompletionList">A pointer to a UMS completion list. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createumscompletionlist">CreateUmsCompletionList</a> function provides this pointer.</param>
        /// <param name = "UmsCompletionEvent">A pointer to a HANDLE variable. On output, the <i>UmsCompletionEvent</i> parameter is set to a handle to the event associated with the specified completion list.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getumscompletionlistevent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetUmsCompletionListEvent(void *UmsCompletionList, win32.System.SystemServices.HANDLE*UmsCompletionEvent);
        /// <summary>Runs the specified UMS worker thread.</summary>
        /// <param name = "UmsThread">A pointer to the UMS thread context of the worker thread to run.</param>
        /// <returns>
        /// <para>If the function succeeds, it does not return a value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-executeumsthread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ExecuteUmsThread(void *UmsThread);
        /// <summary>Yields control to the user-mode scheduling (UMS) scheduler thread on which the calling UMS worker thread is running.</summary>
        /// <param name = "SchedulerParam">A parameter to pass to the scheduler thread's <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</a> function.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-umsthreadyield">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool UmsThreadYield(void *SchedulerParam);
        /// <summary>Deletes the specified user-mode scheduling (UMS) completion list. The list must be empty.</summary>
        /// <param name = "UmsCompletionList">A pointer to the UMS completion list to be deleted. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createumscompletionlist">CreateUmsCompletionList</a> function provides this pointer.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deleteumscompletionlist">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool DeleteUmsCompletionList(void *UmsCompletionList);
        /// <summary>Returns the user-mode scheduling (UMS) thread context of the calling UMS thread.</summary>
        /// <returns>
        /// <para>The function returns a pointer to the UMS thread context of the calling thread.</para>
        /// <para>If calling thread is not a UMS thread, the function returns NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcurrentumsthread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *GetCurrentUmsThread();
        /// <summary>Returns the next user-mode scheduling (UMS) thread context in a list of thread contexts.</summary>
        /// <param name = "UmsContext">A pointer to a UMS context in a list of thread contexts. This list is retrieved by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-dequeueumscompletionlistitems">DequeueUmsCompletionListItems</a> function.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a pointer to the next thread context in the list.</para>
        /// <para>If there is no thread context after the context specified by the <i>UmsContext</i> parameter,  the function returns NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnextumslistitem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *GetNextUmsListItem(void *UmsContext);
        /// <summary>Retrieves information about the specified user-mode scheduling (UMS) worker thread.</summary>
        /// <param name = "UmsThread">A pointer to a UMS thread context.</param>
        /// <param name = "UmsThreadInfoClass">A UMS_THREAD_INFO_CLASS value that specifies the kind of information to retrieve.</param>
        /// <param name = "UmsThreadInformation">
        /// <para>A pointer to a buffer to receive the specified information. The required size of this buffer depends on the specified information class.</para>
        /// <para>If the information class is <b>UmsThreadContext</b> or <b>UmsThreadTeb</b>, the buffer must be <c>sizeof(PVOID)</c>.</para>
        /// <para>If the information class is <b>UmsThreadIsSuspended</b> or <b>UmsThreadIsTerminated</b>, the buffer must be <c>sizeof(BOOLEAN)</c>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-queryumsthreadinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "UmsThreadInformationLength">The size of the <i>UmsThreadInformation</i> buffer, in bytes.</param>
        /// <param name = "ReturnLength">A pointer to a ULONG variable. On output, this parameter receives the number of bytes written to the <i>UmsThreadInformation</i> buffer.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error values include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-queryumsthreadinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool QueryUmsThreadInformation(void *UmsThread, win32.System.SystemServices.RTL_UMS_THREAD_INFO_CLASS UmsThreadInfoClass, void *UmsThreadInformation, uint UmsThreadInformationLength, [Optional] uint *ReturnLength);
        /// <summary>Sets application-specific context information for the specified user-mode scheduling (UMS) worker thread.</summary>
        /// <param name = "UmsThread">A pointer to a UMS thread context.</param>
        /// <param name = "UmsThreadInfoClass">A <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ne-winnt-_rtl_ums_thread_info_class">UMS_THREAD_INFO_CLASS</a> value that specifies the kind of information to set. This parameter must be <b>UmsThreadUserContext</b>.</param>
        /// <param name = "UmsThreadInformation">A pointer to a buffer that contains the information to set.</param>
        /// <param name = "UmsThreadInformationLength">The size of the <i>UmsThreadInformation</i> buffer, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error values include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setumsthreadinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetUmsThreadInformation(void *UmsThread, win32.System.SystemServices.RTL_UMS_THREAD_INFO_CLASS UmsThreadInfoClass, void *UmsThreadInformation, uint UmsThreadInformationLength);
        /// <summary>Deletes the specified user-mode scheduling (UMS) thread context. The thread must be terminated.</summary>
        /// <param name = "UmsThread">A pointer to the UMS thread context to be deleted. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createumsthreadcontext">CreateUmsThreadContext</a> function provides this pointer.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deleteumsthreadcontext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool DeleteUmsThreadContext(void *UmsThread);
        /// <inheritdoc cref = "CreateUmsThreadContext(void **)"/>
        internal static unsafe bool CreateUmsThreadContext(out void *lpUmsThread)
        {
            fixed (void **lpUmsThreadLocal = &lpUmsThread)
            {
                bool __result = Kernel32.CreateUmsThreadContext(lpUmsThreadLocal);
                return __result;
            }
        }

        /// <summary>Creates a user-mode scheduling (UMS) thread context to represent a UMS worker thread.</summary>
        /// <param name = "lpUmsThread">A PUMS_CONTEXT variable. On output, this parameter receives a pointer to a UMS thread context.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error values include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createumsthreadcontext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool CreateUmsThreadContext(void **lpUmsThread);
        /// <inheritdoc cref = "EnterUmsSchedulingMode(win32.System.SystemServices.UMS_SCHEDULER_STARTUP_INFO*)"/>
        internal static unsafe bool EnterUmsSchedulingMode(in win32.System.SystemServices.UMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
        {
            fixed (win32.System.SystemServices.UMS_SCHEDULER_STARTUP_INFO*SchedulerStartupInfoLocal = &SchedulerStartupInfo)
            {
                bool __result = Kernel32.EnterUmsSchedulingMode(SchedulerStartupInfoLocal);
                return __result;
            }
        }

        /// <summary>Converts the calling thread into a user-mode scheduling (UMS) scheduler thread.</summary>
        /// <param name = "SchedulerStartupInfo">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ums_scheduler_startup_info">UMS_SCHEDULER_STARTUP_INFO</a> structure that specifies UMS attributes for the thread, including a completion list and a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</a>     entry point function.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enterumsschedulingmode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool EnterUmsSchedulingMode(win32.System.SystemServices.UMS_SCHEDULER_STARTUP_INFO*SchedulerStartupInfo);
        /// <inheritdoc cref = "GetUmsSystemThreadInformation(win32.System.SystemServices.HANDLE, win32.System.SystemServices.UMS_SYSTEM_THREAD_INFORMATION*)"/>
        internal static unsafe bool GetUmsSystemThreadInformation(SafeHandle ThreadHandle, ref win32.System.SystemServices.UMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
        {
            bool ThreadHandleAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.UMS_SYSTEM_THREAD_INFORMATION*SystemThreadInfoLocal = &SystemThreadInfo)
                {
                    win32.System.SystemServices.HANDLE ThreadHandleLocal;
                    if (ThreadHandle is object)
                    {
                        ThreadHandle.DangerousAddRef(ref ThreadHandleAddRef);
                        ThreadHandleLocal = (win32.System.SystemServices.HANDLE)ThreadHandle.DangerousGetHandle();
                    }
                    else
                        ThreadHandleLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetUmsSystemThreadInformation(ThreadHandleLocal, SystemThreadInfoLocal);
                    return __result;
                }
            }
            finally
            {
                if (ThreadHandleAddRef)
                    ThreadHandle.DangerousRelease();
            }
        }

        /// <summary>Queries whether the specified thread is a UMS scheduler thread, a UMS worker thread, or a non-UMS thread.</summary>
        /// <param name = "ThreadHandle">A handle to a thread. The thread handle must have the THREAD_QUERY_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
        /// <param name = "SystemThreadInfo">A pointer to an initialized <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ums_system_thread_information">UMS_SYSTEM_THREAD_INFORMATION</a> structure that specifies the kind of thread for the query.</param>
        /// <returns>Returns TRUE if the specified thread matches the kind of thread specified by the <i>SystemThreadInfo</i> parameter. Otherwise, the function returns FALSE.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getumssystemthreadinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetUmsSystemThreadInformation(win32.System.SystemServices.HANDLE ThreadHandle, win32.System.SystemServices.UMS_SYSTEM_THREAD_INFORMATION*SystemThreadInfo);
        /// <inheritdoc cref = "SetThreadAffinityMask(win32.System.SystemServices.HANDLE, nuint)"/>
        internal static unsafe nuint SetThreadAffinityMask(SafeHandle hThread, nuint dwThreadAffinityMask)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                nuint __result = Kernel32.SetThreadAffinityMask(hThreadLocal, dwThreadAffinityMask);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Sets a processor affinity mask for the specified thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread whose affinity mask is to be set.</para>
        /// <para>This handle must have the <b>THREAD_SET_INFORMATION</b> or <b>THREAD_SET_LIMITED_INFORMATION</b> access right and the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_SET_INFORMATION</b> and <b>THREAD_QUERY_INFORMATION</b> access rights.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setthreadaffinitymask#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwThreadAffinityMask">
        /// <para>The affinity mask for the thread.</para>
        /// <para>On a system with more than 64 processors, the affinity mask must specify processors in the thread's current <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/processor-groups">processor group</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setthreadaffinitymask#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the thread's previous affinity mask.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the thread affinity mask requests a processor that is not selected for the process affinity mask, the last error code is <b>ERROR_INVALID_PARAMETER</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setthreadaffinitymask">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nuint SetThreadAffinityMask(win32.System.SystemServices.HANDLE hThread, nuint dwThreadAffinityMask);
        /// <summary>Changes data execution prevention (DEP) and DEP-ATL thunk emulation settings for a 32-bit process.</summary>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>.</para>
        /// <para>If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function,  call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setprocessdeppolicy">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetProcessDEPPolicy(win32.System.SystemServices.PROCESS_DEP_FLAGS dwFlags);
        /// <inheritdoc cref = "GetProcessDEPPolicy(win32.System.SystemServices.HANDLE, uint *, bool *)"/>
        internal static unsafe bool GetProcessDEPPolicy(SafeHandle hProcess, out uint lpFlags, out bool lpPermanent)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (bool *lpPermanentLocal = &lpPermanent)
                {
                    fixed (uint *lpFlagsLocal = &lpFlags)
                    {
                        win32.System.SystemServices.HANDLE hProcessLocal;
                        if (hProcess is object)
                        {
                            hProcess.DangerousAddRef(ref hProcessAddRef);
                            hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                        }
                        else
                            hProcessLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.GetProcessDEPPolicy(hProcessLocal, lpFlagsLocal, lpPermanentLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Gets the data execution prevention (DEP) and DEP-ATL thunk emulation settings for the specified 32-bit process.Windows XP with SP3:  Gets the DEP and DEP-ATL thunk emulation settings for the current process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process. <b>PROCESS_QUERY_INFORMATION</b> privilege is required to get the DEP policy of a process.</para>
        /// <para><b>Windows XP with SP3:  </b>The <i>hProcess</i> parameter is ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprocessdeppolicy#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFlags">
        /// <para>A <b>DWORD</b> that receives one or more of the following flags.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprocessdeppolicy#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpPermanent"><b>TRUE</b> if DEP is enabled or disabled permanently for the specified process; otherwise <b>FALSE</b>. If <i>lpPermanent</i> is <b>TRUE</b>, the current DEP setting persists for the life of the process and cannot be changed by calling <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setprocessdeppolicy">SetProcessDEPPolicy</a>.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>.</para>
        /// <para>If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function,  call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprocessdeppolicy">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessDEPPolicy(win32.System.SystemServices.HANDLE hProcess, uint *lpFlags, bool *lpPermanent);
        /// <summary>Has no effect and returns STATUS_NOT_SUPPORTED. This function is provided only for compatibility with earlier versions of Windows.Windows Server 2008 and Windows Vista:  Has no effect and always returns success.</summary>
        /// <param name = "latency">
        /// <para>The latency requirement for the time is takes to wake the computer. This parameter can be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-requestwakeuplatency#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>The return value is nonzero.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-requestwakeuplatency">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool RequestWakeupLatency(win32.System.SystemServices.LATENCY_TIME latency);
        /// <summary>Determines the current state of the computer.</summary>
        /// <returns>If the system was restored to the working state automatically and the user is not active, the function returns <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-issystemresumeautomatic">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool IsSystemResumeAutomatic();
        /// <summary>Enables an application to inform the system that it is in use, thereby preventing the system from entering sleep or turning off the display while the application is running.</summary>
        /// <param name = "esFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the previous thread execution state.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setthreadexecutionstate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.EXECUTION_STATE SetThreadExecutionState(win32.System.SystemServices.EXECUTION_STATE esFlags);
        /// <inheritdoc cref = "PulseEvent(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool PulseEvent(SafeHandle hEvent)
        {
            bool hEventAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hEventLocal;
                if (hEvent is object)
                {
                    hEvent.DangerousAddRef(ref hEventAddRef);
                    hEventLocal = (win32.System.SystemServices.HANDLE)hEvent.DangerousGetHandle();
                }
                else
                    hEventLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.PulseEvent(hEventLocal);
                return __result;
            }
            finally
            {
                if (hEventAddRef)
                    hEvent.DangerousRelease();
            }
        }

        /// <summary>Sets the specified event object to the signaled state and then resets it to the nonsignaled state after releasing the appropriate number of waiting threads.</summary>
        /// <param name = "hEvent">
        /// <para>A handle to the event object. The <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-createeventa">CreateEvent</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-openeventa">OpenEvent</a> function returns this handle.</para>
        /// <para>The handle must have the EVENT_MODIFY_STATE access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-pulseevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-pulseevent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool PulseEvent(win32.System.SystemServices.HANDLE hEvent);
        /// <inheritdoc cref = "GetDevicePowerState(win32.System.SystemServices.HANDLE, bool *)"/>
        internal static unsafe bool GetDevicePowerState(SafeHandle hDevice, out bool pfOn)
        {
            bool hDeviceAddRef = false;
            try
            {
                fixed (bool *pfOnLocal = &pfOn)
                {
                    win32.System.SystemServices.HANDLE hDeviceLocal;
                    if (hDevice is object)
                    {
                        hDevice.DangerousAddRef(ref hDeviceAddRef);
                        hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                    }
                    else
                        hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetDevicePowerState(hDeviceLocal, pfOnLocal);
                    return __result;
                }
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Retrieves the current power state of the specified device.</summary>
        /// <param name = "hDevice">A handle to an object on the device, such as a file or socket, or a handle to the device itself.</param>
        /// <param name = "pfOn">
        /// <para>A pointer to the variable that receives the <a href = "https://docs.microsoft.com/windows/desktop/Power/system-power-states">power state</a>. This value is <b>TRUE</b> if the device is in the working state. Otherwise, it is <b>FALSE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getdevicepowerstate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getdevicepowerstate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetDevicePowerState(win32.System.SystemServices.HANDLE hDevice, bool *pfOn);
        /// <summary>Loads and executes an application or creates a new instance of an existing application.</summary>
        /// <param name = "lpModuleName">
        /// <para>The file name of the application to be run. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). If the <i>lpModuleName</i> parameter does not contain a directory path, the system searches for the executable file in this order:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-loadmodule#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpParameterBlock">
        /// <para>A pointer to an application-defined <b>LOADPARMS32</b> structure that defines the new application's parameter block.</para>
        /// <para>Set all unused members to NULL, except for <b>lpCmdLine</b>, which must point to a null-terminated string if it is not used. For more information, see Remarks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-loadmodule#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is greater than 31.</para>
        /// <para>If the function fails, the return value is an error value, which may be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-loadmodule">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint LoadModule(win32.System.SystemServices.PCSTR lpModuleName, void *lpParameterBlock);
        /// <summary>Runs the specified application.</summary>
        /// <param name = "lpCmdLine">
        /// <para>The command line (file name plus optional parameters) for the application to be executed. If the name of the executable file in the <i>lpCmdLine</i> parameter does not contain a directory path, the system searches for the executable file in this sequence:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-winexec#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uCmdShow">
        /// <para>The display options. For a list of the acceptable values, see the description of the <i>nCmdShow</i> parameter of the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-winexec#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is greater than 31.</para>
        /// <para>If the function fails, the return value is one of the following error values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-winexec">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint WinExec(win32.System.SystemServices.PCSTR lpCmdLine, uint uCmdShow);
        /// <inheritdoc cref = "ClearCommBreak(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool ClearCommBreak(SafeHandle hFile)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.ClearCommBreak(hFileLocal);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Restores character transmission for a specified communications device and places the transmission line in a nonbreak state.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-clearcommbreak#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-clearcommbreak">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ClearCommBreak(win32.System.SystemServices.HANDLE hFile);
        /// <inheritdoc cref = "ClearCommError(win32.System.SystemServices.HANDLE, win32.System.SystemServices.CLEAR_COMM_ERROR_FLAGS*, win32.System.SystemServices.COMSTAT*)"/>
        internal static unsafe bool ClearCommError(SafeHandle hFile, win32.System.SystemServices.CLEAR_COMM_ERROR_FLAGS*lpErrors, win32.System.SystemServices.COMSTAT*lpStat)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.ClearCommError(hFileLocal, lpErrors, lpStat);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about a communications error and reports the current status of a communications device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-clearcommerror#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpErrors"></param>
        /// <param name = "lpStat">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-comstat">COMSTAT</a> structure in which the device's status information is returned. If this parameter is <b>NULL</b>, no status information is returned.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-clearcommerror#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-clearcommerror">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ClearCommError(win32.System.SystemServices.HANDLE hFile, [Optional] win32.System.SystemServices.CLEAR_COMM_ERROR_FLAGS*lpErrors, [Optional] win32.System.SystemServices.COMSTAT*lpStat);
        /// <inheritdoc cref = "SetupComm(win32.System.SystemServices.HANDLE, uint, uint)"/>
        internal static unsafe bool SetupComm(SafeHandle hFile, uint dwInQueue, uint dwOutQueue)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetupComm(hFileLocal, dwInQueue, dwOutQueue);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Initializes the communications parameters for a specified communications device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setupcomm#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwInQueue">The recommended size of the device's internal input buffer, in bytes.</param>
        /// <param name = "dwOutQueue">The recommended size of the device's internal output buffer, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setupcomm">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetupComm(win32.System.SystemServices.HANDLE hFile, uint dwInQueue, uint dwOutQueue);
        /// <inheritdoc cref = "EscapeCommFunction(win32.System.SystemServices.HANDLE, win32.System.SystemServices.ESCAPE_COMM_FUNCTION)"/>
        internal static unsafe bool EscapeCommFunction(SafeHandle hFile, win32.System.SystemServices.ESCAPE_COMM_FUNCTION dwFunc)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.EscapeCommFunction(hFileLocal, dwFunc);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Directs the specified communications device to perform an extended function.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-escapecommfunction#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFunc"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-escapecommfunction">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool EscapeCommFunction(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.ESCAPE_COMM_FUNCTION dwFunc);
        /// <inheritdoc cref = "GetCommConfig(win32.System.SystemServices.HANDLE, win32.System.SystemServices.COMMCONFIG*, uint *)"/>
        internal static unsafe bool GetCommConfig(SafeHandle hCommDev, win32.System.SystemServices.COMMCONFIG*lpCC, ref uint lpdwSize)
        {
            bool hCommDevAddRef = false;
            try
            {
                fixed (uint *lpdwSizeLocal = &lpdwSize)
                {
                    win32.System.SystemServices.HANDLE hCommDevLocal;
                    if (hCommDev is object)
                    {
                        hCommDev.DangerousAddRef(ref hCommDevAddRef);
                        hCommDevLocal = (win32.System.SystemServices.HANDLE)hCommDev.DangerousGetHandle();
                    }
                    else
                        hCommDevLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetCommConfig(hCommDevLocal, lpCC, lpdwSizeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hCommDevAddRef)
                    hCommDev.DangerousRelease();
            }
        }

        /// <summary>Retrieves the current configuration of a communications device.</summary>
        /// <param name = "hCommDev">
        /// <para>A handle to the open communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommconfig#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCC">
        /// <para>A pointer to a buffer that receives a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-commconfig">COMMCONFIG</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommconfig#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpdwSize">The size, in bytes, of the buffer pointed to by <i>lpCC</i>. When the function returns, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommconfig">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCommConfig(win32.System.SystemServices.HANDLE hCommDev, [Optional] win32.System.SystemServices.COMMCONFIG*lpCC, uint *lpdwSize);
        /// <inheritdoc cref = "GetCommMask(win32.System.SystemServices.HANDLE, win32.System.SystemServices.COMM_EVENT_MASK*)"/>
        internal static unsafe bool GetCommMask(SafeHandle hFile, out win32.System.SystemServices.COMM_EVENT_MASK lpEvtMask)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.COMM_EVENT_MASK*lpEvtMaskLocal = &lpEvtMask)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetCommMask(hFileLocal, lpEvtMaskLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the value of the event mask for a specified communications device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommmask#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEvtMask"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommmask">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCommMask(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.COMM_EVENT_MASK*lpEvtMask);
        /// <inheritdoc cref = "GetCommProperties(win32.System.SystemServices.HANDLE, win32.System.SystemServices.COMMPROP*)"/>
        internal static unsafe bool GetCommProperties(SafeHandle hFile, ref win32.System.SystemServices.COMMPROP lpCommProp)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.COMMPROP*lpCommPropLocal = &lpCommProp)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetCommProperties(hFileLocal, lpCommPropLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the communications properties for a specified communications device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommproperties#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCommProp">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-commprop">COMMPROP</a> structure in which the communications properties information is returned. This information can be used in subsequent calls to the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setcommstate">SetCommState</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setcommtimeouts">SetCommTimeouts</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setupcomm">SetupComm</a> function to configure the communications device.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommproperties#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommproperties">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCommProperties(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.COMMPROP*lpCommProp);
        /// <inheritdoc cref = "GetCommModemStatus(win32.System.SystemServices.HANDLE, win32.System.SystemServices.MODEM_STATUS_FLAGS*)"/>
        internal static unsafe bool GetCommModemStatus(SafeHandle hFile, out win32.System.SystemServices.MODEM_STATUS_FLAGS lpModemStat)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.MODEM_STATUS_FLAGS*lpModemStatLocal = &lpModemStat)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetCommModemStatus(hFileLocal, lpModemStatLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the modem control-register values.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommmodemstatus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpModemStat"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommmodemstatus">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCommModemStatus(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.MODEM_STATUS_FLAGS*lpModemStat);
        /// <inheritdoc cref = "GetCommState(win32.System.SystemServices.HANDLE, win32.System.SystemServices.DCB*)"/>
        internal static unsafe bool GetCommState(SafeHandle hFile, out win32.System.SystemServices.DCB lpDCB)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.DCB*lpDCBLocal = &lpDCB)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetCommState(hFileLocal, lpDCBLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the current control settings for a specified communications device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommstate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDCB">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-dcb">DCB</a> structure that receives the control settings information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommstate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommstate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCommState(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.DCB*lpDCB);
        /// <inheritdoc cref = "GetCommTimeouts(win32.System.SystemServices.HANDLE, win32.System.SystemServices.COMMTIMEOUTS*)"/>
        internal static unsafe bool GetCommTimeouts(SafeHandle hFile, out win32.System.SystemServices.COMMTIMEOUTS lpCommTimeouts)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.COMMTIMEOUTS*lpCommTimeoutsLocal = &lpCommTimeouts)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetCommTimeouts(hFileLocal, lpCommTimeoutsLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the time-out parameters for all read and write operations on a specified communications device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommtimeouts#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCommTimeouts">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-commtimeouts">COMMTIMEOUTS</a> structure in which the time-out information is returned.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommtimeouts#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcommtimeouts">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCommTimeouts(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.COMMTIMEOUTS*lpCommTimeouts);
        /// <inheritdoc cref = "PurgeComm(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PURGE_COMM_FLAGS)"/>
        internal static unsafe bool PurgeComm(SafeHandle hFile, win32.System.SystemServices.PURGE_COMM_FLAGS dwFlags)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.PurgeComm(hFileLocal, dwFlags);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Discards all characters from the output or input buffer of a specified communications resource. It can also terminate pending read or write operations on the resource.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications resource. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-purgecomm#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-purgecomm">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool PurgeComm(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.PURGE_COMM_FLAGS dwFlags);
        /// <inheritdoc cref = "SetCommBreak(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool SetCommBreak(SafeHandle hFile)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetCommBreak(hFileLocal);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Suspends character transmission for a specified communications device and places the transmission line in a break state until the ClearCommBreak function is called.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommbreak#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommbreak">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetCommBreak(win32.System.SystemServices.HANDLE hFile);
        /// <inheritdoc cref = "SetCommConfig(win32.System.SystemServices.HANDLE, win32.System.SystemServices.COMMCONFIG*, uint)"/>
        internal static unsafe bool SetCommConfig(SafeHandle hCommDev, in win32.System.SystemServices.COMMCONFIG lpCC, uint dwSize)
        {
            bool hCommDevAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.COMMCONFIG*lpCCLocal = &lpCC)
                {
                    win32.System.SystemServices.HANDLE hCommDevLocal;
                    if (hCommDev is object)
                    {
                        hCommDev.DangerousAddRef(ref hCommDevAddRef);
                        hCommDevLocal = (win32.System.SystemServices.HANDLE)hCommDev.DangerousGetHandle();
                    }
                    else
                        hCommDevLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetCommConfig(hCommDevLocal, lpCCLocal, dwSize);
                    return __result;
                }
            }
            finally
            {
                if (hCommDevAddRef)
                    hCommDev.DangerousRelease();
            }
        }

        /// <summary>Sets the current configuration of a communications device.</summary>
        /// <param name = "hCommDev">
        /// <para>A handle to the open communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommconfig#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCC">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-commconfig">COMMCONFIG</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommconfig#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSize">The size of the structure pointed to by <i>lpCC</i>, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommconfig">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetCommConfig(win32.System.SystemServices.HANDLE hCommDev, win32.System.SystemServices.COMMCONFIG*lpCC, uint dwSize);
        /// <inheritdoc cref = "SetCommMask(win32.System.SystemServices.HANDLE, win32.System.SystemServices.COMM_EVENT_MASK)"/>
        internal static unsafe bool SetCommMask(SafeHandle hFile, win32.System.SystemServices.COMM_EVENT_MASK dwEvtMask)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetCommMask(hFileLocal, dwEvtMask);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Specifies a set of events to be monitored for a communications device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommmask#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwEvtMask"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommmask">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetCommMask(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.COMM_EVENT_MASK dwEvtMask);
        /// <inheritdoc cref = "SetCommState(win32.System.SystemServices.HANDLE, win32.System.SystemServices.DCB*)"/>
        internal static unsafe bool SetCommState(SafeHandle hFile, in win32.System.SystemServices.DCB lpDCB)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.DCB*lpDCBLocal = &lpDCB)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetCommState(hFileLocal, lpDCBLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Configures a communications device according to the specifications in a device-control block (a DCB structure). The function reinitializes all hardware and control settings, but it does not empty output or input queues.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommstate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDCB">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-dcb">DCB</a> structure that contains the configuration information for the specified communications device.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommstate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommstate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetCommState(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.DCB*lpDCB);
        /// <inheritdoc cref = "SetCommTimeouts(win32.System.SystemServices.HANDLE, win32.System.SystemServices.COMMTIMEOUTS*)"/>
        internal static unsafe bool SetCommTimeouts(SafeHandle hFile, in win32.System.SystemServices.COMMTIMEOUTS lpCommTimeouts)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.COMMTIMEOUTS*lpCommTimeoutsLocal = &lpCommTimeouts)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetCommTimeouts(hFileLocal, lpCommTimeoutsLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Sets the time-out parameters for all read and write operations on a specified communications device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommtimeouts#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCommTimeouts">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-commtimeouts">COMMTIMEOUTS</a> structure that contains the new time-out values.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommtimeouts#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setcommtimeouts">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetCommTimeouts(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.COMMTIMEOUTS*lpCommTimeouts);
        /// <inheritdoc cref = "TransmitCommChar(win32.System.SystemServices.HANDLE, win32.System.SystemServices.CHAR)"/>
        internal static unsafe bool TransmitCommChar(SafeHandle hFile, win32.System.SystemServices.CHAR cChar)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.TransmitCommChar(hFileLocal, cChar);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Transmits a specified character ahead of any pending data in the output buffer of the specified communications device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-transmitcommchar#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cChar">The character to be transmitted.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-transmitcommchar">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool TransmitCommChar(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.CHAR cChar);
        /// <inheritdoc cref = "WaitCommEvent(win32.System.SystemServices.HANDLE, win32.System.SystemServices.COMM_EVENT_MASK*, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool WaitCommEvent(SafeHandle hFile, ref win32.System.SystemServices.COMM_EVENT_MASK lpEvtMask, win32.System.SystemServices.OVERLAPPED*lpOverlapped)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.COMM_EVENT_MASK*lpEvtMaskLocal = &lpEvtMask)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.WaitCommEvent(hFileLocal, lpEvtMaskLocal, lpOverlapped);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Waits for an event to occur for a specified communications device. The set of events that are monitored by this function is contained in the event mask associated with the device handle.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the communications device. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-waitcommevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEvtMask"></param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. This structure is required if <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b>.</para>
        /// <para>If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b>, the <i>lpOverlapped</i> parameter must not be <b>NULL</b>. It must point to a valid <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b> and <i>lpOverlapped</i> is <b>NULL</b>, the function can incorrectly report that the operation is complete.</para>
        /// <para>If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b> and <i>lpOverlapped</i> is not <b>NULL</b>, <b>WaitCommEvent</b> is performed as an overlapped operation. In this case, the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure must contain a handle to a manual-reset event object (created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-createeventa">CreateEvent</a> function).</para>
        /// <para>If <i>hFile</i> was not opened with <b>FILE_FLAG_OVERLAPPED</b>, <b>WaitCommEvent</b> does not return until one of the specified events or an error occurs.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-waitcommevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-waitcommevent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool WaitCommEvent(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.COMM_EVENT_MASK*lpEvtMask, [Optional] win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <inheritdoc cref = "SetTapePosition(win32.System.SystemServices.HANDLE, win32.System.SystemServices.TAPE_POSITION_METHOD, uint, uint, uint, bool)"/>
        internal static unsafe uint SetTapePosition(SafeHandle hDevice, win32.System.SystemServices.TAPE_POSITION_METHOD dwPositionMethod, uint dwPartition, uint dwOffsetLow, uint dwOffsetHigh, bool bImmediate)
        {
            bool hDeviceAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDeviceLocal;
                if (hDevice is object)
                {
                    hDevice.DangerousAddRef(ref hDeviceAddRef);
                    hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                }
                else
                    hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.SetTapePosition(hDeviceLocal, dwPositionMethod, dwPartition, dwOffsetLow, dwOffsetHigh, bImmediate);
                return __result;
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Sets the tape position on the specified device.</summary>
        /// <param name = "hDevice">
        /// <para>Handle to the device on which to set the tape position. This handle is created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-settapeposition#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwPositionMethod"></param>
        /// <param name = "dwPartition">Partition to position within. If <i>dwPartition</i> is zero, the current partition is used. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last.</param>
        /// <param name = "dwOffsetLow">Low-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i> parameter.</param>
        /// <param name = "dwOffsetHigh">High-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i> parameter. If the high-order bits are not required, this parameter should be zero.</param>
        /// <param name = "bImmediate">Indicates whether to return as soon as the move operation begins. If this parameter is <b>TRUE</b>, the function returns immediately; if <b>FALSE</b>, the function does not return until the move operation has been completed.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is NO_ERROR.</para>
        /// <para>If the function fails, it can return one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-settapeposition">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint SetTapePosition(win32.System.SystemServices.HANDLE hDevice, win32.System.SystemServices.TAPE_POSITION_METHOD dwPositionMethod, uint dwPartition, uint dwOffsetLow, uint dwOffsetHigh, bool bImmediate);
        /// <inheritdoc cref = "GetTapePosition(win32.System.SystemServices.HANDLE, win32.System.SystemServices.TAPE_POSITION_TYPE, uint *, uint *, uint *)"/>
        internal static unsafe uint GetTapePosition(SafeHandle hDevice, win32.System.SystemServices.TAPE_POSITION_TYPE dwPositionType, out uint lpdwPartition, out uint lpdwOffsetLow, out uint lpdwOffsetHigh)
        {
            bool hDeviceAddRef = false;
            try
            {
                fixed (uint *lpdwOffsetHighLocal = &lpdwOffsetHigh)
                {
                    fixed (uint *lpdwOffsetLowLocal = &lpdwOffsetLow)
                    {
                        fixed (uint *lpdwPartitionLocal = &lpdwPartition)
                        {
                            win32.System.SystemServices.HANDLE hDeviceLocal;
                            if (hDevice is object)
                            {
                                hDevice.DangerousAddRef(ref hDeviceAddRef);
                                hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                            }
                            else
                                hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                            uint __result = Kernel32.GetTapePosition(hDeviceLocal, dwPositionType, lpdwPartitionLocal, lpdwOffsetLowLocal, lpdwOffsetHighLocal);
                            return __result;
                        }
                    }
                }
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Retrieves the current address of the tape, in logical or absolute blocks.</summary>
        /// <param name = "hDevice">
        /// <para>Handle to the device on which to get the tape position. This handle is created by using <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-gettapeposition#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwPositionType"></param>
        /// <param name = "lpdwPartition">Pointer to a variable that receives the number of the current tape partition. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last. When a device-specific block address is retrieved, or if the device supports only one partition, this parameter receives zero.</param>
        /// <param name = "lpdwOffsetLow">Pointer to a variable that receives the low-order bits of the current tape position.</param>
        /// <param name = "lpdwOffsetHigh">Pointer to a variable that receives the high-order bits of the current tape position. This parameter can be <b>NULL</b> if the high-order bits are not required.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is NO_ERROR.</para>
        /// <para>If the function fails, it can return one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-gettapeposition">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint GetTapePosition(win32.System.SystemServices.HANDLE hDevice, win32.System.SystemServices.TAPE_POSITION_TYPE dwPositionType, uint *lpdwPartition, uint *lpdwOffsetLow, uint *lpdwOffsetHigh);
        /// <inheritdoc cref = "PrepareTape(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PREPARE_TAPE_OPERATION, bool)"/>
        internal static unsafe uint PrepareTape(SafeHandle hDevice, win32.System.SystemServices.PREPARE_TAPE_OPERATION dwOperation, bool bImmediate)
        {
            bool hDeviceAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDeviceLocal;
                if (hDevice is object)
                {
                    hDevice.DangerousAddRef(ref hDeviceAddRef);
                    hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                }
                else
                    hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.PrepareTape(hDeviceLocal, dwOperation, bImmediate);
                return __result;
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Prepares the tape to be accessed or removed.</summary>
        /// <param name = "hDevice">
        /// <para>Handle to the device preparing the tape. This handle is created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-preparetape#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwOperation"></param>
        /// <param name = "bImmediate">If this parameter is <b>TRUE</b>, the function returns immediately. If it is <b>FALSE</b>, the function does not return until the operation has been completed.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is NO_ERROR.</para>
        /// <para>If the function fails, it can return one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-preparetape">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint PrepareTape(win32.System.SystemServices.HANDLE hDevice, win32.System.SystemServices.PREPARE_TAPE_OPERATION dwOperation, bool bImmediate);
        /// <inheritdoc cref = "EraseTape(win32.System.SystemServices.HANDLE, win32.System.SystemServices.ERASE_TAPE_TYPE, bool)"/>
        internal static unsafe uint EraseTape(SafeHandle hDevice, win32.System.SystemServices.ERASE_TAPE_TYPE dwEraseType, bool bImmediate)
        {
            bool hDeviceAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDeviceLocal;
                if (hDevice is object)
                {
                    hDevice.DangerousAddRef(ref hDeviceAddRef);
                    hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                }
                else
                    hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.EraseTape(hDeviceLocal, dwEraseType, bImmediate);
                return __result;
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Erases all or part of a tape.</summary>
        /// <param name = "hDevice">
        /// <para>Handle to the device where the tape is to be erased. This handle is created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-erasetape#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwEraseType"></param>
        /// <param name = "bImmediate">If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not return until the erase operation has been completed.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is NO_ERROR.</para>
        /// <para>If the function fails, it can return one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-erasetape">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint EraseTape(win32.System.SystemServices.HANDLE hDevice, win32.System.SystemServices.ERASE_TAPE_TYPE dwEraseType, bool bImmediate);
        /// <inheritdoc cref = "CreateTapePartition(win32.System.SystemServices.HANDLE, win32.System.SystemServices.CREATE_TAPE_PARTITION_METHOD, uint, uint)"/>
        internal static unsafe uint CreateTapePartition(SafeHandle hDevice, win32.System.SystemServices.CREATE_TAPE_PARTITION_METHOD dwPartitionMethod, uint dwCount, uint dwSize)
        {
            bool hDeviceAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDeviceLocal;
                if (hDevice is object)
                {
                    hDevice.DangerousAddRef(ref hDeviceAddRef);
                    hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                }
                else
                    hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.CreateTapePartition(hDeviceLocal, dwPartitionMethod, dwCount, dwSize);
                return __result;
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Reformats a tape.</summary>
        /// <param name = "hDevice">
        /// <para>Handle to the device where the new partition is to be created. This handle is created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createtapepartition#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwPartitionMethod"></param>
        /// <param name = "dwCount">
        /// <para>Number of partitions to create. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-gettapeparameters">GetTapeParameters</a> function provides the maximum number of partitions a tape can support.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createtapepartition#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSize">Size of each partition, in megabytes. This value is ignored if the <i>dwPartitionMethod</i> parameter is <b>TAPE_SELECT_PARTITIONS</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is NO_ERROR.</para>
        /// <para>If the function fails, it can return one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createtapepartition">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint CreateTapePartition(win32.System.SystemServices.HANDLE hDevice, win32.System.SystemServices.CREATE_TAPE_PARTITION_METHOD dwPartitionMethod, uint dwCount, uint dwSize);
        /// <inheritdoc cref = "WriteTapemark(win32.System.SystemServices.HANDLE, win32.System.SystemServices.TAPEMARK_TYPE, uint, bool)"/>
        internal static unsafe uint WriteTapemark(SafeHandle hDevice, win32.System.SystemServices.TAPEMARK_TYPE dwTapemarkType, uint dwTapemarkCount, bool bImmediate)
        {
            bool hDeviceAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDeviceLocal;
                if (hDevice is object)
                {
                    hDevice.DangerousAddRef(ref hDeviceAddRef);
                    hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                }
                else
                    hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.WriteTapemark(hDeviceLocal, dwTapemarkType, dwTapemarkCount, bImmediate);
                return __result;
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Writes a specified number of filemarks, setmarks, short filemarks, or long filemarks to a tape device.</summary>
        /// <param name = "hDevice">
        /// <para>Handle to the device on which to write tapemarks. This handle is created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writetapemark#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwTapemarkType"></param>
        /// <param name = "dwTapemarkCount">Number of tapemarks to write.</param>
        /// <param name = "bImmediate">If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not return until the operation has been completed.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is NO_ERROR.</para>
        /// <para>If the function fails, it can return one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writetapemark">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint WriteTapemark(win32.System.SystemServices.HANDLE hDevice, win32.System.SystemServices.TAPEMARK_TYPE dwTapemarkType, uint dwTapemarkCount, bool bImmediate);
        /// <inheritdoc cref = "GetTapeStatus(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint GetTapeStatus(SafeHandle hDevice)
        {
            bool hDeviceAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDeviceLocal;
                if (hDevice is object)
                {
                    hDevice.DangerousAddRef(ref hDeviceAddRef);
                    hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                }
                else
                    hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.GetTapeStatus(hDeviceLocal);
                return __result;
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Determines whether the tape device is ready to process tape commands.</summary>
        /// <param name = "hDevice">
        /// <para>Handle to the device for which to get the device status. This handle is created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-gettapestatus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the tape device is ready to accept appropriate tape-access commands without returning errors, the return value is NO_ERROR.</para>
        /// <para>If the function fails, it can return one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-gettapestatus">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetTapeStatus(win32.System.SystemServices.HANDLE hDevice);
        /// <inheritdoc cref = "GetTapeParameters(win32.System.SystemServices.HANDLE, win32.System.SystemServices.GET_TAPE_DRIVE_PARAMETERS_OPERATION, uint *, void *)"/>
        internal static unsafe uint GetTapeParameters(SafeHandle hDevice, win32.System.SystemServices.GET_TAPE_DRIVE_PARAMETERS_OPERATION dwOperation, ref uint lpdwSize, void *lpTapeInformation)
        {
            bool hDeviceAddRef = false;
            try
            {
                fixed (uint *lpdwSizeLocal = &lpdwSize)
                {
                    win32.System.SystemServices.HANDLE hDeviceLocal;
                    if (hDevice is object)
                    {
                        hDevice.DangerousAddRef(ref hDeviceAddRef);
                        hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                    }
                    else
                        hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                    uint __result = Kernel32.GetTapeParameters(hDeviceLocal, dwOperation, lpdwSizeLocal, lpTapeInformation);
                    return __result;
                }
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Retrieves information that describes the tape or the tape drive.</summary>
        /// <param name = "hDevice">
        /// <para>Handle to the device about which information is sought. This handle is created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-gettapeparameters#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwOperation"></param>
        /// <param name = "lpdwSize">Pointer to a variable that receives the size, in bytes, of the buffer specified by the <i>lpTapeInformation</i> parameter. If the buffer is too small, this parameter receives the required size.</param>
        /// <param name = "lpTapeInformation">
        /// <para>Pointer to a structure that contains the requested information. If the <i>dwOperation</i> parameter is <b>GET_TAPE_MEDIA_INFORMATION</b>, <i>lpTapeInformation</i> points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_get_media_parameters">TAPE_GET_MEDIA_PARAMETERS</a> structure.</para>
        /// <para>If <i>dwOperation</i> is <b>GET_TAPE_DRIVE_INFORMATION</b>, <i>lpTapeInformation</i> points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_get_drive_parameters">TAPE_GET_DRIVE_PARAMETERS</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-gettapeparameters#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is <b>NO_ERROR</b>.</para>
        /// <para>If the function fails, it can return one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-gettapeparameters">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint GetTapeParameters(win32.System.SystemServices.HANDLE hDevice, win32.System.SystemServices.GET_TAPE_DRIVE_PARAMETERS_OPERATION dwOperation, uint *lpdwSize, void *lpTapeInformation);
        /// <inheritdoc cref = "SetTapeParameters(win32.System.SystemServices.HANDLE, win32.System.SystemServices.TAPE_INFORMATION_TYPE, void *)"/>
        internal static unsafe uint SetTapeParameters(SafeHandle hDevice, win32.System.SystemServices.TAPE_INFORMATION_TYPE dwOperation, void *lpTapeInformation)
        {
            bool hDeviceAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDeviceLocal;
                if (hDevice is object)
                {
                    hDevice.DangerousAddRef(ref hDeviceAddRef);
                    hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                }
                else
                    hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.SetTapeParameters(hDeviceLocal, dwOperation, lpTapeInformation);
                return __result;
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        /// <summary>Specifies the block size of a tape or configures the tape device.</summary>
        /// <param name = "hDevice">
        /// <para>Handle to the device for which to set configuration information. This handle is created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-settapeparameters#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwOperation"></param>
        /// <param name = "lpTapeInformation">
        /// <para>Pointer to a structure that contains the information to set. If the <i>dwOperation</i> parameter is SET_TAPE_MEDIA_INFORMATION, <i>lpTapeInformation</i> points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_set_media_parameters">TAPE_SET_MEDIA_PARAMETERS</a> structure.</para>
        /// <para>If <i>dwOperation</i> is SET_TAPE_DRIVE_INFORMATION, <i>lpTapeInformation</i> points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_set_drive_parameters">TAPE_SET_DRIVE_PARAMETERS</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-settapeparameters#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is NO_ERROR.</para>
        /// <para>If the function fails, it can return one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-settapeparameters">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint SetTapeParameters(win32.System.SystemServices.HANDLE hDevice, win32.System.SystemServices.TAPE_INFORMATION_TYPE dwOperation, void *lpTapeInformation);
        /// <summary>Gets the data execution prevention (DEP) policy setting for the system.</summary>
        /// <returns>
        /// <para>This function returns a value of type <b>DEP_SYSTEM_POLICY_TYPE</b>, which can be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getsystemdeppolicy">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.WindowsProgramming.DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy();
        /// <inheritdoc cref = "CreateMailslot(win32.System.SystemServices.PCWSTR, uint, uint, win32.System.SystemServices.SECURITY_ATTRIBUTES*)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateMailslot(string lpName, uint nMaxMessageSize, uint lReadTimeout, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpSecurityAttributes)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpSecurityAttributesLocal = lpSecurityAttributes.HasValue ? lpSecurityAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateMailslot(lpNameLocal, nMaxMessageSize, lReadTimeout, lpSecurityAttributes.HasValue ? &lpSecurityAttributesLocal : null);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates a mailslot with the specified name and returns a handle that a mailslot server can use to perform operations on the mailslot.</summary>
        /// <param name = "lpName">
        /// <para>The name of the mailslot. This name must have the following form:</para>
        /// <para>\\\\.\mailslot\\[<i>path</i>]<i>name</i></para>
        /// <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\\\.\mailslot\example_mailslot_name and \\\\.\mailslot\abc\def\ghi are valid names.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createmailslotw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nMaxMessageSize">The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</param>
        /// <param name = "lReadTimeout">
        /// <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createmailslotw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSecurityAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createmailslotw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations.  The handle returned by this function is asynchronous, or overlapped.</para>
        /// <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createmailslotw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateMailslotW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateMailslot(win32.System.SystemServices.PCWSTR lpName, uint nMaxMessageSize, uint lReadTimeout, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributes);
        /// <inheritdoc cref = "GetMailslotInfo(win32.System.SystemServices.HANDLE, uint *, uint *, uint *, uint *)"/>
        internal static unsafe bool GetMailslotInfo(SafeHandle hMailslot, uint *lpMaxMessageSize, uint *lpNextSize, uint *lpMessageCount, uint *lpReadTimeout)
        {
            bool hMailslotAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hMailslotLocal;
                if (hMailslot is object)
                {
                    hMailslot.DangerousAddRef(ref hMailslotAddRef);
                    hMailslotLocal = (win32.System.SystemServices.HANDLE)hMailslot.DangerousGetHandle();
                }
                else
                    hMailslotLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.GetMailslotInfo(hMailslotLocal, lpMaxMessageSize, lpNextSize, lpMessageCount, lpReadTimeout);
                return __result;
            }
            finally
            {
                if (hMailslotAddRef)
                    hMailslot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the specified mailslot.</summary>
        /// <param name = "hMailslot">
        /// <para>A handle to a mailslot. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createmailslota">CreateMailslot</a> function must create this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getmailslotinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMaxMessageSize">
        /// <para>The maximum message size, in bytes, allowed for this mailslot. This value can be greater than or equal to the value specified in the <i>cbMaxMsg</i> parameter of the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createmailslota">CreateMailslot</a> function that created the mailslot. This parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getmailslotinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNextSize">
        /// <para>The size of the next message, in bytes. The following value has special meaning.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getmailslotinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMessageCount">The total number of messages waiting to be read, when the function returns. This parameter can be <b>NULL</b>.</param>
        /// <param name = "lpReadTimeout">The amount of time, in milliseconds, a read operation can wait for a message to be written to the mailslot before a time-out occurs. This parameter is filled in when the function returns. This parameter can be <b>NULL</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getmailslotinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetMailslotInfo(win32.System.SystemServices.HANDLE hMailslot, [Optional] uint *lpMaxMessageSize, [Optional] uint *lpNextSize, [Optional] uint *lpMessageCount, [Optional] uint *lpReadTimeout);
        /// <inheritdoc cref = "SetMailslotInfo(win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe bool SetMailslotInfo(SafeHandle hMailslot, uint lReadTimeout)
        {
            bool hMailslotAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hMailslotLocal;
                if (hMailslot is object)
                {
                    hMailslot.DangerousAddRef(ref hMailslotAddRef);
                    hMailslotLocal = (win32.System.SystemServices.HANDLE)hMailslot.DangerousGetHandle();
                }
                else
                    hMailslotLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetMailslotInfo(hMailslotLocal, lReadTimeout);
                return __result;
            }
            finally
            {
                if (hMailslotAddRef)
                    hMailslot.DangerousRelease();
            }
        }

        /// <summary>Sets the time-out value used by the specified mailslot for a read operation.</summary>
        /// <param name = "hMailslot">
        /// <para>A handle to a mailslot. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createmailslota">CreateMailslot</a> function must create this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setmailslotinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lReadTimeout">
        /// <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setmailslotinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setmailslotinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetMailslotInfo(win32.System.SystemServices.HANDLE hMailslot, uint lReadTimeout);
        /// <inheritdoc cref = "BackupRead(win32.System.SystemServices.HANDLE, byte *, uint, uint *, bool, bool, void **)"/>
        internal static unsafe bool BackupRead(SafeHandle hFile, out byte lpBuffer, uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, bool bAbort, bool bProcessSecurity, ref void *lpContext)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (void **lpContextLocal = &lpContext)
                {
                    fixed (uint *lpNumberOfBytesReadLocal = &lpNumberOfBytesRead)
                    {
                        fixed (byte *lpBufferLocal = &lpBuffer)
                        {
                            win32.System.SystemServices.HANDLE hFileLocal;
                            if (hFile is object)
                            {
                                hFile.DangerousAddRef(ref hFileAddRef);
                                hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                            }
                            else
                                hFileLocal = default(win32.System.SystemServices.HANDLE);
                            bool __result = Kernel32.BackupRead(hFileLocal, lpBufferLocal, nNumberOfBytesToRead, lpNumberOfBytesReadLocal, bAbort, bProcessSecurity, lpContextLocal);
                            return __result;
                        }
                    }
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Back up a file or directory, including the security information.</summary>
        /// <param name = "hFile">
        /// <para>Handle to the file or directory to be backed up. To obtain the handle, call the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function. The SACLs are not read unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. For more information, see [File security and access rights](/windows/win32/fileio/file-security-and-access-rights).</para>
        /// <para>The handle must be synchronous (nonoverlapped). This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set when <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.</para>
        /// <para>The <b>BackupRead</b> function may fail if <b>CreateFile</b> was called with the flag <b>FILE_FLAG_NO_BUFFERING</b>. In this case, the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the value <b>ERROR_INVALID_PARAMETER</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">Pointer to a buffer that receives the data.</param>
        /// <param name = "nNumberOfBytesToRead">
        /// <para>Length of the buffer, in bytes. The buffer size must be greater than the size of a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-win32_stream_id">WIN32_STREAM_ID</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNumberOfBytesRead">
        /// <para>Pointer to a variable that receives the number of bytes read.</para>
        /// <para>If the function returns a nonzero value, and the variable pointed to by <i>lpNumberOfBytesRead</i> is zero, then all the data associated with the file handle has been read.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bAbort">
        /// <para>Indicates whether you have finished using <b>BackupRead</b> on the handle. While you are backing up the file, specify this parameter as <b>FALSE</b>. Once you are done using <b>BackupRead</b>, you must call <b>BackupRead</b> one more time specifying <b>TRUE</b> for this parameter and passing the appropriate <i>lpContext</i>. <i>lpContext</i> must be passed when <i>bAbort</i> is <b>TRUE</b>; all other parameters are ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bProcessSecurity">
        /// <para>Indicates whether the function will restore the access-control list (ACL) data for the file or directory.</para>
        /// <para>If <i>bProcessSecurity</i> is <b>TRUE</b>, the ACL data will be backed up.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpContext">
        /// <para>Pointer to a variable that receives a pointer to an internal data structure used by <b>BackupRead</b> to maintain context information during a backup operation.</para>
        /// <para>You must set the variable pointed to by <i>lpContext</i> to <b>NULL</b> before the first call to <b>BackupRead</b> for the specified file or directory. The function allocates memory for the data structure, and then sets the variable to point to that structure. You must not change <i>lpContext</i> or the variable that it points to between calls to <b>BackupRead</b>.</para>
        /// <para>To release the memory used by the data structure, call <b>BackupRead</b> with the <i>bAbort</i> parameter set to <b>TRUE</b> when the backup operation is complete.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero, indicating that an I/O error occurred. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool BackupRead(win32.System.SystemServices.HANDLE hFile, byte *lpBuffer, uint nNumberOfBytesToRead, uint *lpNumberOfBytesRead, bool bAbort, bool bProcessSecurity, void **lpContext);
        /// <inheritdoc cref = "BackupSeek(win32.System.SystemServices.HANDLE, uint, uint, uint *, uint *, void **)"/>
        internal static unsafe bool BackupSeek(SafeHandle hFile, uint dwLowBytesToSeek, uint dwHighBytesToSeek, out uint lpdwLowByteSeeked, out uint lpdwHighByteSeeked, ref void *lpContext)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (void **lpContextLocal = &lpContext)
                {
                    fixed (uint *lpdwHighByteSeekedLocal = &lpdwHighByteSeeked)
                    {
                        fixed (uint *lpdwLowByteSeekedLocal = &lpdwLowByteSeeked)
                        {
                            win32.System.SystemServices.HANDLE hFileLocal;
                            if (hFile is object)
                            {
                                hFile.DangerousAddRef(ref hFileAddRef);
                                hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                            }
                            else
                                hFileLocal = default(win32.System.SystemServices.HANDLE);
                            bool __result = Kernel32.BackupSeek(hFileLocal, dwLowBytesToSeek, dwHighBytesToSeek, lpdwLowByteSeekedLocal, lpdwHighByteSeekedLocal, lpContextLocal);
                            return __result;
                        }
                    }
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Seeks forward in a data stream initially accessed by using the BackupRead or BackupWrite function.</summary>
        /// <param name = "hFile">
        /// <para>Handle to the file or directory. This handle is created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</para>
        /// <para>The handle must be synchronous (nonoverlapped). This means that the FILE_FLAG_OVERLAPPED flag must not be set when <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupseek#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwLowBytesToSeek">Low-order part of the number of bytes to seek.</param>
        /// <param name = "dwHighBytesToSeek">High-order part of the number of bytes to seek.</param>
        /// <param name = "lpdwLowByteSeeked">Pointer to a variable that receives the low-order bits of the number of bytes the function actually seeks.</param>
        /// <param name = "lpdwHighByteSeeked">Pointer to a variable that receives the high-order bits of the number of bytes the function actually seeks.</param>
        /// <param name = "lpContext">
        /// <para>Pointer to an internal data structure used by the function. This structure must be the same structure that was initialized by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupread">BackupRead</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupwrite">BackupWrite</a> function. An application must not touch the contents of this structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupseek#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function could seek the requested amount, the function returns a nonzero value.</para>
        /// <para>If the function could not seek the requested amount, the function returns zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupseek">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool BackupSeek(win32.System.SystemServices.HANDLE hFile, uint dwLowBytesToSeek, uint dwHighBytesToSeek, uint *lpdwLowByteSeeked, uint *lpdwHighByteSeeked, void **lpContext);
        /// <inheritdoc cref = "BackupWrite(win32.System.SystemServices.HANDLE, byte *, uint, uint *, bool, bool, void **)"/>
        internal static unsafe bool BackupWrite(SafeHandle hFile, in byte lpBuffer, uint nNumberOfBytesToWrite, out uint lpNumberOfBytesWritten, bool bAbort, bool bProcessSecurity, ref void *lpContext)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (void **lpContextLocal = &lpContext)
                {
                    fixed (uint *lpNumberOfBytesWrittenLocal = &lpNumberOfBytesWritten)
                    {
                        fixed (byte *lpBufferLocal = &lpBuffer)
                        {
                            win32.System.SystemServices.HANDLE hFileLocal;
                            if (hFile is object)
                            {
                                hFile.DangerousAddRef(ref hFileAddRef);
                                hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                            }
                            else
                                hFileLocal = default(win32.System.SystemServices.HANDLE);
                            bool __result = Kernel32.BackupWrite(hFileLocal, lpBufferLocal, nNumberOfBytesToWrite, lpNumberOfBytesWrittenLocal, bAbort, bProcessSecurity, lpContextLocal);
                            return __result;
                        }
                    }
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Restore a file or directory that was backed up using BackupRead.</summary>
        /// <param name = "hFile">
        /// <para>Handle to the file or directory to be restored. To obtain the handle, call the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function. The SACLs are not restored unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. To ensure that the integrity ACEs are restored correctly, the file handle must also have been created with the <b>WRITE_OWNER</b> access right. For more information, see [File security and access rights](/windows/win32/fileio/file-security-and-access-rights).</para>
        /// <para>The handle must be synchronous (nonoverlapped). This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set when <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.</para>
        /// <para>The <b>BackupWrite</b> function may fail if <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> was called with the flag <b>FILE_FLAG_NO_BUFFERING</b>. In this case, the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the value <b>ERROR_INVALID_PARAMETER</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupwrite#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">Pointer to a buffer that the function writes data from.</param>
        /// <param name = "nNumberOfBytesToWrite">
        /// <para>Size of the buffer, in bytes. The buffer size must be greater than the size of a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-win32_stream_id">WIN32_STREAM_ID</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupwrite#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNumberOfBytesWritten">Pointer to a variable that receives the number of bytes written.</param>
        /// <param name = "bAbort">
        /// <para>Indicates whether you have finished using <b>BackupWrite</b> on the handle. While you are restoring the file, specify this parameter as <b>FALSE</b>. After you are done using <b>BackupWrite</b>, you must call <b>BackupWrite</b> one more time specifying <b>TRUE</b> for this parameter and passing the appropriate <i>lpContext</i>. <i>lpContext</i> must be passed when <i>bAbort</i> is <b>TRUE</b>; all other parameters are ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupwrite#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bProcessSecurity">
        /// <para>Specifies whether the function will restore the access-control list (ACL) data for the file or directory.</para>
        /// <para>If <i>bProcessSecurity</i> is <b>TRUE</b>, you need to specify <b>WRITE_OWNER</b> and <b>WRITE_DAC</b> access when opening the file or directory handle. If the handle does not have those access rights, the operating system denies access to the ACL data, and ACL data restoration will not occur.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupwrite#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpContext">
        /// <para>Pointer to a variable that receives a pointer to an internal data structure used by <b>BackupWrite</b> to maintain context information during a restore operation.</para>
        /// <para>You must set the variable pointed to by <i>lpContext</i> to <b>NULL</b> before the first call to <b>BackupWrite</b> for the specified file or directory. The function allocates memory for the data structure, and then sets the variable to point to that structure. You must not change <i>lpContext</i> or the variable that it points to between calls to <b>BackupWrite</b>.</para>
        /// <para>To release the memory used by the data structure, call <b>BackupWrite</b> with the <i>bAbort</i> parameter set to <b>TRUE</b> when the restore operation is complete.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupwrite#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero, indicating that an I/O error occurred. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupwrite">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool BackupWrite(win32.System.SystemServices.HANDLE hFile, byte *lpBuffer, uint nNumberOfBytesToWrite, uint *lpNumberOfBytesWritten, bool bAbort, bool bProcessSecurity, void **lpContext);
        /// <inheritdoc cref = "LoadPackagedLibrary(win32.System.SystemServices.PCWSTR, uint)"/>
        internal static unsafe Kernel32.FreeLibrarySafeHandle LoadPackagedLibrary(string lpwLibFileName, uint Reserved)
        {
            fixed (char *lpwLibFileNameLocal = lpwLibFileName)
            {
                win32.System.SystemServices.HINSTANCE __result = Kernel32.LoadPackagedLibrary(lpwLibFileNameLocal, Reserved);
                return new Kernel32.FreeLibrarySafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Loads the specified packaged module and its dependencies into the address space of the calling process.</summary>
        /// <param name = "lpwLibFileName">
        /// <para>The file name of the packaged module to load. The module can be a library module (a .dll file) or an executable module (an .exe file).</para>
        /// <para>If this parameter specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.</para>
        /// <para>If this parameter specifies a path, the function searches that path for the module. The path cannot be an absolute path or a relative path that contains ".." in the path.   When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
        /// <para>If the specified module is already loaded in the process, the function returns a handle to the loaded module. The module must have been originally loaded  from the package dependency graph of the process.</para>
        /// <para>If loading the specified module causes the system to load other associated modules, the function first searches loaded modules, then it searches the package dependency graph of the process.  For more information, see Remarks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-loadpackagedlibrary#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Reserved">This parameter is reserved. It must be 0.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the loaded module.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-loadpackagedlibrary">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HINSTANCE LoadPackagedLibrary(win32.System.SystemServices.PCWSTR lpwLibFileName, uint Reserved);
        /// <inheritdoc cref = "QueryFullProcessImageName(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PROCESS_NAME_FORMAT, win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe bool QueryFullProcessImageName(SafeHandle hProcess, win32.System.SystemServices.PROCESS_NAME_FORMAT dwFlags, win32.System.SystemServices.PWSTR lpExeName, ref uint lpdwSize)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *lpdwSizeLocal = &lpdwSize)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.QueryFullProcessImageName(hProcessLocal, dwFlags, lpExeName, lpdwSizeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the full name of the executable image for the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-queryfullprocessimagenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <param name = "lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
        /// <param name = "lpdwSize">On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-queryfullprocessimagenamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "QueryFullProcessImageNameW", SetLastError = true)]
        internal static extern unsafe bool QueryFullProcessImageName(win32.System.SystemServices.HANDLE hProcess, win32.System.SystemServices.PROCESS_NAME_FORMAT dwFlags, win32.System.SystemServices.PWSTR lpExeName, uint *lpdwSize);
        /// <inheritdoc cref = "SetDllDirectory(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetDllDirectory(string lpPathName)
        {
            fixed (char *lpPathNameLocal = lpPathName)
            {
                bool __result = Kernel32.SetDllDirectory(lpPathNameLocal);
                return __result;
            }
        }

        /// <summary>Adds a directory to the search path used to locate DLLs for the application.</summary>
        /// <param name = "lpPathName">The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setdlldirectoryw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetDllDirectoryW", SetLastError = true)]
        internal static extern bool SetDllDirectory(win32.System.SystemServices.PCWSTR lpPathName);
        /// <summary>Retrieves the application-specific portion of the search path used to locate DLLs for the application.</summary>
        /// <param name = "nBufferLength">The size of the output buffer, in characters.</param>
        /// <param name = "lpBuffer">A pointer to a buffer that receives the application-specific portion of the search path.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length of the string copied to <i>lpBuffer</i>, in characters, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for the path.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getdlldirectoryw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetDllDirectoryW", SetLastError = true)]
        internal static extern uint GetDllDirectory(uint nBufferLength, win32.System.SystemServices.PWSTR lpBuffer);
        /// <inheritdoc cref = "GetNamedPipeClientProcessId(win32.System.SystemServices.HANDLE, uint *)"/>
        internal static unsafe bool GetNamedPipeClientProcessId(SafeHandle Pipe, out uint ClientProcessId)
        {
            bool PipeAddRef = false;
            try
            {
                fixed (uint *ClientProcessIdLocal = &ClientProcessId)
                {
                    win32.System.SystemServices.HANDLE PipeLocal;
                    if (Pipe is object)
                    {
                        Pipe.DangerousAddRef(ref PipeAddRef);
                        PipeLocal = (win32.System.SystemServices.HANDLE)Pipe.DangerousGetHandle();
                    }
                    else
                        PipeLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetNamedPipeClientProcessId(PipeLocal, ClientProcessIdLocal);
                    return __result;
                }
            }
            finally
            {
                if (PipeAddRef)
                    Pipe.DangerousRelease();
            }
        }

        /// <summary>Retrieves the client process identifier for the specified named pipe.</summary>
        /// <param name = "Pipe">
        /// <para>A handle to an instance of a named pipe. This handle must be created by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnamedpipeclientprocessid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ClientProcessId">The process identifier.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnamedpipeclientprocessid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNamedPipeClientProcessId(win32.System.SystemServices.HANDLE Pipe, uint *ClientProcessId);
        /// <inheritdoc cref = "GetNamedPipeClientSessionId(win32.System.SystemServices.HANDLE, uint *)"/>
        internal static unsafe bool GetNamedPipeClientSessionId(SafeHandle Pipe, out uint ClientSessionId)
        {
            bool PipeAddRef = false;
            try
            {
                fixed (uint *ClientSessionIdLocal = &ClientSessionId)
                {
                    win32.System.SystemServices.HANDLE PipeLocal;
                    if (Pipe is object)
                    {
                        Pipe.DangerousAddRef(ref PipeAddRef);
                        PipeLocal = (win32.System.SystemServices.HANDLE)Pipe.DangerousGetHandle();
                    }
                    else
                        PipeLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetNamedPipeClientSessionId(PipeLocal, ClientSessionIdLocal);
                    return __result;
                }
            }
            finally
            {
                if (PipeAddRef)
                    Pipe.DangerousRelease();
            }
        }

        /// <summary>Retrieves the client session identifier for the specified named pipe.</summary>
        /// <param name = "Pipe">
        /// <para>A handle to an instance of a named pipe. This handle must be created by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnamedpipeclientsessionid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ClientSessionId">The session identifier.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnamedpipeclientsessionid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNamedPipeClientSessionId(win32.System.SystemServices.HANDLE Pipe, uint *ClientSessionId);
        /// <inheritdoc cref = "GetNamedPipeServerProcessId(win32.System.SystemServices.HANDLE, uint *)"/>
        internal static unsafe bool GetNamedPipeServerProcessId(SafeHandle Pipe, out uint ServerProcessId)
        {
            bool PipeAddRef = false;
            try
            {
                fixed (uint *ServerProcessIdLocal = &ServerProcessId)
                {
                    win32.System.SystemServices.HANDLE PipeLocal;
                    if (Pipe is object)
                    {
                        Pipe.DangerousAddRef(ref PipeAddRef);
                        PipeLocal = (win32.System.SystemServices.HANDLE)Pipe.DangerousGetHandle();
                    }
                    else
                        PipeLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetNamedPipeServerProcessId(PipeLocal, ServerProcessIdLocal);
                    return __result;
                }
            }
            finally
            {
                if (PipeAddRef)
                    Pipe.DangerousRelease();
            }
        }

        /// <summary>Retrieves the server process identifier for the specified named pipe.</summary>
        /// <param name = "Pipe">
        /// <para>A handle to an instance of a named pipe. This handle must be created by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnamedpipeserverprocessid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ServerProcessId">The process identifier.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnamedpipeserverprocessid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNamedPipeServerProcessId(win32.System.SystemServices.HANDLE Pipe, uint *ServerProcessId);
        /// <inheritdoc cref = "GetNamedPipeServerSessionId(win32.System.SystemServices.HANDLE, uint *)"/>
        internal static unsafe bool GetNamedPipeServerSessionId(SafeHandle Pipe, out uint ServerSessionId)
        {
            bool PipeAddRef = false;
            try
            {
                fixed (uint *ServerSessionIdLocal = &ServerSessionId)
                {
                    win32.System.SystemServices.HANDLE PipeLocal;
                    if (Pipe is object)
                    {
                        Pipe.DangerousAddRef(ref PipeAddRef);
                        PipeLocal = (win32.System.SystemServices.HANDLE)Pipe.DangerousGetHandle();
                    }
                    else
                        PipeLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetNamedPipeServerSessionId(PipeLocal, ServerSessionIdLocal);
                    return __result;
                }
            }
            finally
            {
                if (PipeAddRef)
                    Pipe.DangerousRelease();
            }
        }

        /// <summary>Retrieves the server session identifier for the specified named pipe.</summary>
        /// <param name = "Pipe">
        /// <para>A handle to an instance of a named pipe. This handle must be created by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnamedpipeserversessionid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ServerSessionId">The session identifier.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnamedpipeserversessionid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNamedPipeServerSessionId(win32.System.SystemServices.HANDLE Pipe, uint *ServerSessionId);
        /// <inheritdoc cref = "MapViewOfFileExNuma(win32.System.SystemServices.HANDLE, win32.System.SystemServices.FILE_MAP, uint, uint, nuint, void *, uint)"/>
        internal static unsafe void *MapViewOfFileExNuma(SafeHandle hFileMappingObject, win32.System.SystemServices.FILE_MAP dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, nuint dwNumberOfBytesToMap, void *lpBaseAddress, uint nndPreferred)
        {
            bool hFileMappingObjectAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileMappingObjectLocal;
                if (hFileMappingObject is object)
                {
                    hFileMappingObject.DangerousAddRef(ref hFileMappingObjectAddRef);
                    hFileMappingObjectLocal = (win32.System.SystemServices.HANDLE)hFileMappingObject.DangerousGetHandle();
                }
                else
                    hFileMappingObjectLocal = default(win32.System.SystemServices.HANDLE);
                void *__result = Kernel32.MapViewOfFileExNuma(hFileMappingObjectLocal, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress, nndPreferred);
                return __result;
            }
            finally
            {
                if (hFileMappingObjectAddRef)
                    hFileMappingObject.DangerousRelease();
            }
        }

        /// <summary>Maps a view of a file mapping into the address space of a calling process and specifies the NUMA node for the physical memory.</summary>
        /// <param name = "hFileMappingObject">
        /// <para>A handle to a file mapping object. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfilemappingnumaa">CreateFileMappingNuma</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openfilemappinga">OpenFileMapping</a> functions return this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-mapviewoffileexnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">The type of access to a file mapping object, which determines the page protection of the pages. This</param>
        /// <param name = "dwFileOffsetHigh">The high-order <b>DWORD</b> of the file offset where the view is to begin.</param>
        /// <param name = "dwFileOffsetLow">
        /// <para>The low-order <b>DWORD</b> of the file offset where the view is to begin. The combination of the high and low offsets must specify an offset within the file mapping. They must also match the memory allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To obtain the memory allocation granularity of the system, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function, which fills in the members of a <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/ns-sysinfoapi-system_info">SYSTEM_INFO</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-mapviewoffileexnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwNumberOfBytesToMap">
        /// <para>The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size specified by <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping</a>. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the file mapping.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-mapviewoffileexnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBaseAddress">
        /// <para>A pointer to the memory address in the calling process address space where mapping begins. This must be a multiple of the system's memory allocation granularity, or the function fails. To determine the memory allocation granularity of the system, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function. If there is not enough address space at the specified address, the function fails.</para>
        /// <para>If the <i>lpBaseAddress</i> parameter is <b>NULL</b>, the operating system chooses the mapping address.</para>
        /// <para>While it is possible to specify an address that is safe now (not used by the operating system), there is no guarantee that the address will remain safe over time. Therefore, it is better to let the operating system choose the address. In this case, you would not store pointers in the memory mapped file; you would store offsets from the base of the file mapping so that the mapping can be used at any address.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-mapviewoffileexnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nndPreferred">
        /// <para>The NUMA node where the physical memory should reside.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-mapviewoffileexnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-mapviewoffileexnuma">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *MapViewOfFileExNuma(win32.System.SystemServices.HANDLE hFileMappingObject, win32.System.SystemServices.FILE_MAP dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, nuint dwNumberOfBytesToMap, [Optional] void *lpBaseAddress, uint nndPreferred);
        /// <summary>Verifies that the calling process has read access to the specified range of memory.</summary>
        /// <param name = "lp">A pointer to the first byte of the memory block.</param>
        /// <param name = "ucb">The size of the memory block, in bytes. If this parameter is zero, the return value is zero.</param>
        /// <returns>
        /// <para>If the calling process has read access to all bytes in the specified memory range, the return value is zero.</para>
        /// <para>If the calling process does not have read access to all bytes in the specified memory range, the return value is nonzero.</para>
        /// <para>If the application is compiled as a debugging version, and the process does not have read access to all bytes in the specified memory range, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value. This behavior is by design, as a debugging aid.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-isbadreadptr">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool IsBadReadPtr([Optional] void *lp, nuint ucb);
        /// <summary>Verifies that the calling process has write access to the specified range of memory.</summary>
        /// <param name = "lp">A pointer to the first byte of the memory block.</param>
        /// <param name = "ucb">The size of the memory block, in bytes. If this parameter is zero, the return value is zero.</param>
        /// <returns>
        /// <para>If the calling process has write access to all bytes in the specified memory range, the return value is zero.</para>
        /// <para>If the calling process does not have write access to all bytes in the specified memory range, the return value is nonzero.</para>
        /// <para>If the application is run under a debugger and the process does not have write access to all bytes in the specified memory range, the function causes a first chance STATUS_ACCESS_VIOLATION exception. The debugger can be configured to break for this condition. After resuming process execution in the debugger, the function continues as usual and returns a nonzero value This behavior is by design and serves as a debugging aid.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-isbadwriteptr">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool IsBadWritePtr([Optional] void *lp, nuint ucb);
        /// <summary>Determines whether the calling process has read access to the memory at the specified address.</summary>
        /// <param name = "lpfn">A pointer to a memory address.</param>
        /// <returns>
        /// <para>If the calling process has read access to the specified memory, the return value is zero.</para>
        /// <para>If the calling process does not have read access to the specified memory, the return value is nonzero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the application is compiled as a debugging version, and the process does not have read access to  the specified memory location, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value. This behavior is by design, as a debugging aid.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-isbadcodeptr">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool IsBadCodePtr(delegate *unmanaged[Stdcall]<nint>lpfn);
        /// <inheritdoc cref = "IsBadStringPtr(win32.System.SystemServices.PCWSTR, nuint)"/>
        internal static unsafe bool IsBadStringPtr(string lpsz, nuint ucchMax)
        {
            fixed (char *lpszLocal = lpsz)
            {
                bool __result = Kernel32.IsBadStringPtr(lpszLocal, ucchMax);
                return __result;
            }
        }

        /// <summary>Verifies that the calling process has read access to the specified range of memory.</summary>
        /// <param name = "lpsz">A pointer to a null-terminated string, either Unicode or ASCII.</param>
        /// <param name = "ucchMax">The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</param>
        /// <returns>
        /// <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
        /// <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
        /// <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-isbadstringptrw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "IsBadStringPtrW")]
        internal static extern bool IsBadStringPtr(win32.System.SystemServices.PCWSTR lpsz, nuint ucchMax);
        /// <inheritdoc cref = "BuildCommDCBA(win32.System.SystemServices.PCSTR, win32.System.SystemServices.DCB*)"/>
        internal static unsafe bool BuildCommDCBA(win32.System.SystemServices.PCSTR lpDef, out win32.System.SystemServices.DCB lpDCB)
        {
            fixed (win32.System.SystemServices.DCB*lpDCBLocal = &lpDCB)
            {
                bool __result = Kernel32.BuildCommDCBA(lpDef, lpDCBLocal);
                return __result;
            }
        }

        /// <summary>Fills a specified DCB structure with values specified in a device-control string.</summary>
        /// <param name = "lpDef">
        /// <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-dcb">DCB</a> structure pointed to by <i>lpDCB</i>.</para>
        /// <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
        /// <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
        /// <para>The device name is optional, but it must specify a valid device if used.</para>
        /// <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
        /// <para><c>baud=1200 parity=N data=8 stop=1</c></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-buildcommdcba#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDCB">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-dcb">DCB</a> structure that receives the information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-buildcommdcba#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-buildcommdcba">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool BuildCommDCBA(win32.System.SystemServices.PCSTR lpDef, win32.System.SystemServices.DCB*lpDCB);
        /// <inheritdoc cref = "BuildCommDCBW(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.DCB*)"/>
        internal static unsafe bool BuildCommDCBW(string lpDef, out win32.System.SystemServices.DCB lpDCB)
        {
            fixed (win32.System.SystemServices.DCB*lpDCBLocal = &lpDCB)
            {
                fixed (char *lpDefLocal = lpDef)
                {
                    bool __result = Kernel32.BuildCommDCBW(lpDefLocal, lpDCBLocal);
                    return __result;
                }
            }
        }

        /// <summary>Fills a specified DCB structure with values specified in a device-control string.</summary>
        /// <param name = "lpDef">
        /// <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-dcb">DCB</a> structure pointed to by <i>lpDCB</i>.</para>
        /// <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
        /// <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
        /// <para>The device name is optional, but it must specify a valid device if used.</para>
        /// <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
        /// <para><c>baud=1200 parity=N data=8 stop=1</c></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-buildcommdcbw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDCB">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-dcb">DCB</a> structure that receives the information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-buildcommdcbw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-buildcommdcbw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool BuildCommDCBW(win32.System.SystemServices.PCWSTR lpDef, win32.System.SystemServices.DCB*lpDCB);
        /// <inheritdoc cref = "BuildCommDCBAndTimeouts(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.DCB*, win32.System.SystemServices.COMMTIMEOUTS*)"/>
        internal static unsafe bool BuildCommDCBAndTimeouts(string lpDef, out win32.System.SystemServices.DCB lpDCB, out win32.System.SystemServices.COMMTIMEOUTS lpCommTimeouts)
        {
            fixed (win32.System.SystemServices.COMMTIMEOUTS*lpCommTimeoutsLocal = &lpCommTimeouts)
            {
                fixed (win32.System.SystemServices.DCB*lpDCBLocal = &lpDCB)
                {
                    fixed (char *lpDefLocal = lpDef)
                    {
                        bool __result = Kernel32.BuildCommDCBAndTimeouts(lpDefLocal, lpDCBLocal, lpCommTimeoutsLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Translates a device-definition string into appropriate device-control block codes and places them into a device control block.</summary>
        /// <param name = "lpDef">
        /// <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-dcb">DCB</a> structure pointed to by <i>lpDCB</i>.</para>
        /// <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
        /// <para><b>COM</b><i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
        /// <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19 represents 19,200 baud.</para>
        /// <para>The "parity" substring indicates how the parity bit is used to detect transmission errors. The values represent "none", "even", "odd", "mark", and "space".</para>
        /// <para>For more information, see the <a href = "https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command reference in TechNet.</para>
        /// <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
        /// <para><c>baud=1200 parity=N data=8 stop=1</c></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-buildcommdcbandtimeoutsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDCB">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-dcb">DCB</a> structure that receives information from the device-control information string pointed to by <i>lpDef</i>. This <b>DCB</b> structure defines the control settings for a communications device.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-buildcommdcbandtimeoutsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCommTimeouts">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-commtimeouts">COMMTIMEOUTS</a> structure that receives time-out information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-buildcommdcbandtimeoutsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-buildcommdcbandtimeoutsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "BuildCommDCBAndTimeoutsW", SetLastError = true)]
        internal static extern unsafe bool BuildCommDCBAndTimeouts(win32.System.SystemServices.PCWSTR lpDef, win32.System.SystemServices.DCB*lpDCB, win32.System.SystemServices.COMMTIMEOUTS*lpCommTimeouts);
        /// <inheritdoc cref = "CommConfigDialog(win32.System.SystemServices.PCWSTR, win32.UI.WindowsAndMessaging.HWND, win32.System.SystemServices.COMMCONFIG*)"/>
        internal static unsafe bool CommConfigDialog(string lpszName, win32.UI.WindowsAndMessaging.HWND hWnd, ref win32.System.SystemServices.COMMCONFIG lpCC)
        {
            fixed (win32.System.SystemServices.COMMCONFIG*lpCCLocal = &lpCC)
            {
                fixed (char *lpszNameLocal = lpszName)
                {
                    bool __result = Kernel32.CommConfigDialog(lpszNameLocal, hWnd, lpCCLocal);
                    return __result;
                }
            }
        }

        /// <summary>Displays a driver-supplied configuration dialog box.</summary>
        /// <param name = "lpszName">The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
        /// <param name = "hWnd">A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</param>
        /// <param name = "lpCC">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-commconfig">COMMCONFIG</a> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-commconfigdialogw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-commconfigdialogw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CommConfigDialogW", SetLastError = true)]
        internal static extern unsafe bool CommConfigDialog(win32.System.SystemServices.PCWSTR lpszName, win32.UI.WindowsAndMessaging.HWND hWnd, win32.System.SystemServices.COMMCONFIG*lpCC);
        /// <inheritdoc cref = "GetDefaultCommConfig(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.COMMCONFIG*, uint *)"/>
        internal static unsafe bool GetDefaultCommConfig(string lpszName, out win32.System.SystemServices.COMMCONFIG lpCC, ref uint lpdwSize)
        {
            fixed (uint *lpdwSizeLocal = &lpdwSize)
            {
                fixed (win32.System.SystemServices.COMMCONFIG*lpCCLocal = &lpCC)
                {
                    fixed (char *lpszNameLocal = lpszName)
                    {
                        bool __result = Kernel32.GetDefaultCommConfig(lpszNameLocal, lpCCLocal, lpdwSizeLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Retrieves the default configuration for the specified communications device.</summary>
        /// <param name = "lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
        /// <param name = "lpCC">
        /// <para>A pointer to a buffer that receives a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-commconfig">COMMCONFIG</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getdefaultcommconfigw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpdwSize">A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getdefaultcommconfigw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetDefaultCommConfigW", SetLastError = true)]
        internal static extern unsafe bool GetDefaultCommConfig(win32.System.SystemServices.PCWSTR lpszName, win32.System.SystemServices.COMMCONFIG*lpCC, uint *lpdwSize);
        /// <inheritdoc cref = "SetDefaultCommConfig(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.COMMCONFIG*, uint)"/>
        internal static unsafe bool SetDefaultCommConfig(string lpszName, in win32.System.SystemServices.COMMCONFIG lpCC, uint dwSize)
        {
            fixed (win32.System.SystemServices.COMMCONFIG*lpCCLocal = &lpCC)
            {
                fixed (char *lpszNameLocal = lpszName)
                {
                    bool __result = Kernel32.SetDefaultCommConfig(lpszNameLocal, lpCCLocal, dwSize);
                    return __result;
                }
            }
        }

        /// <summary>Sets the default configuration for a communications device.</summary>
        /// <param name = "lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
        /// <param name = "lpCC">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-commconfig">COMMCONFIG</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setdefaultcommconfigw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSize">The size of the structure pointed to by <i>lpCC</i>, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setdefaultcommconfigw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetDefaultCommConfigW", SetLastError = true)]
        internal static extern unsafe bool SetDefaultCommConfig(win32.System.SystemServices.PCWSTR lpszName, win32.System.SystemServices.COMMCONFIG*lpCC, uint dwSize);
        /// <inheritdoc cref = "RegisterWaitForSingleObject(win32.System.SystemServices.HANDLE*, win32.System.SystemServices.HANDLE, delegate *unmanaged[Stdcall]{void *, byte, void}, void *, uint, win32.System.SystemServices.WORKER_THREAD_FLAGS)"/>
        internal static unsafe bool RegisterWaitForSingleObject(out Microsoft.Win32.SafeHandles.SafeFileHandle phNewWaitObject, SafeHandle hObject, delegate *unmanaged[Stdcall]<void *, byte, void>Callback, void *Context, uint dwMilliseconds, win32.System.SystemServices.WORKER_THREAD_FLAGS dwFlags)
        {
            bool hObjectAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE phNewWaitObjectLocal;
                win32.System.SystemServices.HANDLE hObjectLocal;
                if (hObject is object)
                {
                    hObject.DangerousAddRef(ref hObjectAddRef);
                    hObjectLocal = (win32.System.SystemServices.HANDLE)hObject.DangerousGetHandle();
                }
                else
                    hObjectLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.RegisterWaitForSingleObject(&phNewWaitObjectLocal, hObjectLocal, Callback, Context, dwMilliseconds, dwFlags);
                phNewWaitObject = new Microsoft.Win32.SafeHandles.SafeFileHandle(phNewWaitObjectLocal, ownsHandle: true);
                return __result;
            }
            finally
            {
                if (hObjectAddRef)
                    hObject.DangerousRelease();
            }
        }

        /// <summary>Directs a wait thread in the thread pool to wait on the object.</summary>
        /// <param name = "phNewWaitObject">
        /// <para>A pointer to a variable that receives a wait handle on return. Note that a wait handle cannot be used in functions that require an object handle, such as <a href = "https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-registerwaitforsingleobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hObject">
        /// <para>A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.</para>
        /// <para>If this handle is closed while the wait is still pending, the function's behavior is undefined.</para>
        /// <para>The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-registerwaitforsingleobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Callback">
        /// <para>A pointer to the application-defined function of type <b>WAITORTIMERCALLBACK</b> to be executed when <i>hObject</i> is in the signaled state, or <i>dwMilliseconds</i> elapses. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms687066(v=vs.85)">WaitOrTimerCallback</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-registerwaitforsingleobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Context">A single value that is passed to the callback function.</param>
        /// <param name = "dwMilliseconds">The time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state is nonsignaled. If <i>dwMilliseconds</i> is zero, the function tests the object's state and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses.</param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-registerwaitforsingleobject">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool RegisterWaitForSingleObject(win32.System.SystemServices.HANDLE*phNewWaitObject, win32.System.SystemServices.HANDLE hObject, delegate *unmanaged[Stdcall]<void *, byte, void>Callback, [Optional] void *Context, uint dwMilliseconds, win32.System.SystemServices.WORKER_THREAD_FLAGS dwFlags);
        /// <inheritdoc cref = "UnregisterWait(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool UnregisterWait(SafeHandle WaitHandle)
        {
            bool WaitHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE WaitHandleLocal;
                if (WaitHandle is object)
                {
                    WaitHandle.DangerousAddRef(ref WaitHandleAddRef);
                    WaitHandleLocal = (win32.System.SystemServices.HANDLE)WaitHandle.DangerousGetHandle();
                }
                else
                    WaitHandleLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.UnregisterWait(WaitHandleLocal);
                return __result;
            }
            finally
            {
                if (WaitHandleAddRef)
                    WaitHandle.DangerousRelease();
            }
        }

        /// <summary>Cancels a registered wait operation issued by the RegisterWaitForSingleObject function.</summary>
        /// <param name = "WaitHandle">
        /// <para>The wait handle. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-registerwaitforsingleobject">RegisterWaitForSingleObject</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-unregisterwait#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-unregisterwait">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool UnregisterWait(win32.System.SystemServices.HANDLE WaitHandle);
        /// <inheritdoc cref = "BindIoCompletionCallback(win32.System.SystemServices.HANDLE, delegate *unmanaged[Stdcall]{uint, uint, win32.System.SystemServices.OVERLAPPED*, void}, uint)"/>
        internal static unsafe bool BindIoCompletionCallback(SafeHandle FileHandle, delegate *unmanaged[Stdcall]<uint, uint, win32.System.SystemServices.OVERLAPPED*, void>Function, uint Flags)
        {
            bool FileHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE FileHandleLocal;
                if (FileHandle is object)
                {
                    FileHandle.DangerousAddRef(ref FileHandleAddRef);
                    FileHandleLocal = (win32.System.SystemServices.HANDLE)FileHandle.DangerousGetHandle();
                }
                else
                    FileHandleLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.BindIoCompletionCallback(FileHandleLocal, Function, Flags);
                return __result;
            }
            finally
            {
                if (FileHandleAddRef)
                    FileHandle.DangerousRelease();
            }
        }

        /// <summary>Associates the I/O completion port owned by the thread pool with the specified file handle. On completion of an I/O request involving this file, a non-I/O worker thread will execute the specified callback function.</summary>
        /// <param name = "FileHandle">
        /// <para>A handle to the file opened for overlapped I/O completion. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function, with the <b>FILE_FLAG_OVERLAPPED</b> flag.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-bindiocompletioncallback#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Function">
        /// <para>A pointer to the callback function to be executed in a non-I/O worker thread when the I/O operation is complete. This callback function must not call the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread">TerminateThread</a> function.</para>
        /// <para>For more information about the completion routine, see <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-bindiocompletioncallback#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags">This parameter must be zero.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function. The value returned is an <b>NTSTATUS</b> error code. To retrieve the corresponding system error code, use the <a href = "/windows/desktop/api/winternl/nf-winternl-rtlntstatustodoserror">RtlNtStatusToDosError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-bindiocompletioncallback">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool BindIoCompletionCallback(win32.System.SystemServices.HANDLE FileHandle, delegate *unmanaged[Stdcall]<uint, uint, win32.System.SystemServices.OVERLAPPED*, void>Function, uint Flags);
        /// <inheritdoc cref = "DeleteTimerQueue(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool DeleteTimerQueue(SafeHandle TimerQueue)
        {
            bool TimerQueueAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE TimerQueueLocal;
                if (TimerQueue is object)
                {
                    TimerQueue.DangerousAddRef(ref TimerQueueAddRef);
                    TimerQueueLocal = (win32.System.SystemServices.HANDLE)TimerQueue.DangerousGetHandle();
                }
                else
                    TimerQueueLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.DeleteTimerQueue(TimerQueueLocal);
                return __result;
            }
            finally
            {
                if (TimerQueueAddRef)
                    TimerQueue.DangerousRelease();
            }
        }

        /// <summary>Deletes a timer queue. Any pending timers in the queue are canceled and deleted.</summary>
        /// <param name = "TimerQueue">
        /// <para>A handle to the timer queue. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueue">CreateTimerQueue</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deletetimerqueue#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deletetimerqueue">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DeleteTimerQueue(win32.System.SystemServices.HANDLE TimerQueue);
        /// <inheritdoc cref = "AddIntegrityLabelToBoundaryDescriptor(win32.System.SystemServices.HANDLE*, win32.Security.PSID)"/>
        internal static unsafe bool AddIntegrityLabelToBoundaryDescriptor(ref win32.System.SystemServices.HANDLE BoundaryDescriptor, win32.Security.PSID IntegrityLabel)
        {
            fixed (win32.System.SystemServices.HANDLE*BoundaryDescriptorLocal = &BoundaryDescriptor)
            {
                bool __result = Kernel32.AddIntegrityLabelToBoundaryDescriptor(BoundaryDescriptorLocal, IntegrityLabel);
                return __result;
            }
        }

        /// <summary>Adds a new required security identifier (SID) to the specified boundary descriptor.</summary>
        /// <param name = "BoundaryDescriptor">A handle to the boundary descriptor. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createboundarydescriptora">CreateBoundaryDescriptor</a> function returns this handle.</param>
        /// <param name = "IntegrityLabel">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-sid">SID</a> structure that represents the mandatory integrity level for the namespace. Use one of the following RID values to create the SID:</para>
        /// <para><b>SECURITY_MANDATORY_UNTRUSTED_RID</b> <b>SECURITY_MANDATORY_LOW_RID</b> <b>SECURITY_MANDATORY_MEDIUM_RID</b> <b>SECURITY_MANDATORY_SYSTEM_RID</b> <b>SECURITY_MANDATORY_PROTECTED_PROCESS_RID</b> For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/well-known-sids">Well-Known SIDs</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-addintegritylabeltoboundarydescriptor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-addintegritylabeltoboundarydescriptor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool AddIntegrityLabelToBoundaryDescriptor(win32.System.SystemServices.HANDLE*BoundaryDescriptor, win32.Security.PSID IntegrityLabel);
        /// <summary>Suspends the system by shutting power down. Depending on the ForceFlag parameter, the function either suspends operation immediately or requests permission from all applications and device drivers before doing so.</summary>
        /// <param name = "fSuspend">
        /// <para>If this parameter is <b>TRUE</b>, the system is suspended. If the parameter is <b>FALSE</b>, the system hibernates.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setsystempowerstate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fForce">This parameter has no effect.</param>
        /// <returns>
        /// <para>If power has been suspended and subsequently restored, the return value is nonzero.</para>
        /// <para>If the system was not suspended, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setsystempowerstate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetSystemPowerState(bool fSuspend, bool fForce);
        /// <inheritdoc cref = "GetSystemPowerStatus(win32.System.SystemServices.SYSTEM_POWER_STATUS*)"/>
        internal static unsafe bool GetSystemPowerStatus(out win32.System.SystemServices.SYSTEM_POWER_STATUS lpSystemPowerStatus)
        {
            fixed (win32.System.SystemServices.SYSTEM_POWER_STATUS*lpSystemPowerStatusLocal = &lpSystemPowerStatus)
            {
                bool __result = Kernel32.GetSystemPowerStatus(lpSystemPowerStatusLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the power status of the system. The status indicates whether the system is running on AC or DC power, whether the battery is currently charging, how much battery life remains, and if battery saver is on or off.</summary>
        /// <param name = "lpSystemPowerStatus">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-system_power_status">SYSTEM_POWER_STATUS</a> structure that receives status information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getsystempowerstatus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getsystempowerstatus">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetSystemPowerStatus(win32.System.SystemServices.SYSTEM_POWER_STATUS*lpSystemPowerStatus);
        /// <inheritdoc cref = "MapUserPhysicalPagesScatter(void **, nuint, nuint*)"/>
        internal static unsafe bool MapUserPhysicalPagesScatter(void **VirtualAddresses, Span<nuint> PageArray)
        {
            fixed (nuint*PageArrayLocal = PageArray)
            {
                bool __result = Kernel32.MapUserPhysicalPagesScatter(VirtualAddresses, (nuint)PageArray.Length, PageArrayLocal);
                return __result;
            }
        }

        /// <summary>Maps previously allocated physical memory pages at a specified address in an Address Windowing Extensions (AWE) region.</summary>
        /// <param name = "VirtualAddresses">
        /// <para>A pointer to an array of starting addresses of the regions of memory to remap.</para>
        /// <para>Each entry in <i>VirtualAddresses</i> must be within the address range that the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> function returns when the <a href = "https://docs.microsoft.com/windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region is allocated. The value in <i>NumberOfPages</i> indicates the size of the array. Entries can be from multiple Address Windowing Extensions (AWE) regions.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-mapuserphysicalpagesscatter#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "NumberOfPages">
        /// <para>The size of the physical memory and virtual address space for which to establish translations, in pages.</para>
        /// <para>The array at <i>VirtualAddresses</i> specifies the virtual address range.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-mapuserphysicalpagesscatter#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "PageArray">
        /// <para>A pointer to an array of values that indicates how each corresponding page in <i>VirtualAddresses</i> should be treated. A 0 (zero) indicates that the corresponding entry in <i>VirtualAddresses</i> should be unmapped, and any nonzero value that it has should be mapped.</para>
        /// <para>If this parameter is <b>NULL</b>, then every address in the <i>VirtualAddresses</i> array is unmapped. The value in <i>NumberOfPages</i> indicates the size of the array.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-mapuserphysicalpagesscatter#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
        /// <para>If the function fails, the return value is <b>FALSE</b>, and the function does not map or unmap—partial or otherwise. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-mapuserphysicalpagesscatter">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool MapUserPhysicalPagesScatter(void **VirtualAddresses, nuint NumberOfPages, [Optional] nuint*PageArray);
        /// <summary>Returns the number of active processor groups in the system.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is the number of active processor groups in the system.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getactiveprocessorgroupcount">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern ushort GetActiveProcessorGroupCount();
        /// <summary>Returns the maximum number of processor groups that the system can have.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is the maximum number of processor groups that the system can have.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getmaximumprocessorgroupcount">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern ushort GetMaximumProcessorGroupCount();
        /// <summary>Returns the number of active processors in a processor group or in the system.</summary>
        /// <param name = "GroupNumber">The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the number of active processors in the system.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the number of active processors in the specified group.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getactiveprocessorcount">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetActiveProcessorCount(ushort GroupNumber);
        /// <summary>Returns the maximum number of logical processors that a processor group or the system can have.</summary>
        /// <param name = "GroupNumber">The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the maximum number of processors that the system can have.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the maximum number of processors that the specified group can have.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getmaximumprocessorcount">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetMaximumProcessorCount(ushort GroupNumber);
        /// <inheritdoc cref = "GetNumaProcessorNode(byte, byte *)"/>
        internal static unsafe bool GetNumaProcessorNode(byte Processor, out byte NodeNumber)
        {
            fixed (byte *NodeNumberLocal = &NodeNumber)
            {
                bool __result = Kernel32.GetNumaProcessorNode(Processor, NodeNumberLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the node number for the specified processor.</summary>
        /// <param name = "Processor">
        /// <para>The processor number.</para>
        /// <para>On a system with more than 64 logical processors, the processor number is relative to the <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/processor-groups">processor group</a> that contains the processor on which the calling thread is running.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnumaprocessornode#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "NodeNumber">The node number. If the processor does not exist, this parameter is 0xFF.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnumaprocessornode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNumaProcessorNode(byte Processor, byte *NodeNumber);
        /// <inheritdoc cref = "GetNumaNodeNumberFromHandle(win32.System.SystemServices.HANDLE, ushort *)"/>
        internal static unsafe bool GetNumaNodeNumberFromHandle(SafeHandle hFile, out ushort NodeNumber)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (ushort *NodeNumberLocal = &NodeNumber)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetNumaNodeNumberFromHandle(hFileLocal, NodeNumberLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the NUMA node associated with the file or I/O device represented by the specified file handle.</summary>
        /// <param name = "hFile">A handle to a file or I/O device. Examples of I/O devices include files, file streams, volumes, physical disks, and sockets. For more information, see the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</param>
        /// <param name = "NodeNumber">A pointer to a variable to receive the number of the NUMA node associated with the specified file handle.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnumanodenumberfromhandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNumaNodeNumberFromHandle(win32.System.SystemServices.HANDLE hFile, ushort *NodeNumber);
        /// <inheritdoc cref = "GetNumaProcessorNodeEx(win32.System.Kernel.PROCESSOR_NUMBER*, ushort *)"/>
        internal static unsafe bool GetNumaProcessorNodeEx(in win32.System.Kernel.PROCESSOR_NUMBER Processor, out ushort NodeNumber)
        {
            fixed (ushort *NodeNumberLocal = &NodeNumber)
            {
                fixed (win32.System.Kernel.PROCESSOR_NUMBER*ProcessorLocal = &Processor)
                {
                    bool __result = Kernel32.GetNumaProcessorNodeEx(ProcessorLocal, NodeNumberLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves the node number as a USHORT value for the specified logical processor.</summary>
        /// <param name = "Processor">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-processor_number">PROCESSOR_NUMBER</a> structure that represents the logical processor and the processor group to which it is assigned.</param>
        /// <param name = "NodeNumber">A pointer  to a variable to receive the node number. If the specified processor does not exist, this parameter is set to MAXUSHORT.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnumaprocessornodeex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNumaProcessorNodeEx(win32.System.Kernel.PROCESSOR_NUMBER*Processor, ushort *NodeNumber);
        /// <inheritdoc cref = "GetNumaNodeProcessorMask(byte, ulong *)"/>
        internal static unsafe bool GetNumaNodeProcessorMask(byte Node, out ulong ProcessorMask)
        {
            fixed (ulong *ProcessorMaskLocal = &ProcessorMask)
            {
                bool __result = Kernel32.GetNumaNodeProcessorMask(Node, ProcessorMaskLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the processor mask for the specified node.</summary>
        /// <param name = "Node">The number of the node.</param>
        /// <param name = "ProcessorMask">
        /// <para>The processor mask for the node. A processor mask is a bit vector in which each bit represents a processor and whether it is in the node.</para>
        /// <para>If the node has no processors configured, the processor mask is zero.</para>
        /// <para>On systems with more than 64 processors, this parameter is set to the processor mask for the node only if the node is in the same <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/processor-groups">processor group</a> as the calling thread. Otherwise, the parameter is set to zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnumanodeprocessormask#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnumanodeprocessormask">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNumaNodeProcessorMask(byte Node, ulong *ProcessorMask);
        /// <inheritdoc cref = "GetNumaAvailableMemoryNode(byte, ulong *)"/>
        internal static unsafe bool GetNumaAvailableMemoryNode(byte Node, out ulong AvailableBytes)
        {
            fixed (ulong *AvailableBytesLocal = &AvailableBytes)
            {
                bool __result = Kernel32.GetNumaAvailableMemoryNode(Node, AvailableBytesLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the amount of memory available in the specified node.</summary>
        /// <param name = "Node">The number of the node.</param>
        /// <param name = "AvailableBytes">The amount of available memory for the node, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnumaavailablememorynode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNumaAvailableMemoryNode(byte Node, ulong *AvailableBytes);
        /// <inheritdoc cref = "GetNumaAvailableMemoryNodeEx(ushort, ulong *)"/>
        internal static unsafe bool GetNumaAvailableMemoryNodeEx(ushort Node, out ulong AvailableBytes)
        {
            fixed (ulong *AvailableBytesLocal = &AvailableBytes)
            {
                bool __result = Kernel32.GetNumaAvailableMemoryNodeEx(Node, AvailableBytesLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the amount of memory that is available in a node specified as a USHORT value.</summary>
        /// <param name = "Node">The number of the node.</param>
        /// <param name = "AvailableBytes">The amount of available memory for the node, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnumaavailablememorynodeex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNumaAvailableMemoryNodeEx(ushort Node, ulong *AvailableBytes);
        /// <inheritdoc cref = "GetNumaProximityNode(uint, byte *)"/>
        internal static unsafe bool GetNumaProximityNode(uint ProximityId, out byte NodeNumber)
        {
            fixed (byte *NodeNumberLocal = &NodeNumber)
            {
                bool __result = Kernel32.GetNumaProximityNode(ProximityId, NodeNumberLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the NUMA node number that corresponds to the specified proximity domain identifier.</summary>
        /// <param name = "ProximityId">The proximity domain identifier of the node.</param>
        /// <param name = "NodeNumber">The node number. If the processor does not exist, this parameter is 0xFF.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error  information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getnumaproximitynode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNumaProximityNode(uint ProximityId, byte *NodeNumber);
        /// <summary>Registers a callback function to be called when a secured memory range is freed or its protections are changed.</summary>
        /// <param name = "pfnCallBack">
        /// <para>A pointer to the application-defined <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nc-winnt-psecure_memory_cache_callback">SecureMemoryCacheCallback</a> function to register.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-addsecurememorycachecallback#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it registers the callback function and returns <b>TRUE</b>.</para>
        /// <para>If the function fails, it returns <b>FALSE</b>. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-addsecurememorycachecallback">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool AddSecureMemoryCacheCallback(delegate *unmanaged[Stdcall]<void *, nuint, byte>pfnCallBack);
        /// <summary>Unregisters a callback function that was previously registered with the AddSecureMemoryCacheCallback function.</summary>
        /// <param name = "pfnCallBack">A pointer to the application-defined <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nc-winnt-psecure_memory_cache_callback">SecureMemoryCacheCallback</a> function to remove.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>.</para>
        /// <para>If the function fails, it returns <b>FALSE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-removesecurememorycachecallback">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool RemoveSecureMemoryCacheCallback(delegate *unmanaged[Stdcall]<void *, nuint, byte>pfnCallBack);
        /// <inheritdoc cref = "SetThreadPriority(win32.System.SystemServices.HANDLE, win32.System.SystemServices.THREAD_PRIORITY)"/>
        internal static unsafe bool SetThreadPriority(SafeHandle hThread, win32.System.SystemServices.THREAD_PRIORITY nPriority)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetThreadPriority(hThreadLocal, nPriority);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Sets the priority value for the specified thread. This value, together with the priority class of the thread's process, determines the thread's base priority level.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread whose priority value is to be set.</para>
        /// <para>The handle must have the <b>THREAD_SET_INFORMATION</b> or <b>THREAD_SET_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.<b>Windows Server 2003:  </b>The handle must have the <b>THREAD_SET_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadpriority#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nPriority"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para><b>Windows Phone 8.1:  </b>Windows Phone Store apps may call this function but it has no effect. The function will return a nonzero value indicating success.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadpriority">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetThreadPriority(win32.System.SystemServices.HANDLE hThread, win32.System.SystemServices.THREAD_PRIORITY nPriority);
        /// <summary>Allocates a fiber local storage (FLS) index.</summary>
        /// <param name = "lpCallback">
        /// <para>A pointer to the application-defined callback function of type <b>PFLS_CALLBACK_FUNCTION</b>. This parameter is optional. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nc-winnt-pfls_callback_function">FlsCallback</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fibersapi/nf-fibersapi-flsalloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is an FLS index initialized to zero.</para>
        /// <para>If the function fails, the return value is FLS_OUT_OF_INDEXES. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fibersapi/nf-fibersapi-flsalloc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint FlsAlloc(delegate *unmanaged[Stdcall]<void *, void>lpCallback);
        /// <summary>Retrieves the value in the calling fiber's fiber local storage (FLS) slot for the specified FLS index. Each fiber has its own slot for each FLS index.</summary>
        /// <param name = "dwFlsIndex">
        /// <para>The FLS index that was allocated by the <a href = "https://docs.microsoft.com/windows/desktop/api/fibersapi/nf-fibersapi-flsalloc">FlsAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fibersapi/nf-fibersapi-flsgetvalue#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the value stored in the calling fiber's FLS slot associated with the specified index.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fibersapi/nf-fibersapi-flsgetvalue">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *FlsGetValue(uint dwFlsIndex);
        /// <summary>Stores a value in the calling fiber's fiber local storage (FLS) slot for the specified FLS index. Each fiber has its own slot for each FLS index.</summary>
        /// <param name = "dwFlsIndex">
        /// <para>The FLS index that was allocated by the <a href = "https://docs.microsoft.com/windows/desktop/api/fibersapi/nf-fibersapi-flsalloc">FlsAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fibersapi/nf-fibersapi-flssetvalue#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFlsData">The value to be stored in the FLS slot for the calling fiber.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following errors can be returned.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fibersapi/nf-fibersapi-flssetvalue">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool FlsSetValue(uint dwFlsIndex, [Optional] void *lpFlsData);
        /// <summary>Releases a fiber local storage (FLS) index, making it available for reuse.</summary>
        /// <param name = "dwFlsIndex">
        /// <para>The FLS index that was allocated by the <a href = "https://docs.microsoft.com/windows/desktop/api/fibersapi/nf-fibersapi-flsalloc">FlsAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fibersapi/nf-fibersapi-flsfree#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fibersapi/nf-fibersapi-flsfree">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool FlsFree(uint dwFlsIndex);
        /// <summary>Determines whether the current thread is a fiber.</summary>
        /// <returns>The function returns <b>TRUE</b> if the thread is a fiber and <b>FALSE</b> otherwise.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fibersapi/nf-fibersapi-isthreadafiber">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool IsThreadAFiber();
        /// <inheritdoc cref = "InitializeSRWLock(win32.System.SystemServices.RTL_SRWLOCK*)"/>
        internal static unsafe void InitializeSRWLock(out win32.System.SystemServices.RTL_SRWLOCK SRWLock)
        {
            fixed (win32.System.SystemServices.RTL_SRWLOCK*SRWLockLocal = &SRWLock)
            {
                Kernel32.InitializeSRWLock(SRWLockLocal);
            }
        }

        /// <summary>Initialize a slim reader/writer (SRW) lock.</summary>
        /// <param name = "SRWLock">A pointer to the SRW lock.</param>
        /// <remarks>
        /// <para>An SRW lock must be initialized before it is used. The InitializeSRWLock function is used to initialize a SRW lock dynamically. To initialize the structure statically, assign the constant <b>SRWLOCK_INIT</b> to the structure variable.</para>
        /// <para>An SRW lock cannot be moved or copied while in use. The process must not modify the object, and must instead treat it as logically opaque. Only use the SRW functions to manage SRW locks.</para>
        /// <para>An unlocked SRW lock with no waiting threads is in its initial state and can be copied, moved, and forgotten without being explicitly destroyed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initializesrwlock#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void InitializeSRWLock(win32.System.SystemServices.RTL_SRWLOCK*SRWLock);
        /// <inheritdoc cref = "ReleaseSRWLockExclusive(win32.System.SystemServices.RTL_SRWLOCK*)"/>
        internal static unsafe void ReleaseSRWLockExclusive(ref win32.System.SystemServices.RTL_SRWLOCK SRWLock)
        {
            fixed (win32.System.SystemServices.RTL_SRWLOCK*SRWLockLocal = &SRWLock)
            {
                Kernel32.ReleaseSRWLockExclusive(SRWLockLocal);
            }
        }

        /// <summary>Releases a slim reader/writer (SRW) lock that was acquired in exclusive mode.</summary>
        /// <param name = "SRWLock">A pointer to the SRW lock.</param>
        /// <remarks>
        /// <para>The SRW lock must be released by the same thread that acquired it. You can use [Application Verifier](/windows-hardware/drivers/devtest/application-verifier) to help verify that your program uses SRW locks correctly (enable Locks checker from Basic group).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-releasesrwlockexclusive#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void ReleaseSRWLockExclusive(win32.System.SystemServices.RTL_SRWLOCK*SRWLock);
        /// <inheritdoc cref = "ReleaseSRWLockShared(win32.System.SystemServices.RTL_SRWLOCK*)"/>
        internal static unsafe void ReleaseSRWLockShared(ref win32.System.SystemServices.RTL_SRWLOCK SRWLock)
        {
            fixed (win32.System.SystemServices.RTL_SRWLOCK*SRWLockLocal = &SRWLock)
            {
                Kernel32.ReleaseSRWLockShared(SRWLockLocal);
            }
        }

        /// <summary>Releases a slim reader/writer (SRW) lock that was acquired in shared mode.</summary>
        /// <param name = "SRWLock">A pointer to the SRW lock.</param>
        /// <remarks>
        /// <para>The SRW lock must be released by the same thread that acquired it. You can use [Application Verifier](/windows-hardware/drivers/devtest/application-verifier) to help verify that your program uses SRW locks correctly (enable Locks checker from Basic group).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-releasesrwlockshared#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void ReleaseSRWLockShared(win32.System.SystemServices.RTL_SRWLOCK*SRWLock);
        /// <inheritdoc cref = "AcquireSRWLockExclusive(win32.System.SystemServices.RTL_SRWLOCK*)"/>
        internal static unsafe void AcquireSRWLockExclusive(ref win32.System.SystemServices.RTL_SRWLOCK SRWLock)
        {
            fixed (win32.System.SystemServices.RTL_SRWLOCK*SRWLockLocal = &SRWLock)
            {
                Kernel32.AcquireSRWLockExclusive(SRWLockLocal);
            }
        }

        /// <summary>Acquires a slim reader/writer (SRW) lock in exclusive mode.</summary>
        /// <param name = "SRWLock">A pointer to the SRW lock.</param>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-acquiresrwlockexclusive">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void AcquireSRWLockExclusive(win32.System.SystemServices.RTL_SRWLOCK*SRWLock);
        /// <inheritdoc cref = "AcquireSRWLockShared(win32.System.SystemServices.RTL_SRWLOCK*)"/>
        internal static unsafe void AcquireSRWLockShared(ref win32.System.SystemServices.RTL_SRWLOCK SRWLock)
        {
            fixed (win32.System.SystemServices.RTL_SRWLOCK*SRWLockLocal = &SRWLock)
            {
                Kernel32.AcquireSRWLockShared(SRWLockLocal);
            }
        }

        /// <summary>Acquires a slim reader/writer (SRW) lock in shared mode.</summary>
        /// <param name = "SRWLock">A pointer to the SRW lock.</param>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-acquiresrwlockshared">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void AcquireSRWLockShared(win32.System.SystemServices.RTL_SRWLOCK*SRWLock);
        /// <inheritdoc cref = "TryAcquireSRWLockExclusive(win32.System.SystemServices.RTL_SRWLOCK*)"/>
        internal static unsafe byte TryAcquireSRWLockExclusive(ref win32.System.SystemServices.RTL_SRWLOCK SRWLock)
        {
            fixed (win32.System.SystemServices.RTL_SRWLOCK*SRWLockLocal = &SRWLock)
            {
                byte __result = Kernel32.TryAcquireSRWLockExclusive(SRWLockLocal);
                return __result;
            }
        }

        /// <summary>Attempts to acquire a slim reader/writer (SRW) lock in exclusive mode. If the call is successful, the calling thread takes ownership of the lock.</summary>
        /// <param name = "SRWLock">A pointer to the SRW lock.</param>
        /// <returns>
        /// <para>If the lock is successfully acquired, the return value is nonzero.</para>
        /// <para>if the current thread could not acquire the lock, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-tryacquiresrwlockexclusive">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe byte TryAcquireSRWLockExclusive(win32.System.SystemServices.RTL_SRWLOCK*SRWLock);
        /// <inheritdoc cref = "TryAcquireSRWLockShared(win32.System.SystemServices.RTL_SRWLOCK*)"/>
        internal static unsafe byte TryAcquireSRWLockShared(ref win32.System.SystemServices.RTL_SRWLOCK SRWLock)
        {
            fixed (win32.System.SystemServices.RTL_SRWLOCK*SRWLockLocal = &SRWLock)
            {
                byte __result = Kernel32.TryAcquireSRWLockShared(SRWLockLocal);
                return __result;
            }
        }

        /// <summary>Attempts to acquire a slim reader/writer (SRW) lock in shared mode. If the call is successful, the calling thread takes ownership of the lock.</summary>
        /// <param name = "SRWLock">A pointer to the SRW lock.</param>
        /// <returns>
        /// <para>If the lock is successfully acquired, the return value is nonzero.</para>
        /// <para>if the current thread could not acquire the lock, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-tryacquiresrwlockshared">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe byte TryAcquireSRWLockShared(win32.System.SystemServices.RTL_SRWLOCK*SRWLock);
        /// <inheritdoc cref = "InitializeCriticalSection(win32.System.SystemServices.RTL_CRITICAL_SECTION*)"/>
        internal static unsafe void InitializeCriticalSection(out win32.System.SystemServices.RTL_CRITICAL_SECTION lpCriticalSection)
        {
            fixed (win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSectionLocal = &lpCriticalSection)
            {
                Kernel32.InitializeCriticalSection(lpCriticalSectionLocal);
            }
        }

        /// <summary>Initializes a critical section object.</summary>
        /// <param name = "lpCriticalSection">A pointer to the critical section object.</param>
        /// <returns>
        /// <para>This function does not return a value.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>In low memory situations, <b>InitializeCriticalSection</b> can raise a <b>STATUS_NO_MEMORY</b> exception. Starting with Windows Vista, this exception was eliminated and <b>InitializeCriticalSection</b> always succeeds, even in low memory situations.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initializecriticalsection">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void InitializeCriticalSection(win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSection);
        /// <inheritdoc cref = "EnterCriticalSection(win32.System.SystemServices.RTL_CRITICAL_SECTION*)"/>
        internal static unsafe void EnterCriticalSection(ref win32.System.SystemServices.RTL_CRITICAL_SECTION lpCriticalSection)
        {
            fixed (win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSectionLocal = &lpCriticalSection)
            {
                Kernel32.EnterCriticalSection(lpCriticalSectionLocal);
            }
        }

        /// <summary>Waits for ownership of the specified critical section object. The function returns when the calling thread is granted ownership.</summary>
        /// <param name = "lpCriticalSection">A pointer to the critical section object.</param>
        /// <returns>
        /// <para>This function does not return a value.</para>
        /// <para>This function can raise <b>EXCEPTION_POSSIBLE_DEADLOCK</b> if a wait operation on the critical section times out. The timeout interval is specified by the following registry value: <b>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager</b>&#92;<b>CriticalSectionTimeout</b>. Do not handle a possible deadlock exception; instead, debug the application.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-entercriticalsection">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void EnterCriticalSection(win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSection);
        /// <inheritdoc cref = "LeaveCriticalSection(win32.System.SystemServices.RTL_CRITICAL_SECTION*)"/>
        internal static unsafe void LeaveCriticalSection(ref win32.System.SystemServices.RTL_CRITICAL_SECTION lpCriticalSection)
        {
            fixed (win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSectionLocal = &lpCriticalSection)
            {
                Kernel32.LeaveCriticalSection(lpCriticalSectionLocal);
            }
        }

        /// <summary>Releases ownership of the specified critical section object.</summary>
        /// <param name = "lpCriticalSection">A pointer to the critical section object.</param>
        /// <remarks>
        /// <para>The threads of a single process can use a critical-section object for mutual-exclusion synchronization. The process is responsible for allocating the memory used by a critical-section object, which it can do by declaring a variable of type <b>CRITICAL_SECTION</b>. Before using a critical section, some thread of the process must call the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsection">InitializeCriticalSection</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount">InitializeCriticalSectionAndSpinCount</a> function to initialize the object.</para>
        /// <para>A thread uses the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection">EnterCriticalSection</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-tryentercriticalsection">TryEnterCriticalSection</a> function to acquire ownership of a critical section object. To release its ownership, the thread must call <b>LeaveCriticalSection</b> once for each time that it entered the critical section.</para>
        /// <para>If a thread calls <b>LeaveCriticalSection</b> when it does not have ownership of the specified critical section object, an error occurs that may cause another thread using <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection">EnterCriticalSection</a> to wait indefinitely.</para>
        /// <para>Any thread of the process can use the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-deletecriticalsection">DeleteCriticalSection</a> function to release the system resources that were allocated when the critical section object was initialized. After this function has been called, the critical section object can no longer be used for synchronization.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-leavecriticalsection#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void LeaveCriticalSection(win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSection);
        /// <inheritdoc cref = "InitializeCriticalSectionAndSpinCount(win32.System.SystemServices.RTL_CRITICAL_SECTION*, uint)"/>
        internal static unsafe bool InitializeCriticalSectionAndSpinCount(out win32.System.SystemServices.RTL_CRITICAL_SECTION lpCriticalSection, uint dwSpinCount)
        {
            fixed (win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSectionLocal = &lpCriticalSection)
            {
                bool __result = Kernel32.InitializeCriticalSectionAndSpinCount(lpCriticalSectionLocal, dwSpinCount);
                return __result;
            }
        }

        /// <summary>Initializes a critical section object and sets the spin count for the critical section.</summary>
        /// <param name = "lpCriticalSection">A pointer to the critical section object.</param>
        /// <param name = "dwSpinCount">The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to 0 (zero). On multiprocessor systems, if the critical section is unavailable, the calling thread spins <i>dwSpinCount</i> times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</param>
        /// <returns>
        /// <para>This function always succeeds and returns a nonzero value.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.  Starting with Windows Vista, the <b>InitializeCriticalSectionAndSpinCount</b> function always succeeds, even in low memory situations.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initializecriticalsectionandspincount">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool InitializeCriticalSectionAndSpinCount(win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSection, uint dwSpinCount);
        /// <inheritdoc cref = "InitializeCriticalSectionEx(win32.System.SystemServices.RTL_CRITICAL_SECTION*, uint, uint)"/>
        internal static unsafe bool InitializeCriticalSectionEx(out win32.System.SystemServices.RTL_CRITICAL_SECTION lpCriticalSection, uint dwSpinCount, uint Flags)
        {
            fixed (win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSectionLocal = &lpCriticalSection)
            {
                bool __result = Kernel32.InitializeCriticalSectionEx(lpCriticalSectionLocal, dwSpinCount, Flags);
                return __result;
            }
        }

        /// <summary>Initializes a critical section object with a spin count and optional flags.</summary>
        /// <param name = "lpCriticalSection">A pointer to the critical section object.</param>
        /// <param name = "dwSpinCount">The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to 0 (zero). On multiprocessor systems, if the critical section is unavailable, the calling thread spin <i>dwSpinCount</i> times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</param>
        /// <param name = "Flags">
        /// <para>This parameter can be 0 or the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initializecriticalsectionex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initializecriticalsectionex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool InitializeCriticalSectionEx(win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSection, uint dwSpinCount, uint Flags);
        /// <inheritdoc cref = "SetCriticalSectionSpinCount(win32.System.SystemServices.RTL_CRITICAL_SECTION*, uint)"/>
        internal static unsafe uint SetCriticalSectionSpinCount(ref win32.System.SystemServices.RTL_CRITICAL_SECTION lpCriticalSection, uint dwSpinCount)
        {
            fixed (win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSectionLocal = &lpCriticalSection)
            {
                uint __result = Kernel32.SetCriticalSectionSpinCount(lpCriticalSectionLocal, dwSpinCount);
                return __result;
            }
        }

        /// <summary>Sets the spin count for the specified critical section.</summary>
        /// <param name = "lpCriticalSection">A pointer to the critical section object.</param>
        /// <param name = "dwSpinCount">The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to zero (0). On multiprocessor systems, if the critical section is unavailable, the calling thread spins <i>dwSpinCount</i> times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</param>
        /// <returns>The function returns the previous spin count for the critical section.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setcriticalsectionspincount">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint SetCriticalSectionSpinCount(win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSection, uint dwSpinCount);
        /// <inheritdoc cref = "TryEnterCriticalSection(win32.System.SystemServices.RTL_CRITICAL_SECTION*)"/>
        internal static unsafe bool TryEnterCriticalSection(ref win32.System.SystemServices.RTL_CRITICAL_SECTION lpCriticalSection)
        {
            fixed (win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSectionLocal = &lpCriticalSection)
            {
                bool __result = Kernel32.TryEnterCriticalSection(lpCriticalSectionLocal);
                return __result;
            }
        }

        /// <summary>Attempts to enter a critical section without blocking. If the call is successful, the calling thread takes ownership of the critical section.</summary>
        /// <param name = "lpCriticalSection">A pointer to the critical section object.</param>
        /// <returns>
        /// <para>If the critical section is successfully entered or the current thread already owns the critical section, the return value is nonzero.</para>
        /// <para>If another thread already owns the critical section, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-tryentercriticalsection">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool TryEnterCriticalSection(win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSection);
        /// <inheritdoc cref = "DeleteCriticalSection(win32.System.SystemServices.RTL_CRITICAL_SECTION*)"/>
        internal static unsafe void DeleteCriticalSection(ref win32.System.SystemServices.RTL_CRITICAL_SECTION lpCriticalSection)
        {
            fixed (win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSectionLocal = &lpCriticalSection)
            {
                Kernel32.DeleteCriticalSection(lpCriticalSectionLocal);
            }
        }

        /// <summary>Releases all resources used by an unowned critical section object.</summary>
        /// <param name = "lpCriticalSection">
        /// <para>A pointer to the critical section object. The object must have been previously initialized with the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsection">InitializeCriticalSection</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-deletecriticalsection#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>Deleting a critical section object releases all system resources used by the object. The caller is responsible for ensuring that the critical section object is unowned and the specified CRITICAL_SECTION structure is not being accessed by any critical section functions called by other threads in the process.</para>
        /// <para>After a critical section object has been deleted, do not reference the object in any function that operates on critical sections (such as <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection">EnterCriticalSection</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-tryentercriticalsection">TryEnterCriticalSection</a>, and <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection">LeaveCriticalSection</a>) other than <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsection">InitializeCriticalSection</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount">InitializeCriticalSectionAndSpinCount</a>. If you attempt to do so, memory corruption and other unexpected errors can occur.</para>
        /// <para>If a critical section is deleted while it is still owned, the state of the threads waiting for ownership of the deleted critical section is undefined.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-deletecriticalsection#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void DeleteCriticalSection(win32.System.SystemServices.RTL_CRITICAL_SECTION*lpCriticalSection);
        /// <inheritdoc cref = "InitOnceInitialize(win32.System.SystemServices.RTL_RUN_ONCE*)"/>
        internal static unsafe void InitOnceInitialize(out win32.System.SystemServices.RTL_RUN_ONCE InitOnce)
        {
            fixed (win32.System.SystemServices.RTL_RUN_ONCE*InitOnceLocal = &InitOnce)
            {
                Kernel32.InitOnceInitialize(InitOnceLocal);
            }
        }

        /// <summary>Initializes a one-time initialization structure.</summary>
        /// <param name = "InitOnce">A pointer to the one-time initialization structure.</param>
        /// <remarks>
        /// <para>The <b>InitOnceInitialize</b> function is used to initialize a one-time initialization structure dynamically. To initialize the structure statically, assign the constant <b>INIT_ONCE_STATIC_INIT</b> to the structure variable.</para>
        /// <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
        /// <para>A one-time initialization object cannot be moved or copied. The process must not modify the initialization object, and must instead treat it as logically opaque. Only use the one-time initialization functions to manage one-time initialization objects.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initonceinitialize#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void InitOnceInitialize(win32.System.SystemServices.RTL_RUN_ONCE*InitOnce);
        /// <inheritdoc cref = "InitOnceExecuteOnce(win32.System.SystemServices.RTL_RUN_ONCE*, delegate *unmanaged[Stdcall]{win32.System.SystemServices.RTL_RUN_ONCE*, void *, void **, win32.System.SystemServices.BOOL}, void *, void **)"/>
        internal static unsafe bool InitOnceExecuteOnce(ref win32.System.SystemServices.RTL_RUN_ONCE InitOnce, delegate *unmanaged[Stdcall]<win32.System.SystemServices.RTL_RUN_ONCE*, void *, void **, win32.System.SystemServices.BOOL>InitFn, void *Parameter, void **Context)
        {
            fixed (win32.System.SystemServices.RTL_RUN_ONCE*InitOnceLocal = &InitOnce)
            {
                bool __result = Kernel32.InitOnceExecuteOnce(InitOnceLocal, InitFn, Parameter, Context);
                return __result;
            }
        }

        /// <summary>Executes the specified function successfully one time. No other threads that specify the same one-time initialization structure can execute the specified function while it is being executed by the current thread.</summary>
        /// <param name = "InitOnce">A pointer to the one-time initialization structure.</param>
        /// <param name = "InitFn">A pointer to an application-defined <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nc-synchapi-pinit_once_fn">InitOnceCallback</a> function.</param>
        /// <param name = "Parameter">A parameter to be passed to the callback function.</param>
        /// <param name = "Context">A parameter that receives data stored with the one-time initialization structure upon success. The low-order <b>INIT_ONCE_CTX_RESERVED_BITS</b> bits of the data are always zero.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initonceexecuteonce">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool InitOnceExecuteOnce(win32.System.SystemServices.RTL_RUN_ONCE*InitOnce, delegate *unmanaged[Stdcall]<win32.System.SystemServices.RTL_RUN_ONCE*, void *, void **, win32.System.SystemServices.BOOL>InitFn, [Optional] void *Parameter, [Optional] void **Context);
        /// <inheritdoc cref = "InitOnceBeginInitialize(win32.System.SystemServices.RTL_RUN_ONCE*, uint, bool *, void **)"/>
        internal static unsafe bool InitOnceBeginInitialize(ref win32.System.SystemServices.RTL_RUN_ONCE lpInitOnce, uint dwFlags, out bool fPending, void **lpContext)
        {
            fixed (bool *fPendingLocal = &fPending)
            {
                fixed (win32.System.SystemServices.RTL_RUN_ONCE*lpInitOnceLocal = &lpInitOnce)
                {
                    bool __result = Kernel32.InitOnceBeginInitialize(lpInitOnceLocal, dwFlags, fPendingLocal, lpContext);
                    return __result;
                }
            }
        }

        /// <summary>Begins one-time initialization.</summary>
        /// <param name = "lpInitOnce">A pointer to the one-time initialization structure.</param>
        /// <param name = "dwFlags">
        /// <para>This parameter can have a value of 0, or one or more of the following flags.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initoncebegininitialize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fPending">
        /// <para>If the function succeeds, this parameter indicates the current initialization status.</para>
        /// <para>If this parameter is **TRUE** and *dwFlags* contains **INIT_ONCE_CHECK_ONLY**, the initialization is pending and the context data is invalid.</para>
        /// <para>If this parameter is **FALSE**, initialization has already completed and the caller can retrieve the context data from the *lpContext* parameter.</para>
        /// <para>If this parameter is **TRUE** and *dwFlags* does not contain **INIT_ONCE_CHECK_ONLY**, initialization has been started and the caller can perform the initialization tasks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initoncebegininitialize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpContext">An optional parameter that receives the data stored with the one-time initialization structure upon success. The low-order **INIT_ONCE_CTX_RESERVED_BITS** bits of the data are always zero.</param>
        /// <returns>
        /// <para>If **INIT_ONCE_CHECK_ONLY** is not specified and the function succeeds, the return value is <b>TRUE</b>.</para>
        /// <para>If **INIT_ONCE_CHECK_ONLY** is specified and initialization has completed, the return value is <b>TRUE</b>.</para>
        /// <para>Otherwise, the return value is **FALSE**.</para>
        /// <para>To get extended error information, call [GetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initoncebegininitialize">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool InitOnceBeginInitialize(win32.System.SystemServices.RTL_RUN_ONCE*lpInitOnce, uint dwFlags, bool *fPending, [Optional] void **lpContext);
        /// <inheritdoc cref = "InitOnceComplete(win32.System.SystemServices.RTL_RUN_ONCE*, uint, void *)"/>
        internal static unsafe bool InitOnceComplete(ref win32.System.SystemServices.RTL_RUN_ONCE lpInitOnce, uint dwFlags, void *lpContext)
        {
            fixed (win32.System.SystemServices.RTL_RUN_ONCE*lpInitOnceLocal = &lpInitOnce)
            {
                bool __result = Kernel32.InitOnceComplete(lpInitOnceLocal, dwFlags, lpContext);
                return __result;
            }
        }

        /// <summary>Completes one-time initialization started with the InitOnceBeginInitialize function.</summary>
        /// <param name = "lpInitOnce">A pointer to the one-time initialization structure.</param>
        /// <param name = "dwFlags">
        /// <para>This parameter can be one of the following flags.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initoncecomplete#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpContext">A pointer to the data to be stored with the one-time initialization structure. This data is returned in the <i>lpContext</i> parameter passed to subsequent calls to the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-initoncebegininitialize">InitOnceBeginInitialize</a> function. If <i>lpContext</i> points to a value, the low-order <b>INIT_ONCE_CTX_RESERVED_BITS</b> of the value must be zero. If <i>lpContext</i>  points to a data structure, the data structure must be <b>DWORD</b>-aligned.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initoncecomplete">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool InitOnceComplete(win32.System.SystemServices.RTL_RUN_ONCE*lpInitOnce, uint dwFlags, [Optional] void *lpContext);
        /// <inheritdoc cref = "InitializeConditionVariable(win32.System.SystemServices.RTL_CONDITION_VARIABLE*)"/>
        internal static unsafe void InitializeConditionVariable(out win32.System.SystemServices.RTL_CONDITION_VARIABLE ConditionVariable)
        {
            fixed (win32.System.SystemServices.RTL_CONDITION_VARIABLE*ConditionVariableLocal = &ConditionVariable)
            {
                Kernel32.InitializeConditionVariable(ConditionVariableLocal);
            }
        }

        /// <summary>Initializes a condition variable.</summary>
        /// <param name = "ConditionVariable">A pointer to the condition variable.</param>
        /// <remarks>
        /// <para>Threads  can atomically release a lock and enter the sleeping state using the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-sleepconditionvariablecs">SleepConditionVariableCS</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-sleepconditionvariablesrw">SleepConditionVariableSRW</a> function. The threads are woken using the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-wakeconditionvariable">WakeConditionVariable</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-wakeallconditionvariable">WakeAllConditionVariable</a> function.</para>
        /// <para>Condition variables are user-mode objects that cannot be shared across processes.</para>
        /// <para>A condition variable cannot be moved or copied while in use. The process must not modify the object, and must instead treat it as logically opaque. Only use the condition variable functions to manage condition variables.</para>
        /// <para>A condition variable with no waiting threads is in its initial state and can be copied, moved, and forgotten without being explicitly destroyed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initializeconditionvariable#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void InitializeConditionVariable(win32.System.SystemServices.RTL_CONDITION_VARIABLE*ConditionVariable);
        /// <inheritdoc cref = "WakeConditionVariable(win32.System.SystemServices.RTL_CONDITION_VARIABLE*)"/>
        internal static unsafe void WakeConditionVariable(ref win32.System.SystemServices.RTL_CONDITION_VARIABLE ConditionVariable)
        {
            fixed (win32.System.SystemServices.RTL_CONDITION_VARIABLE*ConditionVariableLocal = &ConditionVariable)
            {
                Kernel32.WakeConditionVariable(ConditionVariableLocal);
            }
        }

        /// <summary>Wake a single thread waiting on the specified condition variable.</summary>
        /// <param name = "ConditionVariable">A pointer to the condition variable.</param>
        /// <remarks>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-wakeallconditionvariable">WakeAllConditionVariable</a> wakes all waiting threads while the <b>WakeConditionVariable</b> wakes only a single thread. Waking one thread is similar to setting an auto-reset event, while waking all threads is similar to pulsing a manual reset event but more reliable (see <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-pulseevent">PulseEvent</a> for details).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-wakeconditionvariable#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void WakeConditionVariable(win32.System.SystemServices.RTL_CONDITION_VARIABLE*ConditionVariable);
        /// <inheritdoc cref = "WakeAllConditionVariable(win32.System.SystemServices.RTL_CONDITION_VARIABLE*)"/>
        internal static unsafe void WakeAllConditionVariable(ref win32.System.SystemServices.RTL_CONDITION_VARIABLE ConditionVariable)
        {
            fixed (win32.System.SystemServices.RTL_CONDITION_VARIABLE*ConditionVariableLocal = &ConditionVariable)
            {
                Kernel32.WakeAllConditionVariable(ConditionVariableLocal);
            }
        }

        /// <summary>Wake all threads waiting on the specified condition variable.</summary>
        /// <param name = "ConditionVariable">A pointer to the condition variable.</param>
        /// <remarks>
        /// <para>The <b>WakeAllConditionVariable</b> wakes all waiting threads while the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-wakeconditionvariable">WakeConditionVariable</a> wakes only a single thread. Waking one thread is similar to setting an auto-reset event, while waking all threads is similar to pulsing a manual reset event but more reliable (see <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-pulseevent">PulseEvent</a> for details).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-wakeallconditionvariable#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void WakeAllConditionVariable(win32.System.SystemServices.RTL_CONDITION_VARIABLE*ConditionVariable);
        /// <inheritdoc cref = "SleepConditionVariableCS(win32.System.SystemServices.RTL_CONDITION_VARIABLE*, win32.System.SystemServices.RTL_CRITICAL_SECTION*, uint)"/>
        internal static unsafe bool SleepConditionVariableCS(ref win32.System.SystemServices.RTL_CONDITION_VARIABLE ConditionVariable, ref win32.System.SystemServices.RTL_CRITICAL_SECTION CriticalSection, uint dwMilliseconds)
        {
            fixed (win32.System.SystemServices.RTL_CRITICAL_SECTION*CriticalSectionLocal = &CriticalSection)
            {
                fixed (win32.System.SystemServices.RTL_CONDITION_VARIABLE*ConditionVariableLocal = &ConditionVariable)
                {
                    bool __result = Kernel32.SleepConditionVariableCS(ConditionVariableLocal, CriticalSectionLocal, dwMilliseconds);
                    return __result;
                }
            }
        }

        /// <summary>Sleeps on the specified condition variable and releases the specified critical section as an atomic operation.</summary>
        /// <param name = "ConditionVariable">A pointer to the condition variable. This variable must be initialized using the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-initializeconditionvariable">InitializeConditionVariable</a> function.</param>
        /// <param name = "CriticalSection">A pointer to the critical section object. This critical section must be entered exactly once by the caller at the time <b>SleepConditionVariableCS</b> is called.</param>
        /// <param name = "dwMilliseconds">The time-out interval, in milliseconds. If the time-out interval elapses, the function re-acquires the critical section and returns zero. If <i>dwMilliseconds</i> is zero, the function tests the states of the specified objects and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses. For more information, see Remarks.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails or the time-out interval elapses, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include <b>ERROR_TIMEOUT</b>, which indicates that the time-out interval has elapsed before another thread has attempted to wake the sleeping thread.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-sleepconditionvariablecs">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SleepConditionVariableCS(win32.System.SystemServices.RTL_CONDITION_VARIABLE*ConditionVariable, win32.System.SystemServices.RTL_CRITICAL_SECTION*CriticalSection, uint dwMilliseconds);
        /// <inheritdoc cref = "SleepConditionVariableSRW(win32.System.SystemServices.RTL_CONDITION_VARIABLE*, win32.System.SystemServices.RTL_SRWLOCK*, uint, uint)"/>
        internal static unsafe bool SleepConditionVariableSRW(ref win32.System.SystemServices.RTL_CONDITION_VARIABLE ConditionVariable, ref win32.System.SystemServices.RTL_SRWLOCK SRWLock, uint dwMilliseconds, uint Flags)
        {
            fixed (win32.System.SystemServices.RTL_SRWLOCK*SRWLockLocal = &SRWLock)
            {
                fixed (win32.System.SystemServices.RTL_CONDITION_VARIABLE*ConditionVariableLocal = &ConditionVariable)
                {
                    bool __result = Kernel32.SleepConditionVariableSRW(ConditionVariableLocal, SRWLockLocal, dwMilliseconds, Flags);
                    return __result;
                }
            }
        }

        /// <summary>Sleeps on the specified condition variable and releases the specified lock as an atomic operation.</summary>
        /// <param name = "ConditionVariable">A pointer to the condition variable. This variable must be initialized using the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-initializeconditionvariable">InitializeConditionVariable</a> function.</param>
        /// <param name = "SRWLock">A pointer to the lock. This lock must be held in the manner specified by the <i>Flags</i> parameter.</param>
        /// <param name = "dwMilliseconds">The time-out interval, in milliseconds. The function returns if the interval elapses. If <i>dwMilliseconds</i> is zero, the function tests the states of the specified objects and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses.</param>
        /// <param name = "Flags">If this parameter is <b>CONDITION_VARIABLE_LOCKMODE_SHARED</b>, the SRW lock is in shared mode. Otherwise, the lock is in exclusive mode.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the timeout expires the function returns FALSE and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_TIMEOUT.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-sleepconditionvariablesrw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SleepConditionVariableSRW(win32.System.SystemServices.RTL_CONDITION_VARIABLE*ConditionVariable, win32.System.SystemServices.RTL_SRWLOCK*SRWLock, uint dwMilliseconds, uint Flags);
        /// <inheritdoc cref = "SetEvent(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool SetEvent(SafeHandle hEvent)
        {
            bool hEventAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hEventLocal;
                if (hEvent is object)
                {
                    hEvent.DangerousAddRef(ref hEventAddRef);
                    hEventLocal = (win32.System.SystemServices.HANDLE)hEvent.DangerousGetHandle();
                }
                else
                    hEventLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetEvent(hEventLocal);
                return __result;
            }
            finally
            {
                if (hEventAddRef)
                    hEvent.DangerousRelease();
            }
        }

        /// <summary>Sets the specified event object to the signaled state.</summary>
        /// <param name = "hEvent">
        /// <para>A handle to the event object. The <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-createeventa">CreateEvent</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-openeventa">OpenEvent</a> function returns this handle.</para>
        /// <para>The handle must have the EVENT_MODIFY_STATE access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setevent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetEvent(win32.System.SystemServices.HANDLE hEvent);
        /// <inheritdoc cref = "ResetEvent(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool ResetEvent(SafeHandle hEvent)
        {
            bool hEventAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hEventLocal;
                if (hEvent is object)
                {
                    hEvent.DangerousAddRef(ref hEventAddRef);
                    hEventLocal = (win32.System.SystemServices.HANDLE)hEvent.DangerousGetHandle();
                }
                else
                    hEventLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.ResetEvent(hEventLocal);
                return __result;
            }
            finally
            {
                if (hEventAddRef)
                    hEvent.DangerousRelease();
            }
        }

        /// <summary>Sets the specified event object to the nonsignaled state.</summary>
        /// <param name = "hEvent">
        /// <para>A handle to the event object. The <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-createeventa">CreateEvent</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-openeventa">OpenEvent</a> function returns this handle.</para>
        /// <para>The handle must have the EVENT_MODIFY_STATE access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-resetevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-resetevent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ResetEvent(win32.System.SystemServices.HANDLE hEvent);
        /// <inheritdoc cref = "ReleaseSemaphore(win32.System.SystemServices.HANDLE, int, int *)"/>
        internal static unsafe bool ReleaseSemaphore(SafeHandle hSemaphore, int lReleaseCount, int *lpPreviousCount)
        {
            bool hSemaphoreAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hSemaphoreLocal;
                if (hSemaphore is object)
                {
                    hSemaphore.DangerousAddRef(ref hSemaphoreAddRef);
                    hSemaphoreLocal = (win32.System.SystemServices.HANDLE)hSemaphore.DangerousGetHandle();
                }
                else
                    hSemaphoreLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.ReleaseSemaphore(hSemaphoreLocal, lReleaseCount, lpPreviousCount);
                return __result;
            }
            finally
            {
                if (hSemaphoreAddRef)
                    hSemaphore.DangerousRelease();
            }
        }

        /// <summary>Increases the count of the specified semaphore object by a specified amount.</summary>
        /// <param name = "hSemaphore">
        /// <para>A handle to the semaphore object. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createsemaphorea">CreateSemaphore</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-opensemaphorea">OpenSemaphore</a> function returns this handle.</para>
        /// <para>This handle must have the <b>SEMAPHORE_MODIFY_STATE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-releasesemaphore#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lReleaseCount">The amount by which the semaphore object's current count is to be increased. The value must be greater than zero. If the specified amount would cause the semaphore's count to exceed the maximum count that was specified when the semaphore was created, the count is not changed and the function returns <b>FALSE</b>.</param>
        /// <param name = "lpPreviousCount">A pointer to a variable to receive the previous count for the semaphore. This parameter can be <b>NULL</b> if the previous count is not required.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-releasesemaphore">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ReleaseSemaphore(win32.System.SystemServices.HANDLE hSemaphore, int lReleaseCount, [Optional] int *lpPreviousCount);
        /// <inheritdoc cref = "ReleaseMutex(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool ReleaseMutex(SafeHandle hMutex)
        {
            bool hMutexAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hMutexLocal;
                if (hMutex is object)
                {
                    hMutex.DangerousAddRef(ref hMutexAddRef);
                    hMutexLocal = (win32.System.SystemServices.HANDLE)hMutex.DangerousGetHandle();
                }
                else
                    hMutexLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.ReleaseMutex(hMutexLocal);
                return __result;
            }
            finally
            {
                if (hMutexAddRef)
                    hMutex.DangerousRelease();
            }
        }

        /// <summary>Releases ownership of the specified mutex object.</summary>
        /// <param name = "hMutex">
        /// <para>A handle to the mutex object. The <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-createmutexa">CreateMutex</a> or</para>
        /// <para><a href = "https://docs.microsoft.com/windows/win32/api/synchapi/nf-synchapi-openmutexw">OpenMutex</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-releasemutex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-releasemutex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ReleaseMutex(win32.System.SystemServices.HANDLE hMutex);
        /// <inheritdoc cref = "WaitForSingleObject(win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe win32.System.Threading.WAIT_RETURN_CAUSE WaitForSingleObject(SafeHandle hHandle, uint dwMilliseconds)
        {
            bool hHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hHandleLocal;
                if (hHandle is object)
                {
                    hHandle.DangerousAddRef(ref hHandleAddRef);
                    hHandleLocal = (win32.System.SystemServices.HANDLE)hHandle.DangerousGetHandle();
                }
                else
                    hHandleLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.Threading.WAIT_RETURN_CAUSE __result = Kernel32.WaitForSingleObject(hHandleLocal, dwMilliseconds);
                return __result;
            }
            finally
            {
                if (hHandleAddRef)
                    hHandle.DangerousRelease();
            }
        }

        /// <summary>Waits until the specified object is in the signaled state or the time-out interval elapses.</summary>
        /// <param name = "hHandle">
        /// <para>A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.</para>
        /// <para>If this handle is closed while the wait is still pending, the function's behavior is undefined.</para>
        /// <para>The handle must have the <b>SYNCHRONIZE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitforsingleobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMilliseconds">
        /// <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the object is signaled.</para>
        /// <para><b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
        /// <para><b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitforsingleobject#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitforsingleobject">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.Threading.WAIT_RETURN_CAUSE WaitForSingleObject(win32.System.SystemServices.HANDLE hHandle, uint dwMilliseconds);
        /// <summary>Suspends the current thread until the specified condition is met.</summary>
        /// <param name = "dwMilliseconds">
        /// <para>The time interval for which execution is to be suspended, in milliseconds.</para>
        /// <para>A value of zero, together with the bAlertable parameter set to FALSE, causes the thread to relinquish the remainder of its time slice to any other thread that is ready to run, if there are no pending user APCs on the calling thread. If there are no other threads ready to run and no user APCs are queued, the function returns immediately, and the thread continues execution.<b>Windows XP: </b>A value of zero causes the thread to relinquish the remainder of its time slice to any other thread of equal priority that is ready to run. If there are no other threads of equal priority ready to run, the function returns immediately, and the thread continues execution. This behavior changed starting with Windows Server 2003.</para>
        /// <para>A value of INFINITE indicates that the suspension should not time out.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-sleepex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bAlertable">
        /// <para>If this parameter is FALSE, the function does not return until the time-out period has elapsed. If an I/O completion callback occurs, the function does not return and the I/O completion function is not executed. If an APC is queued to the thread, the function does not return and the APC function is not executed.</para>
        /// <para>If the parameter is TRUE and the thread that called this function is the same thread that called the extended I/O function (<a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefileex">WriteFileEx</a>), the function returns when either the time-out period has elapsed or when an I/O completion callback function occurs. If an I/O completion callback occurs, the I/O completion function is called. If an APC is queued to the thread (<a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-queueuserapc">QueueUserAPC</a>), the function returns when either the timer-out period has elapsed or when the APC function is called.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-sleepex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>The return value is zero if the specified time interval expired.</para>
        /// <para>The return value is <b>WAIT_IO_COMPLETION</b> if the function returned due to one or more I/O completion callback functions. This can happen only if <i>bAlertable</i> is TRUE, and if the thread that called the <b>SleepEx</b> function is the same thread that called the extended I/O function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-sleepex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint SleepEx(uint dwMilliseconds, bool bAlertable);
        /// <inheritdoc cref = "WaitForSingleObjectEx(win32.System.SystemServices.HANDLE, uint, bool)"/>
        internal static unsafe win32.System.Threading.WAIT_RETURN_CAUSE WaitForSingleObjectEx(SafeHandle hHandle, uint dwMilliseconds, bool bAlertable)
        {
            bool hHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hHandleLocal;
                if (hHandle is object)
                {
                    hHandle.DangerousAddRef(ref hHandleAddRef);
                    hHandleLocal = (win32.System.SystemServices.HANDLE)hHandle.DangerousGetHandle();
                }
                else
                    hHandleLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.Threading.WAIT_RETURN_CAUSE __result = Kernel32.WaitForSingleObjectEx(hHandleLocal, dwMilliseconds, bAlertable);
                return __result;
            }
            finally
            {
                if (hHandleAddRef)
                    hHandle.DangerousRelease();
            }
        }

        /// <summary>Waits until the specified object is in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses.</summary>
        /// <param name = "hHandle">
        /// <para>A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.</para>
        /// <para>If this handle is closed while the wait is still pending, the function's behavior is undefined.</para>
        /// <para>The handle must have the <b>SYNCHRONIZE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitforsingleobjectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMilliseconds">
        /// <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled, an I/O completion routine or APC is queued, or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the object is signaled or an I/O completion routine or APC is queued.</para>
        /// <para><b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
        /// <para><b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitforsingleobjectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bAlertable">
        /// <para>If this parameter is <b>TRUE</b> and the thread is in the waiting state, the function returns when the system queues an I/O completion routine or APC, and the thread runs the routine or function. Otherwise, the function does not return, and the completion routine or APC function is not executed.</para>
        /// <para>A completion routine is queued when the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefileex">WriteFileEx</a> function in which it was specified has completed. The wait function returns and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b>, and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-queueuserapc">QueueUserAPC</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitforsingleobjectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitforsingleobjectex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.Threading.WAIT_RETURN_CAUSE WaitForSingleObjectEx(win32.System.SystemServices.HANDLE hHandle, uint dwMilliseconds, bool bAlertable);
        /// <inheritdoc cref = "WaitForMultipleObjectsEx(uint, win32.System.SystemServices.HANDLE*, bool, uint, bool)"/>
        internal static unsafe win32.System.Threading.WAIT_RETURN_CAUSE WaitForMultipleObjectsEx(ReadOnlySpan<win32.System.SystemServices.HANDLE> lpHandles, bool bWaitAll, uint dwMilliseconds, bool bAlertable)
        {
            fixed (win32.System.SystemServices.HANDLE*lpHandlesLocal = lpHandles)
            {
                win32.System.Threading.WAIT_RETURN_CAUSE __result = Kernel32.WaitForMultipleObjectsEx((uint)lpHandles.Length, lpHandlesLocal, bWaitAll, dwMilliseconds, bAlertable);
                return __result;
            }
        }

        /// <summary>Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses.</summary>
        /// <param name = "nCount">The number of object handles to wait for in the array pointed to by <i>lpHandles</i>. The maximum number of object handles is <b>MAXIMUM_WAIT_OBJECTS</b>. This parameter cannot be zero.</param>
        /// <param name = "lpHandles">
        /// <para>An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle.</para>
        /// <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
        /// <para>The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitformultipleobjectsex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bWaitAll">If this parameter is <b>TRUE</b>, the function returns when the state of all objects in the <i>lpHandles</i> array is set to signaled. If <b>FALSE</b>, the function returns when the state of any one of the objects is set to signaled. In the latter case, the return value indicates the object whose state caused the function to return.</param>
        /// <param name = "dwMilliseconds">
        /// <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled, an I/O completion routine or APC is queued, or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the specified objects are signaled or an I/O completion routine or APC is queued.</para>
        /// <para><b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
        /// <para><b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitformultipleobjectsex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bAlertable">
        /// <para>If this parameter is <b>TRUE</b> and the thread is in the waiting state, the function returns when the system queues an I/O completion routine or APC, and the thread runs the routine or function. Otherwise, the function does not return and the completion routine or APC function is not executed.</para>
        /// <para>A completion routine is queued when the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefileex">WriteFileEx</a> function in which it was specified has completed. The wait function returns and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b> and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-queueuserapc">QueueUserAPC</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitformultipleobjectsex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined as 0x00000080L.)</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitformultipleobjectsex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.Threading.WAIT_RETURN_CAUSE WaitForMultipleObjectsEx(uint nCount, win32.System.SystemServices.HANDLE*lpHandles, bool bWaitAll, uint dwMilliseconds, bool bAlertable);
        /// <inheritdoc cref = "CreateMutex(win32.System.SystemServices.SECURITY_ATTRIBUTES*, bool, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateMutex(win32.System.SystemServices.SECURITY_ATTRIBUTES? lpMutexAttributes, bool bInitialOwner, string lpName)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpMutexAttributesLocal = lpMutexAttributes.HasValue ? lpMutexAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateMutex(lpMutexAttributes.HasValue ? &lpMutexAttributesLocal : null, bInitialOwner, lpNameLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates or opens a named or unnamed mutex object.</summary>
        /// <param name = "lpMutexAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createmutexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInitialOwner">If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</param>
        /// <param name = "lpName">
        /// <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
        /// <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
        /// <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
        /// <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
        /// <para>The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para>The object can be created in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createmutexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createmutexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateMutexW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateMutex([Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpMutexAttributes, bool bInitialOwner, win32.System.SystemServices.PCWSTR lpName);
        /// <inheritdoc cref = "OpenMutex(uint, bool, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle OpenMutex(uint dwDesiredAccess, bool bInheritHandle, string lpName)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.HANDLE __result = Kernel32.OpenMutex(dwDesiredAccess, bInheritHandle, lpNameLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Opens an existing named mutex object.</summary>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the mutex object. Only the <b>SYNCHRONIZE</b> access right is required to use a mutex; to change the mutex's security, specify <b>MUTEX_ALL_ACCESS</b>. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-openmutexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name = "lpName">
        /// <para>The name of the mutex to be opened. Name comparisons are case sensitive.</para>
        /// <para>This function can open objects in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><b>Terminal Services:  </b>The name can have a "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
        /// <para><b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-openmutexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the mutex object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If a named mutex does not exist, the function fails and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_FILE_NOT_FOUND</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-openmutexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "OpenMutexW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE OpenMutex(uint dwDesiredAccess, bool bInheritHandle, win32.System.SystemServices.PCWSTR lpName);
        /// <inheritdoc cref = "CreateEvent(win32.System.SystemServices.SECURITY_ATTRIBUTES*, bool, bool, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateEvent(win32.System.SystemServices.SECURITY_ATTRIBUTES? lpEventAttributes, bool bManualReset, bool bInitialState, string lpName)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpEventAttributesLocal = lpEventAttributes.HasValue ? lpEventAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateEvent(lpEventAttributes.HasValue ? &lpEventAttributesLocal : null, bManualReset, bInitialState, lpNameLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates or opens a named or unnamed event object.</summary>
        /// <param name = "lpEventAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createeventw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bManualReset">
        /// <para>If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-resetevent">ResetEvent</a> function to set the event state to nonsignaled. If this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and system automatically resets the event state to nonsignaled after a single waiting thread has been released.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createeventw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInitialState">If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</param>
        /// <param name = "lpName">
        /// <para>The name of the event object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
        /// <para>If <i>lpName</i> matches the name of an existing named event object, this function requests the <b>EVENT_ALL_ACCESS</b> access right. In this case, the <i>bManualReset</i> and <i>bInitialState</i> parameters are ignored because they have already been set by the creating process. If the <i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored. If <i>lpName</i> is <b>NULL</b>, the event object is created without a name. If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createeventw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createeventw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateEventW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateEvent([Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpEventAttributes, bool bManualReset, bool bInitialState, win32.System.SystemServices.PCWSTR lpName);
        /// <inheritdoc cref = "OpenEvent(uint, bool, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle OpenEvent(uint dwDesiredAccess, bool bInheritHandle, string lpName)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.HANDLE __result = Kernel32.OpenEvent(dwDesiredAccess, bInheritHandle, lpNameLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Opens an existing named event object.</summary>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-openeventw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name = "lpName">
        /// <para>The  name of the event to be opened. Name comparisons are case sensitive.</para>
        /// <para>This function can open objects in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><b>Terminal Services:  </b>The name can have a "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
        /// <para><b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-openeventw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the event object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-openeventw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "OpenEventW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE OpenEvent(uint dwDesiredAccess, bool bInheritHandle, win32.System.SystemServices.PCWSTR lpName);
        /// <inheritdoc cref = "OpenSemaphore(uint, bool, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle OpenSemaphore(uint dwDesiredAccess, bool bInheritHandle, string lpName)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.HANDLE __result = Kernel32.OpenSemaphore(dwDesiredAccess, bInheritHandle, lpNameLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Opens an existing named semaphore object.</summary>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the semaphore object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-opensemaphorew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name = "lpName">
        /// <para>The name of the semaphore to be opened. Name comparisons are case sensitive.</para>
        /// <para>This function can open objects in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><b>Terminal Services:  </b>The name can have a "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
        /// <para><b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-opensemaphorew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the semaphore object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-opensemaphorew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "OpenSemaphoreW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE OpenSemaphore(uint dwDesiredAccess, bool bInheritHandle, win32.System.SystemServices.PCWSTR lpName);
        /// <inheritdoc cref = "OpenWaitableTimer(uint, bool, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle OpenWaitableTimer(uint dwDesiredAccess, bool bInheritHandle, string lpTimerName)
        {
            fixed (char *lpTimerNameLocal = lpTimerName)
            {
                win32.System.SystemServices.HANDLE __result = Kernel32.OpenWaitableTimer(dwDesiredAccess, bInheritHandle, lpTimerNameLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Opens an existing named waitable timer object.</summary>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the timer object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-openwaitabletimerw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name = "lpTimerName">
        /// <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
        /// <para>This function can open objects in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><b>Terminal Services:  </b>The name can have a "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
        /// <para><b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-openwaitabletimerw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the timer object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-openwaitabletimerw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "OpenWaitableTimerW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE OpenWaitableTimer(uint dwDesiredAccess, bool bInheritHandle, win32.System.SystemServices.PCWSTR lpTimerName);
        /// <inheritdoc cref = "SetWaitableTimerEx(win32.System.SystemServices.HANDLE, long *, int, delegate *unmanaged[Stdcall]{void *, uint, uint, void}, void *, win32.System.SystemServices.REASON_CONTEXT*, uint)"/>
        internal static unsafe bool SetWaitableTimerEx(SafeHandle hTimer, in long lpDueTime, int lPeriod, delegate *unmanaged[Stdcall]<void *, uint, uint, void>pfnCompletionRoutine, void *lpArgToCompletionRoutine, win32.System.SystemServices.REASON_CONTEXT? WakeContext, uint TolerableDelay)
        {
            bool hTimerAddRef = false;
            try
            {
                fixed (long *lpDueTimeLocal = &lpDueTime)
                {
                    win32.System.SystemServices.HANDLE hTimerLocal;
                    if (hTimer is object)
                    {
                        hTimer.DangerousAddRef(ref hTimerAddRef);
                        hTimerLocal = (win32.System.SystemServices.HANDLE)hTimer.DangerousGetHandle();
                    }
                    else
                        hTimerLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.REASON_CONTEXT WakeContextLocal = WakeContext.HasValue ? WakeContext.Value : default(win32.System.SystemServices.REASON_CONTEXT);
                    bool __result = Kernel32.SetWaitableTimerEx(hTimerLocal, lpDueTimeLocal, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, WakeContext.HasValue ? &WakeContextLocal : null, TolerableDelay);
                    return __result;
                }
            }
            finally
            {
                if (hTimerAddRef)
                    hTimer.DangerousRelease();
            }
        }

        /// <summary>Activates the specified waitable timer and provides context information for the timer. When the due time arrives, the timer is signaled and the thread that set the timer calls the optional completion routine.</summary>
        /// <param name = "hTimer">
        /// <para>A handle to the timer object. The [CreateWaitableTimer](./nf-synchapi-createwaitabletimerexw.md) or [OpenWaitableTimer](./nf-synchapi-openwaitabletimerw.md) function returns this handle.</para>
        /// <para>The handle must have the <b>TIMER_MODIFY_STATE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setwaitabletimerex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDueTime">
        /// <para>The time after which the state of the timer is to be set to signaled, in 100 nanosecond intervals. Use the format described by the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure. Positive values indicate absolute time. Be sure to use a UTC-based absolute time, as the system uses UTC-based time internally. Negative values indicate relative time. The actual timer accuracy depends on the capability of your hardware. For more information about UTC-based time, see <a href = "https://docs.microsoft.com/windows/desktop/SysInfo/system-time">System Time</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setwaitabletimerex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lPeriod">
        /// <para>The period of the timer, in milliseconds. If <i>lPeriod</i> is zero, the timer is signaled once. If <i>lPeriod</i> is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled using the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-cancelwaitabletimer">CancelWaitableTimer</a> function or reset using <b>SetWaitableTimerEx</b>. If <i>lPeriod</i> is less than zero, the function fails.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setwaitabletimerex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pfnCompletionRoutine">
        /// <para>A pointer to an optional completion routine. The completion routine is application-defined function of type <b>PTIMERAPCROUTINE</b> to be executed when the timer is signaled. For more information on the timer callback function, see <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nc-synchapi-ptimerapcroutine">TimerAPCProc</a>.  For more information about APCs and thread pool threads, see Remarks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setwaitabletimerex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpArgToCompletionRoutine">A pointer to a structure that is passed to the completion routine.</param>
        /// <param name = "WakeContext">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-reason_context">REASON_CONTEXT</a> structure that contains context information for the timer.</param>
        /// <param name = "TolerableDelay">The tolerable delay for expiration time, in milliseconds.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setwaitabletimerex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetWaitableTimerEx(win32.System.SystemServices.HANDLE hTimer, long *lpDueTime, int lPeriod, delegate *unmanaged[Stdcall]<void *, uint, uint, void>pfnCompletionRoutine, [Optional] void *lpArgToCompletionRoutine, [Optional] win32.System.SystemServices.REASON_CONTEXT*WakeContext, uint TolerableDelay);
        /// <inheritdoc cref = "SetWaitableTimer(win32.System.SystemServices.HANDLE, long *, int, delegate *unmanaged[Stdcall]{void *, uint, uint, void}, void *, bool)"/>
        internal static unsafe bool SetWaitableTimer(SafeHandle hTimer, in long lpDueTime, int lPeriod, delegate *unmanaged[Stdcall]<void *, uint, uint, void>pfnCompletionRoutine, void *lpArgToCompletionRoutine, bool fResume)
        {
            bool hTimerAddRef = false;
            try
            {
                fixed (long *lpDueTimeLocal = &lpDueTime)
                {
                    win32.System.SystemServices.HANDLE hTimerLocal;
                    if (hTimer is object)
                    {
                        hTimer.DangerousAddRef(ref hTimerAddRef);
                        hTimerLocal = (win32.System.SystemServices.HANDLE)hTimer.DangerousGetHandle();
                    }
                    else
                        hTimerLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetWaitableTimer(hTimerLocal, lpDueTimeLocal, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, fResume);
                    return __result;
                }
            }
            finally
            {
                if (hTimerAddRef)
                    hTimer.DangerousRelease();
            }
        }

        /// <summary>Activates the specified waitable timer. When the due time arrives, the timer is signaled and the thread that set the timer calls the optional completion routine.</summary>
        /// <param name = "hTimer">
        /// <para>A handle to the timer object. The <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-createwaitabletimerw">CreateWaitableTimer</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-openwaitabletimerw">OpenWaitableTimer</a> function returns this handle.</para>
        /// <para>The handle must have the <b>TIMER_MODIFY_STATE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setwaitabletimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDueTime">
        /// <para>The time after which the state of the timer is to be set to signaled, in 100 nanosecond intervals. Use the format described by the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure. Positive values indicate absolute time. Be sure to use a UTC-based absolute time, as the system uses UTC-based time internally. Negative values indicate relative time. The actual timer accuracy depends on the capability of your hardware. For more information about UTC-based time, see <a href = "https://docs.microsoft.com/windows/desktop/SysInfo/system-time">System Time</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setwaitabletimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lPeriod">
        /// <para>The period of the timer, in milliseconds. If <i>lPeriod</i> is zero, the timer is signaled once. If <i>lPeriod</i> is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled using the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-cancelwaitabletimer">CancelWaitableTimer</a> function or reset using <b>SetWaitableTimer</b>. If <i>lPeriod</i> is less than zero, the function fails.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setwaitabletimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pfnCompletionRoutine">
        /// <para>A pointer to an optional completion routine. The completion routine is application-defined function of type <b>PTIMERAPCROUTINE</b> to be executed when the timer is signaled. For more information on the timer callback function, see <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nc-synchapi-ptimerapcroutine">TimerAPCProc</a>. For more information about APCs and thread pool threads, see Remarks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setwaitabletimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpArgToCompletionRoutine">A pointer to a structure that is passed to the completion routine.</param>
        /// <param name = "fResume">If this parameter is <b>TRUE</b>, restores a system in suspended power conservation mode when the timer state is set to signaled. Otherwise, the system is not restored. If the system does not support a restore, the call succeeds, but <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_NOT_SUPPORTED</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-setwaitabletimer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetWaitableTimer(win32.System.SystemServices.HANDLE hTimer, long *lpDueTime, int lPeriod, delegate *unmanaged[Stdcall]<void *, uint, uint, void>pfnCompletionRoutine, [Optional] void *lpArgToCompletionRoutine, bool fResume);
        /// <inheritdoc cref = "CancelWaitableTimer(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool CancelWaitableTimer(SafeHandle hTimer)
        {
            bool hTimerAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hTimerLocal;
                if (hTimer is object)
                {
                    hTimer.DangerousAddRef(ref hTimerAddRef);
                    hTimerLocal = (win32.System.SystemServices.HANDLE)hTimer.DangerousGetHandle();
                }
                else
                    hTimerLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.CancelWaitableTimer(hTimerLocal);
                return __result;
            }
            finally
            {
                if (hTimerAddRef)
                    hTimer.DangerousRelease();
            }
        }

        /// <summary>Sets the specified waitable timer to the inactive state.</summary>
        /// <param name = "hTimer">
        /// <para>A handle to the timer object. The [CreateWaitableTimer](./nf-synchapi-createwaitabletimerw.md) or [OpenWaitableTimer](./nf-synchapi-openwaitabletimerw.md) function returns this handle. The handle must have the <b>TIMER_MODIFY_STATE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-cancelwaitabletimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-cancelwaitabletimer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool CancelWaitableTimer(win32.System.SystemServices.HANDLE hTimer);
        /// <inheritdoc cref = "CreateMutexEx(win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.System.SystemServices.PCWSTR, uint, uint)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateMutexEx(win32.System.SystemServices.SECURITY_ATTRIBUTES? lpMutexAttributes, string lpName, uint dwFlags, uint dwDesiredAccess)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpMutexAttributesLocal = lpMutexAttributes.HasValue ? lpMutexAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateMutexEx(lpMutexAttributes.HasValue ? &lpMutexAttributesLocal : null, lpNameLocal, dwFlags, dwDesiredAccess);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates or opens a named or unnamed mutex object and returns a handle to the object.</summary>
        /// <param name = "lpMutexAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createmutexexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
        /// <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name. If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createmutexexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>This parameter can be 0 or the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createmutexexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">
        /// <para>The access mask for the mutex object. For a list of access rights, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createmutexexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the [GetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) function returns **ERROR_ALREADY_EXISTS**.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createmutexexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateMutexExW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateMutexEx([Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpMutexAttributes, win32.System.SystemServices.PCWSTR lpName, uint dwFlags, uint dwDesiredAccess);
        /// <inheritdoc cref = "CreateEventEx(win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.System.SystemServices.PCWSTR, win32.System.Threading.CREATE_EVENT, uint)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateEventEx(win32.System.SystemServices.SECURITY_ATTRIBUTES? lpEventAttributes, string lpName, win32.System.Threading.CREATE_EVENT dwFlags, uint dwDesiredAccess)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpEventAttributesLocal = lpEventAttributes.HasValue ? lpEventAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateEventEx(lpEventAttributes.HasValue ? &lpEventAttributesLocal : null, lpNameLocal, dwFlags, dwDesiredAccess);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates or opens a named or unnamed event object and returns a handle to the object.</summary>
        /// <param name = "lpEventAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If <i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createeventexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>The name of the event object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
        /// <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
        /// <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
        /// <para>The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para>The object can be created in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createeventexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <param name = "dwDesiredAccess">
        /// <para>The access mask for the event object. For a list of access rights, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createeventexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createeventexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateEventExW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateEventEx([Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpEventAttributes, win32.System.SystemServices.PCWSTR lpName, win32.System.Threading.CREATE_EVENT dwFlags, uint dwDesiredAccess);
        /// <inheritdoc cref = "CreateSemaphoreEx(win32.System.SystemServices.SECURITY_ATTRIBUTES*, int, int, win32.System.SystemServices.PCWSTR, uint, uint)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateSemaphoreEx(win32.System.SystemServices.SECURITY_ATTRIBUTES? lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, string lpName, uint dwFlags, uint dwDesiredAccess)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpSemaphoreAttributesLocal = lpSemaphoreAttributes.HasValue ? lpSemaphoreAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateSemaphoreEx(lpSemaphoreAttributes.HasValue ? &lpSemaphoreAttributesLocal : null, lInitialCount, lMaximumCount, lpNameLocal, dwFlags, dwDesiredAccess);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates or opens a named or unnamed semaphore object and returns a handle to the object.</summary>
        /// <param name = "lpSemaphoreAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the semaphore handle cannot be inherited by child processes.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createsemaphoreexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lInitialCount">
        /// <para>The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-releasesemaphore">ReleaseSemaphore</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createsemaphoreexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lMaximumCount">The maximum count for the semaphore object. This value must be greater than zero.</param>
        /// <param name = "lpName">
        /// <para>A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
        /// <para>If <i>lpName</i> matches the name of an existing named semaphore object, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited.</para>
        /// <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
        /// <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
        /// <para>The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para>The object can be created in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createsemaphoreexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">This parameter is reserved and must be 0.</param>
        /// <param name = "dwDesiredAccess">
        /// <para>The access mask for the semaphore object. For a list of access rights, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createsemaphoreexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createsemaphoreexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateSemaphoreExW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateSemaphoreEx([Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, win32.System.SystemServices.PCWSTR lpName, uint dwFlags, uint dwDesiredAccess);
        /// <inheritdoc cref = "CreateWaitableTimerEx(win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.System.SystemServices.PCWSTR, uint, uint)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateWaitableTimerEx(win32.System.SystemServices.SECURITY_ATTRIBUTES? lpTimerAttributes, string lpTimerName, uint dwFlags, uint dwDesiredAccess)
        {
            fixed (char *lpTimerNameLocal = lpTimerName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpTimerAttributesLocal = lpTimerAttributes.HasValue ? lpTimerAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateWaitableTimerEx(lpTimerAttributes.HasValue ? &lpTimerAttributesLocal : null, lpTimerNameLocal, dwFlags, dwDesiredAccess);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates or opens a waitable timer object and returns a handle to the object.</summary>
        /// <param name = "lpTimerAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the timer handle cannot be inherited by child processes.</para>
        /// <para>If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createwaitabletimerexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTimerName">
        /// <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
        /// <para>If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name.</para>
        /// <para>If <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
        /// <para>The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para>The object can be created in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createwaitabletimerexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>This parameter can be 0 or the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createwaitabletimerexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">
        /// <para>The access mask for the timer object. For a list of access rights, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createwaitabletimerexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createwaitabletimerexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateWaitableTimerExW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateWaitableTimerEx([Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpTimerAttributes, win32.System.SystemServices.PCWSTR lpTimerName, uint dwFlags, uint dwDesiredAccess);
        /// <inheritdoc cref = "EnterSynchronizationBarrier(win32.System.SystemServices.RTL_BARRIER*, uint)"/>
        internal static unsafe bool EnterSynchronizationBarrier(ref win32.System.SystemServices.RTL_BARRIER lpBarrier, uint dwFlags)
        {
            fixed (win32.System.SystemServices.RTL_BARRIER*lpBarrierLocal = &lpBarrier)
            {
                bool __result = Kernel32.EnterSynchronizationBarrier(lpBarrierLocal, dwFlags);
                return __result;
            }
        }

        /// <summary>Causes the calling thread to wait at a synchronization barrier until the maximum number of threads have entered the barrier.</summary>
        /// <param name = "lpBarrier">
        /// <para>A pointer to an initialized synchronization barrier. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-initializesynchronizationbarrier">InitializeSynchronizationBarrier</a> function to initialize the barrier. <b>SYNCHRONIZATION_BARRIER</b> is an opaque structure that should not be modified by the application.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-entersynchronizationbarrier#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Flags that control the behavior of threads that enter this barrier. This parameter can be one or more of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-entersynchronizationbarrier#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para><b>TRUE</b> for the last thread to signal the barrier. Threads that signal the barrier before the last thread signals it receive a return value of <b>FALSE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-entersynchronizationbarrier">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool EnterSynchronizationBarrier(win32.System.SystemServices.RTL_BARRIER*lpBarrier, uint dwFlags);
        /// <inheritdoc cref = "InitializeSynchronizationBarrier(win32.System.SystemServices.RTL_BARRIER*, int, int)"/>
        internal static unsafe bool InitializeSynchronizationBarrier(out win32.System.SystemServices.RTL_BARRIER lpBarrier, int lTotalThreads, int lSpinCount)
        {
            fixed (win32.System.SystemServices.RTL_BARRIER*lpBarrierLocal = &lpBarrier)
            {
                bool __result = Kernel32.InitializeSynchronizationBarrier(lpBarrierLocal, lTotalThreads, lSpinCount);
                return __result;
            }
        }

        /// <summary>Initializes a new synchronization barrier.</summary>
        /// <param name = "lpBarrier">
        /// <para>A pointer to the <b>SYNCHRONIZATION_BARRIER</b> structure to initialize. This is an opaque structure that should not be modified by applications.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initializesynchronizationbarrier#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lTotalThreads">
        /// <para>The maximum number of threads that can enter this barrier. After the maximum number of threads have entered the barrier, all threads continue.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initializesynchronizationbarrier#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lSpinCount">
        /// <para>The number of times an individual thread should spin while waiting for other threads to arrive at the barrier. If this parameter is -1, the thread spins 2000 times. If the thread exceeds <i>lSpinCount</i>, the thread blocks unless it called <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-entersynchronizationbarrier">EnterSynchronizationBarrier</a> with <b>SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initializesynchronizationbarrier#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para><b>TRUE </b>if the barrier was successfully initialized. If the barrier was not successfully initialized, this function returns <b>FALSE</b>. Use <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-initializesynchronizationbarrier">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool InitializeSynchronizationBarrier(win32.System.SystemServices.RTL_BARRIER*lpBarrier, int lTotalThreads, int lSpinCount);
        /// <inheritdoc cref = "DeleteSynchronizationBarrier(win32.System.SystemServices.RTL_BARRIER*)"/>
        internal static unsafe bool DeleteSynchronizationBarrier(ref win32.System.SystemServices.RTL_BARRIER lpBarrier)
        {
            fixed (win32.System.SystemServices.RTL_BARRIER*lpBarrierLocal = &lpBarrier)
            {
                bool __result = Kernel32.DeleteSynchronizationBarrier(lpBarrierLocal);
                return __result;
            }
        }

        /// <summary>Deletes a synchronization barrier.</summary>
        /// <param name = "lpBarrier">A pointer to the synchronization barrier to delete.</param>
        /// <returns>The <b>DeleteSynchronizationBarrier</b> function always returns <b>TRUE</b>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-deletesynchronizationbarrier">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool DeleteSynchronizationBarrier(win32.System.SystemServices.RTL_BARRIER*lpBarrier);
        /// <summary>Suspends the execution of the current thread until the time-out interval elapses.</summary>
        /// <param name = "dwMilliseconds">
        /// <para>The time interval for which execution is to be suspended, in milliseconds.</para>
        /// <para>A value of zero causes the thread to relinquish the remainder of its time slice to any other thread  that is ready to run. If there are no other threads ready to run, the function returns immediately, and the thread continues execution.<b>Windows XP:  </b>A value of zero causes the thread to relinquish the remainder of its time slice to any other thread of equal priority that is ready to run. If there are no other threads of equal priority ready to run, the function returns immediately, and the thread continues execution. This behavior changed starting with Windows Server 2003.</para>
        /// <para>A value of INFINITE indicates that the suspension should not time out.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-sleep#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>This function causes a thread to relinquish the remainder of its time slice and become unrunnable for an interval based on the value of <i>dwMilliseconds</i>. The system clock "ticks" at a constant rate. If <i>dwMilliseconds</i> is less than the resolution of the system clock, the thread may sleep for less than the specified length of time. If <i>dwMilliseconds</i> is greater than one tick but less than two, the wait can be anywhere between one and two ticks, and so on. To increase the accuracy of the sleep interval, call the <b>timeGetDevCaps</b> function to determine the supported minimum timer resolution and the <b>timeBeginPeriod</b> function to set the timer resolution to its minimum. Use caution when calling <b>timeBeginPeriod</b>, as frequent calls can significantly affect the system clock, system power usage, and the scheduler. If you call <b>timeBeginPeriod</b>, call it one time early in the application and be sure to call the <b>timeEndPeriod</b> function at the very end of the application.</para>
        /// <para>After the sleep interval has passed, the thread is ready to run. If you specify 0 milliseconds, the thread will relinquish the remainder of its time slice but remain ready. Note that a ready thread is not guaranteed to run immediately. Consequently, the thread may not run until some time after the sleep interval elapses. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>.</para>
        /// <para>Be careful when using <b>Sleep</b> in the following scenarios:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-sleep#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void Sleep(uint dwMilliseconds);
        /// <inheritdoc cref = "WaitForMultipleObjects(uint, win32.System.SystemServices.HANDLE*, bool, uint)"/>
        internal static unsafe win32.System.Threading.WAIT_RETURN_CAUSE WaitForMultipleObjects(ReadOnlySpan<win32.System.SystemServices.HANDLE> lpHandles, bool bWaitAll, uint dwMilliseconds)
        {
            fixed (win32.System.SystemServices.HANDLE*lpHandlesLocal = lpHandles)
            {
                win32.System.Threading.WAIT_RETURN_CAUSE __result = Kernel32.WaitForMultipleObjects((uint)lpHandles.Length, lpHandlesLocal, bWaitAll, dwMilliseconds);
                return __result;
            }
        }

        /// <summary>Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses.</summary>
        /// <param name = "nCount">The number of object handles in the array pointed to by <i>lpHandles</i>. The maximum number of object handles is <b>MAXIMUM_WAIT_OBJECTS</b>. This parameter cannot be zero.</param>
        /// <param name = "lpHandles">
        /// <para>An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles to objects of different types. It may not contain multiple copies of the same handle.</para>
        /// <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
        /// <para>The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitformultipleobjects#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bWaitAll">If this parameter is <b>TRUE</b>, the function returns when the state of all objects in the <i>lpHandles</i> array is signaled. If <b>FALSE</b>, the function returns when the state of any one of the objects is set to signaled. In the latter case, the return value indicates the object whose state caused the function to return.</param>
        /// <param name = "dwMilliseconds">
        /// <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the specified objects are not signaled; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the specified objects are signaled.</para>
        /// <para><b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
        /// <para><b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitformultipleobjects#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined as 0x00000080L.)</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-waitformultipleobjects">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.Threading.WAIT_RETURN_CAUSE WaitForMultipleObjects(uint nCount, win32.System.SystemServices.HANDLE*lpHandles, bool bWaitAll, uint dwMilliseconds);
        /// <inheritdoc cref = "CreateSemaphore(win32.System.SystemServices.SECURITY_ATTRIBUTES*, int, int, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateSemaphore(win32.System.SystemServices.SECURITY_ATTRIBUTES? lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, string lpName)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpSemaphoreAttributesLocal = lpSemaphoreAttributes.HasValue ? lpSemaphoreAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateSemaphore(lpSemaphoreAttributes.HasValue ? &lpSemaphoreAttributesLocal : null, lInitialCount, lMaximumCount, lpNameLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates or opens a named or unnamed semaphore object.</summary>
        /// <param name = "lpSemaphoreAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createsemaphorew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lInitialCount">
        /// <para>The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-releasesemaphore">ReleaseSemaphore</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createsemaphorew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lMaximumCount">The maximum count for the semaphore object. This value must be greater than zero.</param>
        /// <param name = "lpName">
        /// <para>The name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
        /// <para>If <i>lpName</i> matches the name of an existing named semaphore object, this function requests the <b>SEMAPHORE_ALL_ACCESS</b> access right. In this case, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
        /// <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
        /// <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
        /// <para>The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para>The object can be created in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createsemaphorew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createsemaphorew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateSemaphoreW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateSemaphore([Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, win32.System.SystemServices.PCWSTR lpName);
        /// <inheritdoc cref = "CreateWaitableTimer(win32.System.SystemServices.SECURITY_ATTRIBUTES*, bool, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateWaitableTimer(win32.System.SystemServices.SECURITY_ATTRIBUTES? lpTimerAttributes, bool bManualReset, string lpTimerName)
        {
            fixed (char *lpTimerNameLocal = lpTimerName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpTimerAttributesLocal = lpTimerAttributes.HasValue ? lpTimerAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateWaitableTimer(lpTimerAttributes.HasValue ? &lpTimerAttributesLocal : null, bManualReset, lpTimerNameLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates or opens a waitable timer object.</summary>
        /// <param name = "lpTimerAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new timer object and determines whether child processes can inherit the returned handle.</para>
        /// <para>If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createwaitabletimerw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bManualReset">If this parameter is <b>TRUE</b>, the timer is a manual-reset notification timer. Otherwise, the timer is a synchronization timer.</param>
        /// <param name = "lpTimerName">
        /// <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
        /// <para>If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name.</para>
        /// <para>If <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
        /// <para>The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para>The object can be created in a private namespace. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createwaitabletimerw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-createwaitabletimerw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateWaitableTimerW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateWaitableTimer([Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpTimerAttributes, bool bManualReset, win32.System.SystemServices.PCWSTR lpTimerName);
        /// <inheritdoc cref = "QueueUserAPC(delegate *unmanaged[Stdcall]{nuint, void}, win32.System.SystemServices.HANDLE, nuint)"/>
        internal static unsafe uint QueueUserAPC(delegate *unmanaged[Stdcall]<nuint, void>pfnAPC, SafeHandle hThread, nuint dwData)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.QueueUserAPC(pfnAPC, hThreadLocal, dwData);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Adds a user-mode asynchronous procedure call (APC) object to the APC queue of the specified thread.</summary>
        /// <param name = "pfnAPC">
        /// <para>A pointer to the application-supplied APC function to be called when the specified thread performs an alertable wait operation. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nc-winnt-papcfunc">APCProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-queueuserapc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hThread">
        /// <para>A handle to the thread. The handle must have the <b>THREAD_SET_CONTEXT</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-queueuserapc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwData">A single value that is passed to the APC function pointed to by the <i>pfnAPC</i> parameter.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <b>Windows Server 2003 and Windows XP:  </b>There are no error values defined for this function that can be retrieved by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-queueuserapc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint QueueUserAPC(delegate *unmanaged[Stdcall]<nuint, void>pfnAPC, win32.System.SystemServices.HANDLE hThread, nuint dwData);
        /// <inheritdoc cref = "GetProcessTimes(win32.System.SystemServices.HANDLE, global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe bool GetProcessTimes(SafeHandle hProcess, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpCreationTime, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpExitTime, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpKernelTime, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpUserTime)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpUserTimeLocal = &lpUserTime)
                {
                    fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpKernelTimeLocal = &lpKernelTime)
                    {
                        fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpExitTimeLocal = &lpExitTime)
                        {
                            fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpCreationTimeLocal = &lpCreationTime)
                            {
                                win32.System.SystemServices.HANDLE hProcessLocal;
                                if (hProcess is object)
                                {
                                    hProcess.DangerousAddRef(ref hProcessAddRef);
                                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                                }
                                else
                                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                                bool __result = Kernel32.GetProcessTimes(hProcessLocal, lpCreationTimeLocal, lpExitTimeLocal, lpKernelTimeLocal, lpUserTimeLocal);
                                return __result;
                            }
                        }
                    }
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves timing information for the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process whose timing information is sought. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocesstimes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCreationTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the creation time of the process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocesstimes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpExitTime">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the exit time of the process. If the process has not exited, the content of this structure is undefined.</param>
        /// <param name = "lpKernelTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the amount of time that the process has executed in kernel mode. The time that each of the threads of the process has executed in kernel mode is determined, and then all of those times are summed together to obtain this value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocesstimes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpUserTime">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the amount of time that the process has executed in user mode. The time that each of the threads of the process has executed in user mode is determined, and then all of those times are summed together to obtain this value. Note that this value can exceed the amount of real time elapsed (between <i>lpCreationTime</i> and <i>lpExitTime</i>) if the process executes across multiple CPU cores.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocesstimes">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessTimes(win32.System.SystemServices.HANDLE hProcess, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpCreationTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpExitTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpKernelTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpUserTime);
        /// <inheritdoc cref = "GetCurrentProcess()"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle GetCurrentProcess_SafeHandle()
        {
            win32.System.SystemServices.HANDLE __result = Kernel32.GetCurrentProcess();
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        /// <summary>Retrieves a pseudo handle for the current process.</summary>
        /// <returns>The return value is a pseudo handle to the current process.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getcurrentprocess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.HANDLE GetCurrentProcess();
        /// <summary>Retrieves the process identifier of the calling process.</summary>
        /// <returns>The return value is the process identifier of the calling process.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getcurrentprocessid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetCurrentProcessId();
        /// <summary>Ends the calling process and all its threads.</summary>
        /// <param name = "uExitCode">The exit code for the process and all threads.</param>
        /// <remarks>
        /// <para>Use the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getexitcodeprocess">GetExitCodeProcess</a> function to retrieve the process's exit value. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getexitcodethread">GetExitCodeThread</a> function to retrieve a thread's exit value.</para>
        /// <para>Exiting a process causes the following:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-exitprocess#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void ExitProcess(uint uExitCode);
        /// <inheritdoc cref = "TerminateProcess(win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe bool TerminateProcess(SafeHandle hProcess, uint uExitCode)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.TerminateProcess(hProcessLocal, uExitCode);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Terminates the specified process and all of its threads.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process to be terminated.</para>
        /// <para>The handle must have the <b>PROCESS_TERMINATE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-terminateprocess#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uExitCode">
        /// <para>The exit code to be used by the process and threads terminated as a result of this call. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getexitcodeprocess">GetExitCodeProcess</a> function to retrieve a process's exit value. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getexitcodethread">GetExitCodeThread</a> function to retrieve a thread's exit value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-terminateprocess#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-terminateprocess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool TerminateProcess(win32.System.SystemServices.HANDLE hProcess, uint uExitCode);
        /// <inheritdoc cref = "GetExitCodeProcess(win32.System.SystemServices.HANDLE, uint *)"/>
        internal static unsafe bool GetExitCodeProcess(SafeHandle hProcess, out uint lpExitCode)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *lpExitCodeLocal = &lpExitCode)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetExitCodeProcess(hProcessLocal, lpExitCodeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the termination status of the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process.</para>
        /// <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getexitcodeprocess#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpExitCode">A pointer to a variable to receive the process termination status. For more information, see Remarks.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getexitcodeprocess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetExitCodeProcess(win32.System.SystemServices.HANDLE hProcess, uint *lpExitCode);
        /// <summary>Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the next thread to be executed.</summary>
        /// <returns>
        /// <para>If calling the <b>SwitchToThread</b> function caused the operating system to switch execution to another thread, the return value is nonzero.</para>
        /// <para>If there are no other threads ready to execute, the operating system does not switch execution to another thread, and the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-switchtothread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SwitchToThread();
        /// <inheritdoc cref = "CreateThread(win32.System.SystemServices.SECURITY_ATTRIBUTES*, nuint, delegate *unmanaged[Stdcall]{void *, uint}, void *, win32.System.Threading.THREAD_CREATION_FLAGS, uint *)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateThread(win32.System.SystemServices.SECURITY_ATTRIBUTES? lpThreadAttributes, nuint dwStackSize, delegate *unmanaged[Stdcall]<void *, uint>lpStartAddress, void *lpParameter, win32.System.Threading.THREAD_CREATION_FLAGS dwCreationFlags, uint *lpThreadId)
        {
            win32.System.SystemServices.SECURITY_ATTRIBUTES lpThreadAttributesLocal = lpThreadAttributes.HasValue ? lpThreadAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
            win32.System.SystemServices.HANDLE __result = Kernel32.CreateThread(lpThreadAttributes.HasValue ? &lpThreadAttributesLocal : null, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        /// <summary>Creates a thread to execute within the virtual address space of the calling process.</summary>
        /// <param name = "lpThreadAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new thread. If <i>lpThreadAttributes</i> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the primary token of the creator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createthread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwStackSize">
        /// <para>The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is zero, the new thread uses the default size for the executable. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createthread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpStartAddress">
        /// <para>A pointer to the application-defined function to be executed by the thread. This pointer represents the starting address of the thread. For more information on the thread function, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createthread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpParameter">A pointer to a variable to be passed to the thread.</param>
        /// <param name = "dwCreationFlags">
        /// <para>The flags that control the creation of the thread.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createthread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpThreadId">
        /// <para>A pointer to a variable that receives the  thread identifier. If this parameter is <b>NULL</b>, the thread identifier is not returned.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createthread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the new thread.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>Note that <b>CreateThread</b> may succeed even if <i>lpStartAddress</i> points to data, code, or is not accessible. If the start address is invalid when the thread runs, an exception occurs, and the thread terminates. Thread termination due to a invalid start address is handled as an error exit for the thread's process. This behavior is similar to the asynchronous nature of <a href = "/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>, where the process is created even if it refers to invalid or missing dynamic-link libraries (DLLs).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createthread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateThread([Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpThreadAttributes, nuint dwStackSize, delegate *unmanaged[Stdcall]<void *, uint>lpStartAddress, [Optional] void *lpParameter, win32.System.Threading.THREAD_CREATION_FLAGS dwCreationFlags, [Optional] uint *lpThreadId);
        /// <inheritdoc cref = "CreateRemoteThread(win32.System.SystemServices.HANDLE, win32.System.SystemServices.SECURITY_ATTRIBUTES*, nuint, delegate *unmanaged[Stdcall]{void *, uint}, void *, uint, uint *)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateRemoteThread(SafeHandle hProcess, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpThreadAttributes, nuint dwStackSize, delegate *unmanaged[Stdcall]<void *, uint>lpStartAddress, void *lpParameter, uint dwCreationFlags, uint *lpThreadId)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpThreadAttributesLocal = lpThreadAttributes.HasValue ? lpThreadAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateRemoteThread(hProcessLocal, lpThreadAttributes.HasValue ? &lpThreadAttributesLocal : null, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Creates a thread that runs in the virtual address space of another process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process in which the thread is to be created. The handle must have the <b>PROCESS_CREATE_THREAD</b>, <b>PROCESS_QUERY_INFORMATION</b>, <b>PROCESS_VM_OPERATION</b>, <b>PROCESS_VM_WRITE</b>, and <b>PROCESS_VM_READ</b> access rights, and may fail without these rights on certain platforms. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpThreadAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If <i>lpThreadAttributes</i> is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.</para>
        /// <para><b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwStackSize">
        /// <para>The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpStartAddress">
        /// <para>A pointer to the application-defined function of type <b>LPTHREAD_START_ROUTINE</b> to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpParameter">A pointer to a variable to be passed to the thread function.</param>
        /// <param name = "dwCreationFlags">
        /// <para>The flags that control the creation of the thread.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpThreadId">
        /// <para>A pointer to a variable that receives the thread identifier.</para>
        /// <para>If this parameter is <b>NULL</b>, the thread identifier is not returned.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the new thread.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>Note that <b>CreateRemoteThread</b> may succeed even if <i>lpStartAddress</i> points to data, code, or is not accessible. If the start address is invalid when the thread runs, an exception occurs, and the thread terminates. Thread termination due to a invalid start address is handled as an error exit for the thread's process. This behavior is similar to the asynchronous nature of <a href = "/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>, where the process is created even if it refers to invalid or missing dynamic-link libraries (DLL).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateRemoteThread(win32.System.SystemServices.HANDLE hProcess, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpThreadAttributes, nuint dwStackSize, delegate *unmanaged[Stdcall]<void *, uint>lpStartAddress, [Optional] void *lpParameter, uint dwCreationFlags, [Optional] uint *lpThreadId);
        /// <inheritdoc cref = "GetCurrentThread()"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle GetCurrentThread_SafeHandle()
        {
            win32.System.SystemServices.HANDLE __result = Kernel32.GetCurrentThread();
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        /// <summary>Retrieves a pseudo handle for the calling thread.</summary>
        /// <returns>The return value is a pseudo handle for the current thread.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getcurrentthread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.HANDLE GetCurrentThread();
        /// <summary>Retrieves the thread identifier of the calling thread.</summary>
        /// <returns>The return value is the thread identifier of the calling thread.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getcurrentthreadid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetCurrentThreadId();
        /// <inheritdoc cref = "OpenThread(uint, bool, uint)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle OpenThread_SafeHandle(uint dwDesiredAccess, bool bInheritHandle, uint dwThreadId)
        {
            win32.System.SystemServices.HANDLE __result = Kernel32.OpenThread(dwDesiredAccess, bInheritHandle, dwThreadId);
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        /// <summary>Opens an existing thread object.</summary>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the thread object. This access right is checked against the security descriptor for the thread. This parameter can be one or more of the <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">thread access rights</a>.</para>
        /// <para>If the caller has enabled the SeDebugPrivilege privilege, the requested access is  granted regardless of the contents of the security descriptor.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-openthread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInheritHandle">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name = "dwThreadId">The identifier of the thread to be opened.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is an open handle to the specified thread.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-openthread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE OpenThread(uint dwDesiredAccess, bool bInheritHandle, uint dwThreadId);
        /// <inheritdoc cref = "SetThreadPriorityBoost(win32.System.SystemServices.HANDLE, bool)"/>
        internal static unsafe bool SetThreadPriorityBoost(SafeHandle hThread, bool bDisablePriorityBoost)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetThreadPriorityBoost(hThreadLocal, bDisablePriorityBoost);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Disables or enables the ability of the system to temporarily boost the priority of a thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread whose priority is to be boosted. The handle must have the <b>THREAD_SET_INFORMATION</b> or <b>THREAD_SET_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_SET_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadpriorityboost#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bDisablePriorityBoost">If this parameter is <b>TRUE</b>, dynamic boosting is disabled. If the parameter is <b>FALSE</b>, dynamic boosting is enabled.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadpriorityboost">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetThreadPriorityBoost(win32.System.SystemServices.HANDLE hThread, bool bDisablePriorityBoost);
        /// <inheritdoc cref = "GetThreadPriorityBoost(win32.System.SystemServices.HANDLE, bool *)"/>
        internal static unsafe bool GetThreadPriorityBoost(SafeHandle hThread, out bool pDisablePriorityBoost)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (bool *pDisablePriorityBoostLocal = &pDisablePriorityBoost)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetThreadPriorityBoost(hThreadLocal, pDisablePriorityBoostLocal);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Retrieves the priority boost control state of the specified thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread. The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadpriorityboost#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pDisablePriorityBoost">A pointer to a variable that receives the priority boost control state. A value of TRUE indicates that dynamic boosting is disabled. A value of FALSE indicates normal behavior.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. In that case, the variable pointed to by the <i>pDisablePriorityBoost</i> parameter receives the priority boost control state.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadpriorityboost">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetThreadPriorityBoost(win32.System.SystemServices.HANDLE hThread, bool *pDisablePriorityBoost);
        /// <inheritdoc cref = "GetThreadPriority(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe int GetThreadPriority(SafeHandle hThread)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                int __result = Kernel32.GetThreadPriority(hThreadLocal);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Retrieves the priority value for the specified thread. This value, together with the priority class of the thread's process, determines the thread's base-priority level.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread.</para>
        /// <para>The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadpriority#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the thread's priority level.</para>
        /// <para>If the function fails, the return value is <b>THREAD_PRIORITY_ERROR_RETURN</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para><b>Windows Phone 8.1:  </b>This function will always return <b>THREAD_PRIORITY_NORMAL</b>.</para>
        /// <para>The thread's priority level is one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadpriority">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetThreadPriority(win32.System.SystemServices.HANDLE hThread);
        /// <summary>Ends the calling thread.</summary>
        /// <param name = "dwExitCode">The exit code for the thread.</param>
        /// <remarks>
        /// <para><b>ExitThread</b> is the preferred method of exiting a thread in C code. However, in C++ code, the thread is exited before any destructors can be called or any other automatic cleanup can be performed. Therefore, in C++ code, you should return from your thread function.</para>
        /// <para>When this function is called (either explicitly or by returning from a thread procedure), the current thread's stack is deallocated, all pending I/O initiated by the thread is canceled, and the thread terminates. The entry-point function of all attached dynamic-link libraries (DLLs) is invoked with a value indicating that the thread is detaching from the DLL.</para>
        /// <para>If the thread is the last thread in the process when this function is called, the thread's process is also terminated.</para>
        /// <para>The state of the thread object becomes signaled, releasing any other threads that had been waiting for the thread to terminate. The thread's termination status changes from STILL_ACTIVE to the value of the <i>dwExitCode</i> parameter.</para>
        /// <para>Terminating a thread does not necessarily remove the thread object from the operating system. A thread object is deleted when the last handle to the thread is closed.</para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitprocess">ExitProcess</a>, <b>ExitThread</b>, <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread">CreateThread</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createremotethread">CreateRemoteThread</a> functions, and a process that is starting (as the result of a <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> call) are serialized between each other within a process. Only one of these events can happen in an address space at a time. This means the following restrictions hold:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-exitthread#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void ExitThread(uint dwExitCode);
        /// <inheritdoc cref = "TerminateThread(win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe bool TerminateThread(SafeHandle hThread, uint dwExitCode)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.TerminateThread(hThreadLocal, dwExitCode);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Terminates a thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread to be terminated.</para>
        /// <para>The handle must have the <b>THREAD_TERMINATE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-terminatethread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwExitCode">
        /// <para>The exit code for the thread. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getexitcodethread">GetExitCodeThread</a> function to retrieve a thread's exit value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-terminatethread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-terminatethread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool TerminateThread(win32.System.SystemServices.HANDLE hThread, uint dwExitCode);
        /// <inheritdoc cref = "GetExitCodeThread(win32.System.SystemServices.HANDLE, uint *)"/>
        internal static unsafe bool GetExitCodeThread(SafeHandle hThread, out uint lpExitCode)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (uint *lpExitCodeLocal = &lpExitCode)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetExitCodeThread(hThreadLocal, lpExitCodeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Retrieves the termination status of the specified thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread.</para>
        /// <para>The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getexitcodethread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpExitCode">A pointer to a variable to receive the thread termination status. For more information, see Remarks.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getexitcodethread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetExitCodeThread(win32.System.SystemServices.HANDLE hThread, uint *lpExitCode);
        /// <inheritdoc cref = "SuspendThread(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint SuspendThread(SafeHandle hThread)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.SuspendThread(hThreadLocal);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Suspends the specified thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread that is to be suspended.</para>
        /// <para>The handle must have the <b>THREAD_SUSPEND_RESUME</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-suspendthread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is <code>(DWORD) -1</code>. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-suspendthread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint SuspendThread(win32.System.SystemServices.HANDLE hThread);
        /// <inheritdoc cref = "ResumeThread(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint ResumeThread(SafeHandle hThread)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.ResumeThread(hThreadLocal);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Decrements a thread's suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread to be restarted.</para>
        /// <para>This handle must have the THREAD_SUSPEND_RESUME access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-resumethread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the thread's previous suspend count.</para>
        /// <para>If the function fails, the return value is (DWORD) -1. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-resumethread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint ResumeThread(win32.System.SystemServices.HANDLE hThread);
        /// <summary>Allocates a thread local storage (TLS) index. Any thread of the process can subsequently use this index to store and retrieve values that are local to the thread, because each thread receives its own slot for the index.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is a TLS index. The slots for the index are initialized to zero.</para>
        /// <para>If the function fails, the return value is <b>TLS_OUT_OF_INDEXES</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-tlsalloc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint TlsAlloc();
        /// <summary>Retrieves the value in the calling thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.</summary>
        /// <param name = "dwTlsIndex">
        /// <para>The TLS index that was allocated by the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc">TlsAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-tlsgetvalue#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the value stored in the calling thread's TLS slot associated with the specified index. If <i>dwTlsIndex</i> is a valid index allocated by a successful call to <a href = "/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc">TlsAlloc</a>, this function always succeeds.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>The data stored in a TLS slot can have a value of 0 because it still has its initial value or because the thread called the <a href = "/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlssetvalue">TlsSetValue</a> function with 0. Therefore, if the return value is 0, you must check whether <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_SUCCESS</b> before determining that the function has failed. If <b>GetLastError</b> returns <b>ERROR_SUCCESS</b>, then the function has succeeded and the data stored in the TLS slot is 0. Otherwise, the function has failed.</para>
        /// <para>Functions that return indications of failure call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a>when they fail. They generally do not call <b>SetLastError</b>when they succeed. The <b>TlsGetValue</b> function is an exception to this general rule. The <b>TlsGetValue</b> function calls <b>SetLastError</b>to clear a thread's last error when it succeeds. That allows checking for the error-free retrieval of zero values.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-tlsgetvalue">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *TlsGetValue(uint dwTlsIndex);
        /// <summary>Stores a value in the calling thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.</summary>
        /// <param name = "dwTlsIndex">
        /// <para>The TLS index that was allocated by the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc">TlsAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-tlssetvalue#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTlsValue">The value to be stored in the calling thread's TLS slot for the index.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-tlssetvalue">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool TlsSetValue(uint dwTlsIndex, [Optional] void *lpTlsValue);
        /// <summary>Releases a thread local storage (TLS) index, making it available for reuse.</summary>
        /// <param name = "dwTlsIndex">
        /// <para>The TLS index that was allocated by the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc">TlsAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-tlsfree#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-tlsfree">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool TlsFree(uint dwTlsIndex);
        /// <inheritdoc cref = "CreateProcess(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.System.SystemServices.SECURITY_ATTRIBUTES*, bool, win32.System.Threading.PROCESS_CREATION_FLAGS, void *, win32.System.SystemServices.PCWSTR, win32.System.Threading.STARTUPINFOW*, win32.System.Threading.PROCESS_INFORMATION*)"/>
        internal static unsafe bool CreateProcess(string lpApplicationName, win32.System.SystemServices.PWSTR lpCommandLine, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpProcessAttributes, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpThreadAttributes, bool bInheritHandles, win32.System.Threading.PROCESS_CREATION_FLAGS dwCreationFlags, void *lpEnvironment, string lpCurrentDirectory, in win32.System.Threading.STARTUPINFOW lpStartupInfo, out win32.System.Threading.PROCESS_INFORMATION lpProcessInformation)
        {
            fixed (win32.System.Threading.PROCESS_INFORMATION*lpProcessInformationLocal = &lpProcessInformation)
            {
                fixed (win32.System.Threading.STARTUPINFOW*lpStartupInfoLocal = &lpStartupInfo)
                {
                    fixed (char *lpCurrentDirectoryLocal = lpCurrentDirectory)
                    {
                        fixed (char *lpApplicationNameLocal = lpApplicationName)
                        {
                            win32.System.SystemServices.SECURITY_ATTRIBUTES lpProcessAttributesLocal = lpProcessAttributes.HasValue ? lpProcessAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                            win32.System.SystemServices.SECURITY_ATTRIBUTES lpThreadAttributesLocal = lpThreadAttributes.HasValue ? lpThreadAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                            bool __result = Kernel32.CreateProcess(lpApplicationNameLocal, lpCommandLine, lpProcessAttributes.HasValue ? &lpProcessAttributesLocal : null, lpThreadAttributes.HasValue ? &lpThreadAttributesLocal : null, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectoryLocal, lpStartupInfoLocal, lpProcessInformationLocal);
                            return __result;
                        }
                    }
                }
            }
        }

        /// <summary>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</summary>
        /// <param name = "lpApplicationName">
        /// <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
        /// <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
        /// <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
        /// <para><b>c:\program.exe</b> <b>c:\program files\sub.exe</b> <b>c:\program files\sub dir\program.exe</b> <b>c:\program files\sub dir\program name.exe</b> If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
        /// <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createprocessw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCommandLine">
        /// <para>The command line to be executed.</para>
        /// <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
        /// <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
        /// <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
        /// <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>,  the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by  <i>lpCommandLine</i> specifies the command line. The new process can use <a href = "https://docs.microsoft.com/windows/desktop/api/processenv/nf-processenv-getcommandlinea">GetCommandLine</a> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
        /// <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createprocessw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpProcessAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createprocessw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpThreadAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createprocessw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInheritHandles">
        /// <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
        /// <para><b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
        /// <para><b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createprocessw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwCreationFlags">
        /// <para>The flags that control the priority class and the creation of the process. For a list of values, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
        /// <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getpriorityclass">GetPriorityClass</a>. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
        /// <para>If the dwCreationFlags parameter has a value of 0:</para>
        /// <para>- The process inherits both the error mode of the caller and the parent's console. - The environment block for the new process is assumed to contain ANSI characters (see *lpEnvironment* parameter for additional information). - A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createprocessw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEnvironment">
        /// <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
        /// <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
        /// <para><i>name</i>=<i>value</i>\0</para>
        /// <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
        /// <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
        /// <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
        /// <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createprocessw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCurrentDirectory">
        /// <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
        /// <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createprocessw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpStartupInfo">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-startupinfoexa">STARTUPINFOEX</a> structure.</para>
        /// <para>To set extended attributes, use a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-startupinfoexa">STARTUPINFOEX</a> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
        /// <para>Handles in <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-startupinfoexa">STARTUPINFOEX</a> must be closed with <a href = "https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> when they are no longer needed.</para>
        /// <para><div class = "alert"><b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a>  contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href = "https://docs.microsoft.com/windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles. </div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createprocessw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpProcessInformation">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> structure that receives identification information about the new process.</para>
        /// <para>Handles in <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> must be closed with <a href = "https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> when they are no longer needed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createprocessw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <a href = "/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getexitcodeprocess">GetExitCodeProcess</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createprocessw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateProcessW", SetLastError = true)]
        internal static extern unsafe bool CreateProcess(win32.System.SystemServices.PCWSTR lpApplicationName, win32.System.SystemServices.PWSTR lpCommandLine, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpProcessAttributes, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpThreadAttributes, bool bInheritHandles, win32.System.Threading.PROCESS_CREATION_FLAGS dwCreationFlags, [Optional] void *lpEnvironment, win32.System.SystemServices.PCWSTR lpCurrentDirectory, win32.System.Threading.STARTUPINFOW*lpStartupInfo, win32.System.Threading.PROCESS_INFORMATION*lpProcessInformation);
        /// <summary>Sets shutdown parameters for the currently calling process. This function sets a shutdown order for a process relative to the other processes in the system.</summary>
        /// <param name = "dwLevel">
        /// <para>The shutdown priority for a process relative to other processes in the system. The system shuts down processes from high <i>dwLevel</i> values to low. The highest and lowest shutdown priorities are reserved for system components. This parameter must be in the following range of values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessshutdownparameters#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>This parameter can be the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessshutdownparameters#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function is succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessshutdownparameters">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetProcessShutdownParameters(uint dwLevel, uint dwFlags);
        /// <summary>Retrieves the major and minor version numbers of the system on which the specified process expects to run.</summary>
        /// <param name = "ProcessId">The process identifier of the process of interest. A value of zero specifies the calling process.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the version of the system on which the process expects to run. The high word of the return value contains the major version number. The low word of the return value contains the minor version number.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The function fails if <i>ProcessId</i> is an invalid value.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessversion">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetProcessVersion(uint ProcessId);
        /// <inheritdoc cref = "GetStartupInfo(win32.System.Threading.STARTUPINFOW*)"/>
        internal static unsafe void GetStartupInfo(out win32.System.Threading.STARTUPINFOW lpStartupInfo)
        {
            fixed (win32.System.Threading.STARTUPINFOW*lpStartupInfoLocal = &lpStartupInfo)
            {
                Kernel32.GetStartupInfo(lpStartupInfoLocal);
            }
        }

        /// <summary>Retrieves the contents of the STARTUPINFO structure that was specified when the calling process was created.</summary>
        /// <param name = "lpStartupInfo">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a> structure that receives the startup information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getstartupinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>This function does not return a value.</para>
        /// <para>If an error occurs, the ANSI version of this function (<b>GetStartupInfoA</b>) can raise an exception. The Unicode version (<b>GetStartupInfoW</b>) does not fail.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getstartupinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetStartupInfoW")]
        internal static extern unsafe void GetStartupInfo(win32.System.Threading.STARTUPINFOW*lpStartupInfo);
        /// <inheritdoc cref = "SetPriorityClass(win32.System.SystemServices.HANDLE, win32.System.Threading.PROCESS_CREATION_FLAGS)"/>
        internal static unsafe bool SetPriorityClass(SafeHandle hProcess, win32.System.Threading.PROCESS_CREATION_FLAGS dwPriorityClass)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetPriorityClass(hProcessLocal, dwPriorityClass);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Sets the priority class for the specified process. This value together with the priority value of each thread of the process determines each thread's base priority level.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process.</para>
        /// <para>The handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setpriorityclass#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwPriorityClass"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setpriorityclass">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetPriorityClass(win32.System.SystemServices.HANDLE hProcess, win32.System.Threading.PROCESS_CREATION_FLAGS dwPriorityClass);
        /// <inheritdoc cref = "GetPriorityClass(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint GetPriorityClass(SafeHandle hProcess)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.GetPriorityClass(hProcessLocal);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the priority class for the specified process. This value, together with the priority value of each thread of the process, determines each thread's base priority level.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process.</para>
        /// <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getpriorityclass#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the priority class of the specified process.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>The process's priority class is one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getpriorityclass">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetPriorityClass(win32.System.SystemServices.HANDLE hProcess);
        /// <inheritdoc cref = "SetThreadStackGuarantee(uint *)"/>
        internal static unsafe bool SetThreadStackGuarantee(ref uint StackSizeInBytes)
        {
            fixed (uint *StackSizeInBytesLocal = &StackSizeInBytes)
            {
                bool __result = Kernel32.SetThreadStackGuarantee(StackSizeInBytesLocal);
                return __result;
            }
        }

        /// <summary>Sets the minimum size of the stack associated with the calling thread or fiber that will be available during any stack overflow exceptions.</summary>
        /// <param name = "StackSizeInBytes">
        /// <para>The size of the stack, in bytes. On return, this value is set to the size of the previous stack, in bytes.</para>
        /// <para>If this parameter is 0 (zero), the function succeeds and the parameter contains the size of the current stack.</para>
        /// <para>If the specified size is less than the current size, the function succeeds but ignores this request. Therefore, you cannot use this function to reduce the size of the stack.</para>
        /// <para>This value cannot be larger than the reserved stack size.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadstackguarantee#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadstackguarantee">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetThreadStackGuarantee(uint *StackSizeInBytes);
        /// <inheritdoc cref = "GetProcessId(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint GetProcessId(SafeHandle Process)
        {
            bool ProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE ProcessLocal;
                if (Process is object)
                {
                    Process.DangerousAddRef(ref ProcessAddRef);
                    ProcessLocal = (win32.System.SystemServices.HANDLE)Process.DangerousGetHandle();
                }
                else
                    ProcessLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.GetProcessId(ProcessLocal);
                return __result;
            }
            finally
            {
                if (ProcessAddRef)
                    Process.DangerousRelease();
            }
        }

        /// <summary>Retrieves the process identifier of the specified process.</summary>
        /// <param name = "Process">
        /// <para>A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the PROCESS_QUERY_INFORMATION access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the process identifier.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetProcessId(win32.System.SystemServices.HANDLE Process);
        /// <inheritdoc cref = "GetThreadId(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint GetThreadId(SafeHandle Thread)
        {
            bool ThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE ThreadLocal;
                if (Thread is object)
                {
                    Thread.DangerousAddRef(ref ThreadAddRef);
                    ThreadLocal = (win32.System.SystemServices.HANDLE)Thread.DangerousGetHandle();
                }
                else
                    ThreadLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.GetThreadId(ThreadLocal);
                return __result;
            }
            finally
            {
                if (ThreadAddRef)
                    Thread.DangerousRelease();
            }
        }

        /// <summary>Retrieves the thread identifier of the specified thread.</summary>
        /// <param name = "Thread">
        /// <para>A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information about access rights, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003:  </b>The handle must have the THREAD_QUERY_INFORMATION access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetThreadId(win32.System.SystemServices.HANDLE Thread);
        /// <summary>Flushes the write queue of each processor that is running a thread of the current process.</summary>
        /// <remarks>
        /// <para>The function generates an interprocessor interrupt (IPI) to all processors that are part of the current process affinity. It guarantees the visibility of write operations performed on one processor to the other processors.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void FlushProcessWriteBuffers();
        /// <inheritdoc cref = "GetProcessIdOfThread(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint GetProcessIdOfThread(SafeHandle Thread)
        {
            bool ThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE ThreadLocal;
                if (Thread is object)
                {
                    Thread.DangerousAddRef(ref ThreadAddRef);
                    ThreadLocal = (win32.System.SystemServices.HANDLE)Thread.DangerousGetHandle();
                }
                else
                    ThreadLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.GetProcessIdOfThread(ThreadLocal);
                return __result;
            }
            finally
            {
                if (ThreadAddRef)
                    Thread.DangerousRelease();
            }
        }

        /// <summary>Retrieves the process identifier of the process associated with the specified thread.</summary>
        /// <param name = "Thread">
        /// <para>A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003:  </b>The handle must have the THREAD_QUERY_INFORMATION access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessidofthread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the process identifier of the process associated with the specified thread.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessidofthread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetProcessIdOfThread(win32.System.SystemServices.HANDLE Thread);
        /// <inheritdoc cref = "InitializeProcThreadAttributeList(win32.System.Threading.LPPROC_THREAD_ATTRIBUTE_LIST, uint, uint, nuint*)"/>
        internal static unsafe bool InitializeProcThreadAttributeList(win32.System.Threading.LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, uint dwAttributeCount, uint dwFlags, out nuint lpSize)
        {
            fixed (nuint*lpSizeLocal = &lpSize)
            {
                bool __result = Kernel32.InitializeProcThreadAttributeList(lpAttributeList, dwAttributeCount, dwFlags, lpSizeLocal);
                return __result;
            }
        }

        /// <summary>Initializes the specified list of attributes for process and thread creation.</summary>
        /// <param name = "lpAttributeList">The attribute list. This parameter can be NULL to determine the buffer size required to support the specified number of attributes.</param>
        /// <param name = "dwAttributeCount">The count of attributes to be added to the list.</param>
        /// <param name = "dwFlags">This parameter is reserved and must be zero.</param>
        /// <param name = "lpSize">
        /// <para>If <i>lpAttributeList</i> is not NULL, this parameter specifies the size in bytes of the <i>lpAttributeList</i> buffer on input. On output, this parameter receives the size in bytes of the initialized attribute list.</para>
        /// <para>If <i>lpAttributeList</i> is NULL, this parameter receives the required buffer size in bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool InitializeProcThreadAttributeList(win32.System.Threading.LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, uint dwAttributeCount, uint dwFlags, nuint*lpSize);
        /// <summary>Deletes the specified list of attributes for process and thread creation.</summary>
        /// <param name = "lpAttributeList">The attribute list. This list is created by the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist">InitializeProcThreadAttributeList</a> function.</param>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-deleteprocthreadattributelist">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void DeleteProcThreadAttributeList(win32.System.Threading.LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList);
        /// <inheritdoc cref = "UpdateProcThreadAttribute(win32.System.Threading.LPPROC_THREAD_ATTRIBUTE_LIST, uint, nuint, void *, nuint, void *, nuint*)"/>
        internal static unsafe bool UpdateProcThreadAttribute(win32.System.Threading.LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, uint dwFlags, nuint Attribute, void *lpValue, nuint cbSize, void *lpPreviousValue, nuint? lpReturnSize)
        {
            nuint lpReturnSizeLocal = lpReturnSize.HasValue ? lpReturnSize.Value : default(nuint);
            bool __result = Kernel32.UpdateProcThreadAttribute(lpAttributeList, dwFlags, Attribute, lpValue, cbSize, lpPreviousValue, lpReturnSize.HasValue ? &lpReturnSizeLocal : null);
            return __result;
        }

        /// <summary>Updates the specified attribute in a list of attributes for process and thread creation.</summary>
        /// <param name = "lpAttributeList">A pointer to an attribute list created by the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist">InitializeProcThreadAttributeList</a> function.</param>
        /// <param name = "dwFlags">This parameter is reserved and must be zero.</param>
        /// <param name = "Attribute"></param>
        /// <param name = "lpValue">A pointer to the attribute value. This value should persist until the attribute is destroyed using the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-deleteprocthreadattributelist">DeleteProcThreadAttributeList</a> function.</param>
        /// <param name = "cbSize">The size of the attribute value specified by the <i>lpValue</i> parameter.</param>
        /// <param name = "lpPreviousValue">This parameter is reserved and must be NULL.</param>
        /// <param name = "lpReturnSize">This parameter is reserved and must be NULL.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-updateprocthreadattribute">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool UpdateProcThreadAttribute(win32.System.Threading.LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, uint dwFlags, nuint Attribute, [Optional] void *lpValue, nuint cbSize, [Optional] void *lpPreviousValue, [Optional] nuint*lpReturnSize);
        /// <inheritdoc cref = "SetProcessDynamicEHContinuationTargets(win32.System.SystemServices.HANDLE, ushort, win32.System.SystemServices.PROCESS_DYNAMIC_EH_CONTINUATION_TARGET*)"/>
        internal static unsafe bool SetProcessDynamicEHContinuationTargets(SafeHandle Process, Span<win32.System.SystemServices.PROCESS_DYNAMIC_EH_CONTINUATION_TARGET> Targets)
        {
            bool ProcessAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.PROCESS_DYNAMIC_EH_CONTINUATION_TARGET*TargetsLocal = Targets)
                {
                    win32.System.SystemServices.HANDLE ProcessLocal;
                    if (Process is object)
                    {
                        Process.DangerousAddRef(ref ProcessAddRef);
                        ProcessLocal = (win32.System.SystemServices.HANDLE)Process.DangerousGetHandle();
                    }
                    else
                        ProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetProcessDynamicEHContinuationTargets(ProcessLocal, (ushort)Targets.Length, TargetsLocal);
                    return __result;
                }
            }
            finally
            {
                if (ProcessAddRef)
                    Process.DangerousRelease();
            }
        }

        /// <summary>Sets dynamic exception handling continuation targets for the specified process.</summary>
        /// <param name = "Process">
        /// <para>A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessdynamicehcontinuationtargets#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "NumberOfTargets">Supplies the number of dynamic exception handling continuation targets to set.</param>
        /// <param name = "Targets">A pointer to an array of dynamic exception handling continuation targets. For more information on this structure, see <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_dynamic_eh_continuation_target">PROCESS_DYNAMIC_EH_CONTINUATION_TARGET</a>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Note that even if the function fails, a portion of the supplied continuation targets may have been successfully processed. The caller needs to check the flags in each individual continuation target specified via <i>Targets</i> to determine if it was successfully processed.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessdynamicehcontinuationtargets">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetProcessDynamicEHContinuationTargets(win32.System.SystemServices.HANDLE Process, ushort NumberOfTargets, win32.System.SystemServices.PROCESS_DYNAMIC_EH_CONTINUATION_TARGET*Targets);
        /// <inheritdoc cref = "SetProcessAffinityUpdateMode(win32.System.SystemServices.HANDLE, win32.System.Threading.PROCESS_AFFINITY_AUTO_UPDATE_FLAGS)"/>
        internal static unsafe bool SetProcessAffinityUpdateMode(SafeHandle hProcess, win32.System.Threading.PROCESS_AFFINITY_AUTO_UPDATE_FLAGS dwFlags)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetProcessAffinityUpdateMode(hProcessLocal, dwFlags);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Sets the affinity update mode of the specified process.</summary>
        /// <param name = "hProcess">A handle to the process. This handle must be returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess">GetCurrentProcess</a> function.</param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessaffinityupdatemode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetProcessAffinityUpdateMode(win32.System.SystemServices.HANDLE hProcess, win32.System.Threading.PROCESS_AFFINITY_AUTO_UPDATE_FLAGS dwFlags);
        /// <inheritdoc cref = "QueryProcessAffinityUpdateMode(win32.System.SystemServices.HANDLE, win32.System.Threading.PROCESS_AFFINITY_AUTO_UPDATE_FLAGS*)"/>
        internal static unsafe bool QueryProcessAffinityUpdateMode(SafeHandle hProcess, win32.System.Threading.PROCESS_AFFINITY_AUTO_UPDATE_FLAGS*lpdwFlags)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.QueryProcessAffinityUpdateMode(hProcessLocal, lpdwFlags);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the affinity update mode of the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-queryprocessaffinityupdatemode#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpdwFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-queryprocessaffinityupdatemode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool QueryProcessAffinityUpdateMode(win32.System.SystemServices.HANDLE hProcess, [Optional] win32.System.Threading.PROCESS_AFFINITY_AUTO_UPDATE_FLAGS*lpdwFlags);
        /// <inheritdoc cref = "CreateRemoteThreadEx(win32.System.SystemServices.HANDLE, win32.System.SystemServices.SECURITY_ATTRIBUTES*, nuint, delegate *unmanaged[Stdcall]{void *, uint}, void *, uint, win32.System.Threading.LPPROC_THREAD_ATTRIBUTE_LIST, uint *)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateRemoteThreadEx(SafeHandle hProcess, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpThreadAttributes, nuint dwStackSize, delegate *unmanaged[Stdcall]<void *, uint>lpStartAddress, void *lpParameter, uint dwCreationFlags, win32.System.Threading.LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, uint *lpThreadId)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpThreadAttributesLocal = lpThreadAttributes.HasValue ? lpThreadAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateRemoteThreadEx(hProcessLocal, lpThreadAttributes.HasValue ? &lpThreadAttributesLocal : null, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpAttributeList, lpThreadId);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights. In Windows 10, version 1607, your code must obtain these access rights for the new handle. However, starting in Windows 10, version 1703, if the new handle is entitled to these access rights, the system obtains them for you. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethreadex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpThreadAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If <i>lpThreadAttributes</i> is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethreadex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwStackSize">
        /// <para>The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethreadex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpStartAddress">
        /// <para>A pointer to the application-defined function of type <b>LPTHREAD_START_ROUTINE</b> to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethreadex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpParameter">A pointer to a variable to be passed to the thread function pointed to by <i>lpStartAddress</i>. This parameter can be NULL.</param>
        /// <param name = "dwCreationFlags">
        /// <para>The flags that control the creation of the thread.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethreadex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpAttributeList">An attribute list that contains additional parameters for the new thread. This list is created by the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist">InitializeProcThreadAttributeList</a> function.</param>
        /// <param name = "lpThreadId">
        /// <para>A pointer to a variable that receives the thread identifier.</para>
        /// <para>If this parameter is NULL, the thread identifier is not returned.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethreadex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the new thread.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-createremotethreadex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateRemoteThreadEx(win32.System.SystemServices.HANDLE hProcess, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpThreadAttributes, nuint dwStackSize, delegate *unmanaged[Stdcall]<void *, uint>lpStartAddress, [Optional] void *lpParameter, uint dwCreationFlags, win32.System.Threading.LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, [Optional] uint *lpThreadId);
        /// <inheritdoc cref = "GetCurrentThreadStackLimits(nuint*, nuint*)"/>
        internal static unsafe void GetCurrentThreadStackLimits(out nuint LowLimit, out nuint HighLimit)
        {
            fixed (nuint*HighLimitLocal = &HighLimit)
            {
                fixed (nuint*LowLimitLocal = &LowLimit)
                {
                    Kernel32.GetCurrentThreadStackLimits(LowLimitLocal, HighLimitLocal);
                }
            }
        }

        /// <summary>Retrieves the boundaries of the stack that was allocated by the system for the current thread.</summary>
        /// <param name = "LowLimit">A pointer variable that receives the lower boundary of the current thread stack.</param>
        /// <param name = "HighLimit">A pointer variable that receives the upper boundary of the current thread stack.</param>
        /// <remarks>
        /// <para>It is possible for user-mode code to execute in stack memory that is outside the region allocated by the system when the thread was created. Callers can use the <b>GetCurrentThreadStackLimits</b> function to verify that the current stack pointer is within the returned limits.</para>
        /// <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0602. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getcurrentthreadstacklimits#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void GetCurrentThreadStackLimits(nuint*LowLimit, nuint*HighLimit);
        /// <inheritdoc cref = "GetProcessMitigationPolicy(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PROCESS_MITIGATION_POLICY, void *, nuint)"/>
        internal static unsafe bool GetProcessMitigationPolicy(SafeHandle hProcess, win32.System.SystemServices.PROCESS_MITIGATION_POLICY MitigationPolicy, void *lpBuffer, nuint dwLength)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.GetProcessMitigationPolicy(hProcessLocal, MitigationPolicy, lpBuffer, dwLength);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves mitigation policy settings for the calling process.</summary>
        /// <param name = "hProcess">A handle to the process. This handle must have the PROCESS_QUERY_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
        /// <param name = "MitigationPolicy"></param>
        /// <param name = "lpBuffer">
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessDEPPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-process_mitigation_dep_policy">PROCESS_MITIGATION_DEP_POLICY</a> structure that receives the DEP policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessASLRPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-process_mitigation_aslr_policy">PROCESS_MITIGATION_ASLR_POLICY</a> structure that receives the ASLR policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessDynamicCodePolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-process_mitigation_dynamic_code_policy">PROCESS_MITIGATION_DYNAMIC_CODE_POLICY</a> structure that receives the dynamic code policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessStrictHandleCheckPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_strict_handle_check_policy">PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY</a> structure that specifies the handle check policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSystemCallDisablePolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_system_call_disable_policy">PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY</a> structure that specifies the system call disable policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessMitigationOptionsMask</b>, this parameter points to a <b>ULONG64</b> bit vector for the mask or a two-element array of <b>ULONG64</b> bit vectors.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessExtensionPointDisablePolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_extension_point_disable_policy">PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY</a> structure that specifies the extension point disable policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessControlFlowGuardPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_control_flow_guard_policy">PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY</a> structure that specifies the CFG policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSignaturePolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_binary_signature_policy">PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY</a> structure that receives the signature policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessFontDisablePolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-process_mitigation_font_disable_policy">PROCESS_MITIGATION_FONT_DISABLE_POLICY</a> structure that receives the policy flags for font loading.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-process_mitigation_image_load_policy">PROCESS_MITIGATION_IMAGE_LOAD_POLICY</a> structure that receives the policy flags for image loading.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessUserShadowStackPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_user_shadow_stack_policy">PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY</a> structure that receives the policy flags for user-mode Hardware-enforced Stack Protection.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessmitigationpolicy#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwLength">The size of <i>lpBuffer</i>, in bytes.</param>
        /// <returns>If the function succeeds, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessmitigationpolicy">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessMitigationPolicy(win32.System.SystemServices.HANDLE hProcess, win32.System.SystemServices.PROCESS_MITIGATION_POLICY MitigationPolicy, void *lpBuffer, nuint dwLength);
        /// <summary>Sets a mitigation policy for the calling process. Mitigation policies enable a process to harden itself against various types of attacks.</summary>
        /// <param name = "MitigationPolicy"></param>
        /// <param name = "lpBuffer">
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessDEPPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-process_mitigation_dep_policy">PROCESS_MITIGATION_DEP_POLICY</a> structure that specifies the DEP policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessASLRPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-process_mitigation_aslr_policy">PROCESS_MITIGATION_ASLR_POLICY</a> structure that specifies the ASLR policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-process_mitigation_image_load_policy">PROCESS_MITIGATION_IMAGE_LOAD_POLICY</a> structure that receives the policy flags for image loading.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessStrictHandleCheckPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_strict_handle_check_policy">PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY</a> structure that specifies the handle check policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSystemCallDisablePolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_system_call_disable_policy">PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY</a> structure that specifies the system call disable policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessMitigationOptionsMask</b>, this parameter points to a <b>ULONG64</b> bit vector for the mask, or to accommodate more than 64 bits, a two-element array of <b>ULONG64</b> bit vectors.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessExtensionPointDisablePolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_extension_point_disable_policy">PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY</a> structure that specifies the extension point disable policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessControlFlowGuardPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_control_flow_guard_policy">PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY</a> structure that specifies the CFG policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSignaturePolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_binary_signature_policy">PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY</a> structure that specifies the signature policy flags.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessFontDisablePolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-process_mitigation_font_disable_policy">PROCESS_MITIGATION_FONT_DISABLE_POLICY</a> structure that specifies the policy flags for font loading.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-process_mitigation_image_load_policy">PROCESS_MITIGATION_IMAGE_LOAD_POLICY</a> structure that specifies the policy flags for image loading.</para>
        /// <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessUserShadowStackPolicy</b>, this parameter points to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-process_mitigation_user_shadow_stack_policy">PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY</a> structure that specifies the policy flags for user-mode Hardware-enforced Stack Protection.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwLength">The size of <i>lpBuffer</i>, in bytes.</param>
        /// <returns>If the function succeeds, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetProcessMitigationPolicy(win32.System.SystemServices.PROCESS_MITIGATION_POLICY MitigationPolicy, void *lpBuffer, nuint dwLength);
        /// <inheritdoc cref = "GetThreadTimes(win32.System.SystemServices.HANDLE, global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe bool GetThreadTimes(SafeHandle hThread, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpCreationTime, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpExitTime, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpKernelTime, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpUserTime)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpUserTimeLocal = &lpUserTime)
                {
                    fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpKernelTimeLocal = &lpKernelTime)
                    {
                        fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpExitTimeLocal = &lpExitTime)
                        {
                            fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpCreationTimeLocal = &lpCreationTime)
                            {
                                win32.System.SystemServices.HANDLE hThreadLocal;
                                if (hThread is object)
                                {
                                    hThread.DangerousAddRef(ref hThreadAddRef);
                                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                                }
                                else
                                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                                bool __result = Kernel32.GetThreadTimes(hThreadLocal, lpCreationTimeLocal, lpExitTimeLocal, lpKernelTimeLocal, lpUserTimeLocal);
                                return __result;
                            }
                        }
                    }
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Retrieves timing information for the specified thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread whose timing information is sought. The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadtimes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCreationTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the creation time of the thread.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadtimes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpExitTime">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the exit time of the thread. If the thread has not exited, the content of this structure is undefined.</param>
        /// <param name = "lpKernelTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the amount of time that the thread has executed in kernel mode.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadtimes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpUserTime">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the amount of time that the thread has executed in user mode.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadtimes">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetThreadTimes(win32.System.SystemServices.HANDLE hThread, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpCreationTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpExitTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpKernelTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpUserTime);
        /// <inheritdoc cref = "OpenProcess(win32.System.Threading.PROCESS_ACCESS_RIGHTS, bool, uint)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle OpenProcess_SafeHandle(win32.System.Threading.PROCESS_ACCESS_RIGHTS dwDesiredAccess, bool bInheritHandle, uint dwProcessId)
        {
            win32.System.SystemServices.HANDLE __result = Kernel32.OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId);
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        /// <summary>Opens an existing local process object.</summary>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the process object. This access right is checked against the  security descriptor for the process. This parameter can be one or more of the <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">process access rights</a>.</para>
        /// <para>If the caller has enabled the SeDebugPrivilege privilege, the requested access is  granted regardless of the contents of the security descriptor.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-openprocess#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInheritHandle">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name = "dwProcessId">
        /// <para>The identifier of the local process to be opened.</para>
        /// <para>If the specified process is the System Idle Process (0x00000000), the function fails and the last error code is `ERROR_INVALID_PARAMETER`. If the specified process is the System process or one of the Client Server Run-Time Subsystem (CSRSS) processes, this function fails and the last error code is `ERROR_ACCESS_DENIED` because their access restrictions prevent user-level code from opening them.</para>
        /// <para>If you are using <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocessid">GetCurrentProcessId</a> as an argument to this function, consider using <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess">GetCurrentProcess</a> instead of OpenProcess, for improved performance.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-openprocess#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is an open handle to the specified process.</para>
        /// <para>If the function fails, the return value is NULL. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-openprocess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE OpenProcess(win32.System.Threading.PROCESS_ACCESS_RIGHTS dwDesiredAccess, bool bInheritHandle, uint dwProcessId);
        /// <summary>Determines whether the specified processor feature is supported by the current computer.</summary>
        /// <param name = "ProcessorFeature"></param>
        /// <returns>
        /// <para>If the feature is supported, the return value is a nonzero value.</para>
        /// <para>If the feature is not supported, the return value is zero.</para>
        /// <para>If the HAL does not support detection of the feature, whether or not the hardware supports the feature, the return value is also zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-isprocessorfeaturepresent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool IsProcessorFeaturePresent(win32.System.Threading.PROCESSOR_FEATURE_ID ProcessorFeature);
        /// <inheritdoc cref = "GetProcessHandleCount(win32.System.SystemServices.HANDLE, uint *)"/>
        internal static unsafe bool GetProcessHandleCount(SafeHandle hProcess, out uint pdwHandleCount)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *pdwHandleCountLocal = &pdwHandleCount)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetProcessHandleCount(hProcessLocal, pdwHandleCountLocal);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the number of open handles that belong to the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process whose handle count is being requested.  The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the PROCESS_QUERY_INFORMATION access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocesshandlecount#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pdwHandleCount">A pointer to a variable that receives the number of open handles that belong to the specified process.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error  information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocesshandlecount">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessHandleCount(win32.System.SystemServices.HANDLE hProcess, uint *pdwHandleCount);
        /// <summary>Retrieves the number of the processor the current thread was running on during the call to this function.</summary>
        /// <returns>The function returns the current processor number.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getcurrentprocessornumber">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetCurrentProcessorNumber();
        /// <inheritdoc cref = "SetThreadIdealProcessorEx(win32.System.SystemServices.HANDLE, win32.System.Kernel.PROCESSOR_NUMBER*, win32.System.Kernel.PROCESSOR_NUMBER*)"/>
        internal static unsafe bool SetThreadIdealProcessorEx(SafeHandle hThread, in win32.System.Kernel.PROCESSOR_NUMBER lpIdealProcessor, win32.System.Kernel.PROCESSOR_NUMBER*lpPreviousIdealProcessor)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (win32.System.Kernel.PROCESSOR_NUMBER*lpIdealProcessorLocal = &lpIdealProcessor)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetThreadIdealProcessorEx(hThreadLocal, lpIdealProcessorLocal, lpPreviousIdealProcessor);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Sets the ideal processor for the specified thread and optionally retrieves the previous ideal processor.</summary>
        /// <param name = "hThread">A handle to the thread for which to set the ideal processor. This handle must have been created with the THREAD_SET_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
        /// <param name = "lpIdealProcessor">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-processor_number">PROCESSOR_NUMBER</a> structure that specifies the processor number of the desired ideal processor.</param>
        /// <param name = "lpPreviousIdealProcessor">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-processor_number">PROCESSOR_NUMBER</a> structure to receive the previous ideal processor. This parameter can point to the same memory location as the <i>lpIdealProcessor</i> parameter. This parameter can be NULL if the previous ideal processor is not required.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, it returns zero. To get extended error information, use <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadidealprocessorex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetThreadIdealProcessorEx(win32.System.SystemServices.HANDLE hThread, win32.System.Kernel.PROCESSOR_NUMBER*lpIdealProcessor, [Optional] win32.System.Kernel.PROCESSOR_NUMBER*lpPreviousIdealProcessor);
        /// <inheritdoc cref = "GetThreadIdealProcessorEx(win32.System.SystemServices.HANDLE, win32.System.Kernel.PROCESSOR_NUMBER*)"/>
        internal static unsafe bool GetThreadIdealProcessorEx(SafeHandle hThread, out win32.System.Kernel.PROCESSOR_NUMBER lpIdealProcessor)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (win32.System.Kernel.PROCESSOR_NUMBER*lpIdealProcessorLocal = &lpIdealProcessor)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetThreadIdealProcessorEx(hThreadLocal, lpIdealProcessorLocal);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Retrieves the processor number of the ideal processor for the specified thread.</summary>
        /// <param name = "hThread">A handle to the thread for which to retrieve the ideal processor. This handle must have been created with the THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
        /// <param name = "lpIdealProcessor">Points to <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-processor_number">PROCESSOR_NUMBER</a> structure to receive the number of the ideal processor.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, it returns zero. To get extended error information, use <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadidealprocessorex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetThreadIdealProcessorEx(win32.System.SystemServices.HANDLE hThread, win32.System.Kernel.PROCESSOR_NUMBER*lpIdealProcessor);
        /// <inheritdoc cref = "GetCurrentProcessorNumberEx(win32.System.Kernel.PROCESSOR_NUMBER*)"/>
        internal static unsafe void GetCurrentProcessorNumberEx(out win32.System.Kernel.PROCESSOR_NUMBER ProcNumber)
        {
            fixed (win32.System.Kernel.PROCESSOR_NUMBER*ProcNumberLocal = &ProcNumber)
            {
                Kernel32.GetCurrentProcessorNumberEx(ProcNumberLocal);
            }
        }

        /// <summary>Retrieves the processor group and number of the logical processor in which the calling thread is running.</summary>
        /// <param name = "ProcNumber">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-processor_number">PROCESSOR_NUMBER</a> structure that receives the processor group to which the logical processor is assigned and the number of the logical processor within its group.</param>
        /// <returns>If the function succeeds, the <i>ProcNumber</i> parameter contains the group and processor number of the processor on which the calling thread is running.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getcurrentprocessornumberex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void GetCurrentProcessorNumberEx(win32.System.Kernel.PROCESSOR_NUMBER*ProcNumber);
        /// <inheritdoc cref = "GetProcessPriorityBoost(win32.System.SystemServices.HANDLE, bool *)"/>
        internal static unsafe bool GetProcessPriorityBoost(SafeHandle hProcess, out bool pDisablePriorityBoost)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (bool *pDisablePriorityBoostLocal = &pDisablePriorityBoost)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetProcessPriorityBoost(hProcessLocal, pDisablePriorityBoostLocal);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the priority boost control state of the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process. This handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocesspriorityboost#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pDisablePriorityBoost">A pointer to a variable that receives the priority boost control state. A value of TRUE indicates that dynamic boosting is disabled. A value of FALSE indicates normal behavior.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. In that case, the variable pointed to by the <i>pDisablePriorityBoost</i> parameter receives the priority boost control state.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocesspriorityboost">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessPriorityBoost(win32.System.SystemServices.HANDLE hProcess, bool *pDisablePriorityBoost);
        /// <inheritdoc cref = "SetProcessPriorityBoost(win32.System.SystemServices.HANDLE, bool)"/>
        internal static unsafe bool SetProcessPriorityBoost(SafeHandle hProcess, bool bDisablePriorityBoost)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetProcessPriorityBoost(hProcessLocal, bDisablePriorityBoost);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Disables or enables the ability of the system to temporarily boost the priority of the threads of the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process. This handle must have the PROCESS_SET_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocesspriorityboost#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bDisablePriorityBoost">If this parameter is TRUE, dynamic boosting is disabled. If the parameter is FALSE, dynamic boosting is enabled.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocesspriorityboost">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetProcessPriorityBoost(win32.System.SystemServices.HANDLE hProcess, bool bDisablePriorityBoost);
        /// <inheritdoc cref = "GetThreadIOPendingFlag(win32.System.SystemServices.HANDLE, bool *)"/>
        internal static unsafe bool GetThreadIOPendingFlag(SafeHandle hThread, out bool lpIOIsPending)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (bool *lpIOIsPendingLocal = &lpIOIsPending)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetThreadIOPendingFlag(hThreadLocal, lpIOIsPendingLocal);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Determines whether a specified thread has any I/O requests pending.</summary>
        /// <param name = "hThread">A handle to the thread in question. This handle must have been created with the THREAD_QUERY_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
        /// <param name = "lpIOIsPending">A pointer to a  variable which the function sets to TRUE if the specified thread has one or more I/O requests pending, or to FALSE otherwise.</param>
        /// <returns>
        /// <para>If the  function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadiopendingflag">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetThreadIOPendingFlag(win32.System.SystemServices.HANDLE hThread, bool *lpIOIsPending);
        /// <summary>Retrieves system timing information. On a multiprocessor system, the values returned are the sum of the designated times across all processors.</summary>
        /// <param name = "lpIdleTime">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the amount of time that the system has been idle.</param>
        /// <param name = "lpKernelTime">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the amount of time that the system has spent executing in Kernel mode (including all threads in all processes, on all processors). This time value also includes the amount of time the system has been idle.</param>
        /// <param name = "lpUserTime">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the amount of time that the system has spent executing in User mode (including all threads in all processes, on all processors).</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error  information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getsystemtimes">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetSystemTimes([Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*lpIdleTime, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*lpKernelTime, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*lpUserTime);
        /// <inheritdoc cref = "GetThreadInformation(win32.System.SystemServices.HANDLE, win32.System.Threading.THREAD_INFORMATION_CLASS, void *, uint)"/>
        internal static unsafe bool GetThreadInformation(SafeHandle hThread, win32.System.Threading.THREAD_INFORMATION_CLASS ThreadInformationClass, void *ThreadInformation, uint ThreadInformationSize)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.GetThreadInformation(hThreadLocal, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the specified thread.</summary>
        /// <param name = "hThread">A handle to the thread. The handle must have THREAD_QUERY_INFORMATION access rights. For more information, see  <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
        /// <param name = "ThreadInformationClass">The class of information to retrieve. The only supported values are <b>ThreadMemoryPriority</b> and <b>ThreadPowerThrottling</b>.</param>
        /// <param name = "ThreadInformation">
        /// <para>Pointer to a structure to receive the type of information specified by the <i>ThreadInformationClass</i> parameter.</para>
        /// <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must point to a <b>MEMORY_PRIORITY_INFORMATION</b> structure.</para>
        /// <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadPowerThrottling</b>, this parameter must point to a <b>THREAD_POWER_THROTTLING_STATE</b> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ThreadInformationSize">
        /// <para>The size in bytes of the structure specified by the <i>ThreadInformation</i> parameter.</para>
        /// <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must be <c>sizeof(MEMORY_PRIORITY_INFORMATION)</c>.</para>
        /// <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadPowerThrottling</b>, this parameter must be <c>sizeof(THREAD_POWER_THROTTLING_STATE)</c>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreadinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetThreadInformation(win32.System.SystemServices.HANDLE hThread, win32.System.Threading.THREAD_INFORMATION_CLASS ThreadInformationClass, void *ThreadInformation, uint ThreadInformationSize);
        /// <inheritdoc cref = "SetThreadInformation(win32.System.SystemServices.HANDLE, win32.System.Threading.THREAD_INFORMATION_CLASS, void *, uint)"/>
        internal static unsafe bool SetThreadInformation(SafeHandle hThread, win32.System.Threading.THREAD_INFORMATION_CLASS ThreadInformationClass, void *ThreadInformation, uint ThreadInformationSize)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetThreadInformation(hThreadLocal, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Sets information for the specified thread.</summary>
        /// <param name = "hThread">A handle to the thread. The handle must have THREAD_SET_INFORMATION access right. For more information, see  <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
        /// <param name = "ThreadInformationClass">The class of information to set. The only supported values are <b>ThreadMemoryPriority</b> and <b>ThreadPowerThrottling</b>.</param>
        /// <param name = "ThreadInformation">
        /// <para>Pointer to a structure that contains the type of information specified by the <i>ThreadInformationClass</i> parameter.</para>
        /// <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must point to a <b>MEMORY_PRIORITY_INFORMATION</b> structure.</para>
        /// <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadPowerThrottling</b>, this parameter must point to a <b>THREAD_POWER_THROTTLING_STATE</b> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ThreadInformationSize">
        /// <para>The size in bytes of the structure specified by the <i>ThreadInformation</i> parameter.</para>
        /// <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must be <c>sizeof(MEMORY_PRIORITY_INFORMATION)</c>.</para>
        /// <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadPowerThrottling</b>, this parameter must be <c>sizeof(THREAD_POWER_THROTTLING_STATE)</c>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetThreadInformation(win32.System.SystemServices.HANDLE hThread, win32.System.Threading.THREAD_INFORMATION_CLASS ThreadInformationClass, void *ThreadInformation, uint ThreadInformationSize);
        /// <inheritdoc cref = "IsProcessCritical(win32.System.SystemServices.HANDLE, bool *)"/>
        internal static unsafe bool IsProcessCritical(SafeHandle hProcess, out bool Critical)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (bool *CriticalLocal = &Critical)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.IsProcessCritical(hProcessLocal, CriticalLocal);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Determines whether the specified process is considered critical.</summary>
        /// <param name = "hProcess">A handle to the process to query. The process must have been          opened with <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access.</param>
        /// <param name = "Critical">A pointer to the <b>BOOL</b> value this function will use to indicate whether the process          is considered critical.</param>
        /// <returns>This routine returns FALSE on failure. Any other value indicates success.      Call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to query for the specific error reason on failure.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-isprocesscritical">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool IsProcessCritical(win32.System.SystemServices.HANDLE hProcess, bool *Critical);
        /// <inheritdoc cref = "SetProtectedPolicy(global::System.Guid*, nuint, nuint*)"/>
        internal static unsafe bool SetProtectedPolicy(in global::System.Guid PolicyGuid, nuint PolicyValue, nuint*OldPolicyValue)
        {
            fixed (global::System.Guid*PolicyGuidLocal = &PolicyGuid)
            {
                bool __result = Kernel32.SetProtectedPolicy(PolicyGuidLocal, PolicyValue, OldPolicyValue);
                return __result;
            }
        }

        /// <summary>Sets a protected policy.</summary>
        /// <param name = "PolicyGuid">The globally-unique identifier of the policy to set.</param>
        /// <param name = "PolicyValue">The value to set the policy to.</param>
        /// <param name = "OldPolicyValue">Optionally receives the original value that was associated with the supplied policy.</param>
        /// <returns>True if the function succeeds; otherwise, false. To retrieve error values for this function, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprotectedpolicy">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetProtectedPolicy(global::System.Guid*PolicyGuid, nuint PolicyValue, [Optional] nuint*OldPolicyValue);
        /// <inheritdoc cref = "QueryProtectedPolicy(global::System.Guid*, nuint*)"/>
        internal static unsafe bool QueryProtectedPolicy(in global::System.Guid PolicyGuid, out nuint PolicyValue)
        {
            fixed (nuint*PolicyValueLocal = &PolicyValue)
            {
                fixed (global::System.Guid*PolicyGuidLocal = &PolicyGuid)
                {
                    bool __result = Kernel32.QueryProtectedPolicy(PolicyGuidLocal, PolicyValueLocal);
                    return __result;
                }
            }
        }

        /// <summary>Queries the value associated with a protected policy.</summary>
        /// <param name = "PolicyGuid">The globally-unique identifier of the policy to query.</param>
        /// <param name = "PolicyValue">Receives the value that the supplied policy is set to.</param>
        /// <returns>True if the function succeeds; otherwise, false.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-queryprotectedpolicy">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool QueryProtectedPolicy(global::System.Guid*PolicyGuid, nuint*PolicyValue);
        /// <inheritdoc cref = "SetThreadIdealProcessor(win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe uint SetThreadIdealProcessor(SafeHandle hThread, uint dwIdealProcessor)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.SetThreadIdealProcessor(hThreadLocal, dwIdealProcessor);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Sets a preferred processor for a thread. The system schedules threads on their preferred processors whenever possible.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread whose preferred processor is to be set. The handle must have the THREAD_SET_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadidealprocessor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwIdealProcessor">The number of the preferred processor for the thread. This value is zero-based. If this parameter is MAXIMUM_PROCESSORS, the function returns the current ideal processor without changing it.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the previous preferred processor.</para>
        /// <para>If the function fails, the return value is (DWORD) – 1. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreadidealprocessor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint SetThreadIdealProcessor(win32.System.SystemServices.HANDLE hThread, uint dwIdealProcessor);
        /// <inheritdoc cref = "SetProcessInformation(win32.System.SystemServices.HANDLE, win32.System.Threading.PROCESS_INFORMATION_CLASS, void *, uint)"/>
        internal static unsafe bool SetProcessInformation(SafeHandle hProcess, win32.System.Threading.PROCESS_INFORMATION_CLASS ProcessInformationClass, void *ProcessInformation, uint ProcessInformationSize)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetProcessInformation(hProcessLocal, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Sets information for the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ProcessInformationClass">A member of the [PROCESS_INFORMATION_CLASS](./ne-processthreadsapi-process_information_class.md) enumeration specifying the kind of information to set.</param>
        /// <param name = "ProcessInformation">
        /// <para>Pointer to an object that contains the type of information specified by the <i>ProcessInformationClass</i> parameter.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessMemoryPriority</b>, this parameter must point to a <a href = "https://docs.microsoft.com/windows/win32/api/processthreadsapi/ns-processthreadsapi-memory_priority_information">MEMORY_PRIORITY_INFORMATION</a> structure.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessPowerThrottling</b>, this parameter must point to a <a href = "https://docs.microsoft.com/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_power_throttling_state">PROCESS_POWER_THROTTLING_STATE</a> structure.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessLeapSecondInfo</b>, this parameter must point to a <a href = "https://docs.microsoft.com/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_leap_second_info">PROCESS_LEAP_SECOND_INFO</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ProcessInformationSize">
        /// <para>The size in bytes of the structure specified by the <i>ProcessInformation</i> parameter.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessMemoryPriority</b>, this parameter must be <c>sizeof(MEMORY_PRIORITY_INFORMATION)</c>.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessPowerThrottling</b>, this parameter must be <c>sizeof(PROCESS_POWER_THROTTLING_STATE)</c>.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessLeapSecondInfo</b>, this parameter must be <c>sizeof(PROCESS_LEAP_SECOND_INFO)</c>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setprocessinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetProcessInformation(win32.System.SystemServices.HANDLE hProcess, win32.System.Threading.PROCESS_INFORMATION_CLASS ProcessInformationClass, void *ProcessInformation, uint ProcessInformationSize);
        /// <inheritdoc cref = "GetProcessInformation(win32.System.SystemServices.HANDLE, win32.System.Threading.PROCESS_INFORMATION_CLASS, void *, uint)"/>
        internal static unsafe bool GetProcessInformation(SafeHandle hProcess, win32.System.Threading.PROCESS_INFORMATION_CLASS ProcessInformationClass, void *ProcessInformation, uint ProcessInformationSize)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.GetProcessInformation(hProcessLocal, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ProcessInformationClass">A member of the [PROCESS_INFORMATION_CLASS](./ne-processthreadsapi-process_information_class.md) enumeration specifying the kind of information to retrieve.</param>
        /// <param name = "ProcessInformation">
        /// <para>Pointer to an object to receive the type of information specified by the <i>ProcessInformationClass</i> parameter.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessMemoryPriority</b>, this parameter must point to a <a href = "https://docs.microsoft.com/windows/win32/api/processthreadsapi/ns-processthreadsapi-memory_priority_information">MEMORY_PRIORITY_INFORMATION</a> structure.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessPowerThrottling</b>, this parameter must point to a <a href = "https://docs.microsoft.com/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_power_throttling_state">PROCESS_POWER_THROTTLING_STATE</a> structure.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessProtectionLevelInfo</b>, this parameter must point to a <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/ns-processthreadsapi-process_protection_level_information">PROCESS_PROTECTION_LEVEL_INFORMATION</a> structure.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessLeapSecondInfo</b>, this parameter must point to a <a href = "../processthreadsapi/ns-processthreadsapi-process_leap_second_info.md">PROCESS_LEAP_SECOND_INFO</a> structure.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessAppMemoryInfo</b>, this parameter must point to a <a href = "https://docs.microsoft.com/windows/win32/api/processthreadsapi/ns-processthreadsapi-app_memory_information">APP_MEMORY_INFORMATION</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ProcessInformationSize">
        /// <para>The size in bytes of the structure specified by the <i>ProcessInformation</i> parameter.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessMemoryPriority</b>, this parameter must be <c>sizeof(MEMORY_PRIORITY_INFORMATION)</c>.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessPowerThrottling</b>, this parameter must be <c>sizeof(PROCESS_POWER_THROTTLING_STATE)</c>.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessProtectionLevelInfo</b>, this parameter must be <c>sizeof(PROCESS_PROTECTION_LEVEL_INFORMATION)</c>.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessLeapSecondInfo</b>, this parameter must be <c>sizeof(PROCESS_LEAP_SECOND_INFO)</c>.</para>
        /// <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessAppMemoryInfo</b>, this parameter must be <c>sizeof(APP_MEMORY_INFORMATION)</c>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessInformation(win32.System.SystemServices.HANDLE hProcess, win32.System.Threading.PROCESS_INFORMATION_CLASS ProcessInformationClass, void *ProcessInformation, uint ProcessInformationSize);
        /// <inheritdoc cref = "GetSystemCpuSetInformation(win32.System.SystemServices.SYSTEM_CPU_SET_INFORMATION*, uint, uint *, win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe bool GetSystemCpuSetInformation(win32.System.SystemServices.SYSTEM_CPU_SET_INFORMATION*Information, uint BufferLength, out uint ReturnedLength, SafeHandle Process, uint Flags)
        {
            bool ProcessAddRef = false;
            try
            {
                fixed (uint *ReturnedLengthLocal = &ReturnedLength)
                {
                    win32.System.SystemServices.HANDLE ProcessLocal;
                    if (Process is object)
                    {
                        Process.DangerousAddRef(ref ProcessAddRef);
                        ProcessLocal = (win32.System.SystemServices.HANDLE)Process.DangerousGetHandle();
                    }
                    else
                        ProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetSystemCpuSetInformation(Information, BufferLength, ReturnedLengthLocal, ProcessLocal, Flags);
                    return __result;
                }
            }
            finally
            {
                if (ProcessAddRef)
                    Process.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetSystemCpuSetInformation([Optional] win32.System.SystemServices.SYSTEM_CPU_SET_INFORMATION*Information, uint BufferLength, uint *ReturnedLength, win32.System.SystemServices.HANDLE Process, uint Flags);
        /// <inheritdoc cref = "GetProcessDefaultCpuSets(win32.System.SystemServices.HANDLE, uint *, uint, uint *)"/>
        internal static unsafe bool GetProcessDefaultCpuSets(SafeHandle Process, Span<uint> CpuSetIds, out uint RequiredIdCount)
        {
            bool ProcessAddRef = false;
            try
            {
                fixed (uint *RequiredIdCountLocal = &RequiredIdCount)
                {
                    fixed (uint *CpuSetIdsLocal = CpuSetIds)
                    {
                        win32.System.SystemServices.HANDLE ProcessLocal;
                        if (Process is object)
                        {
                            Process.DangerousAddRef(ref ProcessAddRef);
                            ProcessLocal = (win32.System.SystemServices.HANDLE)Process.DangerousGetHandle();
                        }
                        else
                            ProcessLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.GetProcessDefaultCpuSets(ProcessLocal, CpuSetIdsLocal, (uint)CpuSetIds.Length, RequiredIdCountLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (ProcessAddRef)
                    Process.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetProcessDefaultCpuSets(win32.System.SystemServices.HANDLE Process, [Optional] uint *CpuSetIds, uint CpuSetIdCount, uint *RequiredIdCount);
        /// <inheritdoc cref = "SetProcessDefaultCpuSets(win32.System.SystemServices.HANDLE, uint *, uint)"/>
        internal static unsafe bool SetProcessDefaultCpuSets(SafeHandle Process, ReadOnlySpan<uint> CpuSetIds)
        {
            bool ProcessAddRef = false;
            try
            {
                fixed (uint *CpuSetIdsLocal = CpuSetIds)
                {
                    win32.System.SystemServices.HANDLE ProcessLocal;
                    if (Process is object)
                    {
                        Process.DangerousAddRef(ref ProcessAddRef);
                        ProcessLocal = (win32.System.SystemServices.HANDLE)Process.DangerousGetHandle();
                    }
                    else
                        ProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetProcessDefaultCpuSets(ProcessLocal, CpuSetIdsLocal, (uint)CpuSetIds.Length);
                    return __result;
                }
            }
            finally
            {
                if (ProcessAddRef)
                    Process.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetProcessDefaultCpuSets(win32.System.SystemServices.HANDLE Process, [Optional] uint *CpuSetIds, uint CpuSetIdCount);
        /// <inheritdoc cref = "GetThreadSelectedCpuSets(win32.System.SystemServices.HANDLE, uint *, uint, uint *)"/>
        internal static unsafe bool GetThreadSelectedCpuSets(SafeHandle Thread, Span<uint> CpuSetIds, out uint RequiredIdCount)
        {
            bool ThreadAddRef = false;
            try
            {
                fixed (uint *RequiredIdCountLocal = &RequiredIdCount)
                {
                    fixed (uint *CpuSetIdsLocal = CpuSetIds)
                    {
                        win32.System.SystemServices.HANDLE ThreadLocal;
                        if (Thread is object)
                        {
                            Thread.DangerousAddRef(ref ThreadAddRef);
                            ThreadLocal = (win32.System.SystemServices.HANDLE)Thread.DangerousGetHandle();
                        }
                        else
                            ThreadLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.GetThreadSelectedCpuSets(ThreadLocal, CpuSetIdsLocal, (uint)CpuSetIds.Length, RequiredIdCountLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (ThreadAddRef)
                    Thread.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetThreadSelectedCpuSets(win32.System.SystemServices.HANDLE Thread, [Optional] uint *CpuSetIds, uint CpuSetIdCount, uint *RequiredIdCount);
        /// <inheritdoc cref = "SetThreadSelectedCpuSets(win32.System.SystemServices.HANDLE, uint *, uint)"/>
        internal static unsafe bool SetThreadSelectedCpuSets(SafeHandle Thread, ReadOnlySpan<uint> CpuSetIds)
        {
            bool ThreadAddRef = false;
            try
            {
                fixed (uint *CpuSetIdsLocal = CpuSetIds)
                {
                    win32.System.SystemServices.HANDLE ThreadLocal;
                    if (Thread is object)
                    {
                        Thread.DangerousAddRef(ref ThreadAddRef);
                        ThreadLocal = (win32.System.SystemServices.HANDLE)Thread.DangerousGetHandle();
                    }
                    else
                        ThreadLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetThreadSelectedCpuSets(ThreadLocal, CpuSetIdsLocal, (uint)CpuSetIds.Length);
                    return __result;
                }
            }
            finally
            {
                if (ThreadAddRef)
                    Thread.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetThreadSelectedCpuSets(win32.System.SystemServices.HANDLE Thread, uint *CpuSetIds, uint CpuSetIdCount);
        /// <inheritdoc cref = "GetProcessShutdownParameters(uint *, uint *)"/>
        internal static unsafe bool GetProcessShutdownParameters(out uint lpdwLevel, out uint lpdwFlags)
        {
            fixed (uint *lpdwFlagsLocal = &lpdwFlags)
            {
                fixed (uint *lpdwLevelLocal = &lpdwLevel)
                {
                    bool __result = Kernel32.GetProcessShutdownParameters(lpdwLevelLocal, lpdwFlagsLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves the shutdown parameters for the currently calling process.</summary>
        /// <param name = "lpdwLevel">
        /// <para>A pointer to a variable that receives the shutdown priority level. Higher levels shut down first. System level shutdown orders are reserved for system components. Higher numbers shut down first. Following are the level conventions.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessshutdownparameters#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpdwFlags">
        /// <para>A pointer to a variable that receives the shutdown flags. This parameter can be the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessshutdownparameters#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getprocessshutdownparameters">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessShutdownParameters(uint *lpdwLevel, uint *lpdwFlags);
        /// <inheritdoc cref = "SetThreadDescription(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.Com.HRESULT SetThreadDescription(SafeHandle hThread, string lpThreadDescription)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (char *lpThreadDescriptionLocal = lpThreadDescription)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.Com.HRESULT __result = Kernel32.SetThreadDescription(hThreadLocal, lpThreadDescriptionLocal);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Assigns a description to a thread.</summary>
        /// <param name = "hThread">A handle for the thread for which you want to set the description. The handle must have THREAD_SET_LIMITED_INFORMATION access.</param>
        /// <param name = "lpThreadDescription">A Unicode string that specifies the description of the thread.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the **HRESULT** that denotes a successful operation. If the function fails, the return value is an **HRESULT** that denotes the error.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-setthreaddescription">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT SetThreadDescription(win32.System.SystemServices.HANDLE hThread, win32.System.SystemServices.PCWSTR lpThreadDescription);
        /// <inheritdoc cref = "GetThreadDescription(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PWSTR*)"/>
        internal static unsafe win32.System.Com.HRESULT GetThreadDescription(SafeHandle hThread, out win32.System.SystemServices.PWSTR ppszThreadDescription)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.PWSTR*ppszThreadDescriptionLocal = &ppszThreadDescription)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.Com.HRESULT __result = Kernel32.GetThreadDescription(hThreadLocal, ppszThreadDescriptionLocal);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Retrieves the description that was assigned to a thread by calling SetThreadDescription.</summary>
        /// <param name = "hThread">A handle to the thread for which to retrieve the description. The handle must have THREAD_QUERY_LIMITED_INFORMATION access.</param>
        /// <param name = "ppszThreadDescription">A Unicode string that contains the description of the thread.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the <b>HRESULT</b> that denotes a successful operation. If the function fails, the return value is an <b>HRESULT</b> that denotes the error.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getthreaddescription">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT GetThreadDescription(win32.System.SystemServices.HANDLE hThread, win32.System.SystemServices.PWSTR*ppszThreadDescription);
        /// <summary>Queues a work item to a worker thread in the thread pool.</summary>
        /// <param name = "Function">
        /// <para>A pointer to the application-defined callback function of type <b>LPTHREAD_START_ROUTINE</b> to be executed by the thread in the thread pool. This value represents the starting address of the thread. This callback function must not call the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread">TerminateThread</a> function.</para>
        /// <para>The return value of the callback function is not used.</para>
        /// <para>For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Context">A single parameter value to be passed to the thread function.</param>
        /// <param name = "Flags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool QueueUserWorkItem(delegate *unmanaged[Stdcall]<void *, uint>Function, [Optional] void *Context, win32.System.SystemServices.WORKER_THREAD_FLAGS Flags);
        /// <inheritdoc cref = "UnregisterWaitEx(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool UnregisterWaitEx(SafeHandle WaitHandle, SafeHandle CompletionEvent)
        {
            bool WaitHandleAddRef = false;
            bool CompletionEventAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE WaitHandleLocal;
                if (WaitHandle is object)
                {
                    WaitHandle.DangerousAddRef(ref WaitHandleAddRef);
                    WaitHandleLocal = (win32.System.SystemServices.HANDLE)WaitHandle.DangerousGetHandle();
                }
                else
                    WaitHandleLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE CompletionEventLocal;
                if (CompletionEvent is object)
                {
                    CompletionEvent.DangerousAddRef(ref CompletionEventAddRef);
                    CompletionEventLocal = (win32.System.SystemServices.HANDLE)CompletionEvent.DangerousGetHandle();
                }
                else
                    CompletionEventLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.UnregisterWaitEx(WaitHandleLocal, CompletionEventLocal);
                return __result;
            }
            finally
            {
                if (WaitHandleAddRef)
                    WaitHandle.DangerousRelease();
                if (CompletionEventAddRef)
                    CompletionEvent.DangerousRelease();
            }
        }

        /// <summary>Cancels a registered wait operation issued by the RegisterWaitForSingleObject function.</summary>
        /// <param name = "WaitHandle">
        /// <para>The wait handle. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-registerwaitforsingleobject">RegisterWaitForSingleObject</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-unregisterwaitex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "CompletionEvent">
        /// <para>A handle to the event object to be signaled when the wait operation has been unregistered. This parameter can be <b>NULL</b>.</para>
        /// <para>If this parameter is <b>INVALID_HANDLE_VALUE</b>, the function waits for all callback functions to complete before returning.</para>
        /// <para>If this parameter is <b>NULL</b>, the function marks the timer for deletion and returns immediately. However, most callers should wait for the callback function to complete so they can perform any needed cleanup.</para>
        /// <para>If the caller provides this event and the function succeeds or the function fails with  <b>ERROR_IO_PENDING</b>,  do not close the event until it is signaled.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-unregisterwaitex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-unregisterwaitex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool UnregisterWaitEx(win32.System.SystemServices.HANDLE WaitHandle, win32.System.SystemServices.HANDLE CompletionEvent);
        /// <inheritdoc cref = "CreateTimerQueue()"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateTimerQueue_SafeHandle()
        {
            win32.System.SystemServices.HANDLE __result = Kernel32.CreateTimerQueue();
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        /// <summary>Creates a queue for timers.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the timer queue. This handle can be used only in functions that require a handle to a timer queue.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueue">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE CreateTimerQueue();
        /// <inheritdoc cref = "CreateTimerQueueTimer(win32.System.SystemServices.HANDLE*, win32.System.SystemServices.HANDLE, delegate *unmanaged[Stdcall]{void *, byte, void}, void *, uint, uint, win32.System.SystemServices.WORKER_THREAD_FLAGS)"/>
        internal static unsafe bool CreateTimerQueueTimer(out Microsoft.Win32.SafeHandles.SafeFileHandle phNewTimer, SafeHandle TimerQueue, delegate *unmanaged[Stdcall]<void *, byte, void>Callback, void *Parameter, uint DueTime, uint Period, win32.System.SystemServices.WORKER_THREAD_FLAGS Flags)
        {
            bool TimerQueueAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE phNewTimerLocal;
                win32.System.SystemServices.HANDLE TimerQueueLocal;
                if (TimerQueue is object)
                {
                    TimerQueue.DangerousAddRef(ref TimerQueueAddRef);
                    TimerQueueLocal = (win32.System.SystemServices.HANDLE)TimerQueue.DangerousGetHandle();
                }
                else
                    TimerQueueLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.CreateTimerQueueTimer(&phNewTimerLocal, TimerQueueLocal, Callback, Parameter, DueTime, Period, Flags);
                phNewTimer = new Microsoft.Win32.SafeHandles.SafeFileHandle(phNewTimerLocal, ownsHandle: true);
                return __result;
            }
            finally
            {
                if (TimerQueueAddRef)
                    TimerQueue.DangerousRelease();
            }
        }

        /// <summary>Creates a timer-queue timer. This timer expires at the specified due time, then after every specified period. When the timer expires, the callback function is called.</summary>
        /// <param name = "phNewTimer">A pointer to a buffer that receives a handle to the timer-queue timer on return. When this handle has expired and is no longer required, release it by calling <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-deletetimerqueuetimer">DeleteTimerQueueTimer</a>.</param>
        /// <param name = "TimerQueue">
        /// <para>A handle to the timer queue. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueue">CreateTimerQueue</a> function.</para>
        /// <para>If this parameter is <b>NULL</b>, the timer is associated with the default timer queue.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueuetimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Callback">
        /// <para>A pointer to the application-defined function of type <b>WAITORTIMERCALLBACK</b> to be executed when the timer expires. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms687066(v=vs.85)">WaitOrTimerCallback</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueuetimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Parameter">A single parameter value that will be passed to the callback function.</param>
        /// <param name = "DueTime">The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time.</param>
        /// <param name = "Period">The period of the timer, in milliseconds. If this parameter is zero, the timer is signaled once. If this parameter is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled.</param>
        /// <param name = "Flags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueuetimer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool CreateTimerQueueTimer(win32.System.SystemServices.HANDLE*phNewTimer, win32.System.SystemServices.HANDLE TimerQueue, delegate *unmanaged[Stdcall]<void *, byte, void>Callback, [Optional] void *Parameter, uint DueTime, uint Period, win32.System.SystemServices.WORKER_THREAD_FLAGS Flags);
        /// <inheritdoc cref = "ChangeTimerQueueTimer(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, uint, uint)"/>
        internal static unsafe bool ChangeTimerQueueTimer(SafeHandle TimerQueue, win32.System.SystemServices.HANDLE Timer, uint DueTime, uint Period)
        {
            bool TimerQueueAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE TimerQueueLocal;
                if (TimerQueue is object)
                {
                    TimerQueue.DangerousAddRef(ref TimerQueueAddRef);
                    TimerQueueLocal = (win32.System.SystemServices.HANDLE)TimerQueue.DangerousGetHandle();
                }
                else
                    TimerQueueLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.ChangeTimerQueueTimer(TimerQueueLocal, Timer, DueTime, Period);
                return __result;
            }
            finally
            {
                if (TimerQueueAddRef)
                    TimerQueue.DangerousRelease();
            }
        }

        /// <summary>Updates a timer-queue timer that was created by the CreateTimerQueueTimer function.</summary>
        /// <param name = "TimerQueue">
        /// <para>A handle to the timer queue. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueue">CreateTimerQueue</a> function.</para>
        /// <para>If this parameter is <b>NULL</b>, the timer is associated with the default timer queue.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-changetimerqueuetimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Timer">
        /// <para>A handle to the timer-queue timer. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueuetimer">CreateTimerQueueTimer</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-changetimerqueuetimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "DueTime">The time after which the timer should expire, in milliseconds.</param>
        /// <param name = "Period">
        /// <para>The period of the timer, in milliseconds. If this parameter is zero, the timer is signaled once. If this parameter is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled using the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-deletetimerqueuetimer">DeleteTimerQueueTimer</a> function or reset using <b>ChangeTimerQueueTimer</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-changetimerqueuetimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-changetimerqueuetimer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ChangeTimerQueueTimer(win32.System.SystemServices.HANDLE TimerQueue, win32.System.SystemServices.HANDLE Timer, uint DueTime, uint Period);
        /// <inheritdoc cref = "DeleteTimerQueueTimer(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool DeleteTimerQueueTimer(SafeHandle TimerQueue, SafeHandle Timer, SafeHandle CompletionEvent)
        {
            bool TimerQueueAddRef = false;
            bool TimerAddRef = false;
            bool CompletionEventAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE TimerQueueLocal;
                if (TimerQueue is object)
                {
                    TimerQueue.DangerousAddRef(ref TimerQueueAddRef);
                    TimerQueueLocal = (win32.System.SystemServices.HANDLE)TimerQueue.DangerousGetHandle();
                }
                else
                    TimerQueueLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE TimerLocal;
                if (Timer is object)
                {
                    Timer.DangerousAddRef(ref TimerAddRef);
                    TimerLocal = (win32.System.SystemServices.HANDLE)Timer.DangerousGetHandle();
                }
                else
                    TimerLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE CompletionEventLocal;
                if (CompletionEvent is object)
                {
                    CompletionEvent.DangerousAddRef(ref CompletionEventAddRef);
                    CompletionEventLocal = (win32.System.SystemServices.HANDLE)CompletionEvent.DangerousGetHandle();
                }
                else
                    CompletionEventLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.DeleteTimerQueueTimer(TimerQueueLocal, TimerLocal, CompletionEventLocal);
                return __result;
            }
            finally
            {
                if (TimerQueueAddRef)
                    TimerQueue.DangerousRelease();
                if (TimerAddRef)
                    Timer.DangerousRelease();
                if (CompletionEventAddRef)
                    CompletionEvent.DangerousRelease();
            }
        }

        /// <summary>Removes a timer from the timer queue and optionally waits for currently running timer callback functions to complete before deleting the timer.</summary>
        /// <param name = "TimerQueue">
        /// <para>A handle to the timer queue. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueue">CreateTimerQueue</a> function.</para>
        /// <para>If the timer was created using the default timer queue, this parameter should be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-deletetimerqueuetimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Timer">
        /// <para>A handle to the timer-queue timer. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueuetimer">CreateTimerQueueTimer</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-deletetimerqueuetimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "CompletionEvent">
        /// <para>A handle to the event object to be signaled when the system has canceled the timer and all callback functions  have completed. This parameter can be <b>NULL</b>.</para>
        /// <para>If this parameter is <b>INVALID_HANDLE_VALUE</b>, the function waits for any running timer callback functions to complete before returning.</para>
        /// <para>If this parameter is <b>NULL</b>, the function marks the timer for deletion and returns immediately. If the timer has already expired, the timer callback function will run to completion. However, there is no notification sent when the timer callback function has completed. Most callers should not use this option, and should wait for running timer callback functions to complete so they can perform any needed cleanup.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-deletetimerqueuetimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the error code is <b>ERROR_IO_PENDING</b>, it is not necessary to call this function again. For any other error, you should retry the call.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-deletetimerqueuetimer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DeleteTimerQueueTimer(win32.System.SystemServices.HANDLE TimerQueue, win32.System.SystemServices.HANDLE Timer, win32.System.SystemServices.HANDLE CompletionEvent);
        /// <summary>Deletes a timer queue. Any pending timers in the queue are canceled and deleted.</summary>
        /// <param name = "TimerQueue">
        /// <para>A handle to the timer queue. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueue">CreateTimerQueue</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-deletetimerqueueex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "CompletionEvent">
        /// <para>A handle to the event object to be signaled when the function is successful and all callback functions have completed. This parameter can be <b>NULL</b>.</para>
        /// <para>If this parameter is <b>INVALID_HANDLE_VALUE</b>, the function waits for all callback functions to complete before returning.</para>
        /// <para>If this parameter is <b>NULL</b>, the function marks the timer for deletion and returns immediately. However, most callers should wait for the callback function to complete so they can perform any needed cleanup.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-deletetimerqueueex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoollegacyapiset/nf-threadpoollegacyapiset-deletetimerqueueex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL DeleteTimerQueueEx(win32.System.SystemServices.HANDLE TimerQueue, win32.System.SystemServices.HANDLE CompletionEvent);
        /// <summary>Closes the specified thread pool.</summary>
        /// <param name = "ptpp">A pointer to a <b>TP_POOL</b> structure that defines the thread pool. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpool">CreateThreadpool</a> function returns this pointer.</param>
        /// <remarks>
        /// <para>The thread pool is closed immediately if there are no outstanding <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwork">work</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio">I/O</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer">timer</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwait">wait</a> objects that are bound to the pool; otherwise, the thread pool is released asynchronously after the outstanding objects are freed.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-closethreadpool#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void CloseThreadpool(win32.System.Threading.PTP_POOL ptpp);
        /// <inheritdoc cref = "CreateThreadpool(void *)"/>
        internal static unsafe Kernel32.CloseThreadpoolSafeHandle CreateThreadpool_SafeHandle(void *reserved)
        {
            win32.System.Threading.PTP_POOL __result = Kernel32.CreateThreadpool(reserved);
            return new Kernel32.CloseThreadpoolSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "Kernel32.CloseThreadpool"/>.
        /// </summary>
        internal class CloseThreadpoolSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal CloseThreadpoolSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal CloseThreadpoolSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle()
            {
                Kernel32.CloseThreadpool((win32.System.Threading.PTP_POOL)this.handle);
                return true;
            }
        }

        /// <summary>Allocates a new pool of threads to execute callbacks.</summary>
        /// <param name = "reserved">This parameter is reserved and must be NULL.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns a pointer to a <b>TP_POOL</b> structure representing the newly allocated thread pool. Applications do not modify the members of this structure.</para>
        /// <para>If function fails, it returns NULL. To retrieve extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-createthreadpool">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.Threading.PTP_POOL CreateThreadpool(void *reserved);
        /// <summary>Sets the maximum number of threads that the specified thread pool can allocate to process callbacks.</summary>
        /// <param name = "ptpp">A pointer to a <b>TP_POOL</b> structure that defines the thread pool. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpool">CreateThreadpool</a> function returns this pointer.</param>
        /// <param name = "cthrdMost">The maximum number of threads.</param>
        /// <remarks>
        /// <para>To specify the minimum number of threads available in the pool, call <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolthreadminimum">SetThreadpoolThreadMinimum</a>.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpoolthreadmaximum#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void SetThreadpoolThreadMaximum(win32.System.Threading.PTP_POOL ptpp, uint cthrdMost);
        /// <summary>Sets the minimum number of threads that the specified thread pool must make available to process callbacks.</summary>
        /// <param name = "ptpp">A pointer to a <b>TP_POOL</b> structure that defines the thread pool. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpool">CreateThreadpool</a> function returns this pointer.</param>
        /// <param name = "cthrdMic">The minimum number of threads.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns TRUE.</para>
        /// <para>If the function fails, it returns FALSE. To retrieve extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpoolthreadminimum">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetThreadpoolThreadMinimum(win32.System.Threading.PTP_POOL ptpp, uint cthrdMic);
        /// <inheritdoc cref = "SetThreadpoolStackInformation(win32.System.Threading.PTP_POOL, win32.System.SystemServices.TP_POOL_STACK_INFORMATION*)"/>
        internal static unsafe bool SetThreadpoolStackInformation(win32.System.Threading.PTP_POOL ptpp, in win32.System.SystemServices.TP_POOL_STACK_INFORMATION ptpsi)
        {
            fixed (win32.System.SystemServices.TP_POOL_STACK_INFORMATION*ptpsiLocal = &ptpsi)
            {
                bool __result = Kernel32.SetThreadpoolStackInformation(ptpp, ptpsiLocal);
                return __result;
            }
        }

        /// <summary>Sets the stack reserve and commit sizes for new threads in the specified thread pool. Stack reserve and commit sizes for existing threads are not changed.</summary>
        /// <param name = "ptpp">A pointer to a <b>TP_POOL</b> structure that specifies the thread pool. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpool">CreateThreadpool</a> function returns this [pomter.</param>
        /// <param name = "ptpsi">A pointer to a <b>TP_POOL_STACK_INFORMATION</b> structure that specifies the stack reserve and commit size for threads in the pool.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpoolstackinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetThreadpoolStackInformation(win32.System.Threading.PTP_POOL ptpp, win32.System.SystemServices.TP_POOL_STACK_INFORMATION*ptpsi);
        /// <inheritdoc cref = "QueryThreadpoolStackInformation(win32.System.Threading.PTP_POOL, win32.System.SystemServices.TP_POOL_STACK_INFORMATION*)"/>
        internal static unsafe bool QueryThreadpoolStackInformation(SafeHandle ptpp, out win32.System.SystemServices.TP_POOL_STACK_INFORMATION ptpsi)
        {
            bool ptppAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.TP_POOL_STACK_INFORMATION*ptpsiLocal = &ptpsi)
                {
                    win32.System.Threading.PTP_POOL ptppLocal;
                    if (ptpp is object)
                    {
                        ptpp.DangerousAddRef(ref ptppAddRef);
                        ptppLocal = (win32.System.Threading.PTP_POOL)ptpp.DangerousGetHandle();
                    }
                    else
                        ptppLocal = default(win32.System.Threading.PTP_POOL);
                    bool __result = Kernel32.QueryThreadpoolStackInformation(ptppLocal, ptpsiLocal);
                    return __result;
                }
            }
            finally
            {
                if (ptppAddRef)
                    ptpp.DangerousRelease();
            }
        }

        /// <summary>Retrieves the stack reserve and commit sizes for threads in the specified thread pool.</summary>
        /// <param name = "ptpp">A pointer to a <b>TP_POOL</b> structure that specifies the thread pool. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpool">CreateThreadpool</a> function returns this pointer.</param>
        /// <param name = "ptpsi">A pointer to a <b>TP_POOL_STACK_INFORMATION</b> structure that receives the stack reserve and commit size.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-querythreadpoolstackinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool QueryThreadpoolStackInformation(win32.System.Threading.PTP_POOL ptpp, win32.System.SystemServices.TP_POOL_STACK_INFORMATION*ptpsi);
        /// <summary>Creates a cleanup group that applications can use to track one or more thread pool callbacks.</summary>
        /// <returns>
        /// <para>If the function succeeds, it returns a pointer to a <b>TP_CLEANUP_GROUP</b> structure of the newly allocated cleanup group. Applications do not modify the members of this structure.</para>
        /// <para>If function fails, it returns NULL. To retrieve extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-createthreadpoolcleanupgroup">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nint CreateThreadpoolCleanupGroup();
        /// <summary>Releases the members of the specified cleanup group, waits for all callback functions to complete, and optionally cancels any outstanding callback functions.</summary>
        /// <param name = "ptpcg">A pointer to a <b>TP_CLEANUP_GROUP</b> structure that defines the cleanup group. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolcleanupgroup">CreateThreadpoolCleanupGroup</a> function returns this pointer.</param>
        /// <param name = "fCancelPendingCallbacks">If this parameter is TRUE, the function cancels outstanding callbacks that have not yet started. If this parameter is FALSE, the function waits for outstanding callback functions to complete.</param>
        /// <param name = "pvCleanupContext">The application-defined data to pass to the application's cleanup group callback function. You can specify the callback function when you call <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setthreadpoolcallbackcleanupgroup">SetThreadpoolCallbackCleanupGroup</a>.</param>
        /// <remarks>
        /// <para>The <b>CloseThreadpoolCleanupGroupMembers</b> function simplifies cleanup of thread pool callback objects by releasing, in a single operation, all work objects, wait objects, and timer objects that are members of the cleanup group. An object becomes a member of a cleanup group when the object is created with the threadpool callback environment that was specified when the cleanup group was created. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolcleanupgroup">CreateThreadpoolCleanupGroup</a>.</para>
        /// <para>The <b>CloseThreadpoolCleanupGroupMembers</b> function blocks until all currently executing callback functions finish. If <i>fCancelPendingCallbacks</i> is TRUE, outstanding callbacks are canceled; otherwise, the function blocks until all outstanding callbacks also finish.  After the <b>CloseThreadpoolCleanupGroupMembers</b> function returns, an application should not use any object that was a member of the cleanup group at the time <b>CloseThreadpoolCleanupGroupMembers</b> was called.  Also, an application should not release any of the objects individually by calling a function such as <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolwork">CloseThreadpoolWork</a>, because the objects have already been released.</para>
        /// <para>The <b>CloseThreadpoolCleanupGroupMembers</b> function does not close the cleanup group itself. Instead, the cleanup group persists until the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolcleanupgroup">CloseThreadpoolCleanupGroup</a> function is called. Also, closing a cleanup group does not affect the associated threadpool callback environment. The callback environment persists until it is destroyed by calling <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-destroythreadpoolenvironment">DestroyThreadpoolEnvironment</a>.</para>
        /// <para>As long as a cleanup group persists, new objects created with the cleanup group's associated threadpool callback environment are added to the cleanup group. This allows an application to reuse the cleanup group. However, it can lead to errors if the application does not synchronize code that calls <b>CloseThreadpoolCleanupGroupMembers</b> with code that creates new objects. For example, suppose a thread creates two threadpool work objects, Work1 and Work2. Another thread calls <b>CloseThreadpoolCleanupGroupMembers</b>. Depending on when the threads run, any of the following might occur:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-closethreadpoolcleanupgroupmembers#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void CloseThreadpoolCleanupGroupMembers(nint ptpcg, bool fCancelPendingCallbacks, [Optional] void *pvCleanupContext);
        /// <summary>Closes the specified cleanup group.</summary>
        /// <param name = "ptpcg">A pointer to a <b>TP_CLEANUP_GROUP</b> structure that defines the cleanup group. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolcleanupgroup">CreateThreadpoolCleanupGroup</a> returns this pointer.</param>
        /// <remarks>
        /// <para>The cleanup group must have no members when you call this function. For information on removing members of the group, see <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolcleanupgroupmembers">CloseThreadpoolCleanupGroupMembers</a>.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-closethreadpoolcleanupgroup#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void CloseThreadpoolCleanupGroup(nint ptpcg);
        /// <inheritdoc cref = "SetEventWhenCallbackReturns(win32.System.SystemServices.TP_CALLBACK_INSTANCE*, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe void SetEventWhenCallbackReturns(ref win32.System.SystemServices.TP_CALLBACK_INSTANCE pci, SafeHandle evt)
        {
            bool evtAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.TP_CALLBACK_INSTANCE*pciLocal = &pci)
                {
                    win32.System.SystemServices.HANDLE evtLocal;
                    if (evt is object)
                    {
                        evt.DangerousAddRef(ref evtAddRef);
                        evtLocal = (win32.System.SystemServices.HANDLE)evt.DangerousGetHandle();
                    }
                    else
                        evtLocal = default(win32.System.SystemServices.HANDLE);
                    Kernel32.SetEventWhenCallbackReturns(pciLocal, evtLocal);
                }
            }
            finally
            {
                if (evtAddRef)
                    evt.DangerousRelease();
            }
        }

        /// <summary>Specifies the event that the thread pool will set when the current callback completes.</summary>
        /// <param name = "pci">A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to the callback function.</param>
        /// <param name = "evt">A handle to the event to be set.</param>
        /// <remarks>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-seteventwhencallbackreturns#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void SetEventWhenCallbackReturns(win32.System.SystemServices.TP_CALLBACK_INSTANCE*pci, win32.System.SystemServices.HANDLE evt);
        /// <inheritdoc cref = "ReleaseSemaphoreWhenCallbackReturns(win32.System.SystemServices.TP_CALLBACK_INSTANCE*, win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe void ReleaseSemaphoreWhenCallbackReturns(ref win32.System.SystemServices.TP_CALLBACK_INSTANCE pci, SafeHandle sem, uint crel)
        {
            bool semAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.TP_CALLBACK_INSTANCE*pciLocal = &pci)
                {
                    win32.System.SystemServices.HANDLE semLocal;
                    if (sem is object)
                    {
                        sem.DangerousAddRef(ref semAddRef);
                        semLocal = (win32.System.SystemServices.HANDLE)sem.DangerousGetHandle();
                    }
                    else
                        semLocal = default(win32.System.SystemServices.HANDLE);
                    Kernel32.ReleaseSemaphoreWhenCallbackReturns(pciLocal, semLocal, crel);
                }
            }
            finally
            {
                if (semAddRef)
                    sem.DangerousRelease();
            }
        }

        /// <summary>Specifies the semaphore that the thread pool will release when the current callback completes.</summary>
        /// <param name = "pci">A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to the callback function.</param>
        /// <param name = "sem">A handle to the semaphore.</param>
        /// <param name = "crel">The amount by which to increment the semaphore object's count.</param>
        /// <remarks>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-releasesemaphorewhencallbackreturns#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void ReleaseSemaphoreWhenCallbackReturns(win32.System.SystemServices.TP_CALLBACK_INSTANCE*pci, win32.System.SystemServices.HANDLE sem, uint crel);
        /// <inheritdoc cref = "ReleaseMutexWhenCallbackReturns(win32.System.SystemServices.TP_CALLBACK_INSTANCE*, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe void ReleaseMutexWhenCallbackReturns(ref win32.System.SystemServices.TP_CALLBACK_INSTANCE pci, SafeHandle mut)
        {
            bool mutAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.TP_CALLBACK_INSTANCE*pciLocal = &pci)
                {
                    win32.System.SystemServices.HANDLE mutLocal;
                    if (mut is object)
                    {
                        mut.DangerousAddRef(ref mutAddRef);
                        mutLocal = (win32.System.SystemServices.HANDLE)mut.DangerousGetHandle();
                    }
                    else
                        mutLocal = default(win32.System.SystemServices.HANDLE);
                    Kernel32.ReleaseMutexWhenCallbackReturns(pciLocal, mutLocal);
                }
            }
            finally
            {
                if (mutAddRef)
                    mut.DangerousRelease();
            }
        }

        /// <summary>Specifies the mutex that the thread pool will release when the current callback completes.</summary>
        /// <param name = "pci">A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to the callback function.</param>
        /// <param name = "mut">A handle to the mutex.</param>
        /// <remarks>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-releasemutexwhencallbackreturns#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void ReleaseMutexWhenCallbackReturns(win32.System.SystemServices.TP_CALLBACK_INSTANCE*pci, win32.System.SystemServices.HANDLE mut);
        /// <inheritdoc cref = "LeaveCriticalSectionWhenCallbackReturns(win32.System.SystemServices.TP_CALLBACK_INSTANCE*, win32.System.SystemServices.RTL_CRITICAL_SECTION*)"/>
        internal static unsafe void LeaveCriticalSectionWhenCallbackReturns(ref win32.System.SystemServices.TP_CALLBACK_INSTANCE pci, ref win32.System.SystemServices.RTL_CRITICAL_SECTION pcs)
        {
            fixed (win32.System.SystemServices.RTL_CRITICAL_SECTION*pcsLocal = &pcs)
            {
                fixed (win32.System.SystemServices.TP_CALLBACK_INSTANCE*pciLocal = &pci)
                {
                    Kernel32.LeaveCriticalSectionWhenCallbackReturns(pciLocal, pcsLocal);
                }
            }
        }

        /// <summary>Specifies the critical section that the thread pool will release when the current callback completes.</summary>
        /// <param name = "pci">A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to the callback function.</param>
        /// <param name = "pcs">The critical section.</param>
        /// <remarks>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-leavecriticalsectionwhencallbackreturns#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void LeaveCriticalSectionWhenCallbackReturns(win32.System.SystemServices.TP_CALLBACK_INSTANCE*pci, win32.System.SystemServices.RTL_CRITICAL_SECTION*pcs);
        /// <inheritdoc cref = "FreeLibraryWhenCallbackReturns(win32.System.SystemServices.TP_CALLBACK_INSTANCE*, win32.System.SystemServices.HINSTANCE)"/>
        internal static unsafe void FreeLibraryWhenCallbackReturns(ref win32.System.SystemServices.TP_CALLBACK_INSTANCE pci, SafeHandle mod)
        {
            bool modAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.TP_CALLBACK_INSTANCE*pciLocal = &pci)
                {
                    win32.System.SystemServices.HINSTANCE modLocal;
                    if (mod is object)
                    {
                        mod.DangerousAddRef(ref modAddRef);
                        modLocal = (win32.System.SystemServices.HINSTANCE)mod.DangerousGetHandle();
                    }
                    else
                        modLocal = default(win32.System.SystemServices.HINSTANCE);
                    Kernel32.FreeLibraryWhenCallbackReturns(pciLocal, modLocal);
                }
            }
            finally
            {
                if (modAddRef)
                    mod.DangerousRelease();
            }
        }

        /// <summary>Specifies the DLL that the thread pool will unload when the current callback completes.</summary>
        /// <param name = "pci">A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to the callback function.</param>
        /// <param name = "mod">A handle to the DLL.</param>
        /// <remarks>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-freelibrarywhencallbackreturns#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void FreeLibraryWhenCallbackReturns(win32.System.SystemServices.TP_CALLBACK_INSTANCE*pci, win32.System.SystemServices.HINSTANCE mod);
        /// <inheritdoc cref = "CallbackMayRunLong(win32.System.SystemServices.TP_CALLBACK_INSTANCE*)"/>
        internal static unsafe bool CallbackMayRunLong(ref win32.System.SystemServices.TP_CALLBACK_INSTANCE pci)
        {
            fixed (win32.System.SystemServices.TP_CALLBACK_INSTANCE*pciLocal = &pci)
            {
                bool __result = Kernel32.CallbackMayRunLong(pciLocal);
                return __result;
            }
        }

        /// <summary>Indicates that the callback may not return quickly.</summary>
        /// <param name = "pci">A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to the callback function.</param>
        /// <returns>
        /// <para>The function returns TRUE if another thread in the thread pool is available for processing callbacks or the thread pool was able to create a new thread.  In this case, the current callback function may use the current thread indefinitely.</para>
        /// <para>The function returns FALSE if another thread in the thread pool is not available to process callbacks and the thread pool was not able to create a new thread.  The thread pool will attempt to create a new thread after a delay, but if the current callback function runs long, the thread pool may lose efficiency.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-callbackmayrunlong">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool CallbackMayRunLong(win32.System.SystemServices.TP_CALLBACK_INSTANCE*pci);
        /// <inheritdoc cref = "DisassociateCurrentThreadFromCallback(win32.System.SystemServices.TP_CALLBACK_INSTANCE*)"/>
        internal static unsafe void DisassociateCurrentThreadFromCallback(ref win32.System.SystemServices.TP_CALLBACK_INSTANCE pci)
        {
            fixed (win32.System.SystemServices.TP_CALLBACK_INSTANCE*pciLocal = &pci)
            {
                Kernel32.DisassociateCurrentThreadFromCallback(pciLocal);
            }
        }

        /// <summary>Removes the association between the currently executing callback function and the object that initiated the callback. The current thread will no longer count as executing a callback on behalf of the object.</summary>
        /// <param name = "pci">A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to the callback function.</param>
        /// <remarks>
        /// <para>If this is the last thread executing a callback on behalf of the object, any threads waiting for the object's callbacks to complete will be released.</para>
        /// <para>The thread remains associated with the object's <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolcleanupgroup">cleanup group</a> until the thread returns to the thread pool. This lets DLL shutdown routines safely synchronize with outstanding callbacks and proceed with unloading the DLL's code when all callbacks have completed.</para>
        /// <para>The callback-generating object remains valid for the duration of the callback. The callback object may be reused or released (although synchronization with cleanup group release is still required).</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-disassociatecurrentthreadfromcallback#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void DisassociateCurrentThreadFromCallback(win32.System.SystemServices.TP_CALLBACK_INSTANCE*pci);
        /// <inheritdoc cref = "TrySubmitThreadpoolCallback(delegate *unmanaged[Stdcall]{win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, void}, void *, win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3*)"/>
        internal static unsafe bool TrySubmitThreadpoolCallback(delegate *unmanaged[Stdcall]<win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, void>pfns, void *pv, win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3? pcbe)
        {
            win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3 pcbeLocal = pcbe.HasValue ? pcbe.Value : default(win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3);
            bool __result = Kernel32.TrySubmitThreadpoolCallback(pfns, pv, pcbe.HasValue ? &pcbeLocal : null);
            return __result;
        }

        /// <summary>Requests that a thread pool worker thread call the specified callback function.</summary>
        /// <param name = "pfns">The callback function. For details, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686295(v=vs.85)">SimpleCallback</a>.</param>
        /// <param name = "pv">Optional application-defined data to pass to the callback function.</param>
        /// <param name = "pcbe">
        /// <para>A pointer to a <b>TP_CALLBACK_ENVIRON</b> structure that defines the environment in which to execute the callback function. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-initializethreadpoolenvironment">InitializeThreadpoolEnvironment</a> function to initialize the structure before calling this function.</para>
        /// <para>If this parameter is NULL, the callback executes in the default callback environment. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-initializethreadpoolenvironment">InitializeThreadpoolEnvironment</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-trysubmitthreadpoolcallback#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns TRUE.</para>
        /// <para>If the function fails, it returns FALSE. To retrieve extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-trysubmitthreadpoolcallback">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool TrySubmitThreadpoolCallback(delegate *unmanaged[Stdcall]<win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, void>pfns, [Optional] void *pv, [Optional] win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3*pcbe);
        /// <inheritdoc cref = "CreateThreadpoolWork(delegate *unmanaged[Stdcall]{win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, win32.System.SystemServices.TP_WORK*, void}, void *, win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3*)"/>
        internal static unsafe win32.System.SystemServices.TP_WORK*CreateThreadpoolWork(delegate *unmanaged[Stdcall]<win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, win32.System.SystemServices.TP_WORK*, void>pfnwk, void *pv, win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3? pcbe)
        {
            win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3 pcbeLocal = pcbe.HasValue ? pcbe.Value : default(win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3);
            win32.System.SystemServices.TP_WORK*__result = Kernel32.CreateThreadpoolWork(pfnwk, pv, pcbe.HasValue ? &pcbeLocal : null);
            return __result;
        }

        /// <summary>Creates a new work object.</summary>
        /// <param name = "pfnwk">The callback function. A worker thread calls this callback each time you call <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-submitthreadpoolwork">SubmitThreadpoolWork</a> to post the work object. For details, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms687396(v=vs.85)">WorkCallback</a>.</param>
        /// <param name = "pv">Optional application-defined data to pass to the callback function.</param>
        /// <param name = "pcbe">
        /// <para>A pointer to a <b>TP_CALLBACK_ENVIRON</b> structure that defines the  environment in which to execute the callback. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-initializethreadpoolenvironment">InitializeThreadpoolEnvironment</a> function to initialize the structure before calling this function.</para>
        /// <para>If this parameter is NULL, the callback executes in the default callback environment. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-initializethreadpoolenvironment">InitializeThreadpoolEnvironment</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-createthreadpoolwork#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns a pointer to a <b>TP_WORK</b> structure that defines the work object. Applications do not modify the members of this structure.</para>
        /// <para>If the function fails, it returns NULL. To retrieve extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-createthreadpoolwork">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.TP_WORK*CreateThreadpoolWork(delegate *unmanaged[Stdcall]<win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, win32.System.SystemServices.TP_WORK*, void>pfnwk, [Optional] void *pv, [Optional] win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3*pcbe);
        /// <inheritdoc cref = "SubmitThreadpoolWork(win32.System.SystemServices.TP_WORK*)"/>
        internal static unsafe void SubmitThreadpoolWork(ref win32.System.SystemServices.TP_WORK pwk)
        {
            fixed (win32.System.SystemServices.TP_WORK*pwkLocal = &pwk)
            {
                Kernel32.SubmitThreadpoolWork(pwkLocal);
            }
        }

        /// <summary>Posts a work object to the thread pool. A worker thread calls the work object's callback function.</summary>
        /// <param name = "pwk">A pointer to a <b>TP_WORK</b> structure that defines the work object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwork">CreateThreadpoolWork</a> function returns this pointer.</param>
        /// <remarks>
        /// <para>You can post a work object one or more times (up to MAXULONG) without waiting for prior callbacks to complete.  The callbacks will execute in parallel. To improve efficiency, the thread pool may throttle the threads.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-submitthreadpoolwork#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void SubmitThreadpoolWork(win32.System.SystemServices.TP_WORK*pwk);
        /// <inheritdoc cref = "WaitForThreadpoolWorkCallbacks(win32.System.SystemServices.TP_WORK*, bool)"/>
        internal static unsafe void WaitForThreadpoolWorkCallbacks(ref win32.System.SystemServices.TP_WORK pwk, bool fCancelPendingCallbacks)
        {
            fixed (win32.System.SystemServices.TP_WORK*pwkLocal = &pwk)
            {
                Kernel32.WaitForThreadpoolWorkCallbacks(pwkLocal, fCancelPendingCallbacks);
            }
        }

        /// <summary>Waits for outstanding work callbacks to complete and optionally cancels pending callbacks that have not yet started to execute.</summary>
        /// <param name = "pwk">A pointer to a <b>TP_WORK</b> structure that defines the work object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwork">CreateThreadpoolWork</a> function returns this pointer.</param>
        /// <param name = "fCancelPendingCallbacks">Indicates whether to cancel queued callbacks that have not yet started to execute.</param>
        /// <remarks>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-waitforthreadpoolworkcallbacks#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void WaitForThreadpoolWorkCallbacks(win32.System.SystemServices.TP_WORK*pwk, bool fCancelPendingCallbacks);
        /// <inheritdoc cref = "CloseThreadpoolWork(win32.System.SystemServices.TP_WORK*)"/>
        internal static unsafe void CloseThreadpoolWork(ref win32.System.SystemServices.TP_WORK pwk)
        {
            fixed (win32.System.SystemServices.TP_WORK*pwkLocal = &pwk)
            {
                Kernel32.CloseThreadpoolWork(pwkLocal);
            }
        }

        /// <summary>Releases the specified work object.</summary>
        /// <param name = "pwk">A pointer to a <b>TP_WORK</b> structure that defines the work object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwork">CreateThreadpoolWork</a> function returns this pointer.</param>
        /// <remarks>
        /// <para>The work object is freed immediately if there are no outstanding callbacks; otherwise, the work object is freed asynchronously after the outstanding callbacks complete.</para>
        /// <para>If there is a cleanup group associated with the work object, it is not necessary to call this function; calling the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolcleanupgroupmembers">CloseThreadpoolCleanupGroupMembers</a> function releases the  work, wait, and timer objects associated with the cleanup group.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-closethreadpoolwork#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void CloseThreadpoolWork(win32.System.SystemServices.TP_WORK*pwk);
        /// <inheritdoc cref = "CreateThreadpoolTimer(delegate *unmanaged[Stdcall]{win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, win32.System.SystemServices.TP_TIMER*, void}, void *, win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3*)"/>
        internal static unsafe win32.System.SystemServices.TP_TIMER*CreateThreadpoolTimer(delegate *unmanaged[Stdcall]<win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, win32.System.SystemServices.TP_TIMER*, void>pfnti, void *pv, win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3? pcbe)
        {
            win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3 pcbeLocal = pcbe.HasValue ? pcbe.Value : default(win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3);
            win32.System.SystemServices.TP_TIMER*__result = Kernel32.CreateThreadpoolTimer(pfnti, pv, pcbe.HasValue ? &pcbeLocal : null);
            return __result;
        }

        /// <summary>Creates a new timer object.</summary>
        /// <param name = "pfnti">The callback function to call each time the timer object expires. For details, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686790(v=vs.85)">TimerCallback</a>.</param>
        /// <param name = "pv">Optional application-defined data to pass to the callback function.</param>
        /// <param name = "pcbe">
        /// <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the environment in which to execute the callback. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-initializethreadpoolenvironment">InitializeThreadpoolEnvironment</a> function returns this structure.</para>
        /// <para>If this parameter is NULL, the callback executes in the default callback environment. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-initializethreadpoolenvironment">InitializeThreadpoolEnvironment</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns a pointer to a <b>TP_TIMER</b> structure that defines the timer object. Applications do not modify the members of this structure.</para>
        /// <para>If the function fails, it returns NULL. To retrieve extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.TP_TIMER*CreateThreadpoolTimer(delegate *unmanaged[Stdcall]<win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, win32.System.SystemServices.TP_TIMER*, void>pfnti, [Optional] void *pv, [Optional] win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3*pcbe);
        /// <inheritdoc cref = "SetThreadpoolTimer(win32.System.SystemServices.TP_TIMER*, global::System.Runtime.InteropServices.ComTypes.FILETIME*, uint, uint)"/>
        internal static unsafe void SetThreadpoolTimer(ref win32.System.SystemServices.TP_TIMER pti, global::System.Runtime.InteropServices.ComTypes.FILETIME? pftDueTime, uint msPeriod, uint msWindowLength)
        {
            fixed (win32.System.SystemServices.TP_TIMER*ptiLocal = &pti)
            {
                global::System.Runtime.InteropServices.ComTypes.FILETIME pftDueTimeLocal = pftDueTime.HasValue ? pftDueTime.Value : default(global::System.Runtime.InteropServices.ComTypes.FILETIME);
                Kernel32.SetThreadpoolTimer(ptiLocal, pftDueTime.HasValue ? &pftDueTimeLocal : null, msPeriod, msWindowLength);
            }
        }

        /// <summary>Sets the timer object�, replacing the previous timer, if any. A worker thread calls the timer object's callback after the specified timeout expires.</summary>
        /// <param name = "pti">A pointer to a <b>TP_TIMER</b> structure that defines the timer object to set. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer">CreateThreadpoolTimer</a> function returns this pointer.</param>
        /// <param name = "pftDueTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the absolute or relative time at which the timer should expire.  If positive or zero, it indicates the absolute time since January 1, 1601 (UTC), measured in 100 nanosecond units. If negative, it indicates the amount of time to wait relative to the current time. For more information about time values, see <a href = "https://docs.microsoft.com/windows/desktop/SysInfo/file-times">File Times</a>.</para>
        /// <para>If this parameter is NULL, the timer object will cease to queue new callbacks (but callbacks already queued will still occur).</para>
        /// <para>The timer is set if the <i>pftDueTime</i> parameter is non-NULL.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpooltimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "msPeriod">The timer period, in milliseconds. If this parameter is zero, the timer is signaled once. If this parameter is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled.</param>
        /// <param name = "msWindowLength">The maximum amount of time the system can delay before calling the timer callback. If this parameter is set, the system can batch calls to conserve power.</param>
        /// <remarks>
        /// <para>Setting the timer cancels the previous timer, if any.</para>
        /// <para>In some cases, callback functions might run after an application closes the threadpool timer. To prevent this behavior, an application should follow the steps described in <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-closethreadpooltimer">CloseThreadpoolTimer</a>.</para>
        /// <para>If the due time specified by <i>pftDueTime</i> is relative, the time that the system spends in sleep or hibernation does not count toward the expiration of the timer. The timer is signaled when the cumulative amount of elapsed time the system spends in the waking state equals the timer's relative due time or period. If the  due time specified by <i>pftDueTime</i> is absolute, the time that the system spends in sleep or hibernation does count toward the expiration of the timer. If the timer expires while the system is sleeping, the timer is signaled immediately when the system wakes.</para>
        /// <para>If the due time specified by <i>pftDueTime</i> is zero, then the timer expires immediately.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpooltimer#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void SetThreadpoolTimer(win32.System.SystemServices.TP_TIMER*pti, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*pftDueTime, uint msPeriod, uint msWindowLength);
        /// <inheritdoc cref = "IsThreadpoolTimerSet(win32.System.SystemServices.TP_TIMER*)"/>
        internal static unsafe bool IsThreadpoolTimerSet(ref win32.System.SystemServices.TP_TIMER pti)
        {
            fixed (win32.System.SystemServices.TP_TIMER*ptiLocal = &pti)
            {
                bool __result = Kernel32.IsThreadpoolTimerSet(ptiLocal);
                return __result;
            }
        }

        /// <summary>Determines whether the specified timer object is currently set.</summary>
        /// <param name = "pti">A pointer to a <b>TP_TIMER</b> structure that defines the timer object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer">CreateThreadpoolTimer</a> function returns this pointer.</param>
        /// <returns>The return value is TRUE if the timer is set; otherwise, the return value is FALSE.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-isthreadpooltimerset">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool IsThreadpoolTimerSet(win32.System.SystemServices.TP_TIMER*pti);
        /// <inheritdoc cref = "WaitForThreadpoolTimerCallbacks(win32.System.SystemServices.TP_TIMER*, bool)"/>
        internal static unsafe void WaitForThreadpoolTimerCallbacks(ref win32.System.SystemServices.TP_TIMER pti, bool fCancelPendingCallbacks)
        {
            fixed (win32.System.SystemServices.TP_TIMER*ptiLocal = &pti)
            {
                Kernel32.WaitForThreadpoolTimerCallbacks(ptiLocal, fCancelPendingCallbacks);
            }
        }

        /// <summary>Waits for outstanding timer callbacks to complete and optionally cancels pending callbacks that have not yet started to execute.</summary>
        /// <param name = "pti">A pointer to a <b>TP_TIMER</b> structure that defines the timer object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer">CreateThreadpoolTimer</a> function returns this pointer.</param>
        /// <param name = "fCancelPendingCallbacks">Indicates whether to cancel queued callbacks that have not yet started to execute.</param>
        /// <remarks>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-waitforthreadpooltimercallbacks#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void WaitForThreadpoolTimerCallbacks(win32.System.SystemServices.TP_TIMER*pti, bool fCancelPendingCallbacks);
        /// <inheritdoc cref = "CloseThreadpoolTimer(win32.System.SystemServices.TP_TIMER*)"/>
        internal static unsafe void CloseThreadpoolTimer(ref win32.System.SystemServices.TP_TIMER pti)
        {
            fixed (win32.System.SystemServices.TP_TIMER*ptiLocal = &pti)
            {
                Kernel32.CloseThreadpoolTimer(ptiLocal);
            }
        }

        /// <summary>Releases the specified timer object.</summary>
        /// <param name = "pti">
        /// <para>A pointer to <b>TP_TIMER</b> structure that defines the timer object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer">CreateThreadpoolTimer</a> function returns this pointer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-closethreadpooltimer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>The timer object is freed immediately if there are no outstanding callbacks; otherwise, the timer object is freed asynchronously after the outstanding callback functions complete.</para>
        /// <para>In some cases, callback functions might run after <b>CloseThreadpoolTimer</b> has been called. To prevent this behavior:</para>
        /// <para>* Call the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-setthreadpooltimer">SetThreadpoolTimer</a> function or <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-setthreadpooltimerex">SetThreadpoolTimerEx</a> function with the <i>pftDueTime</i> parameter set to NULL and the <i>msPeriod</i> and <i>msWindowLength</i> parameters set to 0. * Call the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-waitforthreadpooltimercallbacks">WaitForThreadpoolTimerCallbacks</a> function. * Call <b>CloseThreadpoolTimer</b>.</para>
        /// <para>If there is a cleanup group associated with the timer object, it is not necessary to call this function; calling the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolcleanupgroupmembers">CloseThreadpoolCleanupGroupMembers</a> function releases the  work, wait, and timer objects associated with the cleanup group.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-closethreadpooltimer#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void CloseThreadpoolTimer(win32.System.SystemServices.TP_TIMER*pti);
        /// <inheritdoc cref = "CreateThreadpoolWait(delegate *unmanaged[Stdcall]{win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, win32.System.SystemServices.TP_WAIT*, uint, void}, void *, win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3*)"/>
        internal static unsafe win32.System.SystemServices.TP_WAIT*CreateThreadpoolWait(delegate *unmanaged[Stdcall]<win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, win32.System.SystemServices.TP_WAIT*, uint, void>pfnwa, void *pv, win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3? pcbe)
        {
            win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3 pcbeLocal = pcbe.HasValue ? pcbe.Value : default(win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3);
            win32.System.SystemServices.TP_WAIT*__result = Kernel32.CreateThreadpoolWait(pfnwa, pv, pcbe.HasValue ? &pcbeLocal : null);
            return __result;
        }

        /// <summary>Creates a new wait object.</summary>
        /// <param name = "pfnwa">The callback function to call when the wait completes or times out. For details, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms687017(v=vs.85)">WaitCallback</a>.</param>
        /// <param name = "pv">Optional application-defined data to pass to the callback function.</param>
        /// <param name = "pcbe">
        /// <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the environment in which to execute the callback. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-initializethreadpoolenvironment">InitializeThreadpoolEnvironment</a> function returns this structure.</para>
        /// <para>If this parameter is NULL, the callback executes in the default callback environment. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-initializethreadpoolenvironment">InitializeThreadpoolEnvironment</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-createthreadpoolwait#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns a pointer to a <b>TP_WAIT</b> structure that defines the wait object. Applications do not modify the members of this structure.</para>
        /// <para>If the function fails, it returns NULL. To retrieve extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-createthreadpoolwait">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.TP_WAIT*CreateThreadpoolWait(delegate *unmanaged[Stdcall]<win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, win32.System.SystemServices.TP_WAIT*, uint, void>pfnwa, [Optional] void *pv, [Optional] win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3*pcbe);
        /// <inheritdoc cref = "SetThreadpoolWait(win32.System.SystemServices.TP_WAIT*, win32.System.SystemServices.HANDLE, global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe void SetThreadpoolWait(ref win32.System.SystemServices.TP_WAIT pwa, SafeHandle h, global::System.Runtime.InteropServices.ComTypes.FILETIME? pftTimeout)
        {
            bool hAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.TP_WAIT*pwaLocal = &pwa)
                {
                    win32.System.SystemServices.HANDLE hLocal;
                    if (h is object)
                    {
                        h.DangerousAddRef(ref hAddRef);
                        hLocal = (win32.System.SystemServices.HANDLE)h.DangerousGetHandle();
                    }
                    else
                        hLocal = default(win32.System.SystemServices.HANDLE);
                    global::System.Runtime.InteropServices.ComTypes.FILETIME pftTimeoutLocal = pftTimeout.HasValue ? pftTimeout.Value : default(global::System.Runtime.InteropServices.ComTypes.FILETIME);
                    Kernel32.SetThreadpoolWait(pwaLocal, hLocal, pftTimeout.HasValue ? &pftTimeoutLocal : null);
                }
            }
            finally
            {
                if (hAddRef)
                    h.DangerousRelease();
            }
        }

        /// <summary>Sets the wait object�replacing the previous wait object, if any. A worker thread calls the wait object's callback function after the handle becomes signaled or after the specified timeout expires.</summary>
        /// <param name = "pwa">A pointer to a <b>TP_WAIT</b> structure that defines the wait object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwait">CreateThreadpoolWait</a> function returns this pointer.</param>
        /// <param name = "h">
        /// <para>A handle.</para>
        /// <para>If this parameter is NULL, the wait object will cease to queue new callbacks (but callbacks already queued will still occur).</para>
        /// <para>If this parameter is not NULL, it must refer to a valid waitable object.</para>
        /// <para>If this handle is closed while the wait is still pending, the function's behavior is undefined. If the wait is still pending and the handle must be closed, use <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolwait">CloseThreadpoolWait</a> to cancel the wait and then close the handle.</para>
        /// <para>The wait is considered set if this parameter is non-NULL.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pftTimeout">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the absolute or relative time at which the wait operation should time out.  If this parameter points to a positive value, it indicates the absolute time since January 1, 1601 (UTC), in 100-nanosecond intervals. If this parameter points to a negative value, it indicates the amount of time to wait relative to the current time. For more information about time values, see <a href = "https://docs.microsoft.com/windows/desktop/SysInfo/file-times">File Times</a>.</para>
        /// <para>If this parameter points to 0, the wait times out immediately. If this parameter is NULL, the wait will not time out.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>A wait object can wait for only one handle. Setting the handle for a wait object replaces the previous handle, if any.</para>
        /// <para>You must re-register the event with the wait object  before signaling it each time to trigger the wait callback.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void SetThreadpoolWait(win32.System.SystemServices.TP_WAIT*pwa, win32.System.SystemServices.HANDLE h, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*pftTimeout);
        /// <inheritdoc cref = "WaitForThreadpoolWaitCallbacks(win32.System.SystemServices.TP_WAIT*, bool)"/>
        internal static unsafe void WaitForThreadpoolWaitCallbacks(ref win32.System.SystemServices.TP_WAIT pwa, bool fCancelPendingCallbacks)
        {
            fixed (win32.System.SystemServices.TP_WAIT*pwaLocal = &pwa)
            {
                Kernel32.WaitForThreadpoolWaitCallbacks(pwaLocal, fCancelPendingCallbacks);
            }
        }

        /// <summary>Waits for outstanding wait callbacks to complete and optionally cancels pending callbacks that have not yet started to execute.</summary>
        /// <param name = "pwa">A pointer to a <b>TP_WAIT</b> structure that defines the wait object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwait">CreateThreadpoolWait</a> function returns this pointer.</param>
        /// <param name = "fCancelPendingCallbacks">Indicates whether to cancel queued callbacks that have not yet started to execute.</param>
        /// <remarks>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-waitforthreadpoolwaitcallbacks#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void WaitForThreadpoolWaitCallbacks(win32.System.SystemServices.TP_WAIT*pwa, bool fCancelPendingCallbacks);
        /// <inheritdoc cref = "CloseThreadpoolWait(win32.System.SystemServices.TP_WAIT*)"/>
        internal static unsafe void CloseThreadpoolWait(ref win32.System.SystemServices.TP_WAIT pwa)
        {
            fixed (win32.System.SystemServices.TP_WAIT*pwaLocal = &pwa)
            {
                Kernel32.CloseThreadpoolWait(pwaLocal);
            }
        }

        /// <summary>Releases the specified wait object.</summary>
        /// <param name = "pwa">A pointer to a <b>TP_WAIT</b> structure that defines the wait object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwait">CreateThreadpoolWait</a> function returns this pointer.</param>
        /// <remarks>
        /// <para>The wait object is freed immediately if there are no outstanding callbacks; otherwise, the timer object is freed asynchronously after the outstanding callbacks complete.</para>
        /// <para>In some cases, callback functions might run after <b>CloseThreadpoolWait</b> has been called. To prevent this behavior:</para>
        /// <para>* Call the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait">SetThreadpoolWait</a> function or <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwaitex">SetThreadpoolWaitEx</a> function with the <i>h</i> parameter set to NULL. * Call the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-waitforthreadpoolwaitcallbacks">WaitForThreadpoolWaitCallbacks</a> function. * Call <b>CloseThreadpoolWait</b>.</para>
        /// <para>If there is a cleanup group associated with the wait object, it is not necessary to call this function; calling the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolcleanupgroupmembers">CloseThreadpoolCleanupGroupMembers</a> function releases the  work, wait, and timer objects associated with the cleanup group.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-closethreadpoolwait#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void CloseThreadpoolWait(win32.System.SystemServices.TP_WAIT*pwa);
        /// <inheritdoc cref = "CreateThreadpoolIo(win32.System.SystemServices.HANDLE, delegate *unmanaged[Stdcall]{win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, void *, uint, nuint, win32.System.SystemServices.TP_IO*, void}, void *, win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3*)"/>
        internal static unsafe win32.System.SystemServices.TP_IO*CreateThreadpoolIo(SafeHandle fl, delegate *unmanaged[Stdcall]<win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, void *, uint, nuint, win32.System.SystemServices.TP_IO*, void>pfnio, void *pv, win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3? pcbe)
        {
            bool flAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE flLocal;
                if (fl is object)
                {
                    fl.DangerousAddRef(ref flAddRef);
                    flLocal = (win32.System.SystemServices.HANDLE)fl.DangerousGetHandle();
                }
                else
                    flLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3 pcbeLocal = pcbe.HasValue ? pcbe.Value : default(win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3);
                win32.System.SystemServices.TP_IO*__result = Kernel32.CreateThreadpoolIo(flLocal, pfnio, pv, pcbe.HasValue ? &pcbeLocal : null);
                return __result;
            }
            finally
            {
                if (flAddRef)
                    fl.DangerousRelease();
            }
        }

        /// <summary>Creates a new I/O completion object.</summary>
        /// <param name = "fl">The file handle to bind to this I/O completion object.</param>
        /// <param name = "pfnio">The callback function to be called each time  an overlapped I/O operation completes on the file. For details, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms684124(v=vs.85)">IoCompletionCallback</a>.</param>
        /// <param name = "pv">Optional application-defined data to pass to the callback function.</param>
        /// <param name = "pcbe">
        /// <para>A pointer to a <b>TP_CALLBACK_ENVIRON</b> structure that defines the environment in which to execute the callback. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-initializethreadpoolenvironment">InitializeThreadpoolEnvironment</a> function to initialize the structure before calling this function.</para>
        /// <para>If this parameter is NULL, the callback executes in the default callback environment. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-initializethreadpoolenvironment">InitializeThreadpoolEnvironment</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-createthreadpoolio#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns a pointer to a <b>TP_IO</b> structure that defines the I/O object. Applications do not modify the members of this structure.</para>
        /// <para>If the function fails, it returns NULL. To retrieve extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-createthreadpoolio">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.TP_IO*CreateThreadpoolIo(win32.System.SystemServices.HANDLE fl, delegate *unmanaged[Stdcall]<win32.System.SystemServices.TP_CALLBACK_INSTANCE*, void *, void *, uint, nuint, win32.System.SystemServices.TP_IO*, void>pfnio, [Optional] void *pv, [Optional] win32.System.SystemServices.TP_CALLBACK_ENVIRON_V3*pcbe);
        /// <inheritdoc cref = "StartThreadpoolIo(win32.System.SystemServices.TP_IO*)"/>
        internal static unsafe void StartThreadpoolIo(ref win32.System.SystemServices.TP_IO pio)
        {
            fixed (win32.System.SystemServices.TP_IO*pioLocal = &pio)
            {
                Kernel32.StartThreadpoolIo(pioLocal);
            }
        }

        /// <summary>Notifies the thread pool that I/O operations may possibly begin for the specified I/O completion object. A worker thread calls the I/O completion object's callback function after the operation completes on the file handle bound to this object.</summary>
        /// <param name = "pio">A pointer to a <b>TP_IO</b> structure that defines the I/O completion object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio">CreateThreadpoolIo</a> function returns this pointer.</param>
        /// <remarks>
        /// <para>You must call this function before initiating each asynchronous I/O operation on the file handle bound to the I/O completion object. Failure to do so will cause the thread pool to ignore an I/O operation when it completes and will cause memory corruption.</para>
        /// <para>If the I/O operation fails, call the <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-cancelthreadpoolio">CancelThreadpoolIo</a> function to cancel this notification.</para>
        /// <para>If the file handle bound to the I/O completion object has the notification mode FILE_SKIP_COMPLETION_PORT_ON_SUCCESS and an asynchronous I/O operation returns immediately with success, the object's I/O completion callback function is not called and threadpool I/O notifications must be canceled. For more information, see  <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-cancelthreadpoolio">CancelThreadpoolIo</a>.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-startthreadpoolio#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void StartThreadpoolIo(win32.System.SystemServices.TP_IO*pio);
        /// <inheritdoc cref = "CancelThreadpoolIo(win32.System.SystemServices.TP_IO*)"/>
        internal static unsafe void CancelThreadpoolIo(ref win32.System.SystemServices.TP_IO pio)
        {
            fixed (win32.System.SystemServices.TP_IO*pioLocal = &pio)
            {
                Kernel32.CancelThreadpoolIo(pioLocal);
            }
        }

        /// <summary>Cancels the notification from the StartThreadpoolIo function.</summary>
        /// <param name = "pio">A pointer to a <b>TP_IO</b> structure that defines the I/O completion object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio">CreateThreadpoolIo</a> function returns this pointer.</param>
        /// <remarks>
        /// <para>To prevent memory leaks, you must call the <b>CancelThreadpoolIo</b> function for either of the following scenarios:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-cancelthreadpoolio#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void CancelThreadpoolIo(win32.System.SystemServices.TP_IO*pio);
        /// <inheritdoc cref = "WaitForThreadpoolIoCallbacks(win32.System.SystemServices.TP_IO*, bool)"/>
        internal static unsafe void WaitForThreadpoolIoCallbacks(ref win32.System.SystemServices.TP_IO pio, bool fCancelPendingCallbacks)
        {
            fixed (win32.System.SystemServices.TP_IO*pioLocal = &pio)
            {
                Kernel32.WaitForThreadpoolIoCallbacks(pioLocal, fCancelPendingCallbacks);
            }
        }

        /// <summary>Waits for outstanding I/O completion callbacks to complete and optionally cancels pending callbacks that have not yet started to execute.</summary>
        /// <param name = "pio">A pointer to a <b>TP_IO</b> structure that defines the I/O completion object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio">CreateThreadpoolIo</a> function returns this pointer.</param>
        /// <param name = "fCancelPendingCallbacks">Indicates whether to cancel queued callbacks that have not yet started to execute.</param>
        /// <remarks>
        /// <para>When <i>fCancelPendingCallbacks</i> is set to TRUE, only queued callbacks are canceled. Pending I/O requests are not canceled. Therefore, the caller should call <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> for the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure to check whether the I/O operation has completed before freeing the structure. As an alternative, set <i>fCancelPendingCallbacks</i> to FALSE and have the associated I/O completion callback free the <b>OVERLAPPED</b> structure. Be careful not to free the <b>OVERLAPPED</b> structure while I/O requests are still pending; use <b>GetOverlappedResult</b> to determine the status of the I/O operation and wait for the operation to complete. The <a href = "https://docs.microsoft.com/windows/desktop/FileIO/cancelioex-func">CancelIoEx</a> function can optionally be used first to cancel outstanding I/O requests, potentially shortening the wait. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/canceling-pending-i-o-operations">Canceling Pending I/O Operations</a>.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-waitforthreadpooliocallbacks#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void WaitForThreadpoolIoCallbacks(win32.System.SystemServices.TP_IO*pio, bool fCancelPendingCallbacks);
        /// <inheritdoc cref = "CloseThreadpoolIo(win32.System.SystemServices.TP_IO*)"/>
        internal static unsafe void CloseThreadpoolIo(ref win32.System.SystemServices.TP_IO pio)
        {
            fixed (win32.System.SystemServices.TP_IO*pioLocal = &pio)
            {
                Kernel32.CloseThreadpoolIo(pioLocal);
            }
        }

        /// <summary>Releases the specified I/O completion object.</summary>
        /// <param name = "pio">A pointer to a <b>TP_IO</b> structure that defines the I/O completion object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio">CreateThreadpoolIo</a> function returns this pointer.</param>
        /// <remarks>
        /// <para>The I/O completion object is freed immediately if there are no outstanding callbacks; otherwise, the I/O completion object is freed asynchronously after the outstanding callbacks complete.</para>
        /// <para>You should close the associated file handle and wait for all outstanding overlapped I/O operations to complete before calling this function. You must not cause any more overlapped I/O operations to occur after calling this function.</para>
        /// <para>It may be necessary to cancel threadpool I/O notifications to prevent memory leaks. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-cancelthreadpoolio">CancelThreadpoolIo</a>.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-closethreadpoolio#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void CloseThreadpoolIo(win32.System.SystemServices.TP_IO*pio);
        /// <inheritdoc cref = "SetThreadpoolTimerEx(win32.System.SystemServices.TP_TIMER*, global::System.Runtime.InteropServices.ComTypes.FILETIME*, uint, uint)"/>
        internal static unsafe bool SetThreadpoolTimerEx(ref win32.System.SystemServices.TP_TIMER pti, global::System.Runtime.InteropServices.ComTypes.FILETIME? pftDueTime, uint msPeriod, uint msWindowLength)
        {
            fixed (win32.System.SystemServices.TP_TIMER*ptiLocal = &pti)
            {
                global::System.Runtime.InteropServices.ComTypes.FILETIME pftDueTimeLocal = pftDueTime.HasValue ? pftDueTime.Value : default(global::System.Runtime.InteropServices.ComTypes.FILETIME);
                bool __result = Kernel32.SetThreadpoolTimerEx(ptiLocal, pftDueTime.HasValue ? &pftDueTimeLocal : null, msPeriod, msWindowLength);
                return __result;
            }
        }

        /// <summary>Sets the timer object�, replacing the previous timer, if any. A worker thread calls the timer object's callback after the specified timeout expires.</summary>
        /// <param name = "pti">A pointer to a <b>TP_TIMER</b> structure that defines the timer object to set. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer">CreateThreadpoolTimer</a> function returns this pointer.</param>
        /// <param name = "pftDueTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the absolute or relative time at which the timer should expire.  If this parameter points to a positive value, it indicates the absolute time since January 1, 1601 (UTC), measured in 100 nanosecond units. If this parameter points to a negative value, it indicates the amount of time to wait relative to the current time. If this parameter points to zero, then the timer expires immediately. For more information about time values, see <a href = "https://docs.microsoft.com/windows/desktop/SysInfo/file-times">File Times</a>.</para>
        /// <para>If this parameter is NULL, the timer object will cease to queue new callbacks (but callbacks already queued will still occur).</para>
        /// <para>The timer is set if the <i>pftDueTime</i> parameter is non-NULL.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpooltimerex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "msPeriod">The timer period, in milliseconds. If this parameter is zero, the timer is signaled once. If this parameter is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled.</param>
        /// <param name = "msWindowLength">The maximum amount of time the system can delay before calling the timer callback. If this parameter is set, the system can batch calls to conserve power.</param>
        /// <returns>
        /// <para>Returns TRUE if the timer was previously set and was canceled. Otherwise returns FALSE.</para>
        /// <para>If the timer's previous state was "set", and the function returns FALSE, then a callback is in progress or about to commence. See the remarks for further discussion.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpooltimerex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetThreadpoolTimerEx(win32.System.SystemServices.TP_TIMER*pti, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*pftDueTime, uint msPeriod, uint msWindowLength);
        /// <inheritdoc cref = "SetThreadpoolWaitEx(win32.System.SystemServices.TP_WAIT*, win32.System.SystemServices.HANDLE, global::System.Runtime.InteropServices.ComTypes.FILETIME*, void *)"/>
        internal static unsafe bool SetThreadpoolWaitEx(ref win32.System.SystemServices.TP_WAIT pwa, SafeHandle h, global::System.Runtime.InteropServices.ComTypes.FILETIME? pftTimeout, void *Reserved)
        {
            bool hAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.TP_WAIT*pwaLocal = &pwa)
                {
                    win32.System.SystemServices.HANDLE hLocal;
                    if (h is object)
                    {
                        h.DangerousAddRef(ref hAddRef);
                        hLocal = (win32.System.SystemServices.HANDLE)h.DangerousGetHandle();
                    }
                    else
                        hLocal = default(win32.System.SystemServices.HANDLE);
                    global::System.Runtime.InteropServices.ComTypes.FILETIME pftTimeoutLocal = pftTimeout.HasValue ? pftTimeout.Value : default(global::System.Runtime.InteropServices.ComTypes.FILETIME);
                    bool __result = Kernel32.SetThreadpoolWaitEx(pwaLocal, hLocal, pftTimeout.HasValue ? &pftTimeoutLocal : null, Reserved);
                    return __result;
                }
            }
            finally
            {
                if (hAddRef)
                    h.DangerousRelease();
            }
        }

        /// <summary>Sets the wait object�replacing the previous wait object, if any. A worker thread calls the wait object's callback function after the handle becomes signaled or after the specified timeout expires.</summary>
        /// <param name = "pwa">A pointer to a <b>TP_WAIT</b> structure that defines the wait object. The <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwait">CreateThreadpoolWait</a> function returns this pointer.</param>
        /// <param name = "h">
        /// <para>A handle.</para>
        /// <para>If this parameter is NULL, the wait object will cease to queue new callbacks (but callbacks already queued will still occur).</para>
        /// <para>If this parameter is not NULL, it must refer to a valid waitable object.</para>
        /// <para>If this handle is closed while the wait is still pending, the function's behavior is undefined. If the wait is still pending and the handle must be closed, use <a href = "https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolwait">CloseThreadpoolWait</a> to cancel the wait and then close the handle.</para>
        /// <para>The wait is considered set if this parameter is non-NULL.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpoolwaitex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pftTimeout">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the absolute or relative time at which the wait operation should time out.  If this parameter points to a positive value, it indicates the absolute time since January 1, 1601 (UTC), in 100-nanosecond intervals. If this parameter points to a negative value, it indicates the amount of time to wait relative to the current time. If this parameter points to zero, then the wait times out immediately. For more information about time values, see <a href = "https://docs.microsoft.com/windows/desktop/SysInfo/file-times">File Times</a>.</para>
        /// <para>If this parameter is NULL, then the wait does not time out.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpoolwaitex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Reserved">
        /// <para>Reserved. Must be NULL.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpoolwaitex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns TRUE if the wait was previously set and was canceled. Otherwise returns FALSE.</para>
        /// <para>If the wait's previous state was "set", and the function returns FALSE, then a callback is in progress or about to commence. See the remarks for further discussion.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//threadpoolapiset/nf-threadpoolapiset-setthreadpoolwaitex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetThreadpoolWaitEx(win32.System.SystemServices.TP_WAIT*pwa, win32.System.SystemServices.HANDLE h, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*pftTimeout, void *Reserved);
        /// <inheritdoc cref = "CompareFileTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe int CompareFileTime(in global::System.Runtime.InteropServices.ComTypes.FILETIME lpFileTime1, in global::System.Runtime.InteropServices.ComTypes.FILETIME lpFileTime2)
        {
            fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTime2Local = &lpFileTime2)
            {
                fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTime1Local = &lpFileTime1)
                {
                    int __result = Kernel32.CompareFileTime(lpFileTime1Local, lpFileTime2Local);
                    return __result;
                }
            }
        }

        /// <summary>Compares two file times.</summary>
        /// <param name = "lpFileTime1">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the first file time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-comparefiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileTime2">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the second file time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-comparefiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>The return value is one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-comparefiletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int CompareFileTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTime1, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTime2);
        /// <inheritdoc cref = "FileTimeToLocalFileTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe bool FileTimeToLocalFileTime(in global::System.Runtime.InteropServices.ComTypes.FILETIME lpFileTime, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpLocalFileTime)
        {
            fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpLocalFileTimeLocal = &lpLocalFileTime)
            {
                fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTimeLocal = &lpFileTime)
                {
                    bool __result = Kernel32.FileTimeToLocalFileTime(lpFileTimeLocal, lpLocalFileTimeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Converts a file time to a local file time.</summary>
        /// <param name = "lpFileTime">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure containing the UTC-based file time to be converted into a local file time.</param>
        /// <param name = "lpLocalFileTime">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the converted local file time. This parameter cannot be the same as the <i>lpFileTime</i> parameter.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-filetimetolocalfiletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool FileTimeToLocalFileTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpLocalFileTime);
        /// <inheritdoc cref = "GetFileTime(win32.System.SystemServices.HANDLE, global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe bool GetFileTime(SafeHandle hFile, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpCreationTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpLastAccessTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpLastWriteTime)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.GetFileTime(hFileLocal, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the date and time that a file or directory was created, last accessed, and last modified.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file or directory for which dates and times are to be retrieved. The handle must have been created using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with the <b>GENERIC_READ</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCreationTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the date and time the file or directory was created. This parameter can be <b>NULL</b> if the application does not require this information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpLastAccessTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the date and time the file or directory was last accessed. The last access time includes the last time the file or directory was written to, read from, or, in the case of executable files, run. This parameter can be <b>NULL</b> if the application does not require this information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpLastWriteTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the date and time the file or directory was last written to, truncated, or overwritten (for example, with <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile</a>). This date and time is not updated when file attributes or security descriptors are changed. This parameter can be <b>NULL</b> if the application does not require this information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfiletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetFileTime(win32.System.SystemServices.HANDLE hFile, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*lpCreationTime, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*lpLastAccessTime, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*lpLastWriteTime);
        /// <inheritdoc cref = "LocalFileTimeToFileTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe bool LocalFileTimeToFileTime(in global::System.Runtime.InteropServices.ComTypes.FILETIME lpLocalFileTime, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpFileTime)
        {
            fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTimeLocal = &lpFileTime)
            {
                fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpLocalFileTimeLocal = &lpLocalFileTime)
                {
                    bool __result = Kernel32.LocalFileTimeToFileTime(lpLocalFileTimeLocal, lpFileTimeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Converts a local file time to a file time based on the Coordinated Universal Time (UTC).</summary>
        /// <param name = "lpLocalFileTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the local file time to be converted into a UTC-based file time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-localfiletimetofiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the converted UTC-based file time. This parameter cannot be the same as the <i>lpLocalFileTime</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-localfiletimetofiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-localfiletimetofiletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool LocalFileTimeToFileTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*lpLocalFileTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTime);
        /// <inheritdoc cref = "SetFileTime(win32.System.SystemServices.HANDLE, global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe bool SetFileTime(SafeHandle hFile, global::System.Runtime.InteropServices.ComTypes.FILETIME? lpCreationTime, global::System.Runtime.InteropServices.ComTypes.FILETIME? lpLastAccessTime, global::System.Runtime.InteropServices.ComTypes.FILETIME? lpLastWriteTime)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                global::System.Runtime.InteropServices.ComTypes.FILETIME lpCreationTimeLocal = lpCreationTime.HasValue ? lpCreationTime.Value : default(global::System.Runtime.InteropServices.ComTypes.FILETIME);
                global::System.Runtime.InteropServices.ComTypes.FILETIME lpLastAccessTimeLocal = lpLastAccessTime.HasValue ? lpLastAccessTime.Value : default(global::System.Runtime.InteropServices.ComTypes.FILETIME);
                global::System.Runtime.InteropServices.ComTypes.FILETIME lpLastWriteTimeLocal = lpLastWriteTime.HasValue ? lpLastWriteTime.Value : default(global::System.Runtime.InteropServices.ComTypes.FILETIME);
                bool __result = Kernel32.SetFileTime(hFileLocal, lpCreationTime.HasValue ? &lpCreationTimeLocal : null, lpLastAccessTime.HasValue ? &lpLastAccessTimeLocal : null, lpLastWriteTime.HasValue ? &lpLastWriteTimeLocal : null);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Sets the date and time that the specified file or directory was created, last accessed, or last modified.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file or directory. The handle must have been created using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function  with the <b>FILE_WRITE_ATTRIBUTES</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCreationTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that contains the new creation date and time for the file or directory. If the application does not need to change this information, set this parameter either to <b>NULL</b> or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 0.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpLastAccessTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that contains the new last access date and time for the file or directory. The last access time includes the last time the file or directory was written to, read from, or (in the case of executable files) run. If the application does not need to change this information, set this parameter either to <b>NULL</b> or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 0.</para>
        /// <para>To prevent file operations using the given handle from modifying the last access time, call <b>SetFileTime</b> immediately  after opening the file handle and pass a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 0xFFFFFFFF.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpLastWriteTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that contains the new last modified date and time for the file or directory.  If the application does not need to change this information, set this parameter either  to <b>NULL</b>  or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 0.</para>
        /// <para>To prevent file operations using the given handle from modifying the last access time, call <b>SetFileTime</b> immediately after opening the file handle and pass a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 0xFFFFFFFF.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfiletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetFileTime(win32.System.SystemServices.HANDLE hFile, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*lpCreationTime, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*lpLastAccessTime, [Optional] global::System.Runtime.InteropServices.ComTypes.FILETIME*lpLastWriteTime);
        /// <summary>Retrieves the path of the system directory used by WOW64.</summary>
        /// <param name = "lpBuffer">A pointer to the buffer to receive the path. This path does not end with a backslash.</param>
        /// <param name = "uSize">The maximum size of the buffer, in <b>TCHARs</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to the buffer, not including the terminating null character. If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>On 32-bit Windows, the function always fails, and the extended error is set to ERROR_CALL_NOT_IMPLEMENTED.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-getsystemwow64directoryw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetSystemWow64DirectoryW", SetLastError = true)]
        internal static extern uint GetSystemWow64Directory(win32.System.SystemServices.PWSTR lpBuffer, uint uSize);
        /// <inheritdoc cref = "IsWow64GuestMachineSupported(ushort, bool *)"/>
        internal static unsafe win32.System.Com.HRESULT IsWow64GuestMachineSupported(ushort WowGuestMachine, out bool MachineIsSupported)
        {
            fixed (bool *MachineIsSupportedLocal = &MachineIsSupported)
            {
                win32.System.Com.HRESULT __result = Kernel32.IsWow64GuestMachineSupported(WowGuestMachine, MachineIsSupportedLocal);
                return __result;
            }
        }

        /// <summary>Determines which architectures are supported (under WOW64) on the given machine architecture.</summary>
        /// <param name = "WowGuestMachine">An <a href = "https://docs.microsoft.com/windows/desktop/SysInfo/image-file-machine-constants">IMAGE_FILE_MACHINE_*</a> value that specifies the machine to test.</param>
        /// <param name = "MachineIsSupported">On success, returns a pointer to a boolean: <b>true</b> if the machine supports WOW64, or <b>false</b> if it does not.</param>
        /// <returns>On success, returns <b>S_OK</b>; otherwise, returns an error. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-iswow64guestmachinesupported">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.Com.HRESULT IsWow64GuestMachineSupported(ushort WowGuestMachine, bool *MachineIsSupported);
        /// <param name = "NewEnvironment">
        /// <para>The environment variable string using the following format:</para>
        /// <para><i>Var1</i> <i>Value1</i> <i>Var2</i> <i>Value2</i> <i>Var3</i> <i>Value3</i> <i>VarN</i> <i>ValueN</i></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-setenvironmentstringsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>Returns S_OK on success.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-setenvironmentstringsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetEnvironmentStringsW")]
        internal static extern bool SetEnvironmentStrings(win32.System.SystemServices.PWSTR NewEnvironment);
        /// <inheritdoc cref = "GetStdHandle(win32.System.WindowsProgramming.STD_HANDLE_TYPE)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle GetStdHandle_SafeHandle(win32.System.WindowsProgramming.STD_HANDLE_TYPE nStdHandle)
        {
            win32.System.SystemServices.HANDLE __result = Kernel32.GetStdHandle(nStdHandle);
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.HANDLE GetStdHandle(win32.System.WindowsProgramming.STD_HANDLE_TYPE nStdHandle);
        /// <inheritdoc cref = "SetStdHandle(win32.System.WindowsProgramming.STD_HANDLE_TYPE, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool SetStdHandle(win32.System.WindowsProgramming.STD_HANDLE_TYPE nStdHandle, SafeHandle hHandle)
        {
            bool hHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hHandleLocal;
                if (hHandle is object)
                {
                    hHandle.DangerousAddRef(ref hHandleAddRef);
                    hHandleLocal = (win32.System.SystemServices.HANDLE)hHandle.DangerousGetHandle();
                }
                else
                    hHandleLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetStdHandle(nStdHandle, hHandleLocal);
                return __result;
            }
            finally
            {
                if (hHandleAddRef)
                    hHandle.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SetStdHandle(win32.System.WindowsProgramming.STD_HANDLE_TYPE nStdHandle, win32.System.SystemServices.HANDLE hHandle);
        /// <inheritdoc cref = "SetStdHandleEx(win32.System.WindowsProgramming.STD_HANDLE_TYPE, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE*)"/>
        internal static unsafe bool SetStdHandleEx(win32.System.WindowsProgramming.STD_HANDLE_TYPE nStdHandle, SafeHandle hHandle, out Microsoft.Win32.SafeHandles.SafeFileHandle phPrevValue)
        {
            bool hHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hHandleLocal;
                if (hHandle is object)
                {
                    hHandle.DangerousAddRef(ref hHandleAddRef);
                    hHandleLocal = (win32.System.SystemServices.HANDLE)hHandle.DangerousGetHandle();
                }
                else
                    hHandleLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE phPrevValueLocal;
                bool __result = Kernel32.SetStdHandleEx(nStdHandle, hHandleLocal, &phPrevValueLocal);
                phPrevValue = new Microsoft.Win32.SafeHandles.SafeFileHandle(phPrevValueLocal, ownsHandle: true);
                return __result;
            }
            finally
            {
                if (hHandleAddRef)
                    hHandle.DangerousRelease();
            }
        }

        /// <param name = "nStdHandle">A DWORD indicating the stream for which the handle is being set.</param>
        /// <param name = "hHandle">The handle.</param>
        /// <param name = "phPrevValue">Optional. Receives the previous handle.</param>
        /// <returns>Returns S_OK on success.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-setstdhandleex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetStdHandleEx(win32.System.WindowsProgramming.STD_HANDLE_TYPE nStdHandle, win32.System.SystemServices.HANDLE hHandle, [Optional] win32.System.SystemServices.HANDLE*phPrevValue);
        /// <summary>Retrieves the command-line string for the current process.</summary>
        /// <returns>The return value is a pointer to the command-line string for the current process.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-getcommandlinew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetCommandLineW")]
        internal static extern win32.System.SystemServices.PWSTR GetCommandLine();
        /// <summary>Retrieves the environment variables for the current process.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is a pointer to the environment block of the current process.</para>
        /// <para>If the function fails, the return value is NULL.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-getenvironmentstrings">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.PSTR GetEnvironmentStrings();
        /// <summary>Retrieves the environment variables for the current process.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is a pointer to the environment block of the current process.</para>
        /// <para>If the function fails, the return value is NULL.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-getenvironmentstringsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.SystemServices.PWSTR GetEnvironmentStringsW();
        /// <summary>Frees a block of environment strings.</summary>
        /// <param name = "penv">
        /// <para>A pointer to a block of environment strings. The pointer to the block must be obtained by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/rrascfg/nf-rrascfg-ieapproviderconfig-initialize">GetEnvironmentStrings</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-freeenvironmentstringsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-freeenvironmentstringsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FreeEnvironmentStringsW", SetLastError = true)]
        internal static extern bool FreeEnvironmentStrings(win32.System.SystemServices.PWSTR penv);
        /// <inheritdoc cref = "GetEnvironmentVariable(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint GetEnvironmentVariable(string lpName, win32.System.SystemServices.PWSTR lpBuffer, uint nSize)
        {
            fixed (char *lpNameLocal = lpName)
            {
                uint __result = Kernel32.GetEnvironmentVariable(lpNameLocal, lpBuffer, nSize);
                return __result;
            }
        }

        /// <summary>Retrieves the contents of the specified variable from the environment block of the calling process.</summary>
        /// <param name = "lpName">The name of the environment variable.</param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to a buffer that receives the contents of the specified environment variable as a null-terminated string.</para>
        /// <para>The maximum size of a user-defined environment variable is 32,767 characters. There is no technical limitation on the size of the environment block. However, there are practical limits depending on the mechanism used to access the block. For example, a batch file cannot set a variable that is longer than the maximum command line length. For more information, see [Environment Variables](/windows/desktop/ProcThread/environment-variables).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-getenvironmentvariablew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nSize">The size of the buffer pointed to by the <i>lpBuffer</i> parameter, including the null-terminating character, in characters.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the number of characters stored in the buffer pointed to by <i>lpBuffer</i>, not including the terminating null character.</para>
        /// <para>If <i>lpBuffer</i> is not large enough to hold the data, the return value is the buffer size, in characters, required to hold the string and its terminating null character and the contents of <i>lpBuffer</i> are undefined.</para>
        /// <para>If the function fails, the return value is zero. If the specified environment variable was not found in the environment block, <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_ENVVAR_NOT_FOUND.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-getenvironmentvariablew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetEnvironmentVariableW", SetLastError = true)]
        internal static extern uint GetEnvironmentVariable(win32.System.SystemServices.PCWSTR lpName, win32.System.SystemServices.PWSTR lpBuffer, uint nSize);
        /// <inheritdoc cref = "SetEnvironmentVariable(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetEnvironmentVariable(string lpName, string lpValue)
        {
            fixed (char *lpValueLocal = lpValue)
            {
                fixed (char *lpNameLocal = lpName)
                {
                    bool __result = Kernel32.SetEnvironmentVariable(lpNameLocal, lpValueLocal);
                    return __result;
                }
            }
        }

        /// <summary>Sets the contents of the specified environment variable for the current process.</summary>
        /// <param name = "lpName">The name of the environment variable. The operating system creates the environment variable if it does not exist and <i>lpValue</i> is not NULL.</param>
        /// <param name = "lpValue">
        /// <para>The contents of the environment variable.</para>
        /// <para>The maximum size of a user-defined environment variable is 32,767 characters. There is no technical limitation on the size of the environment block. However, there are practical limits depending on the mechanism used to access the block. For example, a batch file cannot set a variable that is longer than the maximum command line length. For more information, see [Environment Variables](/windows/desktop/ProcThread/environment-variables).</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>The total size of the environment block for a process may not exceed 32,767 characters.</para>
        /// <para>If this parameter is NULL, the variable is deleted from the current process's environment.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-setenvironmentvariablew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-setenvironmentvariablew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetEnvironmentVariableW", SetLastError = true)]
        internal static extern bool SetEnvironmentVariable(win32.System.SystemServices.PCWSTR lpName, win32.System.SystemServices.PCWSTR lpValue);
        /// <inheritdoc cref = "ExpandEnvironmentStrings(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint ExpandEnvironmentStrings(string lpSrc, win32.System.SystemServices.PWSTR lpDst, uint nSize)
        {
            fixed (char *lpSrcLocal = lpSrc)
            {
                uint __result = Kernel32.ExpandEnvironmentStrings(lpSrcLocal, lpDst, nSize);
                return __result;
            }
        }

        /// <summary>Expands environment-variable strings and replaces them with the values defined for the current user.</summary>
        /// <param name = "lpSrc">
        /// <para>A buffer that contains one or more environment-variable strings in the form: %<i>variableName</i>%. For each such reference, the %<i>variableName</i>% portion is replaced with the current value of that environment variable.</para>
        /// <para>Case is ignored when looking up the environment-variable name. If the name is not found, the %<i>variableName</i>% portion is left unexpanded.</para>
        /// <para>Note that this function does not support all the features that Cmd.exe supports. For example, it does not support %<i>variableName</i>:<i>str1</i>=<i>str2</i>% or %<i>variableName</i>:~<i>offset</i>,<i>length</i>%.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-expandenvironmentstringsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDst">A pointer to a buffer that receives the result of expanding the environment variable strings in the <i>lpSrc</i> buffer. Note that this buffer cannot be the same as the <i>lpSrc</i> buffer.</param>
        /// <param name = "nSize">The maximum number of characters that can be stored in the buffer pointed to by the <i>lpDst</i> parameter. When using ANSI strings, the buffer size should be the string length, plus terminating null character, plus one. When using Unicode strings, the buffer size should be the string length plus the terminating null character.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored in the destination buffer, including the terminating null character. If the destination buffer is too small to hold the expanded string, the return value is the required buffer size, in characters.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-expandenvironmentstringsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "ExpandEnvironmentStringsW", SetLastError = true)]
        internal static extern uint ExpandEnvironmentStrings(win32.System.SystemServices.PCWSTR lpSrc, win32.System.SystemServices.PWSTR lpDst, uint nSize);
        /// <inheritdoc cref = "SetCurrentDirectory(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetCurrentDirectory(string lpPathName)
        {
            fixed (char *lpPathNameLocal = lpPathName)
            {
                bool __result = Kernel32.SetCurrentDirectory(lpPathNameLocal);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetCurrentDirectoryW")]
        internal static extern bool SetCurrentDirectory(win32.System.SystemServices.PCWSTR lpPathName);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetCurrentDirectoryW")]
        internal static extern uint GetCurrentDirectory(uint nBufferLength, win32.System.SystemServices.PWSTR lpBuffer);
        /// <inheritdoc cref = "NeedCurrentDirectoryForExePath(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool NeedCurrentDirectoryForExePath(string ExeName)
        {
            fixed (char *ExeNameLocal = ExeName)
            {
                bool __result = Kernel32.NeedCurrentDirectoryForExePath(ExeNameLocal);
                return __result;
            }
        }

        /// <summary>Determines whether the current directory should be included in the search path for the specified executable.</summary>
        /// <param name = "ExeName">The name of the executable file.</param>
        /// <returns>If the current directory should be part of the search path, the return value is TRUE. Otherwise, the return value is FALSE.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-needcurrentdirectoryforexepathw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "NeedCurrentDirectoryForExePathW")]
        internal static extern bool NeedCurrentDirectoryForExePath(win32.System.SystemServices.PCWSTR ExeName);
        /// <inheritdoc cref = "DuplicateHandle(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE*, uint, bool, win32.System.WindowsProgramming.DUPLICATE_HANDLE_OPTIONS)"/>
        internal static unsafe bool DuplicateHandle(SafeHandle hSourceProcessHandle, SafeHandle hSourceHandle, SafeHandle hTargetProcessHandle, out Microsoft.Win32.SafeHandles.SafeFileHandle lpTargetHandle, uint dwDesiredAccess, bool bInheritHandle, win32.System.WindowsProgramming.DUPLICATE_HANDLE_OPTIONS dwOptions)
        {
            bool hSourceProcessHandleAddRef = false;
            bool hSourceHandleAddRef = false;
            bool hTargetProcessHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hSourceProcessHandleLocal;
                if (hSourceProcessHandle is object)
                {
                    hSourceProcessHandle.DangerousAddRef(ref hSourceProcessHandleAddRef);
                    hSourceProcessHandleLocal = (win32.System.SystemServices.HANDLE)hSourceProcessHandle.DangerousGetHandle();
                }
                else
                    hSourceProcessHandleLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE hSourceHandleLocal;
                if (hSourceHandle is object)
                {
                    hSourceHandle.DangerousAddRef(ref hSourceHandleAddRef);
                    hSourceHandleLocal = (win32.System.SystemServices.HANDLE)hSourceHandle.DangerousGetHandle();
                }
                else
                    hSourceHandleLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE hTargetProcessHandleLocal;
                if (hTargetProcessHandle is object)
                {
                    hTargetProcessHandle.DangerousAddRef(ref hTargetProcessHandleAddRef);
                    hTargetProcessHandleLocal = (win32.System.SystemServices.HANDLE)hTargetProcessHandle.DangerousGetHandle();
                }
                else
                    hTargetProcessHandleLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE lpTargetHandleLocal;
                bool __result = Kernel32.DuplicateHandle(hSourceProcessHandleLocal, hSourceHandleLocal, hTargetProcessHandleLocal, &lpTargetHandleLocal, dwDesiredAccess, bInheritHandle, dwOptions);
                lpTargetHandle = new Microsoft.Win32.SafeHandles.SafeFileHandle(lpTargetHandleLocal, ownsHandle: true);
                return __result;
            }
            finally
            {
                if (hSourceProcessHandleAddRef)
                    hSourceProcessHandle.DangerousRelease();
                if (hSourceHandleAddRef)
                    hSourceHandle.DangerousRelease();
                if (hTargetProcessHandleAddRef)
                    hTargetProcessHandle.DangerousRelease();
            }
        }

        /// <summary>Duplicates an object handle.</summary>
        /// <param name = "hSourceProcessHandle">
        /// <para>A handle to the process with the handle to be duplicated.</para>
        /// <para>The handle must have the PROCESS_DUP_HANDLE access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-duplicatehandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hSourceHandle">The handle to be duplicated. This is an open object handle that is valid in the context of the source process. For a list of objects whose handles can be duplicated, see the following Remarks section.</param>
        /// <param name = "hTargetProcessHandle">
        /// <para>A handle to the process that is to receive the duplicated handle. The handle must have the PROCESS_DUP_HANDLE access right.</para>
        /// <para>This parameter is optional and can be specified as NULL if the **DUPLICATE_CLOSE_SOURCE** flag is set in _Options_.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-duplicatehandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTargetHandle">
        /// <para>A pointer to a variable that receives the duplicate handle. This handle value is valid in the context of the target process.</para>
        /// <para>If <i>hSourceHandle</i> is a pseudo handle returned by <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess">GetCurrentProcess</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentthread">GetCurrentThread</a>, <b>DuplicateHandle</b> converts it to a real handle to a process or thread, respectively.</para>
        /// <para>If <i>lpTargetHandle</i> is <b>NULL</b>, the function duplicates the handle, but does not return the duplicate handle value to the caller. This behavior exists only for backward compatibility with previous versions of this function. You should not use this feature, as you will lose system resources until the target process terminates.</para>
        /// <para>This parameter is ignored if _hTargetProcessHandle_ is **NULL**.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-duplicatehandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">
        /// <para>The access requested for the new handle. For the flags that can be specified for each object type, see the following Remarks section.</para>
        /// <para>This parameter is ignored if the <i>dwOptions</i> parameter specifies the DUPLICATE_SAME_ACCESS flag. Otherwise, the flags that can be specified depend on the type of object whose handle is to be duplicated.</para>
        /// <para>This parameter is ignored if _hTargetProcessHandle_ is **NULL**.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-duplicatehandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInheritHandle">
        /// <para>A variable that indicates whether the handle is inheritable. If <b>TRUE</b>, the duplicate handle can be inherited by new processes created by the target process. If <b>FALSE</b>, the new handle cannot be inherited.</para>
        /// <para>This parameter is ignored if _hTargetProcessHandle_ is **NULL**.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-duplicatehandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwOptions"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-duplicatehandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool DuplicateHandle(win32.System.SystemServices.HANDLE hSourceProcessHandle, win32.System.SystemServices.HANDLE hSourceHandle, win32.System.SystemServices.HANDLE hTargetProcessHandle, win32.System.SystemServices.HANDLE*lpTargetHandle, uint dwDesiredAccess, bool bInheritHandle, win32.System.WindowsProgramming.DUPLICATE_HANDLE_OPTIONS dwOptions);
        /// <inheritdoc cref = "GetHandleInformation(win32.System.SystemServices.HANDLE, uint *)"/>
        internal static unsafe bool GetHandleInformation(SafeHandle hObject, out uint lpdwFlags)
        {
            bool hObjectAddRef = false;
            try
            {
                fixed (uint *lpdwFlagsLocal = &lpdwFlags)
                {
                    win32.System.SystemServices.HANDLE hObjectLocal;
                    if (hObject is object)
                    {
                        hObject.DangerousAddRef(ref hObjectAddRef);
                        hObjectLocal = (win32.System.SystemServices.HANDLE)hObject.DangerousGetHandle();
                    }
                    else
                        hObjectLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetHandleInformation(hObjectLocal, lpdwFlagsLocal);
                    return __result;
                }
            }
            finally
            {
                if (hObjectAddRef)
                    hObject.DangerousRelease();
            }
        }

        /// <summary>Retrieves certain properties of an object handle.</summary>
        /// <param name = "hObject">
        /// <para>A handle to an object whose information is to be retrieved.</para>
        /// <para>You can specify a handle to one of the following types of objects: access token, console input buffer, console screen buffer, event, file, file mapping, job, mailslot, mutex, pipe, printer, process, registry key, semaphore, serial communication device, socket, thread, or waitable timer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-gethandleinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpdwFlags">
        /// <para>A pointer to a variable that receives a set of bit flags that specify properties of the object handle or 0. The following values are defined.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-gethandleinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-gethandleinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetHandleInformation(win32.System.SystemServices.HANDLE hObject, uint *lpdwFlags);
        /// <inheritdoc cref = "SetHandleInformation(win32.System.SystemServices.HANDLE, uint, win32.System.WindowsProgramming.HANDLE_FLAG_OPTIONS)"/>
        internal static unsafe bool SetHandleInformation(SafeHandle hObject, uint dwMask, win32.System.WindowsProgramming.HANDLE_FLAG_OPTIONS dwFlags)
        {
            bool hObjectAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hObjectLocal;
                if (hObject is object)
                {
                    hObject.DangerousAddRef(ref hObjectAddRef);
                    hObjectLocal = (win32.System.SystemServices.HANDLE)hObject.DangerousGetHandle();
                }
                else
                    hObjectLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetHandleInformation(hObjectLocal, dwMask, dwFlags);
                return __result;
            }
            finally
            {
                if (hObjectAddRef)
                    hObject.DangerousRelease();
            }
        }

        /// <summary>Sets certain properties of an object handle.</summary>
        /// <param name = "hObject">
        /// <para>A handle to an object whose information is to be set.</para>
        /// <para>You can specify a handle to one of the following types of objects: access token, console input buffer, console screen buffer, event, file, file mapping, job, mailslot, mutex, pipe, printer, process, registry key, semaphore, serial communication device, socket, thread, or waitable timer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-sethandleinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMask">A mask that specifies the bit flags to be changed. Use the same constants shown in the description of <i>dwFlags</i>.</param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-sethandleinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetHandleInformation(win32.System.SystemServices.HANDLE hObject, uint dwMask, win32.System.WindowsProgramming.HANDLE_FLAG_OPTIONS dwFlags);
        /// <inheritdoc cref = "QueryPerformanceCounter(long *)"/>
        internal static unsafe bool QueryPerformanceCounter(out long lpPerformanceCount)
        {
            fixed (long *lpPerformanceCountLocal = &lpPerformanceCount)
            {
                bool __result = Kernel32.QueryPerformanceCounter(lpPerformanceCountLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the current value of the performance counter, which is a high resolution (&lt;1us) time stamp that can be used for time-interval measurements.</summary>
        /// <param name = "lpPerformanceCount">A pointer to a variable that receives the current performance-counter value, in counts.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. On systems that run Windows XP or later, the function will always succeed and will thus never return zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//profileapi/nf-profileapi-queryperformancecounter">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool QueryPerformanceCounter(long *lpPerformanceCount);
        /// <inheritdoc cref = "QueryPerformanceFrequency(long *)"/>
        internal static unsafe bool QueryPerformanceFrequency(out long lpFrequency)
        {
            fixed (long *lpFrequencyLocal = &lpFrequency)
            {
                bool __result = Kernel32.QueryPerformanceFrequency(lpFrequencyLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the frequency of the performance counter.</summary>
        /// <param name = "lpFrequency">A pointer to a variable that receives the current performance-counter frequency, in counts per second. If the installed hardware doesn't support a high-resolution performance counter, this parameter can be zero (this will not occur on systems that run Windows XP or later).</param>
        /// <returns>
        /// <para>If the installed hardware supports a high-resolution performance counter, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. On systems that run Windows XP or later, the function will always succeed and will thus never return zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//profileapi/nf-profileapi-queryperformancefrequency">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool QueryPerformanceFrequency(long *lpFrequency);
        /// <inheritdoc cref = "GlobalMemoryStatusEx(win32.System.WindowsProgramming.MEMORYSTATUSEX*)"/>
        internal static unsafe bool GlobalMemoryStatusEx(out win32.System.WindowsProgramming.MEMORYSTATUSEX lpBuffer)
        {
            fixed (win32.System.WindowsProgramming.MEMORYSTATUSEX*lpBufferLocal = &lpBuffer)
            {
                bool __result = Kernel32.GlobalMemoryStatusEx(lpBufferLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about the system's current usage of both physical and virtual memory.</summary>
        /// <param name = "lpBuffer">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/ns-sysinfoapi-memorystatusex">MEMORYSTATUSEX</a> structure that receives information about current memory availability.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-globalmemorystatusex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-globalmemorystatusex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GlobalMemoryStatusEx(win32.System.WindowsProgramming.MEMORYSTATUSEX*lpBuffer);
        /// <inheritdoc cref = "GetSystemInfo(win32.System.WindowsProgramming.SYSTEM_INFO*)"/>
        internal static unsafe void GetSystemInfo(out win32.System.WindowsProgramming.SYSTEM_INFO lpSystemInfo)
        {
            fixed (win32.System.WindowsProgramming.SYSTEM_INFO*lpSystemInfoLocal = &lpSystemInfo)
            {
                Kernel32.GetSystemInfo(lpSystemInfoLocal);
            }
        }

        /// <summary>Retrieves information about the current system.</summary>
        /// <param name = "lpSystemInfo">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/ns-sysinfoapi-system_info">SYSTEM_INFO</a> structure that receives the information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsysteminfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsysteminfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void GetSystemInfo(win32.System.WindowsProgramming.SYSTEM_INFO*lpSystemInfo);
        /// <inheritdoc cref = "GetSystemTime(win32.System.WindowsProgramming.SYSTEMTIME*)"/>
        internal static unsafe void GetSystemTime(out win32.System.WindowsProgramming.SYSTEMTIME lpSystemTime)
        {
            fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTimeLocal = &lpSystemTime)
            {
                Kernel32.GetSystemTime(lpSystemTimeLocal);
            }
        }

        /// <summary>Retrieves the current system date and time in Coordinated Universal Time (UTC) format.</summary>
        /// <param name = "lpSystemTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure to receive the current system date and time. The <i>lpSystemTime</i> parameter must not be <b>NULL</b>. Using <b>NULL</b> will result in an access violation.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemtime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>To set the current system date and time, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-setsystemtime">SetSystemTime</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemtime#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void GetSystemTime(win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTime);
        /// <inheritdoc cref = "GetSystemTimeAsFileTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe void GetSystemTimeAsFileTime(out global::System.Runtime.InteropServices.ComTypes.FILETIME lpSystemTimeAsFileTime)
        {
            fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpSystemTimeAsFileTimeLocal = &lpSystemTimeAsFileTime)
            {
                Kernel32.GetSystemTimeAsFileTime(lpSystemTimeAsFileTimeLocal);
            }
        }

        /// <summary>Retrieves the current system date and time. The information is in Coordinated Universal Time (UTC) format.</summary>
        /// <param name = "lpSystemTimeAsFileTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the current system date and time in UTC format.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemtimeasfiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemtimeasfiletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void GetSystemTimeAsFileTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*lpSystemTimeAsFileTime);
        /// <inheritdoc cref = "GetLocalTime(win32.System.WindowsProgramming.SYSTEMTIME*)"/>
        internal static unsafe void GetLocalTime(out win32.System.WindowsProgramming.SYSTEMTIME lpSystemTime)
        {
            fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTimeLocal = &lpSystemTime)
            {
                Kernel32.GetLocalTime(lpSystemTimeLocal);
            }
        }

        /// <summary>Retrieves the current local date and time.</summary>
        /// <param name = "lpSystemTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure to receive the current local date and time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getlocaltime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>To set the current local date and time, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-setlocaltime">SetLocalTime</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getlocaltime#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void GetLocalTime(win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTime);
        /// <summary>Queries whether user-mode Hardware-enforced Stack Protection is available for the specified environment.</summary>
        /// <param name = "UserCetEnvironment"></param>
        /// <returns>TRUE if user-mode Hardware-enforced Stack Protection is available for the specified environment, FALSE otherwise.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-isusercetavailableinenvironment">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool IsUserCetAvailableInEnvironment(win32.System.WindowsProgramming.USER_CET_ENVIRONMENT UserCetEnvironment);
        /// <inheritdoc cref = "GetSystemLeapSecondInformation(bool *, uint *)"/>
        internal static unsafe bool GetSystemLeapSecondInformation(out bool Enabled, out uint Flags)
        {
            fixed (uint *FlagsLocal = &Flags)
            {
                fixed (bool *EnabledLocal = &Enabled)
                {
                    bool __result = Kernel32.GetSystemLeapSecondInformation(EnabledLocal, FlagsLocal);
                    return __result;
                }
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetSystemLeapSecondInformation(bool *Enabled, uint *Flags);
        /// <summary>With the release of Windows 8.1, the behavior of the GetVersion API has changed in the value it will return for the operating system version. The value returned by the GetVersion function now depends on how the application is manifested.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value includes the major and minor version numbers of the operating system in the low-order word, and information about the operating system platform in the high-order word.</para>
        /// <para>For all platforms, the low-order word contains the version number of the operating system. The low-order byte of this word specifies the major version number, in hexadecimal notation. The high-order byte specifies the minor version (revision) number, in hexadecimal notation. The  high-order bit is zero, the next 7 bits represent the build number, and the low-order byte is 5.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getversion">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetVersion();
        /// <inheritdoc cref = "SetLocalTime(win32.System.WindowsProgramming.SYSTEMTIME*)"/>
        internal static unsafe bool SetLocalTime(in win32.System.WindowsProgramming.SYSTEMTIME lpSystemTime)
        {
            fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTimeLocal = &lpSystemTime)
            {
                bool __result = Kernel32.SetLocalTime(lpSystemTimeLocal);
                return __result;
            }
        }

        /// <summary>Sets the current local time and date.</summary>
        /// <param name = "lpSystemTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the new local date and time.</para>
        /// <para>The <b>wDayOfWeek</b> member of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure is ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-setlocaltime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-setlocaltime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetLocalTime(win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTime);
        /// <summary>Retrieves the number of milliseconds that have elapsed since the system was started, up to 49.7 days.</summary>
        /// <returns>The return value is the number of milliseconds that have elapsed since the system was started.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-gettickcount">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetTickCount();
        /// <summary>Retrieves the number of milliseconds that have elapsed since the system was started.</summary>
        /// <returns>The number of milliseconds.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-gettickcount64">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern ulong GetTickCount64();
        /// <inheritdoc cref = "GetSystemTimeAdjustment(uint *, uint *, bool *)"/>
        internal static unsafe bool GetSystemTimeAdjustment(out uint lpTimeAdjustment, out uint lpTimeIncrement, out bool lpTimeAdjustmentDisabled)
        {
            fixed (bool *lpTimeAdjustmentDisabledLocal = &lpTimeAdjustmentDisabled)
            {
                fixed (uint *lpTimeIncrementLocal = &lpTimeIncrement)
                {
                    fixed (uint *lpTimeAdjustmentLocal = &lpTimeAdjustment)
                    {
                        bool __result = Kernel32.GetSystemTimeAdjustment(lpTimeAdjustmentLocal, lpTimeIncrementLocal, lpTimeAdjustmentDisabledLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Determines whether the system is applying periodic time adjustments to its time-of-day clock, and obtains the value and period of any such adjustments.</summary>
        /// <param name = "lpTimeAdjustment">A pointer to a variable that the function sets to the number of <i>lpTimeIncrement</i>100-nanosecond units added to the time-of-day clock for every  period of time which actually passes as counted by the system. This value only has meaning if <i>lpTimeAdjustmentDisabled</i> is <b>FALSE</b>.</param>
        /// <param name = "lpTimeIncrement">A pointer to a variable that the function sets to the interval in 100-nanosecond units at which the system will add <i>lpTimeAdjustment</i> to the time-of-day clock. This value only has meaning if <i>lpTimeAdjustmentDisabled</i> is <b>FALSE</b>.</param>
        /// <param name = "lpTimeAdjustmentDisabled">
        /// <para>A pointer to a variable that the function sets to indicate whether periodic time adjustment is in effect.</para>
        /// <para>A value of <b>TRUE</b> indicates that periodic time adjustment is disabled, and the system time-of-day clock advances at the normal rate. In this mode, the system may adjust the time of day using its own internal time synchronization mechanisms. These internal time synchronization mechanisms may cause the time-of-day clock to change during the normal course of the system operation, which can include noticeable jumps in time as deemed necessary by the system.</para>
        /// <para>A value of <b>FALSE</b> indicates that periodic time adjustment is being used to adjust the time-of-day clock. For each <i>lpTimeIncrement</i> period of time that actually passes, <i>lpTimeAdjustment</i> will be added to the time of day.  If the <i>lpTimeAdjustment</i> value is smaller than <i>lpTimeIncrement</i>, the system time-of-day clock will advance at a rate slower than normal. If the <i>lpTimeAdjustment</i> value is larger than <i>lpTimeIncrement</i>, the time-of-day clock will advance at a rate faster than normal. If <i>lpTimeAdjustment</i> equals <i>lpTimeIncrement</i>, the time-of-day clock will advance at its normal speed.  The <i>lpTimeAdjustment</i>  value can be set by calling <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-setsystemtimeadjustment">SetSystemTimeAdjustment</a>. The <i>lpTimeIncrement</i> value is fixed by the system upon start, and does not change during system operation. In this mode, the system will not interfere with the time adjustment scheme, and will not attempt to synchronize time of day on its own via other techniques.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemtimeadjustment#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemtimeadjustment">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetSystemTimeAdjustment(uint *lpTimeAdjustment, uint *lpTimeIncrement, bool *lpTimeAdjustmentDisabled);
        /// <summary>Retrieves the path of the system directory.</summary>
        /// <param name = "lpBuffer">A pointer to the buffer to receive the path. This path does not end with a backslash unless the system directory is the root directory. For example, if the system directory is named Windows\System32 on drive C, the path of the system directory retrieved by this function is C:\Windows\System32.</param>
        /// <param name = "uSize">The maximum size of the buffer, in <b>TCHARs</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to the buffer, not including the terminating null character. If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path, including the terminating null character.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemdirectoryw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetSystemDirectoryW", SetLastError = true)]
        internal static extern uint GetSystemDirectory(win32.System.SystemServices.PWSTR lpBuffer, uint uSize);
        /// <summary>Retrieves the path of the Windows directory.</summary>
        /// <param name = "lpBuffer">
        /// <para>A pointer to a buffer that receives the path. This path does not end with a backslash unless the Windows directory is the root directory. For example, if the Windows directory is named Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system was installed in the root directory of drive C, the path retrieved is C:\.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getwindowsdirectoryw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uSize">
        /// <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in <b>TCHARs</b>. This value should be set to <b>MAX_PATH</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getwindowsdirectoryw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length of the string copied to the buffer, in <b>TCHARs</b>, not including the terminating null character.</para>
        /// <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getwindowsdirectoryw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetWindowsDirectoryW", SetLastError = true)]
        internal static extern uint GetWindowsDirectory(win32.System.SystemServices.PWSTR lpBuffer, uint uSize);
        /// <summary>Retrieves the path of the shared Windows directory on a multi-user system.</summary>
        /// <param name = "lpBuffer">A pointer to the buffer to receive the path. This path does not end with a backslash unless the Windows directory is the root directory. For example, if the Windows directory is named Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system was installed in the root directory of drive C, the path retrieved is C:\.</param>
        /// <param name = "uSize">The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in <b>TCHARs</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length of the string copied to the buffer, in <b>TCHARs</b>, not including the terminating null character.</para>
        /// <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemwindowsdirectoryw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetSystemWindowsDirectoryW", SetLastError = true)]
        internal static extern uint GetSystemWindowsDirectory(win32.System.SystemServices.PWSTR lpBuffer, uint uSize);
        /// <inheritdoc cref = "GetComputerNameEx(win32.System.WindowsProgramming.COMPUTER_NAME_FORMAT, win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe bool GetComputerNameEx(win32.System.WindowsProgramming.COMPUTER_NAME_FORMAT NameType, win32.System.SystemServices.PWSTR lpBuffer, ref uint nSize)
        {
            fixed (uint *nSizeLocal = &nSize)
            {
                bool __result = Kernel32.GetComputerNameEx(NameType, lpBuffer, nSizeLocal);
                return __result;
            }
        }

        /// <summary>Retrieves a NetBIOS or DNS name associated with the local computer. The names are established at system startup, when the system reads them from the registry.</summary>
        /// <param name = "NameType">
        /// <para>The type of name to be retrieved. This parameter is a value from the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/ne-sysinfoapi-computer_name_format">COMPUTER_NAME_FORMAT</a> enumeration type. The following table provides additional information.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getcomputernameexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to a buffer that receives the computer name or the cluster virtual server name.</para>
        /// <para>The length of the name may be greater than MAX_COMPUTERNAME_LENGTH characters because DNS allows longer names. To ensure that this buffer is large enough, set this parameter to <b>NULL</b> and use the required buffer size returned in the <i>lpnSize</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getcomputernameexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nSize">
        /// <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating <b>null</b> character.</para>
        /// <para>If the buffer is too small, the function fails and <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_MORE_DATA. This parameter receives the size of the buffer required,  including the terminating <b>null</b> character.</para>
        /// <para>If <i>lpBuffer</i> is <b>NULL</b>, this parameter must be zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getcomputernameexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible values include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getcomputernameexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetComputerNameExW", SetLastError = true)]
        internal static extern unsafe bool GetComputerNameEx(win32.System.WindowsProgramming.COMPUTER_NAME_FORMAT NameType, win32.System.SystemServices.PWSTR lpBuffer, uint *nSize);
        /// <inheritdoc cref = "SetComputerNameEx(win32.System.WindowsProgramming.COMPUTER_NAME_FORMAT, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetComputerNameEx(win32.System.WindowsProgramming.COMPUTER_NAME_FORMAT NameType, string lpBuffer)
        {
            fixed (char *lpBufferLocal = lpBuffer)
            {
                bool __result = Kernel32.SetComputerNameEx(NameType, lpBufferLocal);
                return __result;
            }
        }

        /// <summary>Sets a new NetBIOS or DNS name for the local computer.</summary>
        /// <param name = "NameType"></param>
        /// <param name = "lpBuffer">The new name. The name cannot include control characters, leading or trailing spaces, or any of the following characters: " / \ [ ] : | &lt; &gt; + = ; , ?</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-setcomputernameexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetComputerNameExW", SetLastError = true)]
        internal static extern bool SetComputerNameEx(win32.System.WindowsProgramming.COMPUTER_NAME_FORMAT NameType, win32.System.SystemServices.PCWSTR lpBuffer);
        /// <inheritdoc cref = "SetSystemTime(win32.System.WindowsProgramming.SYSTEMTIME*)"/>
        internal static unsafe bool SetSystemTime(in win32.System.WindowsProgramming.SYSTEMTIME lpSystemTime)
        {
            fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTimeLocal = &lpSystemTime)
            {
                bool __result = Kernel32.SetSystemTime(lpSystemTimeLocal);
                return __result;
            }
        }

        /// <summary>Sets the current system time and date. The system time is expressed in Coordinated Universal Time (UTC).</summary>
        /// <param name = "lpSystemTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the new system date and time.</para>
        /// <para>The <b>wDayOfWeek</b> member of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure is ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-setsystemtime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-setsystemtime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetSystemTime(win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTime);
        /// <inheritdoc cref = "GetVersionEx(win32.System.WindowsProgramming.OSVERSIONINFOW*)"/>
        internal static unsafe bool GetVersionEx(ref win32.System.WindowsProgramming.OSVERSIONINFOW lpVersionInformation)
        {
            fixed (win32.System.WindowsProgramming.OSVERSIONINFOW*lpVersionInformationLocal = &lpVersionInformation)
            {
                bool __result = Kernel32.GetVersionEx(lpVersionInformationLocal);
                return __result;
            }
        }

        /// <summary>With the release of Windows 8.1, the behavior of the GetVersionEx API has changed in the value it will return for the operating system version. The value returned by the GetVersionEx function now depends on how the application is manifested.</summary>
        /// <param name = "lpVersionInformation">
        /// <para>An <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-osversioninfoa">OSVERSIONINFO</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-osversioninfoexa">OSVERSIONINFOEX</a> structure that receives the operating system information.</para>
        /// <para>Before calling the <b>GetVersionEx</b> function, set the <b>dwOSVersionInfoSize</b> member of the structure as appropriate to indicate which data structure is being passed to this function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getversionexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The function fails if you specify an invalid value for the <b>dwOSVersionInfoSize</b> member of the <a href = "/windows/desktop/api/winnt/ns-winnt-osversioninfoa">OSVERSIONINFO</a> or <a href = "/windows/desktop/api/winnt/ns-winnt-osversioninfoexa">OSVERSIONINFOEX</a> structure.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getversionexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetVersionExW", SetLastError = true)]
        internal static extern unsafe bool GetVersionEx(win32.System.WindowsProgramming.OSVERSIONINFOW*lpVersionInformation);
        /// <inheritdoc cref = "GetLogicalProcessorInformation(win32.System.SystemServices.SYSTEM_LOGICAL_PROCESSOR_INFORMATION*, uint *)"/>
        internal static unsafe bool GetLogicalProcessorInformation(win32.System.SystemServices.SYSTEM_LOGICAL_PROCESSOR_INFORMATION*Buffer, ref uint ReturnedLength)
        {
            fixed (uint *ReturnedLengthLocal = &ReturnedLength)
            {
                bool __result = Kernel32.GetLogicalProcessorInformation(Buffer, ReturnedLengthLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about logical processors and related hardware.</summary>
        /// <param name = "Buffer">A pointer to a buffer that receives  an array of <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-system_logical_processor_information">SYSTEM_LOGICAL_PROCESSOR_INFORMATION</a> structures. If the function fails, the contents of this buffer are undefined.</param>
        /// <param name = "ReturnedLength">On input, specifies the length of the buffer pointed to by  <i>Buffer</i>, in bytes. If the buffer is large enough to contain all of the data, this function succeeds and <i>ReturnLength</i> is set to the number of bytes returned. If the buffer is not large enough to contain all of the data, the function fails, <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER, and <i>ReturnLength</i> is set to the buffer length required to contain all of the data. If the function fails with an error other than ERROR_INSUFFICIENT_BUFFER, the value of <i>ReturnLength</i> is undefined.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is TRUE and at least one <a href = "/windows/desktop/api/winnt/ns-winnt-system_logical_processor_information">SYSTEM_LOGICAL_PROCESSOR_INFORMATION</a> structure is written to the output buffer.</para>
        /// <para>If the function fails, the return value is FALSE. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetLogicalProcessorInformation([Optional] win32.System.SystemServices.SYSTEM_LOGICAL_PROCESSOR_INFORMATION*Buffer, uint *ReturnedLength);
        /// <inheritdoc cref = "GetLogicalProcessorInformationEx(win32.System.SystemServices.LOGICAL_PROCESSOR_RELATIONSHIP, win32.System.SystemServices.SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*, uint *)"/>
        internal static unsafe bool GetLogicalProcessorInformationEx(win32.System.SystemServices.LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, win32.System.SystemServices.SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*Buffer, ref uint ReturnedLength)
        {
            fixed (uint *ReturnedLengthLocal = &ReturnedLength)
            {
                bool __result = Kernel32.GetLogicalProcessorInformationEx(RelationshipType, Buffer, ReturnedLengthLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about the relationships of logical processors and related hardware.</summary>
        /// <param name = "RelationshipType">
        /// <para>The type of relationship to retrieve. This parameter can be one of the following <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ne-winnt-logical_processor_relationship">LOGICAL_PROCESSOR_RELATIONSHIP</a> values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformationex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Buffer">A pointer to a buffer that receives  an array of <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-system_logical_processor_information_ex">SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX</a> structures. If the function fails, the contents of this buffer are undefined.</param>
        /// <param name = "ReturnedLength">On input, specifies the length of the buffer pointed to by  <i>Buffer</i>, in bytes. If the buffer is large enough to contain all of the data, this function succeeds and <i>ReturnedLength</i> is set to the number of bytes returned. If the buffer is not large enough to contain all of the data, the function fails, <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER, and <i>ReturnedLength</i> is set to the buffer length required to contain all of the data. If the function fails with an error other than ERROR_INSUFFICIENT_BUFFER, the value of <i>ReturnedLength</i> is undefined.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is TRUE and at least one <a href = "/windows/win32/api/winnt/ns-winnt-system_logical_processor_information_ex">SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX</a> structure is written to the output buffer.</para>
        /// <para>If the function fails, the return value is FALSE. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformationex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetLogicalProcessorInformationEx(win32.System.SystemServices.LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, [Optional] win32.System.SystemServices.SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*Buffer, uint *ReturnedLength);
        /// <inheritdoc cref = "GetNativeSystemInfo(win32.System.WindowsProgramming.SYSTEM_INFO*)"/>
        internal static unsafe void GetNativeSystemInfo(out win32.System.WindowsProgramming.SYSTEM_INFO lpSystemInfo)
        {
            fixed (win32.System.WindowsProgramming.SYSTEM_INFO*lpSystemInfoLocal = &lpSystemInfo)
            {
                Kernel32.GetNativeSystemInfo(lpSystemInfoLocal);
            }
        }

        /// <summary>Retrieves information about the current system to an application running under WOW64.</summary>
        /// <param name = "lpSystemInfo">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/ns-sysinfoapi-system_info">SYSTEM_INFO</a> structure that receives the information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getnativesysteminfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>To determine whether a Win32-based application is running under WOW64, call the <a href = "https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-iswow64process2">IsWow64Process2</a> function.</para>
        /// <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getnativesysteminfo#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void GetNativeSystemInfo(win32.System.WindowsProgramming.SYSTEM_INFO*lpSystemInfo);
        /// <inheritdoc cref = "GetSystemTimePreciseAsFileTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe void GetSystemTimePreciseAsFileTime(out global::System.Runtime.InteropServices.ComTypes.FILETIME lpSystemTimeAsFileTime)
        {
            fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpSystemTimeAsFileTimeLocal = &lpSystemTimeAsFileTime)
            {
                Kernel32.GetSystemTimePreciseAsFileTime(lpSystemTimeAsFileTimeLocal);
            }
        }

        /// <summary>GetSystemTimePreciseAsFileTime function retrieves the current system date and time with the highest possible level of precision (&lt;1us). The retrieved information is in Coordinated Universal Time (UTC) format.</summary>
        /// <param name = "lpSystemTimeAsFileTime">
        /// <para>Type: <b>LPFILETIME</b></para>
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that contains the current system date and time in UTC format.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemtimepreciseasfiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para><div class = "alert"><b>Note</b>  This function is best suited for high-resolution time-of-day measurements, or time stamps that are synchronized to UTC. For high-resolution interval measurements, use <a href = "https://docs.microsoft.com/windows/desktop/api/profileapi/nf-profileapi-queryperformancecounter">QueryPerformanceCounter</a> or <a href = "https://docs.microsoft.com/windows-hardware/drivers/ddi/content/ntifs/nf-ntifs-kequeryperformancecounter">KeQueryPerformanceCounter</a>. For more info about acquiring high-resolution time stamps, see <a href = "https://docs.microsoft.com/windows/desktop/SysInfo/acquiring-high-resolution-time-stamps">Acquiring high-resolution time stamps</a>.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemtimepreciseasfiletime#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void GetSystemTimePreciseAsFileTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*lpSystemTimeAsFileTime);
        /// <inheritdoc cref = "GetProductInfo(uint, uint, uint, uint, win32.System.WindowsProgramming.OS_PRODUCT_TYPE*)"/>
        internal static unsafe bool GetProductInfo(uint dwOSMajorVersion, uint dwOSMinorVersion, uint dwSpMajorVersion, uint dwSpMinorVersion, out win32.System.WindowsProgramming.OS_PRODUCT_TYPE pdwReturnedProductType)
        {
            fixed (win32.System.WindowsProgramming.OS_PRODUCT_TYPE*pdwReturnedProductTypeLocal = &pdwReturnedProductType)
            {
                bool __result = Kernel32.GetProductInfo(dwOSMajorVersion, dwOSMinorVersion, dwSpMajorVersion, dwSpMinorVersion, pdwReturnedProductTypeLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the product type for the operating system on the local computer, and maps the type to the product types supported by the specified operating system.</summary>
        /// <param name = "dwOSMajorVersion">
        /// <para>The major version number of the operating system. The minimum value is 6.</para>
        /// <para>The combination of the <i>dwOSMajorVersion</i>, <i>dwOSMinorVersion</i>, <i>dwSpMajorVersion</i>, and <i>dwSpMinorVersion</i> parameters describes the maximum target operating system version for the application. For example, Windows Vista and Windows Server 2008 are version 6.0.0.0 and Windows 7 and Windows Server 2008 R2 are version 6.1.0.0. All Windows 10 based releases will be listed as version 6.3.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getproductinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwOSMinorVersion">The minor version number of the operating system. The minimum value is 0.</param>
        /// <param name = "dwSpMajorVersion">The major version number of the operating system service pack. The minimum value is 0.</param>
        /// <param name = "dwSpMinorVersion">The minor version number of the operating system service pack. The minimum value is 0.</param>
        /// <param name = "pdwReturnedProductType">The product type. This parameter cannot be <b>NULL</b>. If the specified operating system  is less than the current operating system, this information is mapped to the types supported by the specified operating system. If the specified operating system is greater than the highest supported operating system, this information is mapped to the types supported by the current operating system.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. This function fails if one of the input parameters is invalid.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getproductinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetProductInfo(uint dwOSMajorVersion, uint dwOSMinorVersion, uint dwSpMajorVersion, uint dwSpMinorVersion, win32.System.WindowsProgramming.OS_PRODUCT_TYPE*pdwReturnedProductType);
        /// <summary>Sets the bits of a 64-bit value to indicate the comparison operator to use for a specified operating system version attribute. This function is used to build the dwlConditionMask parameter of the VerifyVersionInfo function.</summary>
        /// <param name = "ConditionMask">
        /// <para>A value to be passed as the <i>dwlConditionMask</i> parameter of the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-verifyversioninfoa">VerifyVersionInfo</a> function. The function stores the comparison information in the bits of this variable.</para>
        /// <para>Before the first call to <b>VerSetCondition</b>, initialize this variable to zero. For subsequent calls, pass in the variable used in the previous call.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnt/nf-winnt-versetconditionmask#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "TypeMask">
        /// <para>A mask that indicates the member of the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-osversioninfoexa">OSVERSIONINFOEX</a> structure whose comparison operator is being set. This value corresponds to one of the bits specified in the <i>dwTypeMask</i> parameter for the</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnt/nf-winnt-versetconditionmask#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Condition">
        /// <para>The operator to be used for the comparison. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-verifyversioninfoa">VerifyVersionInfo</a> function uses this operator to compare a specified attribute value to the corresponding value for the currently running system.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnt/nf-winnt-versetconditionmask#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>The function returns the condition mask value.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnt/nf-winnt-versetconditionmask">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern ulong VerSetConditionMask(ulong ConditionMask, win32.System.WindowsProgramming.VER_FLAGS TypeMask, byte Condition);
        /// <summary>Enumerates all system firmware tables of the specified type.</summary>
        /// <param name = "FirmwareTableProviderSignature"></param>
        /// <param name = "pFirmwareTableEnumBuffer">
        /// <para>A pointer to a buffer that receives the list of  firmware tables. If this parameter is <b>NULL</b>, the return value is the required buffer size.</para>
        /// <para>For more information on the contents of this buffer, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-enumsystemfirmwaretables#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "BufferSize">The size of the <i>pFirmwareTableBuffer</i> buffer, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the number of bytes written to the buffer. This value will always be less than or equal to <i>BufferSize</i>.</para>
        /// <para>If the function fails because the buffer is not large enough, the return value is the required buffer size, in bytes. This value is always greater than <i>BufferSize</i>.</para>
        /// <para>If the function fails for any other reason, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-enumsystemfirmwaretables">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint EnumSystemFirmwareTables(uint FirmwareTableProviderSignature, [Optional] void *pFirmwareTableEnumBuffer, uint BufferSize);
        /// <summary>Retrieves the specified firmware table from the firmware table provider.</summary>
        /// <param name = "FirmwareTableProviderSignature"></param>
        /// <param name = "FirmwareTableID">
        /// <para>The identifier of the firmware table. This identifier is little endian, you must reverse the characters in the string.</para>
        /// <para>For example, FACP is an ACPI provider, as described in the Signature field of the DESCRIPTION_HEADER structure in the ACPI specification (see <a href = "http://www.acpi.info/">http://www.acpi.info</a>). Therefore, use 'PCAF' to specify the FACP table, as shown in the following example:</para>
        /// <para><c>retVal = GetSystemFirmwareTable('ACPI', 'PCAF', pBuffer, BUFSIZE);</c></para>
        /// <para>For more information, see the Remarks section of the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-enumsystemfirmwaretables">EnumSystemFirmwareTables</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemfirmwaretable#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pFirmwareTableBuffer">
        /// <para>A pointer to a buffer that receives the requested firmware table. If this parameter is <b>NULL</b>, the return value is the required buffer size.</para>
        /// <para>For more information on the contents of this buffer, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemfirmwaretable#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "BufferSize">The size of the <i>pFirmwareTableBuffer</i> buffer, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the number of bytes written to the buffer. This value will always be less than or equal to <i>BufferSize</i>.</para>
        /// <para>If the function fails because the buffer is not large enough, the return value is the required buffer size, in bytes. This value is always greater than <i>BufferSize</i>.</para>
        /// <para>If the function fails for any other reason, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsystemfirmwaretable">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint GetSystemFirmwareTable(uint FirmwareTableProviderSignature, uint FirmwareTableID, [Optional] void *pFirmwareTableBuffer, uint BufferSize);
        /// <inheritdoc cref = "DnsHostnameToComputerNameEx(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe bool DnsHostnameToComputerNameEx(string Hostname, win32.System.SystemServices.PWSTR ComputerName, ref uint nSize)
        {
            fixed (uint *nSizeLocal = &nSize)
            {
                fixed (char *HostnameLocal = Hostname)
                {
                    bool __result = Kernel32.DnsHostnameToComputerNameEx(HostnameLocal, ComputerName, nSizeLocal);
                    return __result;
                }
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "DnsHostnameToComputerNameExW")]
        internal static extern unsafe bool DnsHostnameToComputerNameEx(win32.System.SystemServices.PCWSTR Hostname, win32.System.SystemServices.PWSTR ComputerName, uint *nSize);
        /// <inheritdoc cref = "GetPhysicallyInstalledSystemMemory(ulong *)"/>
        internal static unsafe bool GetPhysicallyInstalledSystemMemory(out ulong TotalMemoryInKilobytes)
        {
            fixed (ulong *TotalMemoryInKilobytesLocal = &TotalMemoryInKilobytes)
            {
                bool __result = Kernel32.GetPhysicallyInstalledSystemMemory(TotalMemoryInKilobytesLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the amount of RAM that is physically installed on the computer.</summary>
        /// <param name = "TotalMemoryInKilobytes">
        /// <para>A pointer to a variable that receives the amount of physically installed RAM, in kilobytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getphysicallyinstalledsystemmemory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b> and sets the <i>TotalMemoryInKilobytes</i> parameter to a nonzero value.</para>
        /// <para>If the function fails, it returns <b>FALSE</b> and does not modify the <i>TotalMemoryInKilobytes</i> parameter. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function. Common errors are listed in the following table.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getphysicallyinstalledsystemmemory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetPhysicallyInstalledSystemMemory(ulong *TotalMemoryInKilobytes);
        /// <inheritdoc cref = "SetComputerNameEx2W(win32.System.WindowsProgramming.COMPUTER_NAME_FORMAT, uint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetComputerNameEx2W(win32.System.WindowsProgramming.COMPUTER_NAME_FORMAT NameType, uint Flags, string lpBuffer)
        {
            fixed (char *lpBufferLocal = lpBuffer)
            {
                bool __result = Kernel32.SetComputerNameEx2W(NameType, Flags, lpBufferLocal);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SetComputerNameEx2W(win32.System.WindowsProgramming.COMPUTER_NAME_FORMAT NameType, uint Flags, win32.System.SystemServices.PCWSTR lpBuffer);
        /// <summary>Enables or disables periodic time adjustments to the system's time-of-day clock. When enabled, such time adjustments can be used to synchronize the time of day with some other source of time information.</summary>
        /// <param name = "dwTimeAdjustment">
        /// <para>This value represents the number of 100-nanosecond units added to the system time-of-day  for each <i>lpTimeIncrement</i> period of time that actually passes. Call <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsystemtimeadjustment">GetSystemTimeAdjustment</a> to obtain the <i>lpTimeIncrement</i> value. See remarks.</para>
        /// <para><div class = "alert"><b>Note</b>  <p class = "note">Currently, Windows Vista and Windows 7 machines will lose any time adjustments set less than 16.</para>
        /// <para></div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-setsystemtimeadjustment#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bTimeAdjustmentDisabled">
        /// <para>The time adjustment mode that the system is to use. Periodic system time adjustments can be disabled or enabled.</para>
        /// <para>A value of <b>TRUE</b> specifies that periodic time adjustment is to be disabled. When disabled, the value of <i>dwTimeAdjustment</i> is ignored, and the system may adjust the time of day using its own internal time synchronization mechanisms. These internal time synchronization mechanisms may cause the time-of-day clock to change during the normal course of the system operation, which can include noticeable jumps in time as deemed necessary by the system.</para>
        /// <para>A value of <b>FALSE</b> specifies that periodic time adjustment is to be enabled, and will be used to adjust the time-of-day clock. The system will not interfere with the time adjustment scheme, and will not attempt to synchronize time of day on its own.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-setsystemtimeadjustment#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is non-zero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One way the function can fail is if the caller does not possess the SE_SYSTEMTIME_NAME privilege.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-setsystemtimeadjustment">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetSystemTimeAdjustment(uint dwTimeAdjustment, bool bTimeAdjustmentDisabled);
        /// <inheritdoc cref = "GetProcessorSystemCycleTime(ushort, win32.System.SystemServices.SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION*, uint *)"/>
        internal static unsafe bool GetProcessorSystemCycleTime(ushort Group, win32.System.SystemServices.SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION*Buffer, ref uint ReturnedLength)
        {
            fixed (uint *ReturnedLengthLocal = &ReturnedLength)
            {
                bool __result = Kernel32.GetProcessorSystemCycleTime(Group, Buffer, ReturnedLengthLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the cycle time each processor in the specified processor group spent executing deferred procedure calls (DPCs) and interrupt service routines (ISRs) since the processor became active.</summary>
        /// <param name = "Group">The number of the processor group for which to retrieve the cycle time.</param>
        /// <param name = "Buffer">A pointer to a buffer to receive a SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION structure for each processor in the group. On output, the DWORD64 <b>CycleTime</b> member of this structure is set to the cycle time for one processor.</param>
        /// <param name = "ReturnedLength">The size of the buffer, in bytes. When the function returns, this parameter contains the number of bytes written to <i>Buffer</i>. If the buffer is too small for the data, the function fails with ERROR_INSUFFICIENT_BUFFER and sets the <i>ReturnedLength</i> parameter to the required buffer size.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the error value is ERROR_INSUFFICIENT_BUFFER, the <i>ReturnedLength</i> parameter contains the required buffer size.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getprocessorsystemcycletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessorSystemCycleTime(ushort Group, [Optional] win32.System.SystemServices.SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION*Buffer, uint *ReturnedLength);
        /// <inheritdoc cref = "SetComputerName(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetComputerName(string lpComputerName)
        {
            fixed (char *lpComputerNameLocal = lpComputerName)
            {
                bool __result = Kernel32.SetComputerName(lpComputerNameLocal);
                return __result;
            }
        }

        /// <summary>Sets a new NetBIOS name for the local computer. The name is stored in the registry and the name change takes effect the next time the user restarts the computer.</summary>
        /// <param name = "lpComputerName">
        /// <para>The computer name that will take effect the next time the computer is started. The name must not be longer than MAX_COMPUTERNAME_LENGTH characters.</para>
        /// <para>The standard character set includes letters, numbers, and the following symbols: ! @ # $ % ^ &amp; ' ) ( . - _ { } ~ . If this parameter contains one or more characters that are outside the standard character set, <b>SetComputerName</b> returns ERROR_INVALID_PARAMETER.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-setcomputernamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-setcomputernamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetComputerNameW", SetLastError = true)]
        internal static extern bool SetComputerName(win32.System.SystemServices.PCWSTR lpComputerName);
        /// <inheritdoc cref = "QueryThreadCycleTime(win32.System.SystemServices.HANDLE, ulong *)"/>
        internal static unsafe bool QueryThreadCycleTime(SafeHandle ThreadHandle, out ulong CycleTime)
        {
            bool ThreadHandleAddRef = false;
            try
            {
                fixed (ulong *CycleTimeLocal = &CycleTime)
                {
                    win32.System.SystemServices.HANDLE ThreadHandleLocal;
                    if (ThreadHandle is object)
                    {
                        ThreadHandle.DangerousAddRef(ref ThreadHandleAddRef);
                        ThreadHandleLocal = (win32.System.SystemServices.HANDLE)ThreadHandle.DangerousGetHandle();
                    }
                    else
                        ThreadHandleLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.QueryThreadCycleTime(ThreadHandleLocal, CycleTimeLocal);
                    return __result;
                }
            }
            finally
            {
                if (ThreadHandleAddRef)
                    ThreadHandle.DangerousRelease();
            }
        }

        /// <summary>Retrieves the cycle time for the specified thread.</summary>
        /// <param name = "ThreadHandle">
        /// <para>A handle to the thread. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//realtimeapiset/nf-realtimeapiset-querythreadcycletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "CycleTime">The number of CPU clock cycles used by the thread. This value includes cycles spent in both user mode and kernel mode.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//realtimeapiset/nf-realtimeapiset-querythreadcycletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool QueryThreadCycleTime(win32.System.SystemServices.HANDLE ThreadHandle, ulong *CycleTime);
        /// <inheritdoc cref = "QueryProcessCycleTime(win32.System.SystemServices.HANDLE, ulong *)"/>
        internal static unsafe bool QueryProcessCycleTime(SafeHandle ProcessHandle, out ulong CycleTime)
        {
            bool ProcessHandleAddRef = false;
            try
            {
                fixed (ulong *CycleTimeLocal = &CycleTime)
                {
                    win32.System.SystemServices.HANDLE ProcessHandleLocal;
                    if (ProcessHandle is object)
                    {
                        ProcessHandle.DangerousAddRef(ref ProcessHandleAddRef);
                        ProcessHandleLocal = (win32.System.SystemServices.HANDLE)ProcessHandle.DangerousGetHandle();
                    }
                    else
                        ProcessHandleLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.QueryProcessCycleTime(ProcessHandleLocal, CycleTimeLocal);
                    return __result;
                }
            }
            finally
            {
                if (ProcessHandleAddRef)
                    ProcessHandle.DangerousRelease();
            }
        }

        /// <summary>Retrieves the sum of the cycle time of all threads of the specified process.</summary>
        /// <param name = "ProcessHandle">
        /// <para>A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//realtimeapiset/nf-realtimeapiset-queryprocesscycletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "CycleTime">The number of CPU clock cycles used by the threads of the process. This value includes cycles spent in both user mode and kernel mode.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//realtimeapiset/nf-realtimeapiset-queryprocesscycletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool QueryProcessCycleTime(win32.System.SystemServices.HANDLE ProcessHandle, ulong *CycleTime);
        /// <inheritdoc cref = "QueryIdleProcessorCycleTime(uint *, ulong *)"/>
        internal static unsafe bool QueryIdleProcessorCycleTime(ref uint BufferLength, ulong *ProcessorIdleCycleTime)
        {
            fixed (uint *BufferLengthLocal = &BufferLength)
            {
                bool __result = Kernel32.QueryIdleProcessorCycleTime(BufferLengthLocal, ProcessorIdleCycleTime);
                return __result;
            }
        }

        /// <summary>Retrieves the cycle time for the idle thread of each processor in the system.</summary>
        /// <param name = "BufferLength">
        /// <para>On input, specifies the size of the <i>ProcessorIdleCycleTime</i> buffer, in bytes. This buffer is expected to be 8 times the number of processors in the group.</para>
        /// <para>On output, specifies the number of elements written to the buffer. If the buffer size is not sufficient, the function fails and this parameter receives the required length of the buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//realtimeapiset/nf-realtimeapiset-queryidleprocessorcycletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ProcessorIdleCycleTime">The number of CPU clock cycles used by each idle thread. This buffer must be 8  times the number of processors in the system in size.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//realtimeapiset/nf-realtimeapiset-queryidleprocessorcycletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool QueryIdleProcessorCycleTime(uint *BufferLength, [Optional] ulong *ProcessorIdleCycleTime);
        /// <inheritdoc cref = "QueryIdleProcessorCycleTimeEx(ushort, uint *, ulong *)"/>
        internal static unsafe bool QueryIdleProcessorCycleTimeEx(ushort Group, ref uint BufferLength, ulong *ProcessorIdleCycleTime)
        {
            fixed (uint *BufferLengthLocal = &BufferLength)
            {
                bool __result = Kernel32.QueryIdleProcessorCycleTimeEx(Group, BufferLengthLocal, ProcessorIdleCycleTime);
                return __result;
            }
        }

        /// <summary>Retrieves the accumulated cycle time for the idle thread on each logical processor in the specified processor group.</summary>
        /// <param name = "Group">The number of the processor group for which to retrieve the cycle time.</param>
        /// <param name = "BufferLength">
        /// <para>On input, specifies the size of the <i>ProcessorIdleCycleTime</i> buffer, in bytes. This buffer is expected to be 8 times the number of processors in the group.</para>
        /// <para>On output, specifies the number of elements written to the buffer. If the buffer size is not sufficient, the function fails and this parameter receives the required length of the buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//realtimeapiset/nf-realtimeapiset-queryidleprocessorcycletimeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ProcessorIdleCycleTime">The number of CPU clock cycles used by each idle thread. If this parameter is NULL, the function updates the <i>BufferLength</i> parameter with the required length.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use <a href = "/windows/desktop/api/adshlp/nf-adshlp-adsgetlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//realtimeapiset/nf-realtimeapiset-queryidleprocessorcycletimeex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool QueryIdleProcessorCycleTimeEx(ushort Group, uint *BufferLength, [Optional] ulong *ProcessorIdleCycleTime);
        /// <inheritdoc cref = "QueryUnbiasedInterruptTime(ulong *)"/>
        internal static unsafe bool QueryUnbiasedInterruptTime(out ulong UnbiasedTime)
        {
            fixed (ulong *UnbiasedTimeLocal = &UnbiasedTime)
            {
                bool __result = Kernel32.QueryUnbiasedInterruptTime(UnbiasedTimeLocal);
                return __result;
            }
        }

        /// <summary>Gets the current unbiased interrupt-time count, in units of 100 nanoseconds. The unbiased interrupt-time count does not include time the system spends in sleep or hibernation.</summary>
        /// <param name = "UnbiasedTime">TBD</param>
        /// <returns>If the function succeeds, the return value is nonzero. If the function fails because it is called with a null parameter, the return value is zero.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//realtimeapiset/nf-realtimeapiset-queryunbiasedinterrupttime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool QueryUnbiasedInterruptTime(ulong *UnbiasedTime);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern nuint GlobalCompact(uint dwMinFree);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void GlobalFix(nint hMem);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void GlobalUnfix(nint hMem);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void *GlobalWire(nint hMem);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool GlobalUnWire(nint hMem);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern nuint LocalShrink(nint hMem, uint cbNewSize);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern nuint LocalCompact(uint uMinFree);
        /// <param name = "uNumber">The requested number of available file handles.</param>
        /// <returns>The number of available file handles.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-sethandlecount">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint SetHandleCount(uint uNumber);
        /// <inheritdoc cref = "RequestDeviceWakeup(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool RequestDeviceWakeup(SafeHandle hDevice)
        {
            bool hDeviceAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDeviceLocal;
                if (hDevice is object)
                {
                    hDevice.DangerousAddRef(ref hDeviceAddRef);
                    hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                }
                else
                    hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.RequestDeviceWakeup(hDeviceLocal);
                return __result;
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool RequestDeviceWakeup(win32.System.SystemServices.HANDLE hDevice);
        /// <inheritdoc cref = "CancelDeviceWakeupRequest(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool CancelDeviceWakeupRequest(SafeHandle hDevice)
        {
            bool hDeviceAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDeviceLocal;
                if (hDevice is object)
                {
                    hDevice.DangerousAddRef(ref hDeviceAddRef);
                    hDeviceLocal = (win32.System.SystemServices.HANDLE)hDevice.DangerousGetHandle();
                }
                else
                    hDeviceLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.CancelDeviceWakeupRequest(hDeviceLocal);
                return __result;
            }
            finally
            {
                if (hDeviceAddRef)
                    hDevice.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool CancelDeviceWakeupRequest(win32.System.SystemServices.HANDLE hDevice);
        /// <inheritdoc cref = "SetMessageWaitingIndicator(win32.System.SystemServices.HANDLE, uint)"/>
        internal static unsafe bool SetMessageWaitingIndicator(SafeHandle hMsgIndicator, uint ulMsgCount)
        {
            bool hMsgIndicatorAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hMsgIndicatorLocal;
                if (hMsgIndicator is object)
                {
                    hMsgIndicator.DangerousAddRef(ref hMsgIndicatorAddRef);
                    hMsgIndicatorLocal = (win32.System.SystemServices.HANDLE)hMsgIndicator.DangerousGetHandle();
                }
                else
                    hMsgIndicatorLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetMessageWaitingIndicator(hMsgIndicatorLocal, ulMsgCount);
                return __result;
            }
            finally
            {
                if (hMsgIndicatorAddRef)
                    hMsgIndicator.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SetMessageWaitingIndicator(win32.System.SystemServices.HANDLE hMsgIndicator, uint ulMsgCount);
        /// <summary>Multiplies two 32-bit values and then divides the 64-bit result by a third 32-bit value.</summary>
        /// <param name = "nNumber">The multiplicand.</param>
        /// <param name = "nNumerator">The multiplier.</param>
        /// <param name = "nDenominator">The number by which the result of the multiplication operation is to be divided.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the result of the multiplication and division, rounded to the nearest integer. If the result is a positive half integer (ends in .5), it is rounded up. If the result is a negative half integer, it is rounded down.</para>
        /// <para>If either an overflow occurred or <i>nDenominator</i> was 0, the return value is -1.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-muldiv">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern int MulDiv(int nNumber, int nNumerator, int nDenominator);
        /// <summary>Retrieves the current size of the registry and the maximum size that the registry is allowed to attain on the system.</summary>
        /// <param name = "pdwQuotaAllowed">A pointer to a variable that receives the maximum size that the registry is allowed to attain on this system, in bytes.</param>
        /// <param name = "pdwQuotaUsed">A pointer to a variable that receives the current size of  the registry, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getsystemregistryquota">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetSystemRegistryQuota([Optional] uint *pdwQuotaAllowed, [Optional] uint *pdwQuotaUsed);
        /// <inheritdoc cref = "FileTimeToDosDateTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*, ushort *, ushort *)"/>
        internal static unsafe bool FileTimeToDosDateTime(in global::System.Runtime.InteropServices.ComTypes.FILETIME lpFileTime, out ushort lpFatDate, out ushort lpFatTime)
        {
            fixed (ushort *lpFatTimeLocal = &lpFatTime)
            {
                fixed (ushort *lpFatDateLocal = &lpFatDate)
                {
                    fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTimeLocal = &lpFileTime)
                    {
                        bool __result = Kernel32.FileTimeToDosDateTime(lpFileTimeLocal, lpFatDateLocal, lpFatTimeLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Converts a file time to MS-DOS date and time values.</summary>
        /// <param name = "lpFileTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure containing the file time to convert to MS-DOS date and time format.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-filetimetodosdatetime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFatDate">
        /// <para>A pointer to a variable to receive the MS-DOS date. The date is a packed value with the following format.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-filetimetodosdatetime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFatTime">
        /// <para>A pointer to a variable to receive the MS-DOS time. The time is a packed value with the following format.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-filetimetodosdatetime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-filetimetodosdatetime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool FileTimeToDosDateTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTime, ushort *lpFatDate, ushort *lpFatTime);
        /// <inheritdoc cref = "DosDateTimeToFileTime(ushort, ushort, global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe bool DosDateTimeToFileTime(ushort wFatDate, ushort wFatTime, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpFileTime)
        {
            fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTimeLocal = &lpFileTime)
            {
                bool __result = Kernel32.DosDateTimeToFileTime(wFatDate, wFatTime, lpFileTimeLocal);
                return __result;
            }
        }

        /// <summary>Converts MS-DOS date and time values to a file time.</summary>
        /// <param name = "wFatDate">
        /// <para>The MS-DOS date. The date is a packed value with the following format.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-dosdatetimetofiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wFatTime">
        /// <para>The MS-DOS time. The time is a packed value with the following format.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-dosdatetimetofiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the converted file time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-dosdatetimetofiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-dosdatetimetofiletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool DosDateTimeToFileTime(ushort wFatDate, ushort wFatTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTime);
        /// <summary>The _lopen function opens an existing file and sets the file pointer to the beginning of the file. This function is provided for compatibility with 16-bit versions of Windows. Win32-based applications should use the CreateFile function.</summary>
        /// <param name = "lpPathName">Pointer to a null-terminated string that names the file to open. The string must consist of characters from the Windows ANSI character set.</param>
        /// <param name = "iReadWrite"></param>
        /// <returns>If the function succeeds, the return value is a file handle.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-_lopen">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern int _lopen(win32.System.SystemServices.PCSTR lpPathName, int iReadWrite);
        /// <summary>Creates or opens the specified file.</summary>
        /// <param name = "lpPathName">The name of the file. The string must consist of characters from the Windows ANSI character set.</param>
        /// <param name = "iAttribute">The attributes of the file.</param>
        /// <returns>If the function succeeds, the return value is a file handle. Otherwise, the return value is HFILE_ERROR. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-_lcreat">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int _lcreat(win32.System.SystemServices.PCSTR lpPathName, int iAttribute);
        /// <summary>The _lread function reads data from the specified file. This function is provided for compatibility with 16-bit versions of Windows. Win32-based applications should use the ReadFile function.</summary>
        /// <param name = "hFile">Identifies the specified file.</param>
        /// <param name = "lpBuffer">Pointer to a buffer that contains the data read from the file.</param>
        /// <param name = "uBytes">Specifies the number of bytes to be read from the file.</param>
        /// <returns>The return value indicates the number of bytes actually read from the file. If the number of bytes read is less than uBytes, the function has reached the end of file (EOF) before reading the specified number of bytes.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-_lread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint _lread(int hFile, void *lpBuffer, uint uBytes);
        /// <summary>Writes data to the specified file.</summary>
        /// <param name = "hFile">A handle to the file that receives the data. This handle is created by <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-_lcreat">_lcreat</a>.</param>
        /// <param name = "lpBuffer">The buffer that contains the data to be added.</param>
        /// <param name = "uBytes">The number of bytes to write to the file.</param>
        /// <returns>If the function succeeds, the return value is the number of bytes written to the file. Otherwise, the return value is HFILE_ERROR. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-_lwrite">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint _lwrite(int hFile, win32.System.SystemServices.PCSTR lpBuffer, uint uBytes);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int _hread(int hFile, void *lpBuffer, int lBytes);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern int _hwrite(int hFile, win32.System.SystemServices.PCSTR lpBuffer, int lBytes);
        /// <summary>The _lclose function closes the specified file so that it is no longer available for reading or writing. This function is provided for compatibility with 16-bit versions of Windows. Win32-based applications should use the CloseHandle function.</summary>
        /// <param name = "hFile">Identifies the file to be closed. This handle is returned by the function that created or last opened the file.</param>
        /// <returns>Handle to file to close.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-_lclose">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern int _lclose(int hFile);
        /// <summary>Repositions the file pointer for the specified file.</summary>
        /// <param name = "hFile">A handle to an open file. This handle is created by <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-_lcreat">_lcreat</a>.</param>
        /// <param name = "lOffset">The number of bytes that the file pointer is to be moved.</param>
        /// <param name = "iOrigin">The starting point and the direction that the pointer will be moved.</param>
        /// <returns>If the function succeeds, the return value specifies the new offset. Otherwise, the return value is HFILE_ERROR. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-_llseek">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int _llseek(int hFile, int lOffset, int iOrigin);
        /// <inheritdoc cref = "SignalObjectAndWait(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, uint, bool)"/>
        internal static unsafe uint SignalObjectAndWait(SafeHandle hObjectToSignal, SafeHandle hObjectToWaitOn, uint dwMilliseconds, bool bAlertable)
        {
            bool hObjectToSignalAddRef = false;
            bool hObjectToWaitOnAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hObjectToSignalLocal;
                if (hObjectToSignal is object)
                {
                    hObjectToSignal.DangerousAddRef(ref hObjectToSignalAddRef);
                    hObjectToSignalLocal = (win32.System.SystemServices.HANDLE)hObjectToSignal.DangerousGetHandle();
                }
                else
                    hObjectToSignalLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE hObjectToWaitOnLocal;
                if (hObjectToWaitOn is object)
                {
                    hObjectToWaitOn.DangerousAddRef(ref hObjectToWaitOnAddRef);
                    hObjectToWaitOnLocal = (win32.System.SystemServices.HANDLE)hObjectToWaitOn.DangerousGetHandle();
                }
                else
                    hObjectToWaitOnLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.SignalObjectAndWait(hObjectToSignalLocal, hObjectToWaitOnLocal, dwMilliseconds, bAlertable);
                return __result;
            }
            finally
            {
                if (hObjectToSignalAddRef)
                    hObjectToSignal.DangerousRelease();
                if (hObjectToWaitOnAddRef)
                    hObjectToWaitOn.DangerousRelease();
            }
        }

        /// <summary>Signals one object and waits on another object as a single operation.</summary>
        /// <param name = "hObjectToSignal">
        /// <para>A handle to the object to be signaled. This object can be a semaphore, a mutex, or an event.</para>
        /// <para>If the handle is a semaphore, the <b>SEMAPHORE_MODIFY_STATE</b> access right is required. If the handle is an event, the <b>EVENT_MODIFY_STATE</b> access right is required. If the handle is a mutex and the caller does not own the mutex, the function fails with <b>ERROR_NOT_OWNER</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-signalobjectandwait#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hObjectToWaitOn">
        /// <para>A handle to the object to wait on. The <b>SYNCHRONIZE</b> access right is required; for more information, see <a href = "https://docs.microsoft.com/windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>. For a list of the object types whose handles you can specify, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-signalobjectandwait#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMilliseconds">The time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state is nonsignaled and no completion or asynchronous procedure call (APC) objects are queued. If <i>dwMilliseconds</i> is zero, the function tests the object's state, checks for queued completion routines or APCs, and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses.</param>
        /// <param name = "bAlertable">
        /// <para>If this parameter is <b>TRUE</b>, the function returns when the system queues an I/O completion routine or APC function, and the thread calls the function. If <b>FALSE</b>, the function does not return, and the thread does not call the completion routine or APC function.</para>
        /// <para>A completion routine is queued when the function call that queued the APC has completed. This function returns and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b>, and the calling thread is the thread that queued the APC.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-signalobjectandwait#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//synchapi/nf-synchapi-signalobjectandwait">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint SignalObjectAndWait(win32.System.SystemServices.HANDLE hObjectToSignal, win32.System.SystemServices.HANDLE hObjectToWaitOn, uint dwMilliseconds, bool bAlertable);
        /// <inheritdoc cref = "GetFirmwareEnvironmentVariable(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, void *, uint)"/>
        internal static unsafe uint GetFirmwareEnvironmentVariable(string lpName, string lpGuid, void *pBuffer, uint nSize)
        {
            fixed (char *lpGuidLocal = lpGuid)
            {
                fixed (char *lpNameLocal = lpName)
                {
                    uint __result = Kernel32.GetFirmwareEnvironmentVariable(lpNameLocal, lpGuidLocal, pBuffer, nSize);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves the value of the specified firmware environment variable.</summary>
        /// <param name = "lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
        /// <param name = "lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</param>
        /// <param name = "pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
        /// <param name = "nSize">The size of the <i>pBuffer</i> buffer, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include ERROR_INVALID_FUNCTION.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfirmwareenvironmentvariablew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetFirmwareEnvironmentVariableW", SetLastError = true)]
        internal static extern unsafe uint GetFirmwareEnvironmentVariable(win32.System.SystemServices.PCWSTR lpName, win32.System.SystemServices.PCWSTR lpGuid, [Optional] void *pBuffer, uint nSize);
        /// <inheritdoc cref = "GetFirmwareEnvironmentVariableEx(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, void *, uint, uint *)"/>
        internal static unsafe uint GetFirmwareEnvironmentVariableEx(string lpName, string lpGuid, void *pBuffer, uint nSize, uint *pdwAttribubutes)
        {
            fixed (char *lpGuidLocal = lpGuid)
            {
                fixed (char *lpNameLocal = lpName)
                {
                    uint __result = Kernel32.GetFirmwareEnvironmentVariableEx(lpNameLocal, lpGuidLocal, pBuffer, nSize, pdwAttribubutes);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves the value of the specified firmware environment variable and its attributes.</summary>
        /// <param name = "lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
        /// <param name = "lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</param>
        /// <param name = "pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
        /// <param name = "nSize">The size of the <i>pValue</i> buffer, in bytes.</param>
        /// <param name = "pdwAttribubutes">Bitmask identifying UEFI variable attributes associated with the variable. See <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setfirmwareenvironmentvariableexa">SetFirmwareEnvironmentVariableEx</a> for the bitmask definition.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include ERROR_INVALID_FUNCTION.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfirmwareenvironmentvariableexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetFirmwareEnvironmentVariableExW", SetLastError = true)]
        internal static extern unsafe uint GetFirmwareEnvironmentVariableEx(win32.System.SystemServices.PCWSTR lpName, win32.System.SystemServices.PCWSTR lpGuid, [Optional] void *pBuffer, uint nSize, [Optional] uint *pdwAttribubutes);
        /// <inheritdoc cref = "SetFirmwareEnvironmentVariable(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, void *, uint)"/>
        internal static unsafe bool SetFirmwareEnvironmentVariable(string lpName, string lpGuid, void *pValue, uint nSize)
        {
            fixed (char *lpGuidLocal = lpGuid)
            {
                fixed (char *lpNameLocal = lpName)
                {
                    bool __result = Kernel32.SetFirmwareEnvironmentVariable(lpNameLocal, lpGuidLocal, pValue, nSize);
                    return __result;
                }
            }
        }

        /// <summary>Sets the value of the specified firmware environment variable.</summary>
        /// <param name = "lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
        /// <param name = "lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</param>
        /// <param name = "pValue">A pointer to the new value for the  firmware environment variable.</param>
        /// <param name = "nSize">The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include ERROR_INVALID_FUNCTION.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfirmwareenvironmentvariablew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetFirmwareEnvironmentVariableW", SetLastError = true)]
        internal static extern unsafe bool SetFirmwareEnvironmentVariable(win32.System.SystemServices.PCWSTR lpName, win32.System.SystemServices.PCWSTR lpGuid, [Optional] void *pValue, uint nSize);
        /// <inheritdoc cref = "SetFirmwareEnvironmentVariableEx(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, void *, uint, uint)"/>
        internal static unsafe bool SetFirmwareEnvironmentVariableEx(string lpName, string lpGuid, void *pValue, uint nSize, uint dwAttributes)
        {
            fixed (char *lpGuidLocal = lpGuid)
            {
                fixed (char *lpNameLocal = lpName)
                {
                    bool __result = Kernel32.SetFirmwareEnvironmentVariableEx(lpNameLocal, lpGuidLocal, pValue, nSize, dwAttributes);
                    return __result;
                }
            }
        }

        /// <summary>Sets the value of the specified firmware environment variable and the attributes that indicate how this variable is stored and maintained.</summary>
        /// <param name = "lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
        /// <param name = "lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</param>
        /// <param name = "pValue">A pointer to the new value for the  firmware environment variable.</param>
        /// <param name = "nSize">
        /// <para>The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE, VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>, setting this value to zero will result in the deletion of this variable.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfirmwareenvironmentvariableexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwAttributes">
        /// <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href = "https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfirmwareenvironmentvariableexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include ERROR_INVALID_FUNCTION.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfirmwareenvironmentvariableexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetFirmwareEnvironmentVariableExW", SetLastError = true)]
        internal static extern unsafe bool SetFirmwareEnvironmentVariableEx(win32.System.SystemServices.PCWSTR lpName, win32.System.SystemServices.PCWSTR lpGuid, [Optional] void *pValue, uint nSize, uint dwAttributes);
        /// <inheritdoc cref = "GetFirmwareType(win32.System.WindowsProgramming.FIRMWARE_TYPE*)"/>
        internal static unsafe bool GetFirmwareType(ref win32.System.WindowsProgramming.FIRMWARE_TYPE FirmwareType)
        {
            fixed (win32.System.WindowsProgramming.FIRMWARE_TYPE*FirmwareTypeLocal = &FirmwareType)
            {
                bool __result = Kernel32.GetFirmwareType(FirmwareTypeLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the firmware type of the local computer.</summary>
        /// <param name = "FirmwareType">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ne-winnt-firmware_type">FIRMWARE_TYPE</a> enumeration.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfirmwaretype">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetFirmwareType(win32.System.WindowsProgramming.FIRMWARE_TYPE*FirmwareType);
        /// <inheritdoc cref = "IsNativeVhdBoot(bool *)"/>
        internal static unsafe bool IsNativeVhdBoot(out bool NativeVhdBoot)
        {
            fixed (bool *NativeVhdBootLocal = &NativeVhdBoot)
            {
                bool __result = Kernel32.IsNativeVhdBoot(NativeVhdBootLocal);
                return __result;
            }
        }

        /// <summary>Indicates if the OS was booted from a VHD container.</summary>
        /// <param name = "NativeVhdBoot">
        /// <para>Pointer to a variable that receives a boolean indicating if the OS was booted from a VHD.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-isnativevhdboot#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>TRUE if the OS was a native VHD boot; otherwise, FALSE.</para>
        /// <para>Call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-isnativevhdboot">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool IsNativeVhdBoot(bool *NativeVhdBoot);
        /// <inheritdoc cref = "GetProfileInt(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, int)"/>
        internal static unsafe uint GetProfileInt(string lpAppName, string lpKeyName, int nDefault)
        {
            fixed (char *lpKeyNameLocal = lpKeyName)
            {
                fixed (char *lpAppNameLocal = lpAppName)
                {
                    uint __result = Kernel32.GetProfileInt(lpAppNameLocal, lpKeyNameLocal, nDefault);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves an integer from a key in the specified section of the Win.ini file.</summary>
        /// <param name = "lpAppName">The name of the section containing the key name.</param>
        /// <param name = "lpKeyName">
        /// <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the <b>GetProfileInt</b> function converts the string into an integer and returns the integer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprofileintw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
        /// <returns>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprofileintw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetProfileIntW")]
        internal static extern uint GetProfileInt(win32.System.SystemServices.PCWSTR lpAppName, win32.System.SystemServices.PCWSTR lpKeyName, int nDefault);
        /// <inheritdoc cref = "GetProfileString(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint GetProfileString(string lpAppName, string lpKeyName, string lpDefault, win32.System.SystemServices.PWSTR lpReturnedString, uint nSize)
        {
            fixed (char *lpDefaultLocal = lpDefault)
            {
                fixed (char *lpKeyNameLocal = lpKeyName)
                {
                    fixed (char *lpAppNameLocal = lpAppName)
                    {
                        uint __result = Kernel32.GetProfileString(lpAppNameLocal, lpKeyNameLocal, lpDefaultLocal, lpReturnedString, nSize);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Retrieves the string associated with a key in the specified section of the Win.ini file.</summary>
        /// <param name = "lpAppName">The name of the section containing the key. If this parameter is <b>NULL</b>, the function copies all section names in the file to the supplied buffer.</param>
        /// <param name = "lpKeyName">The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, the function copies all keys in the given section to the supplied buffer. Each string is followed by a <b>null</b> character, and the final string is followed by a second <b>null</b> character.</param>
        /// <param name = "lpDefault">
        /// <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file, <b>GetProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer. If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
        /// <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprofilestringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpReturnedString">A pointer to a buffer that receives the character string.</param>
        /// <param name = "nSize">The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</param>
        /// <returns>
        /// <para>The return value is the number of characters copied to the buffer, not including the <b>null</b>-terminating character.</para>
        /// <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
        /// <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprofilestringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetProfileStringW")]
        internal static extern uint GetProfileString(win32.System.SystemServices.PCWSTR lpAppName, win32.System.SystemServices.PCWSTR lpKeyName, win32.System.SystemServices.PCWSTR lpDefault, win32.System.SystemServices.PWSTR lpReturnedString, uint nSize);
        /// <inheritdoc cref = "WriteProfileString(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool WriteProfileString(string lpAppName, string lpKeyName, string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                fixed (char *lpKeyNameLocal = lpKeyName)
                {
                    fixed (char *lpAppNameLocal = lpAppName)
                    {
                        bool __result = Kernel32.WriteProfileString(lpAppNameLocal, lpKeyNameLocal, lpStringLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Copies a string into the specified section of the Win.ini file.</summary>
        /// <param name = "lpAppName">The section to which the string is to be copied. If the section does not exist, it is created. The name of the section is not case-sensitive; the string can be any combination of uppercase and lowercase letters.</param>
        /// <param name = "lpKeyName">The key to be associated with the string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries in the section, is deleted.</param>
        /// <param name = "lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
        /// <returns>
        /// <para>If the function successfully copies the string to the Win.ini file, the return value is nonzero.</para>
        /// <para>If the function fails, or if it flushes the cached version of Win.ini, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writeprofilestringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "WriteProfileStringW", SetLastError = true)]
        internal static extern bool WriteProfileString(win32.System.SystemServices.PCWSTR lpAppName, win32.System.SystemServices.PCWSTR lpKeyName, win32.System.SystemServices.PCWSTR lpString);
        /// <inheritdoc cref = "GetProfileSection(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint GetProfileSection(string lpAppName, win32.System.SystemServices.PWSTR lpReturnedString, uint nSize)
        {
            fixed (char *lpAppNameLocal = lpAppName)
            {
                uint __result = Kernel32.GetProfileSection(lpAppNameLocal, lpReturnedString, nSize);
                return __result;
            }
        }

        /// <summary>Retrieves all the keys and values for the specified section of the Win.ini file.</summary>
        /// <param name = "lpAppName">The name of the section in the Win.ini file.</param>
        /// <param name = "lpReturnedString">A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
        /// <param name = "nSize">
        /// <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
        /// <para>The maximum profile section size is 32,767 characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprofilesectionw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprofilesectionw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetProfileSectionW")]
        internal static extern uint GetProfileSection(win32.System.SystemServices.PCWSTR lpAppName, win32.System.SystemServices.PWSTR lpReturnedString, uint nSize);
        /// <inheritdoc cref = "WriteProfileSection(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool WriteProfileSection(string lpAppName, string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                fixed (char *lpAppNameLocal = lpAppName)
                {
                    bool __result = Kernel32.WriteProfileSection(lpAppNameLocal, lpStringLocal);
                    return __result;
                }
            }
        }

        /// <summary>Replaces the contents of the specified section in the Win.ini file with specified keys and values.</summary>
        /// <param name = "lpAppName">The name of the section. This section name is typically the name of the calling application.</param>
        /// <param name = "lpString">
        /// <para>The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</para>
        /// <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writeprofilesectionw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writeprofilesectionw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "WriteProfileSectionW", SetLastError = true)]
        internal static extern bool WriteProfileSection(win32.System.SystemServices.PCWSTR lpAppName, win32.System.SystemServices.PCWSTR lpString);
        /// <inheritdoc cref = "GetPrivateProfileInt(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe uint GetPrivateProfileInt(string lpAppName, string lpKeyName, int nDefault, string lpFileName)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                fixed (char *lpKeyNameLocal = lpKeyName)
                {
                    fixed (char *lpAppNameLocal = lpAppName)
                    {
                        uint __result = Kernel32.GetPrivateProfileInt(lpAppNameLocal, lpKeyNameLocal, nDefault, lpFileNameLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Retrieves an integer associated with a key in the specified section of an initialization file.</summary>
        /// <param name = "lpAppName">The name of the section in the initialization file.</param>
        /// <param name = "lpKeyName">
        /// <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the <b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprivateprofileintw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
        /// <param name = "lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
        /// <returns>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprivateprofileintw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetPrivateProfileIntW")]
        internal static extern uint GetPrivateProfileInt(win32.System.SystemServices.PCWSTR lpAppName, win32.System.SystemServices.PCWSTR lpKeyName, int nDefault, win32.System.SystemServices.PCWSTR lpFileName);
        /// <inheritdoc cref = "GetPrivateProfileString(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe uint GetPrivateProfileString(string lpAppName, string lpKeyName, string lpDefault, win32.System.SystemServices.PWSTR lpReturnedString, uint nSize, string lpFileName)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                fixed (char *lpDefaultLocal = lpDefault)
                {
                    fixed (char *lpKeyNameLocal = lpKeyName)
                    {
                        fixed (char *lpAppNameLocal = lpAppName)
                        {
                            uint __result = Kernel32.GetPrivateProfileString(lpAppNameLocal, lpKeyNameLocal, lpDefaultLocal, lpReturnedString, nSize, lpFileNameLocal);
                            return __result;
                        }
                    }
                }
            }
        }

        /// <summary>Retrieves a string from the specified section in an initialization file.</summary>
        /// <param name = "lpAppName">
        /// <para>The name of the section containing the key name. If this parameter is <b>NULL</b>, the <b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprivateprofilestringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpKeyName">The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</param>
        /// <param name = "lpDefault">
        /// <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file, <b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
        /// <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
        /// <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprivateprofilestringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpReturnedString">A pointer to the buffer that receives the retrieved string.</param>
        /// <param name = "nSize">The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</param>
        /// <param name = "lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
        /// <returns>
        /// <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
        /// <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
        /// <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
        /// <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprivateprofilestringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetPrivateProfileStringW", SetLastError = true)]
        internal static extern uint GetPrivateProfileString(win32.System.SystemServices.PCWSTR lpAppName, win32.System.SystemServices.PCWSTR lpKeyName, win32.System.SystemServices.PCWSTR lpDefault, win32.System.SystemServices.PWSTR lpReturnedString, uint nSize, win32.System.SystemServices.PCWSTR lpFileName);
        /// <inheritdoc cref = "WritePrivateProfileString(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool WritePrivateProfileString(string lpAppName, string lpKeyName, string lpString, string lpFileName)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                fixed (char *lpStringLocal = lpString)
                {
                    fixed (char *lpKeyNameLocal = lpKeyName)
                    {
                        fixed (char *lpAppNameLocal = lpAppName)
                        {
                            bool __result = Kernel32.WritePrivateProfileString(lpAppNameLocal, lpKeyNameLocal, lpStringLocal, lpFileNameLocal);
                            return __result;
                        }
                    }
                }
            }
        }

        /// <summary>Copies a string into the specified section of an initialization file.</summary>
        /// <param name = "lpAppName">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters.</param>
        /// <param name = "lpKeyName">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries within the section, is deleted.</param>
        /// <param name = "lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
        /// <param name = "lpFileName">
        /// <para>The name of the initialization file.</para>
        /// <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writeprivateprofilestringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function successfully copies the string to the initialization file, the return value is nonzero.</para>
        /// <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writeprivateprofilestringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "WritePrivateProfileStringW", SetLastError = true)]
        internal static extern bool WritePrivateProfileString(win32.System.SystemServices.PCWSTR lpAppName, win32.System.SystemServices.PCWSTR lpKeyName, win32.System.SystemServices.PCWSTR lpString, win32.System.SystemServices.PCWSTR lpFileName);
        /// <inheritdoc cref = "GetPrivateProfileSection(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe uint GetPrivateProfileSection(string lpAppName, win32.System.SystemServices.PWSTR lpReturnedString, uint nSize, string lpFileName)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                fixed (char *lpAppNameLocal = lpAppName)
                {
                    uint __result = Kernel32.GetPrivateProfileSection(lpAppNameLocal, lpReturnedString, nSize, lpFileNameLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves all the keys and values for the specified section of an initialization file.</summary>
        /// <param name = "lpAppName">The name of the section in the initialization file.</param>
        /// <param name = "lpReturnedString">A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
        /// <param name = "nSize">
        /// <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
        /// <para>The maximum profile section size is 32,767 characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprivateprofilesectionw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
        /// <returns>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprivateprofilesectionw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetPrivateProfileSectionW")]
        internal static extern uint GetPrivateProfileSection(win32.System.SystemServices.PCWSTR lpAppName, win32.System.SystemServices.PWSTR lpReturnedString, uint nSize, win32.System.SystemServices.PCWSTR lpFileName);
        /// <inheritdoc cref = "WritePrivateProfileSection(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool WritePrivateProfileSection(string lpAppName, string lpString, string lpFileName)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                fixed (char *lpStringLocal = lpString)
                {
                    fixed (char *lpAppNameLocal = lpAppName)
                    {
                        bool __result = Kernel32.WritePrivateProfileSection(lpAppNameLocal, lpStringLocal, lpFileNameLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Replaces the keys and values for the specified section in an initialization file.</summary>
        /// <param name = "lpAppName">The name of the section in which data is written. This section name is typically the name of the calling application.</param>
        /// <param name = "lpString">The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</param>
        /// <param name = "lpFileName">
        /// <para>The name of the initialization file. If this parameter does not contain a full path for the file, the function searches the Windows directory for the file. If the file does not exist and <i>lpFileName</i> does not contain a full path, the function creates the file in the Windows directory.</para>
        /// <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writeprivateprofilesectionw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writeprivateprofilesectionw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "WritePrivateProfileSectionW", SetLastError = true)]
        internal static extern bool WritePrivateProfileSection(win32.System.SystemServices.PCWSTR lpAppName, win32.System.SystemServices.PCWSTR lpString, win32.System.SystemServices.PCWSTR lpFileName);
        /// <inheritdoc cref = "GetPrivateProfileSectionNames(win32.System.SystemServices.PWSTR, uint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe uint GetPrivateProfileSectionNames(win32.System.SystemServices.PWSTR lpszReturnBuffer, uint nSize, string lpFileName)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                uint __result = Kernel32.GetPrivateProfileSectionNames(lpszReturnBuffer, nSize, lpFileNameLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the names of all sections in an initialization file.</summary>
        /// <param name = "lpszReturnBuffer">A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</param>
        /// <param name = "nSize">The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</param>
        /// <param name = "lpFileName">The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
        /// <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprivateprofilesectionnamesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetPrivateProfileSectionNamesW")]
        internal static extern uint GetPrivateProfileSectionNames(win32.System.SystemServices.PWSTR lpszReturnBuffer, uint nSize, win32.System.SystemServices.PCWSTR lpFileName);
        /// <inheritdoc cref = "GetPrivateProfileStruct(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, void *, uint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool GetPrivateProfileStruct(string lpszSection, string lpszKey, void *lpStruct, uint uSizeStruct, string szFile)
        {
            fixed (char *szFileLocal = szFile)
            {
                fixed (char *lpszKeyLocal = lpszKey)
                {
                    fixed (char *lpszSectionLocal = lpszSection)
                    {
                        bool __result = Kernel32.GetPrivateProfileStruct(lpszSectionLocal, lpszKeyLocal, lpStruct, uSizeStruct, szFileLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Retrieves the data associated with a key in the specified section of an initialization file.</summary>
        /// <param name = "lpszSection">The name of the section in the initialization file.</param>
        /// <param name = "lpszKey">The name of the key whose data is to be retrieved.</param>
        /// <param name = "lpStruct">A pointer to the buffer that receives the data associated with the file, section, and key names.</param>
        /// <param name = "uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
        /// <param name = "szFile">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getprivateprofilestructw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetPrivateProfileStructW")]
        internal static extern unsafe bool GetPrivateProfileStruct(win32.System.SystemServices.PCWSTR lpszSection, win32.System.SystemServices.PCWSTR lpszKey, [Optional] void *lpStruct, uint uSizeStruct, win32.System.SystemServices.PCWSTR szFile);
        /// <inheritdoc cref = "WritePrivateProfileStruct(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, void *, uint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool WritePrivateProfileStruct(string lpszSection, string lpszKey, void *lpStruct, uint uSizeStruct, string szFile)
        {
            fixed (char *szFileLocal = szFile)
            {
                fixed (char *lpszKeyLocal = lpszKey)
                {
                    fixed (char *lpszSectionLocal = lpszSection)
                    {
                        bool __result = Kernel32.WritePrivateProfileStruct(lpszSectionLocal, lpszKeyLocal, lpStruct, uSizeStruct, szFileLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Copies data into a key in the specified section of an initialization file. As it copies the data, the function calculates a checksum and appends it to the end of the data.</summary>
        /// <param name = "lpszSection">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case independent, the string can be any combination of uppercase and lowercase letters.</param>
        /// <param name = "lpszKey">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all keys and entries within the section, is deleted.</param>
        /// <param name = "lpStruct">The data to be copied. If this parameter is <b>NULL</b>, the key is deleted.</param>
        /// <param name = "uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
        /// <param name = "szFile">
        /// <para>The  name of the initialization file. If this parameter is <b>NULL</b>, the information is copied into the Win.ini file.</para>
        /// <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writeprivateprofilestructw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function successfully copies the string to the initialization file, the return value is nonzero.</para>
        /// <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writeprivateprofilestructw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "WritePrivateProfileStructW", SetLastError = true)]
        internal static extern unsafe bool WritePrivateProfileStruct(win32.System.SystemServices.PCWSTR lpszSection, win32.System.SystemServices.PCWSTR lpszKey, [Optional] void *lpStruct, uint uSizeStruct, win32.System.SystemServices.PCWSTR szFile);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool IsBadHugeReadPtr([Optional] void *lp, nuint ucb);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool IsBadHugeWritePtr([Optional] void *lp, nuint ucb);
        /// <inheritdoc cref = "GetComputerName(win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe bool GetComputerName(win32.System.SystemServices.PWSTR lpBuffer, ref uint nSize)
        {
            fixed (uint *nSizeLocal = &nSize)
            {
                bool __result = Kernel32.GetComputerName(lpBuffer, nSizeLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</summary>
        /// <param name = "lpBuffer">A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
        /// <param name = "nSize">
        /// <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
        /// <para>If the buffer is too small, the function fails and <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcomputernamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcomputernamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetComputerNameW", SetLastError = true)]
        internal static extern unsafe bool GetComputerName(win32.System.SystemServices.PWSTR lpBuffer, uint *nSize);
        /// <inheritdoc cref = "DnsHostnameToComputerName(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe bool DnsHostnameToComputerName(string Hostname, win32.System.SystemServices.PWSTR ComputerName, ref uint nSize)
        {
            fixed (uint *nSizeLocal = &nSize)
            {
                fixed (char *HostnameLocal = Hostname)
                {
                    bool __result = Kernel32.DnsHostnameToComputerName(HostnameLocal, ComputerName, nSizeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Converts a DNS-style host name to a NetBIOS-style computer name.</summary>
        /// <param name = "Hostname">The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SysInfo/computer-names">Computer Names</a>.</param>
        /// <param name = "ComputerName">A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
        /// <param name = "nSize">
        /// <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
        /// <para>If the buffer is too small, the function fails, <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-dnshostnametocomputernamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible values include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-dnshostnametocomputernamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "DnsHostnameToComputerNameW", SetLastError = true)]
        internal static extern unsafe bool DnsHostnameToComputerName(win32.System.SystemServices.PCWSTR Hostname, win32.System.SystemServices.PWSTR ComputerName, uint *nSize);
        /// <inheritdoc cref = "SetTimerQueueTimer(win32.System.SystemServices.HANDLE, delegate *unmanaged[Stdcall]{void *, byte, void}, void *, uint, uint, bool)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle SetTimerQueueTimer(SafeHandle TimerQueue, delegate *unmanaged[Stdcall]<void *, byte, void>Callback, void *Parameter, uint DueTime, uint Period, bool PreferIo)
        {
            bool TimerQueueAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE TimerQueueLocal;
                if (TimerQueue is object)
                {
                    TimerQueue.DangerousAddRef(ref TimerQueueAddRef);
                    TimerQueueLocal = (win32.System.SystemServices.HANDLE)TimerQueue.DangerousGetHandle();
                }
                else
                    TimerQueueLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE __result = Kernel32.SetTimerQueueTimer(TimerQueueLocal, Callback, Parameter, DueTime, Period, PreferIo);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (TimerQueueAddRef)
                    TimerQueue.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE SetTimerQueueTimer(win32.System.SystemServices.HANDLE TimerQueue, delegate *unmanaged[Stdcall]<void *, byte, void>Callback, [Optional] void *Parameter, uint DueTime, uint Period, bool PreferIo);
        /// <inheritdoc cref = "CancelTimerQueueTimer(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool CancelTimerQueueTimer(SafeHandle TimerQueue, SafeHandle Timer)
        {
            bool TimerQueueAddRef = false;
            bool TimerAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE TimerQueueLocal;
                if (TimerQueue is object)
                {
                    TimerQueue.DangerousAddRef(ref TimerQueueAddRef);
                    TimerQueueLocal = (win32.System.SystemServices.HANDLE)TimerQueue.DangerousGetHandle();
                }
                else
                    TimerQueueLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE TimerLocal;
                if (Timer is object)
                {
                    Timer.DangerousAddRef(ref TimerAddRef);
                    TimerLocal = (win32.System.SystemServices.HANDLE)Timer.DangerousGetHandle();
                }
                else
                    TimerLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.CancelTimerQueueTimer(TimerQueueLocal, TimerLocal);
                return __result;
            }
            finally
            {
                if (TimerQueueAddRef)
                    TimerQueue.DangerousRelease();
                if (TimerAddRef)
                    Timer.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool CancelTimerQueueTimer(win32.System.SystemServices.HANDLE TimerQueue, win32.System.SystemServices.HANDLE Timer);
        /// <inheritdoc cref = "VerifyVersionInfo(win32.System.WindowsProgramming.OSVERSIONINFOEXW*, win32.System.WindowsProgramming.VER_FLAGS, ulong)"/>
        internal static unsafe bool VerifyVersionInfo(ref win32.System.WindowsProgramming.OSVERSIONINFOEXW lpVersionInformation, win32.System.WindowsProgramming.VER_FLAGS dwTypeMask, ulong dwlConditionMask)
        {
            fixed (win32.System.WindowsProgramming.OSVERSIONINFOEXW*lpVersionInformationLocal = &lpVersionInformation)
            {
                bool __result = Kernel32.VerifyVersionInfo(lpVersionInformationLocal, dwTypeMask, dwlConditionMask);
                return __result;
            }
        }

        /// <summary>Compares a set of operating system version requirements to the corresponding values for the currently running version of the system.</summary>
        /// <param name = "lpVersionInformation">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-osversioninfoexa">OSVERSIONINFOEX</a> structure containing the operating system version requirements to compare. The <i>dwTypeMask</i> parameter indicates the members of this structure that contain information to compare.</para>
        /// <para>You must set the <b>dwOSVersionInfoSize</b> member of this structure to <c>sizeof(OSVERSIONINFOEX)</c>. You must also specify valid data for the members indicated by <i>dwTypeMask</i>. The function ignores structure members for which the corresponding <i>dwTypeMask</i> bit is not set.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-verifyversioninfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwTypeMask">A mask that indicates the members of the</param>
        /// <param name = "dwlConditionMask">
        /// <para>The type of comparison to be used for each <b>lpVersionInfo</b> member being compared. To build this value, call the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-versetconditionmask">VerSetConditionMask</a> function or the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-ver_set_condition">VER_SET_CONDITION</a> macro once for each <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-osversioninfoexa">OSVERSIONINFOEX</a> member being compared.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-verifyversioninfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the currently running operating system satisfies the specified requirements, the return value is a nonzero value.</para>
        /// <para>If the current system does not satisfy the requirements, the return value is zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_OLD_WIN_VERSION.</para>
        /// <para>If the function fails, the return value is zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns an error code other than ERROR_OLD_WIN_VERSION.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-verifyversioninfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "VerifyVersionInfoW", SetLastError = true)]
        internal static extern unsafe bool VerifyVersionInfo(win32.System.WindowsProgramming.OSVERSIONINFOEXW*lpVersionInformation, win32.System.WindowsProgramming.VER_FLAGS dwTypeMask, ulong dwlConditionMask);
        /// <inheritdoc cref = "SystemTimeToTzSpecificLocalTime(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*, win32.System.WindowsProgramming.SYSTEMTIME*, win32.System.WindowsProgramming.SYSTEMTIME*)"/>
        internal static unsafe bool SystemTimeToTzSpecificLocalTime(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION? lpTimeZoneInformation, in win32.System.WindowsProgramming.SYSTEMTIME lpUniversalTime, out win32.System.WindowsProgramming.SYSTEMTIME lpLocalTime)
        {
            fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpLocalTimeLocal = &lpLocalTime)
            {
                fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpUniversalTimeLocal = &lpUniversalTime)
                {
                    win32.System.WindowsProgramming.TIME_ZONE_INFORMATION lpTimeZoneInformationLocal = lpTimeZoneInformation.HasValue ? lpTimeZoneInformation.Value : default(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION);
                    bool __result = Kernel32.SystemTimeToTzSpecificLocalTime(lpTimeZoneInformation.HasValue ? &lpTimeZoneInformationLocal : null, lpUniversalTimeLocal, lpLocalTimeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Converts a time in Coordinated Universal Time (UTC) to a specified time zone's corresponding local time.</summary>
        /// <param name = "lpTimeZoneInformation">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/timezoneapi/ns-timezoneapi-time_zone_information">TIME_ZONE_INFORMATION</a> structure that specifies the time zone of interest.</para>
        /// <para>If <i>lpTimeZone</i> is <b>NULL</b>, the function uses the currently active time zone.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-systemtimetotzspecificlocaltime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpUniversalTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that specifies the UTC time to be converted. The function converts this universal time to the specified time zone's corresponding local time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-systemtimetotzspecificlocaltime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpLocalTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that receives the local time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-systemtimetotzspecificlocaltime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero, and the function sets the members of the <a href = "/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure pointed to by <i>lpLocalTime</i> to the appropriate local time values.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-systemtimetotzspecificlocaltime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SystemTimeToTzSpecificLocalTime([Optional] win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*lpTimeZoneInformation, win32.System.WindowsProgramming.SYSTEMTIME*lpUniversalTime, win32.System.WindowsProgramming.SYSTEMTIME*lpLocalTime);
        /// <inheritdoc cref = "TzSpecificLocalTimeToSystemTime(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*, win32.System.WindowsProgramming.SYSTEMTIME*, win32.System.WindowsProgramming.SYSTEMTIME*)"/>
        internal static unsafe bool TzSpecificLocalTimeToSystemTime(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION? lpTimeZoneInformation, in win32.System.WindowsProgramming.SYSTEMTIME lpLocalTime, out win32.System.WindowsProgramming.SYSTEMTIME lpUniversalTime)
        {
            fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpUniversalTimeLocal = &lpUniversalTime)
            {
                fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpLocalTimeLocal = &lpLocalTime)
                {
                    win32.System.WindowsProgramming.TIME_ZONE_INFORMATION lpTimeZoneInformationLocal = lpTimeZoneInformation.HasValue ? lpTimeZoneInformation.Value : default(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION);
                    bool __result = Kernel32.TzSpecificLocalTimeToSystemTime(lpTimeZoneInformation.HasValue ? &lpTimeZoneInformationLocal : null, lpLocalTimeLocal, lpUniversalTimeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Converts a local time to a time in Coordinated Universal Time (UTC).</summary>
        /// <param name = "lpTimeZoneInformation">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/timezoneapi/ns-timezoneapi-time_zone_information">TIME_ZONE_INFORMATION</a> structure that specifies the time zone for the time specified in <i>lpLocalTime</i>.</para>
        /// <para>If <i>lpTimeZoneInformation</i> is <b>NULL</b>, the function uses the currently active time zone.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-tzspecificlocaltimetosystemtime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpLocalTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that specifies the local time to be converted. The function converts this time to the corresponding UTC time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-tzspecificlocaltimetosystemtime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpUniversalTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that receives the UTC time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-tzspecificlocaltimetosystemtime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero, and the function sets the members of the <a href = "/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure pointed to by <i>lpUniversalTime</i> to the appropriate values.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-tzspecificlocaltimetosystemtime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool TzSpecificLocalTimeToSystemTime([Optional] win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*lpTimeZoneInformation, win32.System.WindowsProgramming.SYSTEMTIME*lpLocalTime, win32.System.WindowsProgramming.SYSTEMTIME*lpUniversalTime);
        /// <inheritdoc cref = "FileTimeToSystemTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*, win32.System.WindowsProgramming.SYSTEMTIME*)"/>
        internal static unsafe bool FileTimeToSystemTime(in global::System.Runtime.InteropServices.ComTypes.FILETIME lpFileTime, out win32.System.WindowsProgramming.SYSTEMTIME lpSystemTime)
        {
            fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTimeLocal = &lpSystemTime)
            {
                fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTimeLocal = &lpFileTime)
                {
                    bool __result = Kernel32.FileTimeToSystemTime(lpFileTimeLocal, lpSystemTimeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Converts a file time to system time format. System time is based on Coordinated Universal Time (UTC).</summary>
        /// <param name = "lpFileTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure containing the file time to be converted to system (UTC) date and time format.</para>
        /// <para>This value must be less than 0x8000000000000000. Otherwise, the function fails.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-filetimetosystemtime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSystemTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure to receive the converted file time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-filetimetosystemtime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-filetimetosystemtime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool FileTimeToSystemTime(global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTime, win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTime);
        /// <inheritdoc cref = "SystemTimeToFileTime(win32.System.WindowsProgramming.SYSTEMTIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe bool SystemTimeToFileTime(in win32.System.WindowsProgramming.SYSTEMTIME lpSystemTime, out global::System.Runtime.InteropServices.ComTypes.FILETIME lpFileTime)
        {
            fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTimeLocal = &lpFileTime)
            {
                fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTimeLocal = &lpSystemTime)
                {
                    bool __result = Kernel32.SystemTimeToFileTime(lpSystemTimeLocal, lpFileTimeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Converts a system time to file time format. System time is based on Coordinated Universal Time (UTC).</summary>
        /// <param name = "lpSystemTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the system time to be converted from UTC to file time format.</para>
        /// <para>The <b>wDayOfWeek</b> member of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure is ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-systemtimetofiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the converted system time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-systemtimetofiletime#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>> [!NOTE] > A False return value can indicate that the passed SYSTEMTIME structure represents an invalid date. Certain situations, such as the additional day added in a leap year, can result in application logic unexpectedly creating an invalid date. For more information on avoiding these issues, see [leap year readiness](https://techcommunity.microsoft.com/t5/azure-developer-community-blog/it-s-2020-is-your-code-ready-for-leap-day/ba-p/1157279).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-systemtimetofiletime">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SystemTimeToFileTime(win32.System.WindowsProgramming.SYSTEMTIME*lpSystemTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*lpFileTime);
        /// <inheritdoc cref = "GetTimeZoneInformation(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*)"/>
        internal static unsafe uint GetTimeZoneInformation(out win32.System.WindowsProgramming.TIME_ZONE_INFORMATION lpTimeZoneInformation)
        {
            fixed (win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*lpTimeZoneInformationLocal = &lpTimeZoneInformation)
            {
                uint __result = Kernel32.GetTimeZoneInformation(lpTimeZoneInformationLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the current time zone settings. These settings control the translations between Coordinated Universal Time (UTC) and local time.</summary>
        /// <param name = "lpTimeZoneInformation">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/timezoneapi/ns-timezoneapi-time_zone_information">TIME_ZONE_INFORMATION</a> structure to receive the current settings.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-gettimezoneinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-gettimezoneinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint GetTimeZoneInformation(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*lpTimeZoneInformation);
        /// <inheritdoc cref = "SetTimeZoneInformation(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*)"/>
        internal static unsafe bool SetTimeZoneInformation(in win32.System.WindowsProgramming.TIME_ZONE_INFORMATION lpTimeZoneInformation)
        {
            fixed (win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*lpTimeZoneInformationLocal = &lpTimeZoneInformation)
            {
                bool __result = Kernel32.SetTimeZoneInformation(lpTimeZoneInformationLocal);
                return __result;
            }
        }

        /// <summary>Sets the current time zone settings. These settings control translations from Coordinated Universal Time (UTC) to local time.</summary>
        /// <param name = "lpTimeZoneInformation">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/timezoneapi/ns-timezoneapi-time_zone_information">TIME_ZONE_INFORMATION</a> structure that contains the new settings.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-settimezoneinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-settimezoneinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetTimeZoneInformation(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*lpTimeZoneInformation);
        /// <inheritdoc cref = "SetDynamicTimeZoneInformation(win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*)"/>
        internal static unsafe bool SetDynamicTimeZoneInformation(in win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
        {
            fixed (win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*lpTimeZoneInformationLocal = &lpTimeZoneInformation)
            {
                bool __result = Kernel32.SetDynamicTimeZoneInformation(lpTimeZoneInformationLocal);
                return __result;
            }
        }

        /// <summary>Sets the current time zone and dynamic daylight saving time settings. These settings control translations from Coordinated Universal Time (UTC) to local time.</summary>
        /// <param name = "lpTimeZoneInformation">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/timezoneapi/ns-timezoneapi-dynamic_time_zone_information">DYNAMIC_TIME_ZONE_INFORMATION</a> structure.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-setdynamictimezoneinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetDynamicTimeZoneInformation(win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*lpTimeZoneInformation);
        /// <inheritdoc cref = "GetDynamicTimeZoneInformation(win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*)"/>
        internal static unsafe uint GetDynamicTimeZoneInformation(out win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
        {
            fixed (win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*pTimeZoneInformationLocal = &pTimeZoneInformation)
            {
                uint __result = Kernel32.GetDynamicTimeZoneInformation(pTimeZoneInformationLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the current time zone and dynamic daylight saving time settings. These settings control the translations between Coordinated Universal Time (UTC) and local time.</summary>
        /// <param name = "pTimeZoneInformation">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/timezoneapi/ns-timezoneapi-dynamic_time_zone_information">DYNAMIC_TIME_ZONE_INFORMATION</a> structure.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-getdynamictimezoneinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint GetDynamicTimeZoneInformation(win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*pTimeZoneInformation);
        /// <inheritdoc cref = "GetTimeZoneInformationForYear(ushort, win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*, win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*)"/>
        internal static unsafe bool GetTimeZoneInformationForYear(ushort wYear, win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION? pdtzi, out win32.System.WindowsProgramming.TIME_ZONE_INFORMATION ptzi)
        {
            fixed (win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*ptziLocal = &ptzi)
            {
                win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION pdtziLocal = pdtzi.HasValue ? pdtzi.Value : default(win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION);
                bool __result = Kernel32.GetTimeZoneInformationForYear(wYear, pdtzi.HasValue ? &pdtziLocal : null, ptziLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the time zone settings for the specified year and time zone. These settings control the translations between Coordinated Universal Time (UTC) and local time.</summary>
        /// <param name = "wYear">The year for which the time zone settings are to be retrieved. The <i>wYear</i> parameter must be a local time value.</param>
        /// <param name = "pdtzi">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/timezoneapi/ns-timezoneapi-dynamic_time_zone_information">DYNAMIC_TIME_ZONE_INFORMATION</a> structure that specifies the time zone.  To populate this parameter, call <a href = "https://docs.microsoft.com/windows/desktop/api/timezoneapi/nf-timezoneapi-enumdynamictimezoneinformation">EnumDynamicTimeZoneInformation</a> with the index of the time zone you want. If this parameter is <b>NULL</b>, the current time zone is used.</param>
        /// <param name = "ptzi">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/timezoneapi/ns-timezoneapi-time_zone_information">TIME_ZONE_INFORMATION</a> structure that receives the time zone settings.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-gettimezoneinformationforyear">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetTimeZoneInformationForYear(ushort wYear, [Optional] win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*pdtzi, win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*ptzi);
        /// <inheritdoc cref = "SystemTimeToTzSpecificLocalTimeEx(win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*, win32.System.WindowsProgramming.SYSTEMTIME*, win32.System.WindowsProgramming.SYSTEMTIME*)"/>
        internal static unsafe bool SystemTimeToTzSpecificLocalTimeEx(win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION? lpTimeZoneInformation, in win32.System.WindowsProgramming.SYSTEMTIME lpUniversalTime, out win32.System.WindowsProgramming.SYSTEMTIME lpLocalTime)
        {
            fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpLocalTimeLocal = &lpLocalTime)
            {
                fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpUniversalTimeLocal = &lpUniversalTime)
                {
                    win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformationLocal = lpTimeZoneInformation.HasValue ? lpTimeZoneInformation.Value : default(win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION);
                    bool __result = Kernel32.SystemTimeToTzSpecificLocalTimeEx(lpTimeZoneInformation.HasValue ? &lpTimeZoneInformationLocal : null, lpUniversalTimeLocal, lpLocalTimeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Converts a time in Coordinated Universal Time (UTC) with dynamic daylight saving time settings to a specified time zone's corresponding local time.</summary>
        /// <param name = "lpTimeZoneInformation">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/timezoneapi/ns-timezoneapi-dynamic_time_zone_information">DYNAMIC_TIME_ZONE_INFORMATION</a> structure that specifies  the time zone and dynamic daylight saving time.</param>
        /// <param name = "lpUniversalTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that specifies the UTC time to be converted. The function converts this universal time to the specified time zone's corresponding local time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-systemtimetotzspecificlocaltimeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpLocalTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that receives the local time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-systemtimetotzspecificlocaltimeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-systemtimetotzspecificlocaltimeex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SystemTimeToTzSpecificLocalTimeEx([Optional] win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*lpTimeZoneInformation, win32.System.WindowsProgramming.SYSTEMTIME*lpUniversalTime, win32.System.WindowsProgramming.SYSTEMTIME*lpLocalTime);
        /// <inheritdoc cref = "TzSpecificLocalTimeToSystemTimeEx(win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*, win32.System.WindowsProgramming.SYSTEMTIME*, win32.System.WindowsProgramming.SYSTEMTIME*)"/>
        internal static unsafe bool TzSpecificLocalTimeToSystemTimeEx(win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION? lpTimeZoneInformation, in win32.System.WindowsProgramming.SYSTEMTIME lpLocalTime, out win32.System.WindowsProgramming.SYSTEMTIME lpUniversalTime)
        {
            fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpUniversalTimeLocal = &lpUniversalTime)
            {
                fixed (win32.System.WindowsProgramming.SYSTEMTIME*lpLocalTimeLocal = &lpLocalTime)
                {
                    win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformationLocal = lpTimeZoneInformation.HasValue ? lpTimeZoneInformation.Value : default(win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION);
                    bool __result = Kernel32.TzSpecificLocalTimeToSystemTimeEx(lpTimeZoneInformation.HasValue ? &lpTimeZoneInformationLocal : null, lpLocalTimeLocal, lpUniversalTimeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Converts a local time to a time with dynamic daylight saving time settings to Coordinated Universal Time (UTC).</summary>
        /// <param name = "lpTimeZoneInformation">A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/timezoneapi/ns-timezoneapi-dynamic_time_zone_information">DYNAMIC_TIME_ZONE_INFORMATION</a> structure that specifies  the time zone and dynamic daylight saving time.</param>
        /// <param name = "lpLocalTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that specifies the local time to be converted. The function converts this time to the corresponding UTC time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-tzspecificlocaltimetosystemtimeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpUniversalTime">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that receives the UTC time.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-tzspecificlocaltimetosystemtimeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//timezoneapi/nf-timezoneapi-tzspecificlocaltimetosystemtimeex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool TzSpecificLocalTimeToSystemTimeEx([Optional] win32.System.WindowsProgramming.DYNAMIC_TIME_ZONE_INFORMATION*lpTimeZoneInformation, win32.System.WindowsProgramming.SYSTEMTIME*lpLocalTime, win32.System.WindowsProgramming.SYSTEMTIME*lpUniversalTime);
        /// <inheritdoc cref = "LocalFileTimeToLocalSystemTime(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*, global::System.Runtime.InteropServices.ComTypes.FILETIME*, win32.System.WindowsProgramming.SYSTEMTIME*)"/>
        internal static unsafe bool LocalFileTimeToLocalSystemTime(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION? timeZoneInformation, in global::System.Runtime.InteropServices.ComTypes.FILETIME localFileTime, out win32.System.WindowsProgramming.SYSTEMTIME localSystemTime)
        {
            fixed (win32.System.WindowsProgramming.SYSTEMTIME*localSystemTimeLocal = &localSystemTime)
            {
                fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*localFileTimeLocal = &localFileTime)
                {
                    win32.System.WindowsProgramming.TIME_ZONE_INFORMATION timeZoneInformationLocal = timeZoneInformation.HasValue ? timeZoneInformation.Value : default(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION);
                    bool __result = Kernel32.LocalFileTimeToLocalSystemTime(timeZoneInformation.HasValue ? &timeZoneInformationLocal : null, localFileTimeLocal, localSystemTimeLocal);
                    return __result;
                }
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool LocalFileTimeToLocalSystemTime([Optional] win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*timeZoneInformation, global::System.Runtime.InteropServices.ComTypes.FILETIME*localFileTime, win32.System.WindowsProgramming.SYSTEMTIME*localSystemTime);
        /// <inheritdoc cref = "LocalSystemTimeToLocalFileTime(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*, win32.System.WindowsProgramming.SYSTEMTIME*, global::System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        internal static unsafe bool LocalSystemTimeToLocalFileTime(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION? timeZoneInformation, in win32.System.WindowsProgramming.SYSTEMTIME localSystemTime, out global::System.Runtime.InteropServices.ComTypes.FILETIME localFileTime)
        {
            fixed (global::System.Runtime.InteropServices.ComTypes.FILETIME*localFileTimeLocal = &localFileTime)
            {
                fixed (win32.System.WindowsProgramming.SYSTEMTIME*localSystemTimeLocal = &localSystemTime)
                {
                    win32.System.WindowsProgramming.TIME_ZONE_INFORMATION timeZoneInformationLocal = timeZoneInformation.HasValue ? timeZoneInformation.Value : default(win32.System.WindowsProgramming.TIME_ZONE_INFORMATION);
                    bool __result = Kernel32.LocalSystemTimeToLocalFileTime(timeZoneInformation.HasValue ? &timeZoneInformationLocal : null, localSystemTimeLocal, localFileTimeLocal);
                    return __result;
                }
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool LocalSystemTimeToLocalFileTime([Optional] win32.System.WindowsProgramming.TIME_ZONE_INFORMATION*timeZoneInformation, win32.System.WindowsProgramming.SYSTEMTIME*localSystemTime, global::System.Runtime.InteropServices.ComTypes.FILETIME*localFileTime);
        /// <inheritdoc cref = "CreateJobSet(uint, win32.System.SystemServices.JOB_SET_ARRAY*, uint)"/>
        internal static unsafe bool CreateJobSet(Span<win32.System.SystemServices.JOB_SET_ARRAY> UserJobSet, uint Flags)
        {
            fixed (win32.System.SystemServices.JOB_SET_ARRAY*UserJobSetLocal = UserJobSet)
            {
                bool __result = Kernel32.CreateJobSet((uint)UserJobSet.Length, UserJobSetLocal, Flags);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool CreateJobSet(uint NumJob, win32.System.SystemServices.JOB_SET_ARRAY*UserJobSet, uint Flags);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool ReplacePartitionUnit(win32.System.SystemServices.PWSTR TargetPartition, win32.System.SystemServices.PWSTR SparePartition, uint Flags);
        /// <summary>Checks whether the user has opted in for SQM data collection as part of the Customer Experience Improvement Program (CEIP).</summary>
        /// <returns>True if SQM data collection is opted in and the machine can send data. Otherwise, false.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//windowsceip/nf-windowsceip-ceipisoptedin">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool CeipIsOptedIn();
        /// <inheritdoc cref = "RtlUnwind(void *, void *, win32.System.Diagnostics.Debug.EXCEPTION_RECORD*, void *)"/>
        internal static unsafe void RtlUnwind(void *TargetFrame, void *TargetIp, win32.System.Diagnostics.Debug.EXCEPTION_RECORD? ExceptionRecord, void *ReturnValue)
        {
            win32.System.Diagnostics.Debug.EXCEPTION_RECORD ExceptionRecordLocal = ExceptionRecord.HasValue ? ExceptionRecord.Value : default(win32.System.Diagnostics.Debug.EXCEPTION_RECORD);
            Kernel32.RtlUnwind(TargetFrame, TargetIp, ExceptionRecord.HasValue ? &ExceptionRecordLocal : null, ReturnValue);
        }

        /// <summary>Initiates an unwind of procedure call frames.</summary>
        /// <param name = "TargetFrame">
        /// <para>A pointer to the call frame that is the target of the unwind. If this parameter is <b>NULL</b>, the function performs an exit unwind.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnt/nf-winnt-rtlunwind#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "TargetIp">
        /// <para>The continuation address of the unwind. This parameter is ignored if <i>TargetFrame</i> is <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnt/nf-winnt-rtlunwind#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ExceptionRecord">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-exception_record">EXCEPTION_RECORD</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnt/nf-winnt-rtlunwind#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ReturnValue">A value to be placed in the integer function return register before continuing execution.</param>
        /// <returns>This function does not return a value.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnt/nf-winnt-rtlunwind">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void RtlUnwind([Optional] void *TargetFrame, [Optional] void *TargetIp, [Optional] win32.System.Diagnostics.Debug.EXCEPTION_RECORD*ExceptionRecord, void *ReturnValue);
        /// <inheritdoc cref = "RtlPcToFileHeader(void *, void **)"/>
        internal static unsafe void *RtlPcToFileHeader(void *PcValue, out void *BaseOfImage)
        {
            fixed (void **BaseOfImageLocal = &BaseOfImage)
            {
                void *__result = Kernel32.RtlPcToFileHeader(PcValue, BaseOfImageLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the base address of the image that contains the specified PC value.</summary>
        /// <param name = "PcValue">The PC value. The function searches all modules mapped into the address space of the calling process for a module that contains this value.</param>
        /// <param name = "BaseOfImage">The base address of the image containing the PC value. This value must be added to any relative addresses in the headers to locate the image.</param>
        /// <returns>
        /// <para>If the PC value is found, the function returns the base address of the image that contains the PC value.</para>
        /// <para>If no image contains the PC value, the function returns <b>NULL</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnt/nf-winnt-rtlpctofileheader">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void *RtlPcToFileHeader(void *PcValue, void **BaseOfImage);
        /// <inheritdoc cref = "Wow64GetThreadContext(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.Debug.WOW64_CONTEXT*)"/>
        internal static unsafe bool Wow64GetThreadContext(SafeHandle hThread, ref win32.System.Diagnostics.Debug.WOW64_CONTEXT lpContext)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.Debug.WOW64_CONTEXT*lpContextLocal = &lpContext)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Wow64GetThreadContext(hThreadLocal, lpContextLocal);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Retrieves the context of the specified WOW64 thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread whose context is to be retrieved. The handle must have <b>THREAD_GET_CONTEXT</b> access to the thread. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64getthreadcontext#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpContext">
        /// <para>A <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-wow64_context">WOW64_CONTEXT</a> structure. The caller must initialize the <b>ContextFlags</b> member of this structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64getthreadcontext#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64getthreadcontext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Wow64GetThreadContext(win32.System.SystemServices.HANDLE hThread, win32.System.Diagnostics.Debug.WOW64_CONTEXT*lpContext);
        /// <inheritdoc cref = "Wow64SetThreadContext(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.Debug.WOW64_CONTEXT*)"/>
        internal static unsafe bool Wow64SetThreadContext(SafeHandle hThread, in win32.System.Diagnostics.Debug.WOW64_CONTEXT lpContext)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.Debug.WOW64_CONTEXT*lpContextLocal = &lpContext)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Wow64SetThreadContext(hThreadLocal, lpContextLocal);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Sets the context of the specified WOW64 thread.</summary>
        /// <param name = "hThread">A handle to the thread whose context is to be set.</param>
        /// <param name = "lpContext">
        /// <para>A <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-wow64_context">WOW64_CONTEXT</a> structure. The caller must initialize the <b>ContextFlags</b> member of this structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64setthreadcontext#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64setthreadcontext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Wow64SetThreadContext(win32.System.SystemServices.HANDLE hThread, win32.System.Diagnostics.Debug.WOW64_CONTEXT*lpContext);
        /// <summary>Determines whether the calling process is being debugged by a user-mode debugger.</summary>
        /// <returns>
        /// <para>If the current process is running in the context of a debugger, the return value is nonzero.</para>
        /// <para>If the current process is not running in the context of a debugger, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-isdebuggerpresent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool IsDebuggerPresent();
        /// <summary>Causes a breakpoint exception to occur in the current process. This allows the calling thread to signal the debugger to handle the exception.</summary>
        /// <remarks>
        /// <para>If the process is not being debugged, the function uses the search logic of a standard exception handler. In most cases, this causes the calling process to terminate because of an unhandled breakpoint exception.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-debugbreak#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void DebugBreak();
        /// <inheritdoc cref = "OutputDebugString(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe void OutputDebugString(string lpOutputString)
        {
            fixed (char *lpOutputStringLocal = lpOutputString)
            {
                Kernel32.OutputDebugString(lpOutputStringLocal);
            }
        }

        /// <summary>Sends a string to the debugger for display.</summary>
        /// <param name = "lpOutputString">The null-terminated string to be displayed.</param>
        /// <remarks>
        /// <para>If the application has no debugger, the system debugger displays the string if the filter mask allows it. (Note that this function calls the <b>DbgPrint</b> function to display the string. For details on how the filter mask controls what the system debugger displays, see the <b>DbgPrint</b> function in the Windows Driver Kit (WDK) on MSDN.) If the application has no debugger and the system debugger is not active, <b>OutputDebugString</b> does nothing.<b>Prior to Windows Vista:  </b>The system debugger does not filter content.</para>
        /// <para><b>OutputDebugStringW</b> converts the specified string based on the current system locale information and passes it to <b>OutputDebugStringA</b> to be displayed.  As a result, some Unicode characters may not be displayed correctly.</para>
        /// <para>Applications should send very minimal debug output and provide a way for the user to enable or disable its use. To provide more detailed tracing, see <a href = "https://docs.microsoft.com/windows/desktop/ETW/event-tracing-portal">Event Tracing</a>.</para>
        /// <para>Visual Studio has changed how it handles the display of these strings throughout its revision history.  Refer to the Visual Studio documentation for details of how your version deals with this.</para>
        /// <para>> [!NOTE] > The debugapi.h header defines OutputDebugString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-outputdebugstringw#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "OutputDebugStringW")]
        internal static extern void OutputDebugString(win32.System.SystemServices.PCWSTR lpOutputString);
        /// <summary>Enables a debugger to continue a thread that previously reported a debugging event.</summary>
        /// <param name = "dwProcessId">The process identifier  of the process to continue.</param>
        /// <param name = "dwThreadId">The thread identifier of the thread to continue. The combination of process identifier and thread identifier must identify a thread that has previously reported a debugging event.</param>
        /// <param name = "dwContinueStatus">
        /// <para>The options to continue the thread that reported the debugging event.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-continuedebugevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-continuedebugevent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ContinueDebugEvent(uint dwProcessId, uint dwThreadId, uint dwContinueStatus);
        /// <inheritdoc cref = "WaitForDebugEvent(win32.System.Diagnostics.Debug.DEBUG_EVENT*, uint)"/>
        internal static unsafe bool WaitForDebugEvent(out win32.System.Diagnostics.Debug.DEBUG_EVENT lpDebugEvent, uint dwMilliseconds)
        {
            fixed (win32.System.Diagnostics.Debug.DEBUG_EVENT*lpDebugEventLocal = &lpDebugEvent)
            {
                bool __result = Kernel32.WaitForDebugEvent(lpDebugEventLocal, dwMilliseconds);
                return __result;
            }
        }

        /// <summary>Waits for a debugging event to occur in a process being debugged.</summary>
        /// <param name = "lpDebugEvent">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-debug_event">DEBUG_EVENT</a> structure that receives information about the debugging event.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-waitfordebugevent#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMilliseconds">The number of milliseconds to wait for a debugging event. If this parameter is zero, the function tests for a debugging event and returns immediately. If the parameter is INFINITE, the function does not return until a debugging event has occurred.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-waitfordebugevent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool WaitForDebugEvent(win32.System.Diagnostics.Debug.DEBUG_EVENT*lpDebugEvent, uint dwMilliseconds);
        /// <summary>Enables a debugger to attach to an active process and debug it.</summary>
        /// <param name = "dwProcessId">
        /// <para>The identifier for the process to be debugged. The debugger is granted debugging access to the process as if it created the process with the <b>DEBUG_ONLY_THIS_PROCESS</b> flag. For more information, see the Remarks section of this topic.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-debugactiveprocess#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-debugactiveprocess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DebugActiveProcess(uint dwProcessId);
        /// <summary>Stops the debugger from debugging the specified process.</summary>
        /// <param name = "dwProcessId">The identifier of the process to stop debugging.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-debugactiveprocessstop">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DebugActiveProcessStop(uint dwProcessId);
        /// <inheritdoc cref = "CheckRemoteDebuggerPresent(win32.System.SystemServices.HANDLE, bool *)"/>
        internal static unsafe bool CheckRemoteDebuggerPresent(SafeHandle hProcess, out bool pbDebuggerPresent)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (bool *pbDebuggerPresentLocal = &pbDebuggerPresent)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.CheckRemoteDebuggerPresent(hProcessLocal, pbDebuggerPresentLocal);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Determines whether the specified process is being debugged.</summary>
        /// <param name = "hProcess">A handle to the process.</param>
        /// <param name = "pbDebuggerPresent">A pointer to a variable that the function sets to <b>TRUE</b> if the specified process is being debugged, or <b>FALSE</b> otherwise.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get  extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-checkremotedebuggerpresent">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool CheckRemoteDebuggerPresent(win32.System.SystemServices.HANDLE hProcess, bool *pbDebuggerPresent);
        /// <inheritdoc cref = "WaitForDebugEventEx(win32.System.Diagnostics.Debug.DEBUG_EVENT*, uint)"/>
        internal static unsafe bool WaitForDebugEventEx(out win32.System.Diagnostics.Debug.DEBUG_EVENT lpDebugEvent, uint dwMilliseconds)
        {
            fixed (win32.System.Diagnostics.Debug.DEBUG_EVENT*lpDebugEventLocal = &lpDebugEvent)
            {
                bool __result = Kernel32.WaitForDebugEventEx(lpDebugEventLocal, dwMilliseconds);
                return __result;
            }
        }

        /// <summary>Waits for a debugging event to occur in a process being debugged.</summary>
        /// <param name = "lpDebugEvent">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-debug_event">DEBUG_EVENT</a> structure that receives information about the debugging event.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-waitfordebugeventex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMilliseconds">The number of milliseconds to wait for a debugging event. If this parameter is zero, the function tests for a debugging event and returns immediately. If the parameter is INFINITE, the function does not return until a debugging event has occurred.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//debugapi/nf-debugapi-waitfordebugeventex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool WaitForDebugEventEx(win32.System.Diagnostics.Debug.DEBUG_EVENT*lpDebugEvent, uint dwMilliseconds);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void *EncodePointer([Optional] void *Ptr);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void *DecodePointer([Optional] void *Ptr);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void *EncodeSystemPointer([Optional] void *Ptr);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void *DecodeSystemPointer([Optional] void *Ptr);
        /// <summary>Generates simple tones on the speaker.</summary>
        /// <param name = "dwFreq">The frequency of the sound, in hertz. This parameter must be in the range 37 through 32,767 (0x25 through 0x7FFF).</param>
        /// <param name = "dwDuration">The duration of the sound, in milliseconds.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//utilapiset/nf-utilapiset-beep">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool Beep(uint dwFreq, uint dwDuration);
        /// <inheritdoc cref = "RaiseException(uint, uint, uint, nuint*)"/>
        internal static unsafe void RaiseException(uint dwExceptionCode, uint dwExceptionFlags, ReadOnlySpan<nuint> lpArguments)
        {
            fixed (nuint*lpArgumentsLocal = lpArguments)
            {
                Kernel32.RaiseException(dwExceptionCode, dwExceptionFlags, (uint)lpArguments.Length, lpArgumentsLocal);
            }
        }

        /// <summary>Raises an exception in the calling thread.</summary>
        /// <param name = "dwExceptionCode">
        /// <para>An application-defined exception code of the exception being raised. The filter expression and exception-handler block of an exception handler can use the <a href = "https://docs.microsoft.com/windows/desktop/Debug/getexceptioncode">GetExceptionCode</a> function to retrieve this value.</para>
        /// <para>Note that the system will clear bit 28 of <i>dwExceptionCode</i> before displaying a message This bit is a reserved exception bit, used by the system for its own purposes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//errhandlingapi/nf-errhandlingapi-raiseexception#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwExceptionFlags">The exception flags. This can be either zero to indicate a continuable exception, or EXCEPTION_NONCONTINUABLE to indicate a noncontinuable exception. Any attempt to continue execution after a noncontinuable exception causes the EXCEPTION_NONCONTINUABLE_EXCEPTION exception.</param>
        /// <param name = "nNumberOfArguments">The number of arguments in the <i>lpArguments</i> array. This value must not exceed EXCEPTION_MAXIMUM_PARAMETERS. This parameter is ignored if <i>lpArguments</i> is <b>NULL</b>.</param>
        /// <param name = "lpArguments">An array of arguments. This parameter can be <b>NULL</b>. These arguments can contain any application-defined data that needs to be passed to the filter expression of the exception handler.</param>
        /// <returns>This function does not return a value.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//errhandlingapi/nf-errhandlingapi-raiseexception">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void RaiseException(uint dwExceptionCode, uint dwExceptionFlags, uint nNumberOfArguments, [Optional] nuint*lpArguments);
        /// <summary>Sets the last-error code for the calling thread.</summary>
        /// <param name = "dwErrCode">The last-error code for the thread.</param>
        /// <remarks>
        /// <para>The last-error code is kept in thread local storage so that multiple threads do not overwrite each other's values.</para>
        /// <para>Most functions call <b>SetLastError</b> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a> only when they fail. However, some system functions call <b>SetLastError</b> or <b>SetLastErrorEx</b> under conditions of success; those cases are noted in each function's documentation.</para>
        /// <para>Applications can optionally retrieve the value set by this function by using the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function immediately after a function fails.</para>
        /// <para>Error codes are 32-bit values (bit 31 is the most significant bit). Bit 29 is reserved for application-defined error codes; no system error code has this bit set. If you are defining an error code for your application, set this bit to indicate that the error code has been defined by your application and to ensure that your error code does not conflict with any system-defined error codes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//errhandlingapi/nf-errhandlingapi-setlasterror#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern void SetLastError(uint dwErrCode);
        /// <summary>Retrieves the error mode for the current process.</summary>
        /// <returns>
        /// <para>The process error mode. This function returns one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//errhandlingapi/nf-errhandlingapi-geterrormode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetErrorMode();
        /// <summary>Controls whether the system will handle the specified types of serious errors or whether the process will handle them.</summary>
        /// <param name = "uMode"></param>
        /// <returns>The return value is the previous state of the error-mode bit flags.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//errhandlingapi/nf-errhandlingapi-seterrormode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint SetErrorMode(win32.System.Diagnostics.Debug.THREAD_ERROR_MODE uMode);
        /// <summary>Unregisters a vectored exception handler.</summary>
        /// <param name = "Handle">A handle to the vectored exception handler previously registered using the [AddVectoredExceptionHandler function](nf-errhandlingapi-addvectoredexceptionhandler.md).</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//errhandlingapi/nf-errhandlingapi-removevectoredexceptionhandler">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint RemoveVectoredExceptionHandler(void *Handle);
        /// <summary>Unregisters a vectored continue handler.</summary>
        /// <param name = "Handle">A pointer to a vectored exception handler previously registered using the [AddVectoredContinueHandler function](nf-errhandlingapi-addvectoredcontinuehandler.md).</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//errhandlingapi/nf-errhandlingapi-removevectoredcontinuehandler">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint RemoveVectoredContinueHandler(void *Handle);
        /// <inheritdoc cref = "FatalAppExit(uint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe void FatalAppExit(uint uAction, string lpMessageText)
        {
            fixed (char *lpMessageTextLocal = lpMessageText)
            {
                Kernel32.FatalAppExit(uAction, lpMessageTextLocal);
            }
        }

        /// <summary>Displays a message box and terminates the application when the message box is closed.</summary>
        /// <param name = "uAction">This parameter must be zero.</param>
        /// <param name = "lpMessageText">The null-terminated string that is displayed in the message box.</param>
        /// <remarks>
        /// <para>An application calls <b>FatalAppExit</b> only when it is not capable of terminating any other way.</para>
        /// <para>> [!NOTE] > The errhandlingapi.h header defines FatalAppExit as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//errhandlingapi/nf-errhandlingapi-fatalappexitw#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FatalAppExitW")]
        internal static extern void FatalAppExit(uint uAction, win32.System.SystemServices.PCWSTR lpMessageText);
        /// <summary>Retrieves the error mode for the calling thread.</summary>
        /// <returns>
        /// <para>The process error mode. This function returns one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//errhandlingapi/nf-errhandlingapi-getthreaderrormode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetThreadErrorMode();
        /// <inheritdoc cref = "SetThreadErrorMode(win32.System.Diagnostics.Debug.THREAD_ERROR_MODE, win32.System.Diagnostics.Debug.THREAD_ERROR_MODE*)"/>
        internal static unsafe bool SetThreadErrorMode(win32.System.Diagnostics.Debug.THREAD_ERROR_MODE dwNewMode, win32.System.Diagnostics.Debug.THREAD_ERROR_MODE? lpOldMode)
        {
            win32.System.Diagnostics.Debug.THREAD_ERROR_MODE lpOldModeLocal = lpOldMode.HasValue ? lpOldMode.Value : default(win32.System.Diagnostics.Debug.THREAD_ERROR_MODE);
            bool __result = Kernel32.SetThreadErrorMode(dwNewMode, lpOldMode.HasValue ? &lpOldModeLocal : null);
            return __result;
        }

        /// <summary>Controls whether the system will handle the specified types of serious errors or whether the calling thread will handle them.</summary>
        /// <param name = "dwNewMode"></param>
        /// <param name = "lpOldMode">If the function succeeds, this parameter is set to the thread's previous error mode. This parameter can be <b>NULL</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//errhandlingapi/nf-errhandlingapi-setthreaderrormode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetThreadErrorMode(win32.System.Diagnostics.Debug.THREAD_ERROR_MODE dwNewMode, [Optional] win32.System.Diagnostics.Debug.THREAD_ERROR_MODE*lpOldMode);
        /// <inheritdoc cref = "ReadProcessMemory(win32.System.SystemServices.HANDLE, void *, void *, nuint, nuint*)"/>
        internal static unsafe bool ReadProcessMemory(SafeHandle hProcess, void *lpBaseAddress, void *lpBuffer, nuint nSize, nuint*lpNumberOfBytesRead)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.ReadProcessMemory(hProcessLocal, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.</summary>
        /// <param name = "hProcess">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
        /// <param name = "lpBaseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
        /// <param name = "lpBuffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
        /// <param name = "nSize">The number of bytes to be read from the specified process.</param>
        /// <param name = "lpNumberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer. If *lpNumberOfBytesRead* is **NULL**, the parameter is ignored.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md).</para>
        /// <para>The function fails if the requested read operation crosses into an area of the process that is inaccessible.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-readprocessmemory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ReadProcessMemory(win32.System.SystemServices.HANDLE hProcess, void *lpBaseAddress, void *lpBuffer, nuint nSize, [Optional] nuint*lpNumberOfBytesRead);
        /// <inheritdoc cref = "WriteProcessMemory(win32.System.SystemServices.HANDLE, void *, void *, nuint, nuint*)"/>
        internal static unsafe bool WriteProcessMemory(SafeHandle hProcess, void *lpBaseAddress, void *lpBuffer, nuint nSize, nuint*lpNumberOfBytesWritten)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.WriteProcessMemory(hProcessLocal, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.</summary>
        /// <param name = "hProcess">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
        /// <param name = "lpBaseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
        /// <param name = "lpBuffer">A pointer to the buffer that contains data to be written in  the address space of the specified process.</param>
        /// <param name = "nSize">The number of bytes to be written to the specified process.</param>
        /// <param name = "lpNumberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If <i>lpNumberOfBytesWritten</i> is <b>NULL</b>, the parameter is ignored.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The function fails if the requested write operation crosses into an area of the process that is inaccessible.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-writeprocessmemory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool WriteProcessMemory(win32.System.SystemServices.HANDLE hProcess, void *lpBaseAddress, void *lpBuffer, nuint nSize, [Optional] nuint*lpNumberOfBytesWritten);
        /// <summary>Transfers execution control to the debugger. The behavior of the debugger thereafter is specific to the type of debugger used.</summary>
        /// <param name = "ExitCode">The error code associated with the exit.</param>
        /// <returns>This function does not return a value.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-fatalexit">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void FatalExit(int ExitCode);
        /// <inheritdoc cref = "GetThreadSelectorEntry(win32.System.SystemServices.HANDLE, uint, void *)"/>
        internal static unsafe bool GetThreadSelectorEntry(SafeHandle hThread, uint dwSelector, void *lpSelectorEntry)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.GetThreadSelectorEntry(hThreadLocal, dwSelector, lpSelectorEntry);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Retrieves a descriptor table entry for the specified selector and thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread containing the specified selector. The handle must have THREAD_QUERY_INFORMATION access. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getthreadselectorentry#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSelector">The global or local selector value to look up in the thread's descriptor tables.</param>
        /// <param name = "lpSelectorEntry">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-ldt_entry">LDT_ENTRY</a> structure that receives a copy of the descriptor table entry if the specified selector has an entry in the specified thread's descriptor table. This information can be used to convert a segment-relative address to a linear virtual address.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getthreadselectorentry#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. In that case, the structure pointed to by the <i>lpSelectorEntry</i> parameter receives a copy of the specified descriptor table entry.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getthreadselectorentry">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetThreadSelectorEntry(win32.System.SystemServices.HANDLE hThread, uint dwSelector, void *lpSelectorEntry);
        /// <inheritdoc cref = "Wow64GetThreadSelectorEntry(win32.System.SystemServices.HANDLE, uint, win32.System.Diagnostics.Debug.WOW64_LDT_ENTRY*)"/>
        internal static unsafe bool Wow64GetThreadSelectorEntry(SafeHandle hThread, uint dwSelector, out win32.System.Diagnostics.Debug.WOW64_LDT_ENTRY lpSelectorEntry)
        {
            bool hThreadAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.Debug.WOW64_LDT_ENTRY*lpSelectorEntryLocal = &lpSelectorEntry)
                {
                    win32.System.SystemServices.HANDLE hThreadLocal;
                    if (hThread is object)
                    {
                        hThread.DangerousAddRef(ref hThreadAddRef);
                        hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                    }
                    else
                        hThreadLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Wow64GetThreadSelectorEntry(hThreadLocal, dwSelector, lpSelectorEntryLocal);
                    return __result;
                }
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Retrieves a descriptor table entry for the specified selector and WOW64 thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread containing the specified selector.  The handle must have been created with THREAD_QUERY_INFORMATION access to the thread. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64getthreadselectorentry#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSelector">The global or local selector value to look up in the thread's descriptor tables.</param>
        /// <param name = "lpSelectorEntry">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-wow64_ldt_entry">WOW64_LDT_ENTRY</a> structure that receives a copy of the descriptor table entry if the specified selector has an entry in the specified thread's descriptor table. This information can be used to convert a segment-relative address to a linear virtual address.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64getthreadselectorentry#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. In that case, the structure pointed to by the <i>lpSelectorEntry</i> parameter receives a copy of the specified descriptor table entry.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64getthreadselectorentry">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Wow64GetThreadSelectorEntry(win32.System.SystemServices.HANDLE hThread, uint dwSelector, win32.System.Diagnostics.Debug.WOW64_LDT_ENTRY*lpSelectorEntry);
        /// <summary>Sets the action to be performed when the calling thread exits.</summary>
        /// <param name = "KillOnExit">If this parameter is <b>TRUE</b>, the thread terminates all attached processes on exit (note that this is the default). Otherwise, the thread detaches from all processes being debugged on exit.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-debugsetprocesskillonexit">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DebugSetProcessKillOnExit(bool KillOnExit);
        /// <inheritdoc cref = "DebugBreakProcess(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool DebugBreakProcess(SafeHandle Process)
        {
            bool ProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE ProcessLocal;
                if (Process is object)
                {
                    Process.DangerousAddRef(ref ProcessAddRef);
                    ProcessLocal = (win32.System.SystemServices.HANDLE)Process.DangerousGetHandle();
                }
                else
                    ProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.DebugBreakProcess(ProcessLocal);
                return __result;
            }
            finally
            {
                if (ProcessAddRef)
                    Process.DangerousRelease();
            }
        }

        /// <summary>Causes a breakpoint exception to occur in the specified process. This allows the calling thread to signal the debugger to handle the exception.</summary>
        /// <param name = "Process">A handle to the process.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-debugbreakprocess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DebugBreakProcess(win32.System.SystemServices.HANDLE Process);
        /// <summary>Formats a message string.</summary>
        /// <param name = "dwFlags">
        /// <para>The formatting options, and how to interpret the <i>lpSource</i> parameter. The low-order byte of <i>dwFlags</i> specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSource">
        /// <para>The location of the message definition. The type of this parameter depends upon the settings in the <i>dwFlags</i> parameter.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMessageId">
        /// <para>The message identifier for the requested message. This parameter is ignored if <i>dwFlags</i> includes <b>FORMAT_MESSAGE_FROM_STRING</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwLanguageId">
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> for the requested message. This parameter is ignored if <i>dwFlags</i> includes <b>FORMAT_MESSAGE_FROM_STRING</b>.</para>
        /// <para>If you pass a specific <b>LANGID</b> in this parameter, <b>FormatMessage</b> will return a message for that <b>LANGID</b> only. If the function cannot find a message for that <b>LANGID</b>, it sets Last-Error to <b>ERROR_RESOURCE_LANG_NOT_FOUND</b>. If you pass in zero, <b>FormatMessage</b> looks for a message for <b>LANGIDs</b> in the following order:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If <i>dwFlags</i> includes <b>FORMAT_MESSAGE_ALLOCATE_BUFFER</b>, the function allocates a buffer using the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> function, and places the pointer to the buffer at the address specified in <i>lpBuffer</i>.</para>
        /// <para>This buffer cannot be larger than 64K bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nSize">
        /// <para>If the <b>FORMAT_MESSAGE_ALLOCATE_BUFFER</b> flag is not set, this parameter specifies the size of the output buffer, in <b>TCHARs</b>. If <b>FORMAT_MESSAGE_ALLOCATE_BUFFER</b> is set, this parameter specifies the minimum number of <b>TCHARs</b> to allocate for an output buffer.</para>
        /// <para>The output buffer cannot be larger than 64K bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Arguments">
        /// <para>An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the <i>Arguments</i> array; a %2 indicates the second argument; and so on.</para>
        /// <para>The interpretation of each value depends on the formatting information associated with the insert in the message definition. The default is to treat each value as a pointer to a null-terminated string.</para>
        /// <para>By default, the <i>Arguments</i> parameter is of type <b>va_list*</b>, which is a language- and implementation-specific data type for describing a variable number of arguments. The state of the <b>va_list</b> argument is undefined upon return from the function. To use the <b>va_list</b> again, destroy the variable argument list pointer using <b>va_end</b> and reinitialize it with <b>va_start</b>.</para>
        /// <para>If you do not have a pointer of type <b>va_list*</b>, then specify the <b>FORMAT_MESSAGE_ARGUMENT_ARRAY</b> flag and pass a pointer to an array of <b>DWORD_PTR</b> values; those values are input to the message formatted as the insert values. Each insert must have a corresponding element in the array.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored in the output buffer, excluding the terminating null character.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-formatmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FormatMessageW", SetLastError = true)]
        internal static extern unsafe uint FormatMessage(win32.System.Diagnostics.Debug.FORMAT_MESSAGE_OPTIONS dwFlags, [Optional] void *lpSource, uint dwMessageId, uint dwLanguageId, win32.System.SystemServices.PWSTR lpBuffer, uint nSize, [Optional] sbyte **Arguments);
        /// <inheritdoc cref = "FlushInstructionCache(win32.System.SystemServices.HANDLE, void *, nuint)"/>
        internal static unsafe bool FlushInstructionCache(SafeHandle hProcess, void *lpBaseAddress, nuint dwSize)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.FlushInstructionCache(hProcessLocal, lpBaseAddress, dwSize);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Flushes the instruction cache for the specified process.</summary>
        /// <param name = "hProcess">A handle to a process whose instruction cache is to be flushed.</param>
        /// <param name = "lpBaseAddress">A pointer to the base of the region to be flushed. This parameter can be <b>NULL</b>.</param>
        /// <param name = "dwSize">The size of the region to be flushed if the <i>lpBaseAddress</i> parameter is not <b>NULL</b>, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-flushinstructioncache">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool FlushInstructionCache(win32.System.SystemServices.HANDLE hProcess, [Optional] void *lpBaseAddress, nuint dwSize);
        /// <inheritdoc cref = "PssCaptureSnapshot(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ProcessSnapshotting.PSS_CAPTURE_FLAGS, uint, win32.System.Diagnostics.ProcessSnapshotting.HPSS*)"/>
        internal static unsafe uint PssCaptureSnapshot(SafeHandle ProcessHandle, win32.System.Diagnostics.ProcessSnapshotting.PSS_CAPTURE_FLAGS CaptureFlags, uint ThreadContextFlags, out win32.System.Diagnostics.ProcessSnapshotting.HPSS SnapshotHandle)
        {
            bool ProcessHandleAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ProcessSnapshotting.HPSS*SnapshotHandleLocal = &SnapshotHandle)
                {
                    win32.System.SystemServices.HANDLE ProcessHandleLocal;
                    if (ProcessHandle is object)
                    {
                        ProcessHandle.DangerousAddRef(ref ProcessHandleAddRef);
                        ProcessHandleLocal = (win32.System.SystemServices.HANDLE)ProcessHandle.DangerousGetHandle();
                    }
                    else
                        ProcessHandleLocal = default(win32.System.SystemServices.HANDLE);
                    uint __result = Kernel32.PssCaptureSnapshot(ProcessHandleLocal, CaptureFlags, ThreadContextFlags, SnapshotHandleLocal);
                    return __result;
                }
            }
            finally
            {
                if (ProcessHandleAddRef)
                    ProcessHandle.DangerousRelease();
            }
        }

        /// <summary>Captures a snapshot of a target process.</summary>
        /// <param name = "ProcessHandle">A handle to the target process.</param>
        /// <param name = "CaptureFlags">Flags that specify what to capture. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/api/processsnapshot/ne-processsnapshot-pss_capture_flags">PSS_CAPTURE_FLAGS</a>.</param>
        /// <param name = "ThreadContextFlags">The <b>CONTEXT</b> record flags to capture if <i>CaptureFlags</i> specifies thread contexts.</param>
        /// <param name = "SnapshotHandle">A handle to the snapshot that this function captures.</param>
        /// <returns>
        /// <para>This function returns <b>ERROR_SUCCESS</b> on success.</para>
        /// <para>All error codes are defined in winerror.h. Use <a href = "/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a message for an error code.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processsnapshot/nf-processsnapshot-psscapturesnapshot">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint PssCaptureSnapshot(win32.System.SystemServices.HANDLE ProcessHandle, win32.System.Diagnostics.ProcessSnapshotting.PSS_CAPTURE_FLAGS CaptureFlags, uint ThreadContextFlags, win32.System.Diagnostics.ProcessSnapshotting.HPSS*SnapshotHandle);
        /// <inheritdoc cref = "PssFreeSnapshot(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ProcessSnapshotting.HPSS)"/>
        internal static unsafe uint PssFreeSnapshot(SafeHandle ProcessHandle, win32.System.Diagnostics.ProcessSnapshotting.HPSS SnapshotHandle)
        {
            bool ProcessHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE ProcessHandleLocal;
                if (ProcessHandle is object)
                {
                    ProcessHandle.DangerousAddRef(ref ProcessHandleAddRef);
                    ProcessHandleLocal = (win32.System.SystemServices.HANDLE)ProcessHandle.DangerousGetHandle();
                }
                else
                    ProcessHandleLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.PssFreeSnapshot(ProcessHandleLocal, SnapshotHandle);
                return __result;
            }
            finally
            {
                if (ProcessHandleAddRef)
                    ProcessHandle.DangerousRelease();
            }
        }

        /// <summary>Frees a snapshot.</summary>
        /// <param name = "ProcessHandle">A handle to the process that contains the snapshot. The handle must have <b>PROCESS_VM_READ</b>, <b>PROCESS_VM_OPERATION</b>, and <b>PROCESS_DUP_HANDLE</b> rights. If the snapshot was captured from the current process, or duplicated into the current process, then pass in the result of <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess">GetCurrentProcess</a>.</param>
        /// <param name = "SnapshotHandle">A handle to the snapshot to free.</param>
        /// <returns>
        /// <para>This function returns <b>ERROR_SUCCESS</b> on success or one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processsnapshot/nf-processsnapshot-pssfreesnapshot">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint PssFreeSnapshot(win32.System.SystemServices.HANDLE ProcessHandle, win32.System.Diagnostics.ProcessSnapshotting.HPSS SnapshotHandle);
        /// <summary>Queries the snapshot.</summary>
        /// <param name = "SnapshotHandle">A handle to the snapshot to query.</param>
        /// <param name = "InformationClass">An enumerator member that selects what information to query. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/api/processsnapshot/ne-processsnapshot-pss_query_information_class">PSS_QUERY_INFORMATION_CLASS</a>.</param>
        /// <param name = "Buffer">The information that this function provides.</param>
        /// <param name = "BufferLength">The size of <i>Buffer</i>, in bytes.</param>
        /// <returns>
        /// <para>This function returns <b>ERROR_SUCCESS</b> on success or one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processsnapshot/nf-processsnapshot-pssquerysnapshot">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint PssQuerySnapshot(win32.System.Diagnostics.ProcessSnapshotting.HPSS SnapshotHandle, win32.System.Diagnostics.ProcessSnapshotting.PSS_QUERY_INFORMATION_CLASS InformationClass, void *Buffer, uint BufferLength);
        /// <summary>Returns information from the current walk position and advanced the walk marker to the next position.</summary>
        /// <param name = "SnapshotHandle">A handle to the snapshot.</param>
        /// <param name = "InformationClass">The type of information to return. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/api/processsnapshot/ne-processsnapshot-pss_walk_information_class">PSS_WALK_INFORMATION_CLASS</a>.</param>
        /// <param name = "WalkMarkerHandle">A handle to a walk marker. The walk marker indicates the walk position from which data is to be returned. <b>PssWalkSnapshot</b> advances the walk marker to the next walk position in time order before returning to the caller.</param>
        /// <param name = "Buffer">The snapshot information that this function returns.</param>
        /// <param name = "BufferLength">The size of <i>Buffer</i>, in bytes.</param>
        /// <returns>
        /// <para>This function returns <b>ERROR_SUCCESS</b> on success or one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processsnapshot/nf-processsnapshot-psswalksnapshot">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint PssWalkSnapshot(win32.System.Diagnostics.ProcessSnapshotting.HPSS SnapshotHandle, win32.System.Diagnostics.ProcessSnapshotting.PSS_WALK_INFORMATION_CLASS InformationClass, win32.System.Diagnostics.ProcessSnapshotting.HPSSWALK WalkMarkerHandle, [Optional] void *Buffer, uint BufferLength);
        /// <inheritdoc cref = "PssDuplicateSnapshot(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ProcessSnapshotting.HPSS, win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ProcessSnapshotting.HPSS*, win32.System.Diagnostics.ProcessSnapshotting.PSS_DUPLICATE_FLAGS)"/>
        internal static unsafe uint PssDuplicateSnapshot(SafeHandle SourceProcessHandle, win32.System.Diagnostics.ProcessSnapshotting.HPSS SnapshotHandle, SafeHandle TargetProcessHandle, out win32.System.Diagnostics.ProcessSnapshotting.HPSS TargetSnapshotHandle, win32.System.Diagnostics.ProcessSnapshotting.PSS_DUPLICATE_FLAGS Flags)
        {
            bool SourceProcessHandleAddRef = false;
            bool TargetProcessHandleAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ProcessSnapshotting.HPSS*TargetSnapshotHandleLocal = &TargetSnapshotHandle)
                {
                    win32.System.SystemServices.HANDLE SourceProcessHandleLocal;
                    if (SourceProcessHandle is object)
                    {
                        SourceProcessHandle.DangerousAddRef(ref SourceProcessHandleAddRef);
                        SourceProcessHandleLocal = (win32.System.SystemServices.HANDLE)SourceProcessHandle.DangerousGetHandle();
                    }
                    else
                        SourceProcessHandleLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.HANDLE TargetProcessHandleLocal;
                    if (TargetProcessHandle is object)
                    {
                        TargetProcessHandle.DangerousAddRef(ref TargetProcessHandleAddRef);
                        TargetProcessHandleLocal = (win32.System.SystemServices.HANDLE)TargetProcessHandle.DangerousGetHandle();
                    }
                    else
                        TargetProcessHandleLocal = default(win32.System.SystemServices.HANDLE);
                    uint __result = Kernel32.PssDuplicateSnapshot(SourceProcessHandleLocal, SnapshotHandle, TargetProcessHandleLocal, TargetSnapshotHandleLocal, Flags);
                    return __result;
                }
            }
            finally
            {
                if (SourceProcessHandleAddRef)
                    SourceProcessHandle.DangerousRelease();
                if (TargetProcessHandleAddRef)
                    TargetProcessHandle.DangerousRelease();
            }
        }

        /// <summary>Duplicates a snapshot handle from one process to another.</summary>
        /// <param name = "SourceProcessHandle">A handle to the source process from which the original snapshot was captured. The handle must have <b>PROCESS_VM_READ</b> and <b>PROCESS_DUP_HANDLE</b> rights.</param>
        /// <param name = "SnapshotHandle">A handle to the snapshot to duplicate. This handle must be in the context of the source process.</param>
        /// <param name = "TargetProcessHandle">A handle to the target process that receives the duplicate snapshot. The handle must have <b>PROCESS_VM_OPERATION</b>, <b>PROCESS_VM_WRITE</b>, and <b>PROCESS_DUP_HANDLE</b> rights.</param>
        /// <param name = "TargetSnapshotHandle">A handle to the duplicate snapshot that this function creates, in the context of the target process.</param>
        /// <param name = "Flags">The duplication flags. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/api/processsnapshot/ne-processsnapshot-pss_duplicate_flags">PSS_DUPLICATE_FLAGS</a>.</param>
        /// <returns>
        /// <para>This function returns <b>ERROR_SUCCESS</b> on success or the following error code.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processsnapshot/nf-processsnapshot-pssduplicatesnapshot">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint PssDuplicateSnapshot(win32.System.SystemServices.HANDLE SourceProcessHandle, win32.System.Diagnostics.ProcessSnapshotting.HPSS SnapshotHandle, win32.System.SystemServices.HANDLE TargetProcessHandle, win32.System.Diagnostics.ProcessSnapshotting.HPSS*TargetSnapshotHandle, win32.System.Diagnostics.ProcessSnapshotting.PSS_DUPLICATE_FLAGS Flags);
        /// <inheritdoc cref = "PssWalkMarkerCreate(win32.System.Diagnostics.ProcessSnapshotting.PSS_ALLOCATOR*, win32.System.Diagnostics.ProcessSnapshotting.HPSSWALK*)"/>
        internal static unsafe uint PssWalkMarkerCreate(win32.System.Diagnostics.ProcessSnapshotting.PSS_ALLOCATOR? Allocator, out win32.System.Diagnostics.ProcessSnapshotting.HPSSWALK WalkMarkerHandle)
        {
            fixed (win32.System.Diagnostics.ProcessSnapshotting.HPSSWALK*WalkMarkerHandleLocal = &WalkMarkerHandle)
            {
                win32.System.Diagnostics.ProcessSnapshotting.PSS_ALLOCATOR AllocatorLocal = Allocator.HasValue ? Allocator.Value : default(win32.System.Diagnostics.ProcessSnapshotting.PSS_ALLOCATOR);
                uint __result = Kernel32.PssWalkMarkerCreate(Allocator.HasValue ? &AllocatorLocal : null, WalkMarkerHandleLocal);
                return __result;
            }
        }

        /// <summary>Creates a walk marker.</summary>
        /// <param name = "Allocator">A structure that provides functions to allocate and free memory.  If you provide the structure, <b>PssWalkMarkerCreate</b> uses the functions to  allocate the internal walk marker structures. Otherwise it uses the default process heap. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/api/processsnapshot/ns-processsnapshot-pss_allocator">PSS_ALLOCATOR</a>.</param>
        /// <param name = "WalkMarkerHandle">A handle to the walk marker that this function creates.</param>
        /// <returns>
        /// <para>This function returns <b>ERROR_SUCCESS</b> on success or the following error code.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processsnapshot/nf-processsnapshot-psswalkmarkercreate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint PssWalkMarkerCreate([Optional] win32.System.Diagnostics.ProcessSnapshotting.PSS_ALLOCATOR*Allocator, win32.System.Diagnostics.ProcessSnapshotting.HPSSWALK*WalkMarkerHandle);
        /// <summary>Frees a walk marker created by PssWalkMarkerCreate.</summary>
        /// <param name = "WalkMarkerHandle">A handle to the walk marker.</param>
        /// <returns>
        /// <para>This function returns <b>ERROR_SUCCESS</b> on success.</para>
        /// <para>All error codes are defined in winerror.h. Use <a href = "/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a message for an error code.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processsnapshot/nf-processsnapshot-psswalkmarkerfree">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint PssWalkMarkerFree(win32.System.Diagnostics.ProcessSnapshotting.HPSSWALK WalkMarkerHandle);
        /// <inheritdoc cref = "PssWalkMarkerGetPosition(win32.System.Diagnostics.ProcessSnapshotting.HPSSWALK, nuint*)"/>
        internal static unsafe uint PssWalkMarkerGetPosition(win32.System.Diagnostics.ProcessSnapshotting.HPSSWALK WalkMarkerHandle, out nuint Position)
        {
            fixed (nuint*PositionLocal = &Position)
            {
                uint __result = Kernel32.PssWalkMarkerGetPosition(WalkMarkerHandle, PositionLocal);
                return __result;
            }
        }

        /// <summary>Returns the current position of a walk marker.</summary>
        /// <param name = "WalkMarkerHandle">A  handle to the walk marker.</param>
        /// <param name = "Position">The walk marker position that this function returns.</param>
        /// <returns>
        /// <para>This function returns <b>ERROR_SUCCESS</b> on success.</para>
        /// <para>All error codes are defined in winerror.h. Use <a href = "/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a message for an error code.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processsnapshot/nf-processsnapshot-psswalkmarkergetposition">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint PssWalkMarkerGetPosition(win32.System.Diagnostics.ProcessSnapshotting.HPSSWALK WalkMarkerHandle, nuint*Position);
        /// <summary>Sets the position of a walk marker.</summary>
        /// <param name = "WalkMarkerHandle">A handle to the walk marker.</param>
        /// <param name = "Position">The position to set. This is a position that the  <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/api/processsnapshot/nf-processsnapshot-psswalkmarkergetposition">PssWalkMarkerGetPosition</a> function provided.</param>
        /// <returns>
        /// <para>This function returns <b>ERROR_SUCCESS</b> on success or one of the following error codes.</para>
        /// <para>All error codes are defined in winerror.h. Use <a href = "/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a message for an error code.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processsnapshot/nf-processsnapshot-psswalkmarkersetposition">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint PssWalkMarkerSetPosition(win32.System.Diagnostics.ProcessSnapshotting.HPSSWALK WalkMarkerHandle, nuint Position);
        /// <summary>Rewinds a walk marker back to the beginning.</summary>
        /// <param name = "WalkMarkerHandle">A handle to the walk marker.</param>
        /// <returns>
        /// <para>This function returns <b>ERROR_SUCCESS</b> on success.</para>
        /// <para>All error codes are defined in winerror.h. Use <a href = "/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a message for an error code.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processsnapshot/nf-processsnapshot-psswalkmarkerseektobeginning">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint PssWalkMarkerSeekToBeginning(win32.System.Diagnostics.ProcessSnapshotting.HPSSWALK WalkMarkerHandle);
        /// <inheritdoc cref = "CreateToolhelp32Snapshot(win32.System.Diagnostics.ToolHelp.CREATE_TOOLHELP_SNAPSHOT_FLAGS, uint)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateToolhelp32Snapshot_SafeHandle(win32.System.Diagnostics.ToolHelp.CREATE_TOOLHELP_SNAPSHOT_FLAGS dwFlags, uint th32ProcessID)
        {
            win32.System.SystemServices.HANDLE __result = Kernel32.CreateToolhelp32Snapshot(dwFlags, th32ProcessID);
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        /// <summary>Takes a snapshot of the specified processes, as well as the heaps, modules, and threads used by these processes.</summary>
        /// <param name = "dwFlags"></param>
        /// <param name = "th32ProcessID">
        /// <para>The process identifier of the process to be included in the snapshot. This parameter can be zero to indicate the current process. This parameter is used when the <b>TH32CS_SNAPHEAPLIST</b>, <b>TH32CS_SNAPMODULE</b>, <b>TH32CS_SNAPMODULE32</b>, or <b>TH32CS_SNAPALL</b> value is specified. Otherwise, it is ignored and all processes are included in the snapshot.</para>
        /// <para>If the specified process is the Idle process or one of the CSRSS processes, this function fails and the last error code is <b>ERROR_ACCESS_DENIED</b> because their access restrictions prevent user-level code from opening them.</para>
        /// <para>If the specified process is a 64-bit process and the caller is a 32-bit process, this function fails and the last error code is <b>ERROR_PARTIAL_COPY</b> (299).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-createtoolhelp32snapshot#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns an open handle to the specified snapshot.</para>
        /// <para>If the function fails, it returns <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include <b>ERROR_BAD_LENGTH</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE CreateToolhelp32Snapshot(win32.System.Diagnostics.ToolHelp.CREATE_TOOLHELP_SNAPSHOT_FLAGS dwFlags, uint th32ProcessID);
        /// <inheritdoc cref = "Heap32ListFirst(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.HEAPLIST32*)"/>
        internal static unsafe bool Heap32ListFirst(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.HEAPLIST32 lphl)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.HEAPLIST32*lphlLocal = &lphl)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Heap32ListFirst(hSnapshotLocal, lphlLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the first heap that has been allocated by a specified process.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-heap32listfirst#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lphl">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-heaplist32">HEAPLIST32</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-heap32listfirst#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the first entry of the heap list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function when no heap list exists or the snapshot does not contain heap list information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-heap32listfirst">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Heap32ListFirst(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.HEAPLIST32*lphl);
        /// <inheritdoc cref = "Heap32ListNext(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.HEAPLIST32*)"/>
        internal static unsafe bool Heap32ListNext(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.HEAPLIST32 lphl)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.HEAPLIST32*lphlLocal = &lphl)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Heap32ListNext(hSnapshotLocal, lphlLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the next heap that has been allocated by a process.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-heap32listnext#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lphl">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-heaplist32">HEAPLIST32</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-heap32listnext#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the next entry of the heap list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function when no more entries in the heap list exist.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-heap32listnext">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Heap32ListNext(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.HEAPLIST32*lphl);
        /// <inheritdoc cref = "Heap32First(win32.System.Diagnostics.ToolHelp.HEAPENTRY32*, uint, nuint)"/>
        internal static unsafe bool Heap32First(ref win32.System.Diagnostics.ToolHelp.HEAPENTRY32 lphe, uint th32ProcessID, nuint th32HeapID)
        {
            fixed (win32.System.Diagnostics.ToolHelp.HEAPENTRY32*lpheLocal = &lphe)
            {
                bool __result = Kernel32.Heap32First(lpheLocal, th32ProcessID, th32HeapID);
                return __result;
            }
        }

        /// <summary>Retrieves information about the first block of a heap that has been allocated by a process.</summary>
        /// <param name = "lphe">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-heapentry32">HEAPENTRY32</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-heap32first#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "th32ProcessID">The identifier of the process context that owns the heap.</param>
        /// <param name = "th32HeapID">The identifier of the heap to be enumerated.</param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if information for the first heap block has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if the heap is invalid or empty.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-heap32first">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Heap32First(win32.System.Diagnostics.ToolHelp.HEAPENTRY32*lphe, uint th32ProcessID, nuint th32HeapID);
        /// <inheritdoc cref = "Heap32Next(win32.System.Diagnostics.ToolHelp.HEAPENTRY32*)"/>
        internal static unsafe bool Heap32Next(ref win32.System.Diagnostics.ToolHelp.HEAPENTRY32 lphe)
        {
            fixed (win32.System.Diagnostics.ToolHelp.HEAPENTRY32*lpheLocal = &lphe)
            {
                bool __result = Kernel32.Heap32Next(lpheLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about the next block of a heap that has been allocated by a process.</summary>
        /// <param name = "lphe">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-heapentry32">HEAPENTRY32</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-heap32next#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if information about the next block in the heap has been copied to the buffer or <b>FALSE</b> otherwise. The <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_NO_MORE_FILES</b> when no more objects in the heap exist and <b>ERROR_INVALID_DATA</b> if the heap appears to be corrupt or is modified during the walk in such a way that <b>Heap32Next</b> cannot continue.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-heap32next">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Heap32Next(win32.System.Diagnostics.ToolHelp.HEAPENTRY32*lphe);
        /// <inheritdoc cref = "Toolhelp32ReadProcessMemory(uint, void *, void *, nuint, nuint*)"/>
        internal static unsafe bool Toolhelp32ReadProcessMemory(uint th32ProcessID, void *lpBaseAddress, void *lpBuffer, nuint cbRead, ref nuint lpNumberOfBytesRead)
        {
            fixed (nuint*lpNumberOfBytesReadLocal = &lpNumberOfBytesRead)
            {
                bool __result = Kernel32.Toolhelp32ReadProcessMemory(th32ProcessID, lpBaseAddress, lpBuffer, cbRead, lpNumberOfBytesReadLocal);
                return __result;
            }
        }

        /// <summary>Copies memory allocated to another process into an application-supplied buffer.</summary>
        /// <param name = "th32ProcessID">The identifier of the process whose memory is being copied. This parameter can be zero to copy the memory of the current process.</param>
        /// <param name = "lpBaseAddress">The base address in the specified process to read. Before transferring any data, the system verifies that all data in the base address and memory of the specified size is accessible for read access. If this is the case, the function proceeds. Otherwise, the function fails.</param>
        /// <param name = "lpBuffer">A pointer to a buffer that receives the contents of the address space of the specified process.</param>
        /// <param name = "cbRead">The number of bytes to read from the specified process.</param>
        /// <param name = "lpNumberOfBytesRead">The number of bytes copied to the specified buffer. If this parameter is <b>NULL</b>, it is ignored.</param>
        /// <returns>Returns <b>TRUE</b> if successful.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-toolhelp32readprocessmemory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool Toolhelp32ReadProcessMemory(uint th32ProcessID, void *lpBaseAddress, void *lpBuffer, nuint cbRead, nuint*lpNumberOfBytesRead);
        /// <inheritdoc cref = "Process32FirstW(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.PROCESSENTRY32W*)"/>
        internal static unsafe bool Process32FirstW(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.PROCESSENTRY32W lppe)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.PROCESSENTRY32W*lppeLocal = &lppe)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Process32FirstW(hSnapshotLocal, lppeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the first process encountered in a system snapshot.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32firstw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lppe">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-processentry32w">PROCESSENTRY32W</a> structure. It contains process information such as the name of the executable file, the process identifier, and the process identifier of the parent process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32firstw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the first entry of the process list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no processes exist or the snapshot does not contain process information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32firstw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Process32FirstW(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.PROCESSENTRY32W*lppe);
        /// <inheritdoc cref = "Process32NextW(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.PROCESSENTRY32W*)"/>
        internal static unsafe bool Process32NextW(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.PROCESSENTRY32W lppe)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.PROCESSENTRY32W*lppeLocal = &lppe)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Process32NextW(hSnapshotLocal, lppeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32nextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lppe">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-processentry32w">PROCESSENTRY32W</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32nextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the next entry of the process list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no processes exist or the snapshot does not contain process information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32nextw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Process32NextW(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.PROCESSENTRY32W*lppe);
        /// <inheritdoc cref = "Process32First(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.PROCESSENTRY32*)"/>
        internal static unsafe bool Process32First(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.PROCESSENTRY32 lppe)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.PROCESSENTRY32*lppeLocal = &lppe)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Process32First(hSnapshotLocal, lppeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the first process encountered in a system snapshot.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32first#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lppe">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-processentry32">PROCESSENTRY32</a> structure. It contains process information such as the name of the executable file, the process identifier, and the process identifier of the parent process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32first#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the first entry of the process list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no processes exist or the snapshot does not contain process information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32first">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Process32First(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.PROCESSENTRY32*lppe);
        /// <inheritdoc cref = "Process32Next(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.PROCESSENTRY32*)"/>
        internal static unsafe bool Process32Next(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.PROCESSENTRY32 lppe)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.PROCESSENTRY32*lppeLocal = &lppe)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Process32Next(hSnapshotLocal, lppeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32next#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lppe">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-processentry32">PROCESSENTRY32</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32next#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the next entry of the process list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no processes exist or the snapshot does not contain process information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-process32next">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Process32Next(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.PROCESSENTRY32*lppe);
        /// <inheritdoc cref = "Thread32First(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.THREADENTRY32*)"/>
        internal static unsafe bool Thread32First(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.THREADENTRY32 lpte)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.THREADENTRY32*lpteLocal = &lpte)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Thread32First(hSnapshotLocal, lpteLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the first thread of any process encountered in a system snapshot.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-thread32first#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpte">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-threadentry32">THREADENTRY32</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-thread32first#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the first entry of the thread list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no threads exist or the snapshot does not contain thread information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-thread32first">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Thread32First(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.THREADENTRY32*lpte);
        /// <inheritdoc cref = "Thread32Next(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.THREADENTRY32*)"/>
        internal static unsafe bool Thread32Next(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.THREADENTRY32 lpte)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.THREADENTRY32*lpteLocal = &lpte)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Thread32Next(hSnapshotLocal, lpteLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the next thread of any process encountered in the system memory snapshot.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-thread32next#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpte">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-threadentry32">THREADENTRY32</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-thread32next#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the next entry of the thread list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no threads exist or the snapshot does not contain thread information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-thread32next">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Thread32Next(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.THREADENTRY32*lpte);
        /// <inheritdoc cref = "Module32FirstW(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.MODULEENTRY32W*)"/>
        internal static unsafe bool Module32FirstW(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.MODULEENTRY32W lpme)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.MODULEENTRY32W*lpmeLocal = &lpme)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Module32FirstW(hSnapshotLocal, lpmeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the first module associated with a process.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32firstw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpme">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-moduleentry32w">MODULEENTRY32W</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32firstw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the first entry of the module list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no modules exist or the snapshot does not contain module information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32firstw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Module32FirstW(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.MODULEENTRY32W*lpme);
        /// <inheritdoc cref = "Module32NextW(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.MODULEENTRY32W*)"/>
        internal static unsafe bool Module32NextW(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.MODULEENTRY32W lpme)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.MODULEENTRY32W*lpmeLocal = &lpme)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Module32NextW(hSnapshotLocal, lpmeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the next module associated with a process or thread.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32nextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpme">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-moduleentry32w">MODULEENTRY32W</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32nextw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the next entry of the module list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no more modules exist.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32nextw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Module32NextW(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.MODULEENTRY32W*lpme);
        /// <inheritdoc cref = "Module32First(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.MODULEENTRY32*)"/>
        internal static unsafe bool Module32First(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.MODULEENTRY32 lpme)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.MODULEENTRY32*lpmeLocal = &lpme)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Module32First(hSnapshotLocal, lpmeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the first module associated with a process.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32first#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpme">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-moduleentry32">MODULEENTRY32</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32first#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the first entry of the module list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no modules exist or the snapshot does not contain module information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32first">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Module32First(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.MODULEENTRY32*lpme);
        /// <inheritdoc cref = "Module32Next(win32.System.SystemServices.HANDLE, win32.System.Diagnostics.ToolHelp.MODULEENTRY32*)"/>
        internal static unsafe bool Module32Next(SafeHandle hSnapshot, ref win32.System.Diagnostics.ToolHelp.MODULEENTRY32 lpme)
        {
            bool hSnapshotAddRef = false;
            try
            {
                fixed (win32.System.Diagnostics.ToolHelp.MODULEENTRY32*lpmeLocal = &lpme)
                {
                    win32.System.SystemServices.HANDLE hSnapshotLocal;
                    if (hSnapshot is object)
                    {
                        hSnapshot.DangerousAddRef(ref hSnapshotAddRef);
                        hSnapshotLocal = (win32.System.SystemServices.HANDLE)hSnapshot.DangerousGetHandle();
                    }
                    else
                        hSnapshotLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.Module32Next(hSnapshotLocal, lpmeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hSnapshotAddRef)
                    hSnapshot.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the next module associated with a process or thread.</summary>
        /// <param name = "hSnapshot">
        /// <para>A handle to the snapshot returned from a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32next#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpme">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/tlhelp32/ns-tlhelp32-moduleentry32">MODULEENTRY32</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32next#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the next entry of the module list has been copied to the buffer or <b>FALSE</b> otherwise. The <b>ERROR_NO_MORE_FILES</b> error value is returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function if no more modules exist.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//tlhelp32/nf-tlhelp32-module32next">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Module32Next(win32.System.SystemServices.HANDLE hSnapshot, win32.System.Diagnostics.ToolHelp.MODULEENTRY32*lpme);
        /// <summary>Decrements the reference count of a global string atom. If the atom's reference count reaches zero, GlobalDeleteAtom removes the string associated with the atom from the global atom table.</summary>
        /// <param name = "nAtom">
        /// <para>Type: <b>ATOM</b></para>
        /// <para>The atom and character string to be deleted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globaldeleteatom#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>ATOM</b></para>
        /// <para>The function always returns (<b>ATOM</b>) 0.</para>
        /// <para>To determine whether the function has failed, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with <b>ERROR_SUCCESS</b> before calling <b>GlobalDeleteAtom</b>, then call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the last error code is still <b>ERROR_SUCCESS</b>, <b>GlobalDeleteAtom</b> has succeeded.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globaldeleteatom">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern ushort GlobalDeleteAtom(ushort nAtom);
        /// <summary>Initializes the local atom table and sets the number of hash buckets to the specified size.</summary>
        /// <param name = "nSize">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The number of hash buckets to use for the atom table. If this parameter is zero, the default number of hash buckets are created.</para>
        /// <para>To achieve better performance, specify a prime number in <i>nSize</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-initatomtable#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-initatomtable">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool InitAtomTable(uint nSize);
        /// <summary>Decrements the reference count of a local string atom. If the atom's reference count is reduced to zero, DeleteAtom removes the string associated with the atom from the local atom table.</summary>
        /// <param name = "nAtom">
        /// <para>Type: <b>ATOM</b></para>
        /// <para>The atom to be deleted.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deleteatom#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>ATOM</b></para>
        /// <para>If the function succeeds, the return value is zero.</para>
        /// <para>If the function fails, the return value is the <i>nAtom</i> parameter. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deleteatom">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern ushort DeleteAtom(ushort nAtom);
        /// <inheritdoc cref = "GlobalAddAtom(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe ushort GlobalAddAtom(string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                ushort __result = Kernel32.GlobalAddAtom(lpStringLocal);
                return __result;
            }
        }

        /// <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
        /// <param name = "lpString">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalgetatomnamea">GlobalGetAtomName</a> function.</para>
        /// <para>Alternatively, you can use an integer atom that has been converted using the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-makeintatom">MAKEINTATOM</a> macro. See the Remarks for more information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globaladdatomw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>ATOM</b></para>
        /// <para>If the function succeeds, the return value is the newly created atom.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globaladdatomw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GlobalAddAtomW", SetLastError = true)]
        internal static extern ushort GlobalAddAtom(win32.System.SystemServices.PCWSTR lpString);
        /// <inheritdoc cref = "GlobalAddAtomEx(win32.System.SystemServices.PCWSTR, uint)"/>
        internal static unsafe ushort GlobalAddAtomEx(string lpString, uint Flags)
        {
            fixed (char *lpStringLocal = lpString)
            {
                ushort __result = Kernel32.GlobalAddAtomEx(lpStringLocal, Flags);
                return __result;
            }
        }

        /// <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
        /// <param name = "lpString">
        /// <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-globalgetatomnamea">GlobalGetAtomName</a> function.</para>
        /// <para>Alternatively, you can use an integer atom that has been converted using the <a href = "https://docs.microsoft.com/windows/win32/api/winbase/nf-winbase-makeintatom">MAKEINTATOM</a> macro. See the Remarks for more information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globaladdatomexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the newly created atom.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globaladdatomexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GlobalAddAtomExW", SetLastError = true)]
        internal static extern ushort GlobalAddAtomEx(win32.System.SystemServices.PCWSTR lpString, uint Flags);
        /// <inheritdoc cref = "GlobalFindAtom(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe ushort GlobalFindAtom(string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                ushort __result = Kernel32.GlobalFindAtom(lpStringLocal);
                return __result;
            }
        }

        /// <summary>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</summary>
        /// <param name = "lpString">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The null-terminated character string for which to search.</para>
        /// <para>Alternatively, you can use an integer atom that has been converted using the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-makeintatom">MAKEINTATOM</a> macro. See the Remarks for more information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalfindatomw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>ATOM</b></para>
        /// <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalfindatomw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GlobalFindAtomW", SetLastError = true)]
        internal static extern ushort GlobalFindAtom(win32.System.SystemServices.PCWSTR lpString);
        /// <summary>Retrieves a copy of the character string associated with the specified global atom.</summary>
        /// <param name = "nAtom">
        /// <para>Type: <b>ATOM</b></para>
        /// <para>The global atom associated with the character string to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalgetatomnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The buffer for the character string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalgetatomnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nSize">
        /// <para>Type: <b>int</b></para>
        /// <para>The size, in characters, of the buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalgetatomnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalgetatomnamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GlobalGetAtomNameW", SetLastError = true)]
        internal static extern uint GlobalGetAtomName(ushort nAtom, win32.System.SystemServices.PWSTR lpBuffer, int nSize);
        /// <inheritdoc cref = "AddAtom(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe ushort AddAtom(string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                ushort __result = Kernel32.AddAtom(lpStringLocal);
                return __result;
            }
        }

        /// <summary>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</summary>
        /// <param name = "lpString">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getatomnamea">GetAtomName</a> function.</para>
        /// <para>Alternatively, you can use an integer atom that has been converted using the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-makeintatom">MAKEINTATOM</a> macro. See the Remarks for more information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-addatomw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>ATOM</b></para>
        /// <para>If the function succeeds, the return value is the newly created atom.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-addatomw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "AddAtomW", SetLastError = true)]
        internal static extern ushort AddAtom(win32.System.SystemServices.PCWSTR lpString);
        /// <inheritdoc cref = "FindAtom(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe ushort FindAtom(string lpString)
        {
            fixed (char *lpStringLocal = lpString)
            {
                ushort __result = Kernel32.FindAtom(lpStringLocal);
                return __result;
            }
        }

        /// <summary>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</summary>
        /// <param name = "lpString">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The character string for which to search.</para>
        /// <para>Alternatively, you can use an integer atom that has been converted using the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-makeintatom">MAKEINTATOM</a> macro. See Remarks for more information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findatomw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>ATOM</b></para>
        /// <para>If the function succeeds, the return value is the atom associated with the given string.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findatomw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindAtomW", SetLastError = true)]
        internal static extern ushort FindAtom(win32.System.SystemServices.PCWSTR lpString);
        /// <summary>Retrieves a copy of the character string associated with the specified local atom.</summary>
        /// <param name = "nAtom">
        /// <para>Type: <b>ATOM</b></para>
        /// <para>The local atom that identifies the character string to be retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getatomnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>Type: <b>LPTSTR</b></para>
        /// <para>The character string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getatomnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nSize">
        /// <para>Type: <b>int</b></para>
        /// <para>The size, in characters, of the buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getatomnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>UINT</b></para>
        /// <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getatomnamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetAtomNameW", SetLastError = true)]
        internal static extern uint GetAtomName(ushort nAtom, win32.System.SystemServices.PWSTR lpBuffer, int nSize);
        /// <summary>Retrieves the session identifier of the console session.</summary>
        /// <returns>
        /// <para>The session identifier of the session that is attached to the physical console. If there is no session attached to the physical console, (for example, if the physical console session is in the process of being attached or detached), this function returns 0xFFFFFFFF.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wtsgetactiveconsolesessionid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint WTSGetActiveConsoleSessionId();
        /// <inheritdoc cref = "ProcessIdToSessionId(uint, uint *)"/>
        internal static unsafe bool ProcessIdToSessionId(uint dwProcessId, out uint pSessionId)
        {
            fixed (uint *pSessionIdLocal = &pSessionId)
            {
                bool __result = Kernel32.ProcessIdToSessionId(dwProcessId, pSessionIdLocal);
                return __result;
            }
        }

        /// <summary>Retrieves the Remote Desktop Services session associated with a specified process.</summary>
        /// <param name = "dwProcessId">
        /// <para>Specifies a process identifier. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocessid">GetCurrentProcessId</a> function to retrieve the process identifier for the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-processidtosessionid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pSessionId">
        /// <para>Pointer to a variable that receives the identifier of the Remote Desktop Services session under which the specified process is running. To retrieve the identifier of the session currently attached to the console, use the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-wtsgetactiveconsolesessionid">WTSGetActiveConsoleSessionId</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-processidtosessionid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-processidtosessionid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ProcessIdToSessionId(uint dwProcessId, uint *pSessionId);
        /// <inheritdoc cref = "CreateActCtx(win32.System.ApplicationInstallationAndServicing.ACTCTXW*)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateActCtx(in win32.System.ApplicationInstallationAndServicing.ACTCTXW pActCtx)
        {
            fixed (win32.System.ApplicationInstallationAndServicing.ACTCTXW*pActCtxLocal = &pActCtx)
            {
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateActCtx(pActCtxLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>The CreateActCtx function creates an activation context.</summary>
        /// <param name = "pActCtx">
        /// <para>Pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-actctxa">ACTCTX</a> structure that contains information about the activation context to be created.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createactctxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
        /// <para>This function sets errors that can be retrieved by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. For an example, see <a href = "/windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see <a href = "/windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createactctxw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateActCtxW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateActCtx(win32.System.ApplicationInstallationAndServicing.ACTCTXW*pActCtx);
        /// <summary>The AddRefActCtx function increments the reference count of the specified activation context.</summary>
        /// <param name = "hActCtx">
        /// <para>Handle to an <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-actctxa">ACTCTX</a> structure that contains information on the activation context for which the reference count is to be incremented.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-addrefactctx#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>This function is provided so that multiple clients can access a single activation context.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-addrefactctx#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void AddRefActCtx(win32.System.SystemServices.HANDLE hActCtx);
        /// <summary>The ReleaseActCtx function decrements the reference count of the specified activation context.</summary>
        /// <param name = "hActCtx">
        /// <para>Handle to the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-actctxa">ACTCTX</a> structure that contains information on the activation context for which the reference count is to be decremented.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-releaseactctx#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>This function does not return a value. On successful completion, the activation context reference count is decremented. The recipient of the reference-counted object must decrement the reference count when the object is no longer required.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-releaseactctx">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void ReleaseActCtx(win32.System.SystemServices.HANDLE hActCtx);
        /// <summary>The ZombifyActCtx function deactivates the specified activation context, but does not deallocate it.</summary>
        /// <param name = "hActCtx">Handle to the activation context that is to be deactivated.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>. If a <b>null</b> handle is passed in the <i>hActCtx</i> parameter, NULL_INVALID_PARAMETER will be returned. Otherwise, it returns <b>FALSE</b>.</para>
        /// <para>This function sets errors that can be retrieved by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. For an example, see <a href = "/windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see <a href = "/windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-zombifyactctx">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool ZombifyActCtx(win32.System.SystemServices.HANDLE hActCtx);
        /// <inheritdoc cref = "ActivateActCtx(win32.System.SystemServices.HANDLE, nuint*)"/>
        internal static unsafe bool ActivateActCtx(win32.System.SystemServices.HANDLE hActCtx, out nuint lpCookie)
        {
            fixed (nuint*lpCookieLocal = &lpCookie)
            {
                bool __result = Kernel32.ActivateActCtx(hActCtx, lpCookieLocal);
                return __result;
            }
        }

        /// <summary>The ActivateActCtx function activates the specified activation context.</summary>
        /// <param name = "hActCtx">
        /// <para>Handle to an <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-actctxa">ACTCTX</a> structure that contains information on the activation context that is to be made active.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-activateactctx#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCookie">Pointer to a <b>ULONG_PTR</b> that functions as a cookie, uniquely identifying a specific, activated activation context.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
        /// <para>This function sets errors that can be retrieved by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. For an example, see <a href = "/windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see <a href = "/windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-activateactctx">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ActivateActCtx(win32.System.SystemServices.HANDLE hActCtx, nuint*lpCookie);
        /// <summary>The DeactivateActCtx function deactivates the activation context corresponding to the specified cookie.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags that indicate how the deactivation is to occur.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deactivateactctx#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ulCookie">
        /// <para>The ULONG_PTR that was passed into the call to <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-activateactctx">ActivateActCtx</a>. This value is used as a cookie to identify a specific activated activation context.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deactivateactctx#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
        /// <para>This function sets errors that can be retrieved by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. For an example, see <a href = "/windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see <a href = "/windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deactivateactctx">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool DeactivateActCtx(uint dwFlags, nuint ulCookie);
        /// <inheritdoc cref = "GetCurrentActCtx(win32.System.SystemServices.HANDLE*)"/>
        internal static unsafe bool GetCurrentActCtx(out Microsoft.Win32.SafeHandles.SafeFileHandle lphActCtx)
        {
            win32.System.SystemServices.HANDLE lphActCtxLocal;
            bool __result = Kernel32.GetCurrentActCtx(&lphActCtxLocal);
            lphActCtx = new Microsoft.Win32.SafeHandles.SafeFileHandle(lphActCtxLocal, ownsHandle: true);
            return __result;
        }

        /// <summary>The GetCurrentActCtx function returns the handle to the active activation context of the calling thread.</summary>
        /// <param name = "lphActCtx">
        /// <para>Pointer to the returned <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-actctxa">ACTCTX</a> structure that contains information on the active activation context.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcurrentactctx#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
        /// <para>This function sets errors that can be retrieved by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. For an example, see <a href = "/windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see <a href = "/windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcurrentactctx">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCurrentActCtx(win32.System.SystemServices.HANDLE*lphActCtx);
        /// <inheritdoc cref = "FindActCtxSectionString(uint, global::System.Guid*, uint, win32.System.SystemServices.PCWSTR, win32.System.ApplicationInstallationAndServicing.ACTCTX_SECTION_KEYED_DATA*)"/>
        internal static unsafe bool FindActCtxSectionString(uint dwFlags, in global::System.Guid lpExtensionGuid, uint ulSectionId, string lpStringToFind, out win32.System.ApplicationInstallationAndServicing.ACTCTX_SECTION_KEYED_DATA ReturnedData)
        {
            fixed (win32.System.ApplicationInstallationAndServicing.ACTCTX_SECTION_KEYED_DATA*ReturnedDataLocal = &ReturnedData)
            {
                fixed (char *lpStringToFindLocal = lpStringToFind)
                {
                    fixed (global::System.Guid*lpExtensionGuidLocal = &lpExtensionGuid)
                    {
                        bool __result = Kernel32.FindActCtxSectionString(dwFlags, lpExtensionGuidLocal, ulSectionId, lpStringToFindLocal, ReturnedDataLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>The FindActCtxSectionString function retrieves information on a specific string in the current activation context and returns a ACTCTX_SECTION_KEYED_DATA structure.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findactctxsectionstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpExtensionGuid">Reserved; must be null.</param>
        /// <param name = "ulSectionId">
        /// <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
        /// <para>The following are valid string section identifiers:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findactctxsectionstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpStringToFind">Pointer to a null-terminated string to be used as the search criteria.</param>
        /// <param name = "ReturnedData">
        /// <para>Pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-actctx_section_keyed_data">ACTCTX_SECTION_KEYED_DATA</a> structure to be filled out with the requested string information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findactctxsectionstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
        /// <para>This function sets errors that can be retrieved by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. For an example, see <a href = "/windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see <a href = "/windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findactctxsectionstringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindActCtxSectionStringW", SetLastError = true)]
        internal static extern unsafe bool FindActCtxSectionString(uint dwFlags, global::System.Guid*lpExtensionGuid, uint ulSectionId, win32.System.SystemServices.PCWSTR lpStringToFind, win32.System.ApplicationInstallationAndServicing.ACTCTX_SECTION_KEYED_DATA*ReturnedData);
        /// <inheritdoc cref = "FindActCtxSectionGuid(uint, global::System.Guid*, uint, global::System.Guid*, win32.System.ApplicationInstallationAndServicing.ACTCTX_SECTION_KEYED_DATA*)"/>
        internal static unsafe bool FindActCtxSectionGuid(uint dwFlags, in global::System.Guid lpExtensionGuid, uint ulSectionId, global::System.Guid? lpGuidToFind, out win32.System.ApplicationInstallationAndServicing.ACTCTX_SECTION_KEYED_DATA ReturnedData)
        {
            fixed (win32.System.ApplicationInstallationAndServicing.ACTCTX_SECTION_KEYED_DATA*ReturnedDataLocal = &ReturnedData)
            {
                fixed (global::System.Guid*lpExtensionGuidLocal = &lpExtensionGuid)
                {
                    global::System.Guid lpGuidToFindLocal = lpGuidToFind.HasValue ? lpGuidToFind.Value : default(global::System.Guid);
                    bool __result = Kernel32.FindActCtxSectionGuid(dwFlags, lpExtensionGuidLocal, ulSectionId, lpGuidToFind.HasValue ? &lpGuidToFindLocal : null, ReturnedDataLocal);
                    return __result;
                }
            }
        }

        /// <summary>The FindActCtxSectionGuid function retrieves information on a specific GUID in the current activation context and returns a ACTCTX_SECTION_KEYED_DATA structure.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findactctxsectionguid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpExtensionGuid">Reserved; must be null.</param>
        /// <param name = "ulSectionId">
        /// <para>Identifier of the section of the activation context in which to search for the specified GUID.</para>
        /// <para>The following are valid GUID section identifiers:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findactctxsectionguid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpGuidToFind">Pointer to a GUID to be used as the search criteria.</param>
        /// <param name = "ReturnedData">
        /// <para>Pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-actctx_section_keyed_data">ACTCTX_SECTION_KEYED_DATA</a> structure to be filled out with the requested GUID information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findactctxsectionguid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
        /// <para>This function sets errors that can be retrieved by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. For an example, see <a href = "/windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see <a href = "/windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findactctxsectionguid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool FindActCtxSectionGuid(uint dwFlags, global::System.Guid*lpExtensionGuid, uint ulSectionId, [Optional] global::System.Guid*lpGuidToFind, win32.System.ApplicationInstallationAndServicing.ACTCTX_SECTION_KEYED_DATA*ReturnedData);
        /// <inheritdoc cref = "QueryActCtx(uint, win32.System.SystemServices.HANDLE, void *, uint, void *, nuint, nuint*)"/>
        internal static unsafe bool QueryActCtx(uint dwFlags, SafeHandle hActCtx, void *pvSubInstance, uint ulInfoClass, void *pvBuffer, nuint cbBuffer, nuint*pcbWrittenOrRequired)
        {
            bool hActCtxAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hActCtxLocal;
                if (hActCtx is object)
                {
                    hActCtx.DangerousAddRef(ref hActCtxAddRef);
                    hActCtxLocal = (win32.System.SystemServices.HANDLE)hActCtx.DangerousGetHandle();
                }
                else
                    hActCtxLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.QueryActCtx(dwFlags, hActCtxLocal, pvSubInstance, ulInfoClass, pvBuffer, cbBuffer, pcbWrittenOrRequired);
                return __result;
            }
            finally
            {
                if (hActCtxAddRef)
                    hActCtx.DangerousRelease();
            }
        }

        /// <summary>The QueryActCtxW function queries the activation context.</summary>
        /// <param name = "dwFlags">
        /// <para>This parameter should be set to one of the following flag bits.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-queryactctxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hActCtx">Handle to the activation context that is being queried.</param>
        /// <param name = "pvSubInstance">
        /// <para>Index of the assembly, or assembly and file combination, in the activation context. The meaning of the <i>pvSubInstance</i> depends on the option specified by the value of the <i>ulInfoClass</i> parameter.</para>
        /// <para>This parameter may be null.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-queryactctxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ulInfoClass">
        /// <para>This parameter can have only the values shown in the following table.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-queryactctxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pvBuffer">
        /// <para>Pointer to a buffer that holds the returned information. This parameter is optional. If <i>pvBuffer</i> is <b>null</b>, then <i>cbBuffer</i> must be zero. If the size of the buffer pointed to by <i>pvBuffer</i> is too small, <b>QueryActCtxW</b> returns ERROR_INSUFFICIENT_BUFFER and no data is written into the buffer. See the Remarks section for the method you can use to determine the required size of the buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-queryactctxw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cbBuffer">Size of the buffer in bytes pointed to by <i>pvBuffer</i>. This parameter is optional.</param>
        /// <param name = "pcbWrittenOrRequired">Number of bytes written or required. The parameter <i>pcbWrittenOrRequired</i> can only be <b>NULL</b> when <i>pvBuffer</i> is <b>NULL</b>. If <i>pcbWrittenOrRequired</i> is non-<b>NULL</b>, it is filled with the number of bytes required to store the returned buffer.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
        /// <para>This function sets errors that can be retrieved by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. For an example, see <a href = "/windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see <a href = "/windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-queryactctxw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "QueryActCtxW", SetLastError = true)]
        internal static extern unsafe bool QueryActCtx(uint dwFlags, win32.System.SystemServices.HANDLE hActCtx, [Optional] void *pvSubInstance, uint ulInfoClass, [Optional] void *pvBuffer, nuint cbBuffer, [Optional] nuint*pcbWrittenOrRequired);
        /// <inheritdoc cref = "QueryActCtxSettings(uint, win32.System.SystemServices.HANDLE, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, nuint, nuint*)"/>
        internal static unsafe bool QueryActCtxSettings(uint dwFlags, SafeHandle hActCtx, string settingsNameSpace, string settingName, win32.System.SystemServices.PWSTR pvBuffer, nuint dwBuffer, nuint*pdwWrittenOrRequired)
        {
            bool hActCtxAddRef = false;
            try
            {
                fixed (char *settingNameLocal = settingName)
                {
                    fixed (char *settingsNameSpaceLocal = settingsNameSpace)
                    {
                        win32.System.SystemServices.HANDLE hActCtxLocal;
                        if (hActCtx is object)
                        {
                            hActCtx.DangerousAddRef(ref hActCtxAddRef);
                            hActCtxLocal = (win32.System.SystemServices.HANDLE)hActCtx.DangerousGetHandle();
                        }
                        else
                            hActCtxLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.QueryActCtxSettings(dwFlags, hActCtxLocal, settingsNameSpaceLocal, settingNameLocal, pvBuffer, dwBuffer, pdwWrittenOrRequired);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hActCtxAddRef)
                    hActCtx.DangerousRelease();
            }
        }

        /// <summary>The QueryActCtxSettingsW function specifies the activation context, and the namespace and name of the attribute that is to be queried.</summary>
        /// <param name = "dwFlags">This value must be 0.</param>
        /// <param name = "hActCtx">A handle to the activation context that is being queried.</param>
        /// <param name = "settingsNameSpace">
        /// <para>A pointer to a string that contains the value <b>"http://schemas.microsoft.com/SMI/2005/WindowsSettings"</b> or <b>NULL</b>. These values are equivalent.</para>
        /// <para><b>Windows 8 and Windows Server 2012:  </b>A pointer to a string that contains the value <b>"http://schemas.microsoft.com/SMI/2011/WindowsSettings"</b> is also a valid parameter.  A <b>NULL</b> is still equivalent to the previous value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-queryactctxsettingsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "settingName">The name of the attribute to be queried.</param>
        /// <param name = "pvBuffer">A pointer to the buffer that receives the query result.</param>
        /// <param name = "dwBuffer">The size of the buffer  in characters that receives the query result.</param>
        /// <param name = "pdwWrittenOrRequired">A pointer to a value which is the number of characters written to the buffer specified by <i>pvBuffer</i> or that is required to hold the query result.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
        /// <para>This function sets errors that can be retrieved by calling <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. For an example, see <a href = "/windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see <a href = "/windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-queryactctxsettingsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "QueryActCtxSettingsW", SetLastError = true)]
        internal static extern unsafe bool QueryActCtxSettings(uint dwFlags, win32.System.SystemServices.HANDLE hActCtx, win32.System.SystemServices.PCWSTR settingsNameSpace, win32.System.SystemServices.PCWSTR settingName, win32.System.SystemServices.PWSTR pvBuffer, nuint dwBuffer, [Optional] nuint*pdwWrittenOrRequired);
        /// <inheritdoc cref = "WerRegisterFile(win32.System.SystemServices.PCWSTR, win32.System.ErrorReporting.WER_REGISTER_FILE_TYPE, win32.System.ErrorReporting.WER_FILE)"/>
        internal static unsafe win32.System.Com.HRESULT WerRegisterFile(string pwzFile, win32.System.ErrorReporting.WER_REGISTER_FILE_TYPE regFileType, win32.System.ErrorReporting.WER_FILE dwFlags)
        {
            fixed (char *pwzFileLocal = pwzFile)
            {
                win32.System.Com.HRESULT __result = Kernel32.WerRegisterFile(pwzFileLocal, regFileType, dwFlags);
                return __result;
            }
        }

        /// <summary>Registers a file to be collected when WER creates an error report.</summary>
        /// <param name = "pwzFile">The full path to the file. The maximum length of this path is MAX_PATH characters.</param>
        /// <param name = "regFileType"></param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or an error code on failure, including the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werregisterfile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT WerRegisterFile(win32.System.SystemServices.PCWSTR pwzFile, win32.System.ErrorReporting.WER_REGISTER_FILE_TYPE regFileType, win32.System.ErrorReporting.WER_FILE dwFlags);
        /// <inheritdoc cref = "WerUnregisterFile(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.Com.HRESULT WerUnregisterFile(string pwzFilePath)
        {
            fixed (char *pwzFilePathLocal = pwzFilePath)
            {
                win32.System.Com.HRESULT __result = Kernel32.WerUnregisterFile(pwzFilePathLocal);
                return __result;
            }
        }

        /// <summary>Removes a file from the list of files to be added to reports generated for the current process.</summary>
        /// <param name = "pwzFilePath">The full path to the file. This file must have been registered using the <a href = "https://docs.microsoft.com/windows/desktop/api/werapi/nf-werapi-werregisterfile">WerRegisterFile</a> function.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or an error code on failure, including the following error code.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werunregisterfile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT WerUnregisterFile(win32.System.SystemServices.PCWSTR pwzFilePath);
        /// <summary>Registers a memory block to be collected when WER creates an error report.</summary>
        /// <param name = "pvAddress">The starting address of the memory block.</param>
        /// <param name = "dwSize">The size of the memory block, in bytes. The maximum value for this parameter is WER_MAX_MEM_BLOCK_SIZE bytes.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or an error code on failure, including the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werregistermemoryblock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT WerRegisterMemoryBlock(void *pvAddress, uint dwSize);
        /// <summary>Removes a memory block from the list of data to be collected during error reporting for the application.</summary>
        /// <param name = "pvAddress">The starting address of the memory block. This memory block must have been registered using the <a href = "https://docs.microsoft.com/windows/desktop/api/werapi/nf-werapi-werregistermemoryblock">WerRegisterMemoryBlock</a> function.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or an error code on failure, including the following error code.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werunregistermemoryblock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT WerUnregisterMemoryBlock(void *pvAddress);
        /// <summary>Marks a memory block (that is normally included by default in error reports) to be excluded from the error report.</summary>
        /// <param name = "address">The starting address of the memory block.</param>
        /// <param name = "size">The size of the memory block, in bytes.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or an error code on failure, including the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werregisterexcludedmemoryblock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT WerRegisterExcludedMemoryBlock(void *address, uint size);
        /// <summary>Removes a memory block that was previously marked as excluded (it will again be included in error reports).</summary>
        /// <param name = "address">The starting address of the memory block. This memory block must have been registered using the <a href = "https://docs.microsoft.com/windows/desktop/api/werapi/nf-werapi-werregisterexcludedmemoryblock">WerRegisterExcludedMemoryBlock</a> function.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or an error code on failure, including the following error code.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werunregisterexcludedmemoryblock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT WerUnregisterExcludedMemoryBlock(void *address);
        /// <inheritdoc cref = "WerRegisterCustomMetadata(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.Com.HRESULT WerRegisterCustomMetadata(string key, string value)
        {
            fixed (char *valueLocal = value)
            {
                fixed (char *keyLocal = key)
                {
                    win32.System.Com.HRESULT __result = Kernel32.WerRegisterCustomMetadata(keyLocal, valueLocal);
                    return __result;
                }
            }
        }

        /// <summary>Registers app-specific metadata to be collected (in the form of key/value strings) when WER creates an error report.</summary>
        /// <param name = "key">The "key" string for the metadata element being registered.</param>
        /// <param name = "value">The value string for the metadata element being registered.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or an error code on failure, including the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werregistercustommetadata">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT WerRegisterCustomMetadata(win32.System.SystemServices.PCWSTR key, win32.System.SystemServices.PCWSTR value);
        /// <inheritdoc cref = "WerUnregisterCustomMetadata(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.Com.HRESULT WerUnregisterCustomMetadata(string key)
        {
            fixed (char *keyLocal = key)
            {
                win32.System.Com.HRESULT __result = Kernel32.WerUnregisterCustomMetadata(keyLocal);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT WerUnregisterCustomMetadata(win32.System.SystemServices.PCWSTR key);
        /// <summary>Registers a process to be included in the error report along with the main application process. Optionally specifies a thread within that registered process to get additional data from.</summary>
        /// <param name = "processId">The Id of the process to register.</param>
        /// <param name = "captureExtraInfoForThreadId">The Id of a thread within the registered process from which more information is requested.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or an error code on failure, including the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werregisteradditionalprocess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT WerRegisterAdditionalProcess(uint processId, uint captureExtraInfoForThreadId);
        /// <summary>Removes a process from the list of additional processes to be included in the error report.</summary>
        /// <param name = "processId">The Id of the process to remove. It must have been previously registered with <a href = "https://docs.microsoft.com/windows/desktop/api/werapi/nf-werapi-werregisteradditionalprocess">WerRegisterAdditionalProcess</a>.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or an error code on failure, including the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werunregisteradditionalprocess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT WerUnregisterAdditionalProcess(uint processId);
        /// <inheritdoc cref = "WerRegisterAppLocalDump(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe win32.System.Com.HRESULT WerRegisterAppLocalDump(string localAppDataRelativePath)
        {
            fixed (char *localAppDataRelativePathLocal = localAppDataRelativePath)
            {
                win32.System.Com.HRESULT __result = Kernel32.WerRegisterAppLocalDump(localAppDataRelativePathLocal);
                return __result;
            }
        }

        /// <summary>Registers a path relative to the local app store for the calling application where Windows Error Reporting (WER) should save a copy of the diagnostic memory dump that WER collects when one of the processes for the application stops responding.</summary>
        /// <param name = "localAppDataRelativePath">The path relative to the local app store for the calling application where WER should save a copy of the diagnostic memory dump that WER collects when one of the processes for the application stops responding. The maximum length for this relative path in characters is **WER_MAX_LOCAL_DUMP_SUBPATH_LENGTH**, which has a value of 64. This maximum length includes the null-termination character.</param>
        /// <returns>
        /// <para>This function returns **S_OK** on success or an error code on failure, including the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werregisterapplocaldump">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT WerRegisterAppLocalDump(win32.System.SystemServices.PCWSTR localAppDataRelativePath);
        /// <summary>Cancels the registration that was made by calling the WerRegisterAppLocalDump function to specify that Windows Error Reporting (WER) should save a copy of the diagnostic memory dump that WER collects when one of the processes for the application stops responding.</summary>
        /// <returns>If this function succeeds, it returns <b xmlns: loc = "http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns: loc = "http://microsoft.com/wdcml/l10n">HRESULT</b> error code.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werunregisterapplocaldump">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT WerUnregisterAppLocalDump();
        /// <summary>Sets the fault reporting settings for the current process.</summary>
        /// <param name = "dwFlags"></param>
        /// <returns>This function returns <b>S_OK</b> on success or an error code on failure.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-wersetflags">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT WerSetFlags(win32.System.ErrorReporting.WER_FAULT_REPORTING dwFlags);
        /// <inheritdoc cref = "WerGetFlags(win32.System.SystemServices.HANDLE, win32.System.ErrorReporting.WER_FAULT_REPORTING*)"/>
        internal static unsafe win32.System.Com.HRESULT WerGetFlags(SafeHandle hProcess, out win32.System.ErrorReporting.WER_FAULT_REPORTING pdwFlags)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (win32.System.ErrorReporting.WER_FAULT_REPORTING*pdwFlagsLocal = &pdwFlags)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.Com.HRESULT __result = Kernel32.WerGetFlags(hProcessLocal, pdwFlagsLocal);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the fault reporting settings for the specified process.</summary>
        /// <param name = "hProcess">A handle to the process. This handle must have the PROCESS_VM_READ or PROCESS_QUERY_INFORMATION access right.</param>
        /// <param name = "pdwFlags"></param>
        /// <returns>This function returns <b>S_OK</b> on success or an error code on failure.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-wergetflags">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT WerGetFlags(win32.System.SystemServices.HANDLE hProcess, win32.System.ErrorReporting.WER_FAULT_REPORTING*pdwFlags);
        /// <inheritdoc cref = "WerRegisterRuntimeExceptionModule(win32.System.SystemServices.PCWSTR, void *)"/>
        internal static unsafe win32.System.Com.HRESULT WerRegisterRuntimeExceptionModule(string pwszOutOfProcessCallbackDll, void *pContext)
        {
            fixed (char *pwszOutOfProcessCallbackDllLocal = pwszOutOfProcessCallbackDll)
            {
                win32.System.Com.HRESULT __result = Kernel32.WerRegisterRuntimeExceptionModule(pwszOutOfProcessCallbackDllLocal, pContext);
                return __result;
            }
        }

        /// <summary>Registers a custom runtime exception handler that is used to provide custom error reporting for crashes.</summary>
        /// <param name = "pwszOutOfProcessCallbackDll">The name of the exception handler DLL to register.</param>
        /// <param name = "pContext">A pointer to arbitrary context information that is passed to the handler's callback functions.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or an error code on failure, including the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werregisterruntimeexceptionmodule">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT WerRegisterRuntimeExceptionModule(win32.System.SystemServices.PCWSTR pwszOutOfProcessCallbackDll, void *pContext);
        /// <inheritdoc cref = "WerUnregisterRuntimeExceptionModule(win32.System.SystemServices.PCWSTR, void *)"/>
        internal static unsafe win32.System.Com.HRESULT WerUnregisterRuntimeExceptionModule(string pwszOutOfProcessCallbackDll, void *pContext)
        {
            fixed (char *pwszOutOfProcessCallbackDllLocal = pwszOutOfProcessCallbackDll)
            {
                win32.System.Com.HRESULT __result = Kernel32.WerUnregisterRuntimeExceptionModule(pwszOutOfProcessCallbackDllLocal, pContext);
                return __result;
            }
        }

        /// <summary>Removes the registration of your WER exception handler.</summary>
        /// <param name = "pwszOutOfProcessCallbackDll">The name of the exception handler DLL whose registration you want to remove.</param>
        /// <param name = "pContext">A pointer to arbitrary context information that was passed to the callback.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or an error code on failure, including the following error code.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//werapi/nf-werapi-werunregisterruntimeexceptionmodule">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT WerUnregisterRuntimeExceptionModule(win32.System.SystemServices.PCWSTR pwszOutOfProcessCallbackDll, void *pContext);
        /// <summary>Destroys the specified heap object. It decommits and releases all the pages of a private heap object, and it invalidates the handle to the heap.</summary>
        /// <param name = "hHeap">
        /// <para>A handle to the heap to be destroyed. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> function. Do not use the handle to the process heap returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapdestroy#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapdestroy">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL HeapDestroy(win32.System.Memory.HeapHandle hHeap);
        /// <inheritdoc cref = "HeapCreate(win32.System.Memory.HEAP_FLAGS, nuint, nuint)"/>
        internal static unsafe Kernel32.HeapDestroySafeHandle HeapCreate_SafeHandle(win32.System.Memory.HEAP_FLAGS flOptions, nuint dwInitialSize, nuint dwMaximumSize)
        {
            win32.System.Memory.HeapHandle __result = Kernel32.HeapCreate(flOptions, dwInitialSize, dwMaximumSize);
            return new Kernel32.HeapDestroySafeHandle(__result, ownsHandle: true);
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "Kernel32.HeapDestroy"/>.
        /// </summary>
        internal class HeapDestroySafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal HeapDestroySafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal HeapDestroySafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => Kernel32.HeapDestroy((win32.System.Memory.HeapHandle)this.handle);
        }

        /// <summary>Creates a private heap object that can be used by the calling process. The function reserves space in the virtual address space of the process and allocates physical storage for a specified initial portion of this block.</summary>
        /// <param name = "flOptions"></param>
        /// <param name = "dwInitialSize">
        /// <para>The initial size of the heap, in bytes. This value determines the initial amount of memory that is committed for the heap. The value is rounded up to a multiple of the system page size. The value must be smaller than <i>dwMaximumSize</i>.</para>
        /// <para>If this parameter is 0, the function commits one page. To determine the size of a page on the host computer, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapcreate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMaximumSize">
        /// <para>The maximum size of the heap, in bytes. The <b>HeapCreate</b> function rounds <i>dwMaximumSize</i> up to a multiple of the system page size and then reserves a block of that size in the process's virtual address space for the heap. If allocation requests made by the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapalloc">HeapAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heaprealloc">HeapReAlloc</a> functions exceed the size specified by <i>dwInitialSize</i>, the system commits additional pages of memory for the heap, up to the heap's maximum size.</para>
        /// <para>If <i>dwMaximumSize</i> is not zero, the heap size is fixed and cannot grow beyond the maximum size. Also, the largest memory block that can be allocated from the heap is slightly less than 512 KB for a 32-bit process and slightly less than 1,024 KB for a 64-bit process. Requests to allocate larger blocks fail, even if the maximum size of the heap is large enough to contain the block.</para>
        /// <para>If <i>dwMaximumSize</i> is 0, the heap can grow in size. The heap's size is limited only by the available memory. Requests to allocate memory blocks larger than the limit for a fixed-size heap do not automatically fail; instead, the system calls the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> function to obtain the memory that is needed for large blocks. Applications that need to allocate large memory blocks should set <i>dwMaximumSize</i> to 0.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapcreate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the newly created heap.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapcreate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.Memory.HeapHandle HeapCreate(win32.System.Memory.HEAP_FLAGS flOptions, nuint dwInitialSize, nuint dwMaximumSize);
        /// <inheritdoc cref = "HeapAlloc(win32.System.Memory.HeapHandle, win32.System.Memory.HEAP_FLAGS, nuint)"/>
        internal static unsafe void *HeapAlloc(SafeHandle hHeap, win32.System.Memory.HEAP_FLAGS dwFlags, nuint dwBytes)
        {
            bool hHeapAddRef = false;
            try
            {
                win32.System.Memory.HeapHandle hHeapLocal;
                if (hHeap is object)
                {
                    hHeap.DangerousAddRef(ref hHeapAddRef);
                    hHeapLocal = (win32.System.Memory.HeapHandle)hHeap.DangerousGetHandle();
                }
                else
                    hHeapLocal = default(win32.System.Memory.HeapHandle);
                void *__result = Kernel32.HeapAlloc(hHeapLocal, dwFlags, dwBytes);
                return __result;
            }
            finally
            {
                if (hHeapAddRef)
                    hHeap.DangerousRelease();
            }
        }

        /// <summary>Allocates a block of memory from a heap. The allocated memory is not movable.</summary>
        /// <param name = "hHeap">
        /// <para>A handle to the heap from which the memory will be allocated. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapalloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">The heap allocation options. Specifying any of these values will override the corresponding value specified when the heap was created with</param>
        /// <param name = "dwBytes">
        /// <para>The number of bytes to be allocated.</para>
        /// <para>If the heap specified by the <i>hHeap</i> parameter is a "non-growable" heap, <i>dwBytes</i> must be less than 0x7FFF8. You create a non-growable heap by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> function with a nonzero value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapalloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a pointer to the allocated memory block.</para>
        /// <para>If the function fails and you have not specified <b>HEAP_GENERATE_EXCEPTIONS</b>, the return value is <b>NULL</b>.</para>
        /// <para>If the function fails and you have specified <b>HEAP_GENERATE_EXCEPTIONS</b>, the function may generate either of the exceptions listed in the following table. The particular exception depends upon the nature of the heap corruption. For more information, see <a href = "/windows/desktop/Debug/getexceptioncode">GetExceptionCode</a>.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapalloc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *HeapAlloc(win32.System.Memory.HeapHandle hHeap, win32.System.Memory.HEAP_FLAGS dwFlags, nuint dwBytes);
        /// <summary>Reallocates a block of memory from a heap. This function enables you to resize a memory block and change other memory block properties.</summary>
        /// <param name = "hHeap">
        /// <para>A handle to the heap from which the memory is to be reallocated. This handle is a returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heaprealloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">The heap reallocation options. Specifying a value overrides the corresponding value specified in the <i>flOptions</i> parameter when the heap was created by using the</param>
        /// <param name = "lpMem">
        /// <para>A pointer to the block of memory that the function reallocates. This pointer is returned by an earlier call to the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapalloc">HeapAlloc</a> or <b>HeapReAlloc</b> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heaprealloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwBytes">
        /// <para>The new size of the memory block, in bytes. A memory block's size can be increased or decreased by using this function.</para>
        /// <para>If the heap specified by the <i>hHeap</i> parameter is a "non-growable" heap, <i>dwBytes</i> must be less than 0x7FFF8. You create a non-growable heap by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> function with a nonzero value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heaprealloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a pointer to the reallocated memory block.</para>
        /// <para>If the function fails and you have not specified <b>HEAP_GENERATE_EXCEPTIONS</b>, the return value is <b>NULL</b>.</para>
        /// <para>If the function fails and you have specified <b>HEAP_GENERATE_EXCEPTIONS</b>, the function may generate either of the exceptions listed in the following table. For more information, see <a href = "/windows/desktop/Debug/getexceptioncode">GetExceptionCode</a>.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heaprealloc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *HeapReAlloc(win32.System.Memory.HeapHandle hHeap, win32.System.Memory.HEAP_FLAGS dwFlags, [Optional] void *lpMem, nuint dwBytes);
        /// <summary>Frees a memory block allocated from a heap by the HeapAlloc or HeapReAlloc function.</summary>
        /// <param name = "hHeap">
        /// <para>A handle to the heap whose memory block is to be freed. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapfree#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>The heap free options. Specifying the following value overrides the corresponding value specified in the <i>flOptions</i> parameter when the heap was created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> function.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapfree#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMem">
        /// <para>A pointer to the memory block to be freed. This pointer is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapalloc">HeapAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heaprealloc">HeapReAlloc</a> function. This pointer can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapfree#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. An application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapfree">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool HeapFree(win32.System.Memory.HeapHandle hHeap, win32.System.Memory.HEAP_FLAGS dwFlags, [Optional] void *lpMem);
        /// <inheritdoc cref = "HeapSize(win32.System.Memory.HeapHandle, win32.System.Memory.HEAP_FLAGS, void *)"/>
        internal static unsafe nuint HeapSize(SafeHandle hHeap, win32.System.Memory.HEAP_FLAGS dwFlags, void *lpMem)
        {
            bool hHeapAddRef = false;
            try
            {
                win32.System.Memory.HeapHandle hHeapLocal;
                if (hHeap is object)
                {
                    hHeap.DangerousAddRef(ref hHeapAddRef);
                    hHeapLocal = (win32.System.Memory.HeapHandle)hHeap.DangerousGetHandle();
                }
                else
                    hHeapLocal = default(win32.System.Memory.HeapHandle);
                nuint __result = Kernel32.HeapSize(hHeapLocal, dwFlags, lpMem);
                return __result;
            }
            finally
            {
                if (hHeapAddRef)
                    hHeap.DangerousRelease();
            }
        }

        /// <summary>Retrieves the size of a memory block allocated from a heap by the HeapAlloc or HeapReAlloc function.</summary>
        /// <param name = "hHeap">
        /// <para>A handle to the heap in which the memory block resides. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapsize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>The heap size options. Specifying the following value overrides the corresponding value specified in the <i>flOptions</i> parameter when the heap was created by using the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> function.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapsize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMem">
        /// <para>A pointer to the memory block whose size the function will obtain. This is a pointer returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapalloc">HeapAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heaprealloc">HeapReAlloc</a> function. The memory block must be from the heap specified by the <i>hHeap</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapsize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the requested size of the allocated memory block, in bytes.</para>
        /// <para>If the function fails, the return value is <code>(SIZE_T)-1</code>. The function does not call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a>. An application cannot call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.</para>
        /// <para>If the <i>lpMem</i> parameter refers to a heap allocation that is not in the heap specified by the <i>hHeap</i> parameter, the behavior of the <b>HeapSize</b> function is undefined.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapsize">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe nuint HeapSize(win32.System.Memory.HeapHandle hHeap, win32.System.Memory.HEAP_FLAGS dwFlags, void *lpMem);
        /// <inheritdoc cref = "GetProcessHeap()"/>
        internal static unsafe Kernel32.HeapDestroySafeHandle GetProcessHeap_SafeHandle()
        {
            win32.System.Memory.HeapHandle __result = Kernel32.GetProcessHeap();
            return new Kernel32.HeapDestroySafeHandle(__result, ownsHandle: true);
        }

        /// <summary>Retrieves a handle to the default heap of the calling process.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the calling process's heap.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-getprocessheap">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.Memory.HeapHandle GetProcessHeap();
        /// <inheritdoc cref = "HeapCompact(win32.System.Memory.HeapHandle, win32.System.Memory.HEAP_FLAGS)"/>
        internal static unsafe nuint HeapCompact(SafeHandle hHeap, win32.System.Memory.HEAP_FLAGS dwFlags)
        {
            bool hHeapAddRef = false;
            try
            {
                win32.System.Memory.HeapHandle hHeapLocal;
                if (hHeap is object)
                {
                    hHeap.DangerousAddRef(ref hHeapAddRef);
                    hHeapLocal = (win32.System.Memory.HeapHandle)hHeap.DangerousGetHandle();
                }
                else
                    hHeapLocal = default(win32.System.Memory.HeapHandle);
                nuint __result = Kernel32.HeapCompact(hHeapLocal, dwFlags);
                return __result;
            }
            finally
            {
                if (hHeapAddRef)
                    hHeap.DangerousRelease();
            }
        }

        /// <summary>Returns the size of the largest committed free block in the specified heap. If the Disable heap coalesce on free global flag is set, this function also coalesces adjacent free blocks of memory in the heap.</summary>
        /// <param name = "hHeap">
        /// <para>A handle to the heap. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapcompact#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>The heap access options. This parameter can be the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapcompact#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the size of the largest committed free block in the heap, in bytes.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>In the unlikely case that there is absolutely no space available in the heap, the function return value is zero, and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the value NO_ERROR.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapcompact">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nuint HeapCompact(win32.System.Memory.HeapHandle hHeap, win32.System.Memory.HEAP_FLAGS dwFlags);
        /// <inheritdoc cref = "HeapSetInformation(win32.System.Memory.HeapHandle, win32.System.SystemServices.HEAP_INFORMATION_CLASS, void *, nuint)"/>
        internal static unsafe bool HeapSetInformation(SafeHandle HeapHandle, win32.System.SystemServices.HEAP_INFORMATION_CLASS HeapInformationClass, void *HeapInformation, nuint HeapInformationLength)
        {
            bool HeapHandleAddRef = false;
            try
            {
                win32.System.Memory.HeapHandle HeapHandleLocal;
                if (HeapHandle is object)
                {
                    HeapHandle.DangerousAddRef(ref HeapHandleAddRef);
                    HeapHandleLocal = (win32.System.Memory.HeapHandle)HeapHandle.DangerousGetHandle();
                }
                else
                    HeapHandleLocal = default(win32.System.Memory.HeapHandle);
                bool __result = Kernel32.HeapSetInformation(HeapHandleLocal, HeapInformationClass, HeapInformation, HeapInformationLength);
                return __result;
            }
            finally
            {
                if (HeapHandleAddRef)
                    HeapHandle.DangerousRelease();
            }
        }

        /// <summary>Enables features for a specified heap.</summary>
        /// <param name = "HeapHandle">
        /// <para>A handle to the heap where information is to be set. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapsetinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "HeapInformationClass"></param>
        /// <param name = "HeapInformation">
        /// <para>The heap information buffer. The format of this data depends on the value of the <i>HeapInformationClass</i> parameter.</para>
        /// <para>If the <i>HeapInformationClass</i> parameter is <b>HeapCompatibilityInformation</b>, the <i>HeapInformation</i> parameter is a pointer to a <b>ULONG</b> variable.</para>
        /// <para>If the <i>HeapInformationClass</i> parameter is <b>HeapEnableTerminationOnCorruption</b>, the <i>HeapInformation</i> parameter should be <b>NULL</b> and <i>HeapInformationLength</i> should be 0</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapsetinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "HeapInformationLength">The size of the <i>HeapInformation</i> buffer, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapsetinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool HeapSetInformation(win32.System.Memory.HeapHandle HeapHandle, win32.System.SystemServices.HEAP_INFORMATION_CLASS HeapInformationClass, [Optional] void *HeapInformation, nuint HeapInformationLength);
        /// <inheritdoc cref = "HeapValidate(win32.System.Memory.HeapHandle, win32.System.Memory.HEAP_FLAGS, void *)"/>
        internal static unsafe bool HeapValidate(SafeHandle hHeap, win32.System.Memory.HEAP_FLAGS dwFlags, void *lpMem)
        {
            bool hHeapAddRef = false;
            try
            {
                win32.System.Memory.HeapHandle hHeapLocal;
                if (hHeap is object)
                {
                    hHeap.DangerousAddRef(ref hHeapAddRef);
                    hHeapLocal = (win32.System.Memory.HeapHandle)hHeap.DangerousGetHandle();
                }
                else
                    hHeapLocal = default(win32.System.Memory.HeapHandle);
                bool __result = Kernel32.HeapValidate(hHeapLocal, dwFlags, lpMem);
                return __result;
            }
            finally
            {
                if (hHeapAddRef)
                    hHeap.DangerousRelease();
            }
        }

        /// <summary>Validates the specified heap. The function scans all the memory blocks in the heap and verifies that the heap control structures maintained by the heap manager are in a consistent state.</summary>
        /// <param name = "hHeap">
        /// <para>A handle to the heap to be validated. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapvalidate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>The heap access options. This parameter can be the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapvalidate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMem">
        /// <para>A pointer to a memory block within the specified heap. This parameter may be <b>NULL</b>.</para>
        /// <para>If this parameter is <b>NULL</b>, the function attempts to validate the entire heap specified by <i>hHeap</i>.</para>
        /// <para>If this parameter is not <b>NULL</b>, the function attempts to validate the memory block pointed to by <i>lpMem</i>. It does not attempt to validate the rest of the heap.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapvalidate#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the specified heap or memory block is valid, the return value is nonzero.</para>
        /// <para>If the specified heap or memory block is invalid, the return value is zero. On a system set up for debugging, the <b>HeapValidate</b> function then displays debugging messages that describe the part of the heap or memory block that is invalid, and stops at a hard-coded breakpoint so that you can examine the system to determine the source of the invalidity. The <b>HeapValidate</b> function does not set the thread's last error value. There is no extended error information for this function; do not call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapvalidate">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool HeapValidate(win32.System.Memory.HeapHandle hHeap, win32.System.Memory.HEAP_FLAGS dwFlags, [Optional] void *lpMem);
        /// <inheritdoc cref = "HeapSummary(win32.System.SystemServices.HANDLE, uint, win32.System.Memory.HEAP_SUMMARY*)"/>
        internal static unsafe bool HeapSummary(SafeHandle hHeap, uint dwFlags, out win32.System.Memory.HEAP_SUMMARY lpSummary)
        {
            bool hHeapAddRef = false;
            try
            {
                fixed (win32.System.Memory.HEAP_SUMMARY*lpSummaryLocal = &lpSummary)
                {
                    win32.System.SystemServices.HANDLE hHeapLocal;
                    if (hHeap is object)
                    {
                        hHeap.DangerousAddRef(ref hHeapAddRef);
                        hHeapLocal = (win32.System.SystemServices.HANDLE)hHeap.DangerousGetHandle();
                    }
                    else
                        hHeapLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.HeapSummary(hHeapLocal, dwFlags, lpSummaryLocal);
                    return __result;
                }
            }
            finally
            {
                if (hHeapAddRef)
                    hHeap.DangerousRelease();
            }
        }

        /// <param name = "hHeap">
        /// <para>A handle to the heap to be summarized. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapsummary#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">The heap summary options.</param>
        /// <param name = "lpSummary">Receives a pointer to a [Heap_Summary](ns-heapapi-heap_summary.md) structure representing the heap summary.</param>
        /// <returns>Returns S_OK on success.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapsummary">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool HeapSummary(win32.System.SystemServices.HANDLE hHeap, uint dwFlags, win32.System.Memory.HEAP_SUMMARY*lpSummary);
        /// <inheritdoc cref = "GetProcessHeaps(uint, win32.System.Memory.HeapHandle*)"/>
        internal static unsafe uint GetProcessHeaps(uint NumberOfHeaps, out Kernel32.HeapDestroySafeHandle ProcessHeaps)
        {
            win32.System.Memory.HeapHandle ProcessHeapsLocal;
            uint __result = Kernel32.GetProcessHeaps(NumberOfHeaps, &ProcessHeapsLocal);
            ProcessHeaps = new Kernel32.HeapDestroySafeHandle(ProcessHeapsLocal, ownsHandle: true);
            return __result;
        }

        /// <summary>Returns the number of active heaps and retrieves handles to all of the active heaps for the calling process.</summary>
        /// <param name = "NumberOfHeaps">The maximum number of heap handles that can be stored into the buffer pointed to by <i>ProcessHeaps</i>.</param>
        /// <param name = "ProcessHeaps">A pointer to a buffer that receives an array of heap handles.</param>
        /// <returns>
        /// <para>The return value is the number of handles to heaps that are active for the calling process.</para>
        /// <para>If the return value is less than or equal to <i>NumberOfHeaps</i>, the function has stored that number of heap handles in the buffer pointed to by <i>ProcessHeaps</i>.</para>
        /// <para>If the return value is greater than <i>NumberOfHeaps</i>, the buffer pointed to by <i>ProcessHeaps</i> is too small to hold all the heap handles for the calling process, and the function stores <i>NumberOfHeaps</i> handles in the buffer. Use the return value to allocate a buffer that is large enough to receive all of the handles, and call the function again.</para>
        /// <para>If the return value is zero, the function has failed because every process has at least one active heap, the default heap for the  process. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-getprocessheaps">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint GetProcessHeaps(uint NumberOfHeaps, win32.System.Memory.HeapHandle*ProcessHeaps);
        /// <inheritdoc cref = "HeapLock(win32.System.Memory.HeapHandle)"/>
        internal static unsafe bool HeapLock(SafeHandle hHeap)
        {
            bool hHeapAddRef = false;
            try
            {
                win32.System.Memory.HeapHandle hHeapLocal;
                if (hHeap is object)
                {
                    hHeap.DangerousAddRef(ref hHeapAddRef);
                    hHeapLocal = (win32.System.Memory.HeapHandle)hHeap.DangerousGetHandle();
                }
                else
                    hHeapLocal = default(win32.System.Memory.HeapHandle);
                bool __result = Kernel32.HeapLock(hHeapLocal);
                return __result;
            }
            finally
            {
                if (hHeapAddRef)
                    hHeap.DangerousRelease();
            }
        }

        /// <summary>Attempts to acquire the critical section object, or lock, that is associated with a specified heap.</summary>
        /// <param name = "hHeap">
        /// <para>A handle to the heap to be locked. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heaplock#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heaplock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool HeapLock(win32.System.Memory.HeapHandle hHeap);
        /// <inheritdoc cref = "HeapUnlock(win32.System.Memory.HeapHandle)"/>
        internal static unsafe bool HeapUnlock(SafeHandle hHeap)
        {
            bool hHeapAddRef = false;
            try
            {
                win32.System.Memory.HeapHandle hHeapLocal;
                if (hHeap is object)
                {
                    hHeap.DangerousAddRef(ref hHeapAddRef);
                    hHeapLocal = (win32.System.Memory.HeapHandle)hHeap.DangerousGetHandle();
                }
                else
                    hHeapLocal = default(win32.System.Memory.HeapHandle);
                bool __result = Kernel32.HeapUnlock(hHeapLocal);
                return __result;
            }
            finally
            {
                if (hHeapAddRef)
                    hHeap.DangerousRelease();
            }
        }

        /// <summary>Releases ownership of the critical section object, or lock, that is associated with a specified heap.</summary>
        /// <param name = "hHeap">
        /// <para>A handle to the heap to be unlocked. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapunlock#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapunlock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool HeapUnlock(win32.System.Memory.HeapHandle hHeap);
        /// <inheritdoc cref = "HeapWalk(win32.System.Memory.HeapHandle, win32.System.SystemServices.PROCESS_HEAP_ENTRY*)"/>
        internal static unsafe bool HeapWalk(SafeHandle hHeap, ref win32.System.SystemServices.PROCESS_HEAP_ENTRY lpEntry)
        {
            bool hHeapAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.PROCESS_HEAP_ENTRY*lpEntryLocal = &lpEntry)
                {
                    win32.System.Memory.HeapHandle hHeapLocal;
                    if (hHeap is object)
                    {
                        hHeap.DangerousAddRef(ref hHeapAddRef);
                        hHeapLocal = (win32.System.Memory.HeapHandle)hHeap.DangerousGetHandle();
                    }
                    else
                        hHeapLocal = default(win32.System.Memory.HeapHandle);
                    bool __result = Kernel32.HeapWalk(hHeapLocal, lpEntryLocal);
                    return __result;
                }
            }
            finally
            {
                if (hHeapAddRef)
                    hHeap.DangerousRelease();
            }
        }

        /// <summary>Enumerates the memory blocks in the specified heap.</summary>
        /// <param name = "hHeap">
        /// <para>A handle to the heap. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapwalk#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpEntry">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-process_heap_entry">PROCESS_HEAP_ENTRY</a> structure that maintains state information for a particular heap enumeration.</para>
        /// <para>If the <b>HeapWalk</b> function succeeds, returning the value <b>TRUE</b>, this structure's members contain information about the next memory block in the heap.</para>
        /// <para>To initiate a heap enumeration, set the <b>lpData</b> field of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-process_heap_entry">PROCESS_HEAP_ENTRY</a> structure to <b>NULL</b>. To continue a particular heap enumeration, call the <b>HeapWalk</b> function repeatedly, with no changes to <i>hHeap</i>, <i>lpEntry</i>, or any of the members of the <b>PROCESS_HEAP_ENTRY</b> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapwalk#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the heap enumeration terminates successfully by reaching the end of the heap, the function returns <b>FALSE</b>, and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the error code <b>ERROR_NO_MORE_ITEMS</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapwalk">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool HeapWalk(win32.System.Memory.HeapHandle hHeap, win32.System.SystemServices.PROCESS_HEAP_ENTRY*lpEntry);
        /// <inheritdoc cref = "HeapQueryInformation(win32.System.Memory.HeapHandle, win32.System.SystemServices.HEAP_INFORMATION_CLASS, void *, nuint, nuint*)"/>
        internal static unsafe bool HeapQueryInformation(SafeHandle HeapHandle, win32.System.SystemServices.HEAP_INFORMATION_CLASS HeapInformationClass, void *HeapInformation, nuint HeapInformationLength, nuint*ReturnLength)
        {
            bool HeapHandleAddRef = false;
            try
            {
                win32.System.Memory.HeapHandle HeapHandleLocal;
                if (HeapHandle is object)
                {
                    HeapHandle.DangerousAddRef(ref HeapHandleAddRef);
                    HeapHandleLocal = (win32.System.Memory.HeapHandle)HeapHandle.DangerousGetHandle();
                }
                else
                    HeapHandleLocal = default(win32.System.Memory.HeapHandle);
                bool __result = Kernel32.HeapQueryInformation(HeapHandleLocal, HeapInformationClass, HeapInformation, HeapInformationLength, ReturnLength);
                return __result;
            }
            finally
            {
                if (HeapHandleAddRef)
                    HeapHandle.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the specified heap.</summary>
        /// <param name = "HeapHandle">
        /// <para>A handle to the heap whose information is to be retrieved. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-heapcreate">HeapCreate</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapqueryinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "HeapInformationClass">
        /// <para>The class of information to be retrieved. This parameter can be the following value from the <b>HEAP_INFORMATION_CLASS</b> enumeration type.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapqueryinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "HeapInformation">A pointer to a buffer that receives the heap information. The format of this data depends on the value of the <i>HeapInformationClass</i> parameter.</param>
        /// <param name = "HeapInformationLength">The size of the heap information being queried, in bytes.</param>
        /// <param name = "ReturnLength">
        /// <para>A pointer to a variable that receives the length of data written to the <i>HeapInformation</i> buffer. If the buffer is too small, the function fails and <i>ReturnLength</i> specifies the minimum size required for the buffer.</para>
        /// <para>If you do not want to receive this information, specify <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapqueryinformation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//heapapi/nf-heapapi-heapqueryinformation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool HeapQueryInformation(win32.System.Memory.HeapHandle HeapHandle, win32.System.SystemServices.HEAP_INFORMATION_CLASS HeapInformationClass, [Optional] void *HeapInformation, nuint HeapInformationLength, [Optional] nuint*ReturnLength);
        /// <summary>Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process.</summary>
        /// <param name = "lpAddress">
        /// <para>The starting address of the region to allocate. If the memory is being reserved, the specified address is rounded down to the nearest multiple of the allocation granularity. If the memory is already reserved and is being committed, the address is rounded down to the next page boundary. To determine the size of a page and the allocation granularity on the host computer, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function. If this parameter is <b>NULL</b>, the system determines where to allocate the region.</para>
        /// <para>If this address is within an enclave that you have not initialized by calling <a href = "https://docs.microsoft.com/windows/desktop/api/enclaveapi/nf-enclaveapi-initializeenclave">InitializeEnclave</a>, <b>VirtualAlloc</b> allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.</para>
        /// <para>If the address in within an enclave that you initialized, then the allocation operation fails with the <b>ERROR_INVALID_ADDRESS</b> error.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualalloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSize">
        /// <para>The size of the region, in bytes. If the <i>lpAddress</i> parameter is <b>NULL</b>, this value is rounded up to the next page boundary. Otherwise, the allocated pages include all pages containing one or more bytes in the range from <i>lpAddress</i> to <i>lpAddress</i>+<i>dwSize</i>. This means that a 2-byte range straddling a page boundary causes both pages to be included in the allocated region.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualalloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flAllocationType"></param>
        /// <param name = "flProtect">
        /// <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the <a href = "https://docs.microsoft.com/windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualalloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualalloc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *VirtualAlloc([Optional] void *lpAddress, nuint dwSize, win32.System.Memory.VIRTUAL_ALLOCATION_TYPE flAllocationType, win32.System.SystemServices.PAGE_TYPE flProtect);
        /// <inheritdoc cref = "VirtualProtect(void *, nuint, win32.System.SystemServices.PAGE_TYPE, win32.System.SystemServices.PAGE_TYPE*)"/>
        internal static unsafe bool VirtualProtect(void *lpAddress, nuint dwSize, win32.System.SystemServices.PAGE_TYPE flNewProtect, out win32.System.SystemServices.PAGE_TYPE lpflOldProtect)
        {
            fixed (win32.System.SystemServices.PAGE_TYPE*lpflOldProtectLocal = &lpflOldProtect)
            {
                bool __result = Kernel32.VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtectLocal);
                return __result;
            }
        }

        /// <summary>Changes the protection on a region of committed pages in the virtual address space of the calling process.</summary>
        /// <param name = "lpAddress">
        /// <para>The address of the starting page of the region of pages whose access protection attributes are to be changed.</para>
        /// <para>All pages in the specified region must be within the same reserved region allocated when calling the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a> function using <b>MEM_RESERVE</b>. The pages cannot span adjacent reserved regions that were allocated by separate calls to <b>VirtualAlloc</b> or <b>VirtualAllocEx</b> using <b>MEM_RESERVE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSize">
        /// <para>The size of the region whose access protection attributes are to be changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the <i>lpAddress</i> parameter to <c>(lpAddress+dwSize)</c>. This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flNewProtect">
        /// <para>The memory protection option. This parameter can be one of the <a href = "https://docs.microsoft.com/windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
        /// <para>For mapped views, this value must be compatible with the access protection specified when the view was mapped (see <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffileex">MapViewOfFileEx</a>, and <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-mapviewoffileexnuma">MapViewOfFileExNuma</a>).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpflOldProtect">
        /// <para>A pointer to a variable that receives the previous access protection value of the first page in the specified region of pages. If this parameter is <b>NULL</b> or does not point to a valid variable, the function fails.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotect#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotect">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool VirtualProtect(void *lpAddress, nuint dwSize, win32.System.SystemServices.PAGE_TYPE flNewProtect, win32.System.SystemServices.PAGE_TYPE*lpflOldProtect);
        /// <summary>Releases, decommits, or releases and decommits a region of pages within the virtual address space of the calling process.</summary>
        /// <param name = "lpAddress">
        /// <para>A pointer to the base address of the region of pages to be freed.</para>
        /// <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, this parameter must be the base address returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> function when the region of pages is reserved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualfree#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSize">
        /// <para>The size of the region of memory to be freed, in bytes.</para>
        /// <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, this parameter must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a>.</para>
        /// <para>If the <i>dwFreeType</i> parameter is <b>MEM_DECOMMIT</b>, the function decommits all memory pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to <c>(lpAddress+dwSize)</c>. This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If <i>lpAddress</i> is the base address returned by <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> and <i>dwSize</i> is 0 (zero), the function decommits the entire region that is allocated by <b>VirtualAlloc</b>. After that, the entire region is in the reserved state.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualfree#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFreeType"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualfree">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool VirtualFree(void *lpAddress, nuint dwSize, win32.System.Memory.VIRTUAL_FREE_TYPE dwFreeType);
        /// <inheritdoc cref = "VirtualAllocEx(win32.System.SystemServices.HANDLE, void *, nuint, win32.System.Memory.VIRTUAL_ALLOCATION_TYPE, win32.System.SystemServices.PAGE_TYPE)"/>
        internal static unsafe void *VirtualAllocEx(SafeHandle hProcess, void *lpAddress, nuint dwSize, win32.System.Memory.VIRTUAL_ALLOCATION_TYPE flAllocationType, win32.System.SystemServices.PAGE_TYPE flProtect)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                void *__result = Kernel32.VirtualAllocEx(hProcessLocal, lpAddress, dwSize, flAllocationType, flProtect);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero.</summary>
        /// <param name = "hProcess">
        /// <para>The handle to a process. The function allocates memory within the virtual address space of this process.</para>
        /// <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualallocex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpAddress">
        /// <para>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</para>
        /// <para>If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity.</para>
        /// <para>If you are committing memory that is already reserved, the function rounds this address down to the nearest page boundary. To determine the size of a page and the allocation granularity on the host computer, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function.</para>
        /// <para>If <i>lpAddress</i> is <b>NULL</b>, the function determines where to allocate the region.</para>
        /// <para>If this address is within an enclave that you have not initialized by calling <a href = "https://docs.microsoft.com/windows/desktop/api/enclaveapi/nf-enclaveapi-initializeenclave">InitializeEnclave</a>, <b>VirtualAllocEx</b> allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.</para>
        /// <para>If the address in within an enclave that you initialized, then the allocation operation fails with the <b>ERROR_INVALID_ADDRESS</b> error.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualallocex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSize">
        /// <para>The size of the region of memory to allocate, in bytes.</para>
        /// <para>If <i>lpAddress</i> is <b>NULL</b>, the function rounds <i>dwSize</i> up to the next page boundary.</para>
        /// <para>If <i>lpAddress</i> is not <b>NULL</b>, the function allocates all pages that contain one or more bytes in the range from <i>lpAddress</i> to <i>lpAddress</i>+<i>dwSize</i>. This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualallocex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flAllocationType"></param>
        /// <param name = "flProtect">
        /// <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the <a href = "https://docs.microsoft.com/windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualallocex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualallocex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *VirtualAllocEx(win32.System.SystemServices.HANDLE hProcess, [Optional] void *lpAddress, nuint dwSize, win32.System.Memory.VIRTUAL_ALLOCATION_TYPE flAllocationType, win32.System.SystemServices.PAGE_TYPE flProtect);
        /// <inheritdoc cref = "VirtualProtectEx(win32.System.SystemServices.HANDLE, void *, nuint, win32.System.SystemServices.PAGE_TYPE, win32.System.SystemServices.PAGE_TYPE*)"/>
        internal static unsafe bool VirtualProtectEx(SafeHandle hProcess, void *lpAddress, nuint dwSize, win32.System.SystemServices.PAGE_TYPE flNewProtect, out win32.System.SystemServices.PAGE_TYPE lpflOldProtect)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.PAGE_TYPE*lpflOldProtectLocal = &lpflOldProtect)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.VirtualProtectEx(hProcessLocal, lpAddress, dwSize, flNewProtect, lpflOldProtectLocal);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Changes the protection on a region of committed pages in the virtual address space of a specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process whose memory protection is to be changed. The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpAddress">
        /// <para>A pointer to the base address of the region of pages whose access protection attributes are to be changed.</para>
        /// <para>All pages in the specified region must be within the same reserved region allocated when calling the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a> function using <b>MEM_RESERVE</b>. The pages cannot span adjacent reserved regions that were allocated by separate calls to <b>VirtualAlloc</b> or <b>VirtualAllocEx</b> using <b>MEM_RESERVE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSize">
        /// <para>The size of the region whose access protection attributes are changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the <i>lpAddress</i> parameter to <c>(lpAddress+dwSize)</c>. This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flNewProtect">
        /// <para>The memory protection option. This parameter can be one of the <a href = "https://docs.microsoft.com/windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
        /// <para>For mapped views, this value must be compatible with the access protection specified when the view was mapped (see <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffileex">MapViewOfFileEx</a>, and <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-mapviewoffileexnuma">MapViewOfFileExNuma</a>).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpflOldProtect">
        /// <para>A pointer to a variable that receives the previous access protection of the first page in the specified region of pages. If this parameter is <b>NULL</b> or does not point to a valid variable, the function fails.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotectex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotectex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool VirtualProtectEx(win32.System.SystemServices.HANDLE hProcess, void *lpAddress, nuint dwSize, win32.System.SystemServices.PAGE_TYPE flNewProtect, win32.System.SystemServices.PAGE_TYPE*lpflOldProtect);
        /// <inheritdoc cref = "CreateFileMapping(win32.System.SystemServices.HANDLE, win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.System.SystemServices.PAGE_TYPE, uint, uint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateFileMapping(SafeHandle hFile, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpFileMappingAttributes, win32.System.SystemServices.PAGE_TYPE flProtect, uint dwMaximumSizeHigh, uint dwMaximumSizeLow, string lpName)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (char *lpNameLocal = lpName)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.SECURITY_ATTRIBUTES lpFileMappingAttributesLocal = lpFileMappingAttributes.HasValue ? lpFileMappingAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                    win32.System.SystemServices.HANDLE __result = Kernel32.CreateFileMapping(hFileLocal, lpFileMappingAttributes.HasValue ? &lpFileMappingAttributesLocal : null, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpNameLocal);
                    return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Creates or opens a named or unnamed file mapping object for a specified file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file from which to create a file mapping object.</para>
        /// <para>The file must be opened with access rights that are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and <i>dwMaximumSizeLow</i> parameters. In this scenario, <b>CreateFileMapping</b> creates a file mapping object of a specified size  that is backed by the system paging file instead of by a file in the file system.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileMappingAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether a returned handle can be inherited by child processes. The <b>lpSecurityDescriptor</b> member of the <b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
        /// <para>If <i>lpAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flProtect">
        /// <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
        /// <param name = "dwMaximumSizeLow">
        /// <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
        /// <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that  <i>hFile</i> identifies.</para>
        /// <para>An attempt to map a file with a length of 0 (zero) fails with an error code of <b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>The name of the file mapping object.</para>
        /// <para>If this parameter matches the name of an existing mapping object, the function requests access to the object with the protection that <i>flProtect</i> specifies.</para>
        /// <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
        /// <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails, and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
        /// <para>The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). Creating a file mapping object in the global namespace from a session other than session zero requires the <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
        /// <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
        /// <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>returns <b>ERROR_ALREADY_EXISTS</b>.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateFileMappingW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateFileMapping(win32.System.SystemServices.HANDLE hFile, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpFileMappingAttributes, win32.System.SystemServices.PAGE_TYPE flProtect, uint dwMaximumSizeHigh, uint dwMaximumSizeLow, win32.System.SystemServices.PCWSTR lpName);
        /// <inheritdoc cref = "OpenFileMapping(uint, bool, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle OpenFileMapping(uint dwDesiredAccess, bool bInheritHandle, string lpName)
        {
            fixed (char *lpNameLocal = lpName)
            {
                win32.System.SystemServices.HANDLE __result = Kernel32.OpenFileMapping(dwDesiredAccess, bInheritHandle, lpNameLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Opens a named file mapping object.</summary>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the file mapping object. This access is checked against any security descriptor on the target file mapping object. For a list of values, see <a href = "https://docs.microsoft.com/windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-openfilemappingw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bInheritHandle">
        /// <para>If this parameter is <b>TRUE</b>, a process created by the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> function can inherit the handle; otherwise, the handle cannot be inherited.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-openfilemappingw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>The name of the file mapping object to be opened. If there is an open handle to a file mapping object by this name and the security descriptor on the mapping object does not conflict with the <i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-openfilemappingw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-openfilemappingw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "OpenFileMappingW", SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE OpenFileMapping(uint dwDesiredAccess, bool bInheritHandle, win32.System.SystemServices.PCWSTR lpName);
        /// <inheritdoc cref = "MapViewOfFile(win32.System.SystemServices.HANDLE, win32.System.SystemServices.FILE_MAP, uint, uint, nuint)"/>
        internal static unsafe void *MapViewOfFile(SafeHandle hFileMappingObject, win32.System.SystemServices.FILE_MAP dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, nuint dwNumberOfBytesToMap)
        {
            bool hFileMappingObjectAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileMappingObjectLocal;
                if (hFileMappingObject is object)
                {
                    hFileMappingObject.DangerousAddRef(ref hFileMappingObjectAddRef);
                    hFileMappingObjectLocal = (win32.System.SystemServices.HANDLE)hFileMappingObject.DangerousGetHandle();
                }
                else
                    hFileMappingObjectLocal = default(win32.System.SystemServices.HANDLE);
                void *__result = Kernel32.MapViewOfFile(hFileMappingObjectLocal, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);
                return __result;
            }
            finally
            {
                if (hFileMappingObjectAddRef)
                    hFileMappingObject.DangerousRelease();
            }
        }

        /// <summary>Maps a view of a file mapping into the address space of a calling process.</summary>
        /// <param name = "hFileMappingObject">
        /// <para>A handle to a file mapping object. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openfilemappinga">OpenFileMapping</a> functions return this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">The type of access to a file mapping object, which determines the page protection of the pages. This</param>
        /// <param name = "dwFileOffsetHigh">A high-order <b>DWORD</b> of the file offset where the view begins.</param>
        /// <param name = "dwFileOffsetLow">
        /// <para>A low-order <b>DWORD</b> of the file offset where the view is to begin. The combination of the high and low offsets must specify an offset within the file mapping. They must also match the  memory allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To obtain the memory allocation granularity of the system, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function, which fills in the members of a <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/ns-sysinfoapi-system_info">SYSTEM_INFO</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwNumberOfBytesToMap">
        /// <para>The number of bytes of a file mapping to map to the view. All bytes must be within the maximum size specified by <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping</a>. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the file mapping.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *MapViewOfFile(win32.System.SystemServices.HANDLE hFileMappingObject, win32.System.SystemServices.FILE_MAP dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, nuint dwNumberOfBytesToMap);
        /// <inheritdoc cref = "MapViewOfFileEx(win32.System.SystemServices.HANDLE, win32.System.SystemServices.FILE_MAP, uint, uint, nuint, void *)"/>
        internal static unsafe void *MapViewOfFileEx(SafeHandle hFileMappingObject, win32.System.SystemServices.FILE_MAP dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, nuint dwNumberOfBytesToMap, void *lpBaseAddress)
        {
            bool hFileMappingObjectAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileMappingObjectLocal;
                if (hFileMappingObject is object)
                {
                    hFileMappingObject.DangerousAddRef(ref hFileMappingObjectAddRef);
                    hFileMappingObjectLocal = (win32.System.SystemServices.HANDLE)hFileMappingObject.DangerousGetHandle();
                }
                else
                    hFileMappingObjectLocal = default(win32.System.SystemServices.HANDLE);
                void *__result = Kernel32.MapViewOfFileEx(hFileMappingObjectLocal, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress);
                return __result;
            }
            finally
            {
                if (hFileMappingObjectAddRef)
                    hFileMappingObject.DangerousRelease();
            }
        }

        /// <summary>Maps a view of a file mapping into the address space of a calling process. A caller can optionally specify a suggested base memory address for the view.</summary>
        /// <param name = "hFileMappingObject">
        /// <para>A handle to a file mapping object. The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openfilemappinga">OpenFileMapping</a> functions return this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">The type of access to a file mapping object, which determines the page protection of the pages. This</param>
        /// <param name = "dwFileOffsetHigh">The high-order <b>DWORD</b> of the file offset where the view is to begin.</param>
        /// <param name = "dwFileOffsetLow">
        /// <para>The low-order <b>DWORD</b> of the file offset where the view is to begin. The combination of the high and low offsets must specify an offset within the file mapping. They must also match the memory allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To obtain the memory allocation granularity of the system, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function, which fills in the members of a <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/ns-sysinfoapi-system_info">SYSTEM_INFO</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwNumberOfBytesToMap">
        /// <para>The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size specified by <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping</a>. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the file mapping.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBaseAddress">
        /// <para>A pointer to the memory address in the calling process address space where mapping begins. This must be a multiple of the system's memory allocation granularity, or the function fails. To determine the memory allocation granularity of the system, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function. If there is not enough address space at the specified address, the function fails.</para>
        /// <para>If <i>lpBaseAddress</i> is <b>NULL</b>, the operating system chooses the mapping address. In this scenario, the function is equivalent to the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile</a> function.</para>
        /// <para>While it is possible to specify an address that is safe now (not used by the operating system), there is no guarantee that the address will remain safe over time. Therefore, it is better to let the operating system choose the address. In this case, you would not store pointers in the memory mapped file, you would store offsets from the base of the file mapping so that the mapping can be used at any address.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffileex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *MapViewOfFileEx(win32.System.SystemServices.HANDLE hFileMappingObject, win32.System.SystemServices.FILE_MAP dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, nuint dwNumberOfBytesToMap, [Optional] void *lpBaseAddress);
        /// <inheritdoc cref = "VirtualFreeEx(win32.System.SystemServices.HANDLE, void *, nuint, win32.System.Memory.VIRTUAL_FREE_TYPE)"/>
        internal static unsafe bool VirtualFreeEx(SafeHandle hProcess, void *lpAddress, nuint dwSize, win32.System.Memory.VIRTUAL_FREE_TYPE dwFreeType)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.VirtualFreeEx(hProcessLocal, lpAddress, dwSize, dwFreeType);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to a process. The function frees memory within the virtual address space of the process.</para>
        /// <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualfreeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpAddress">
        /// <para>A pointer to the starting address of the region of memory to be freed.</para>
        /// <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, <i>lpAddress</i> must be the base address returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a> function when the region is reserved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualfreeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSize">
        /// <para>The size of the region of memory to free, in bytes.</para>
        /// <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, <i>dwSize</i> must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a>.</para>
        /// <para>If <i>dwFreeType</i> is <b>MEM_DECOMMIT</b>, the function decommits all memory pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to <c>(lpAddress+dwSize)</c>. This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If <i>lpAddress</i> is the base address returned by <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a> and <i>dwSize</i> is 0 (zero), the function decommits the entire region that is allocated by <b>VirtualAllocEx</b>. After that, the entire region is in the reserved state.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualfreeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFreeType"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualfreeex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool VirtualFreeEx(win32.System.SystemServices.HANDLE hProcess, void *lpAddress, nuint dwSize, win32.System.Memory.VIRTUAL_FREE_TYPE dwFreeType);
        /// <summary>Writes to the disk a byte range within a mapped view of a file.</summary>
        /// <param name = "lpBaseAddress">A pointer to the base address of the byte range to be flushed to the disk representation of the mapped file.</param>
        /// <param name = "dwNumberOfBytesToFlush">The number of bytes to be flushed. If <i>dwNumberOfBytesToFlush</i> is zero, the file is flushed from the base address to the end of the mapping.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-flushviewoffile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool FlushViewOfFile(void *lpBaseAddress, nuint dwNumberOfBytesToFlush);
        /// <summary>Unmaps a mapped view of a file from the calling process's address space.</summary>
        /// <param name = "lpBaseAddress">
        /// <para>A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be identical to the value returned by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffileex">MapViewOfFileEx</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-unmapviewoffile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-unmapviewoffile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool UnmapViewOfFile(void *lpBaseAddress);
        /// <summary>Retrieves the minimum size of a large page.</summary>
        /// <returns>
        /// <para>If the processor supports large pages, the return value is the minimum size of a large page.</para>
        /// <para>If the processor does not support large pages, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getlargepageminimum">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern nuint GetLargePageMinimum();
        /// <inheritdoc cref = "GetProcessWorkingSetSizeEx(win32.System.SystemServices.HANDLE, nuint*, nuint*, uint *)"/>
        internal static unsafe bool GetProcessWorkingSetSizeEx(SafeHandle hProcess, out nuint lpMinimumWorkingSetSize, out nuint lpMaximumWorkingSetSize, out uint Flags)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *FlagsLocal = &Flags)
                {
                    fixed (nuint*lpMaximumWorkingSetSizeLocal = &lpMaximumWorkingSetSize)
                    {
                        fixed (nuint*lpMinimumWorkingSetSizeLocal = &lpMinimumWorkingSetSize)
                        {
                            win32.System.SystemServices.HANDLE hProcessLocal;
                            if (hProcess is object)
                            {
                                hProcess.DangerousAddRef(ref hProcessAddRef);
                                hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                            }
                            else
                                hProcessLocal = default(win32.System.SystemServices.HANDLE);
                            bool __result = Kernel32.GetProcessWorkingSetSizeEx(hProcessLocal, lpMinimumWorkingSetSizeLocal, lpMaximumWorkingSetSizeLocal, FlagsLocal);
                            return __result;
                        }
                    }
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the minimum and maximum working set sizes of the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process whose working set sizes will be obtained. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><b>Windows Server 2003:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getprocessworkingsetsizeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMinimumWorkingSetSize">A pointer to a variable that receives the minimum working set size of the specified process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</param>
        /// <param name = "lpMaximumWorkingSetSize">A pointer to a variable that receives the maximum working set size of the specified process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active when memory is in short supply.</param>
        /// <param name = "Flags">
        /// <para>The flags that control the enforcement of the minimum and maximum working set sizes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getprocessworkingsetsizeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <remarks>
        /// <para>The "working set" of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault. The minimum and maximum working set sizes affect the virtual memory paging behavior of a process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getprocessworkingsetsizeex#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetProcessWorkingSetSizeEx(win32.System.SystemServices.HANDLE hProcess, nuint*lpMinimumWorkingSetSize, nuint*lpMaximumWorkingSetSize, uint *Flags);
        /// <inheritdoc cref = "SetProcessWorkingSetSizeEx(win32.System.SystemServices.HANDLE, nuint, nuint, uint)"/>
        internal static unsafe bool SetProcessWorkingSetSizeEx(SafeHandle hProcess, nuint dwMinimumWorkingSetSize, nuint dwMaximumWorkingSetSize, uint Flags)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetProcessWorkingSetSizeEx(hProcessLocal, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize, Flags);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Sets the minimum and maximum working set sizes for the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to the process whose working set sizes is to be set.</para>
        /// <para>The handle must have <b>PROCESS_SET_QUOTA</b> access rights. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-setprocessworkingsetsizeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMinimumWorkingSetSize">
        /// <para>The minimum working set size for the process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</para>
        /// <para>This parameter must be greater than zero but less than or equal to the maximum working set size. The default size is 50 pages (for example, this is 204,800 bytes on systems with a 4K page size). If the value is greater than zero but less than 20 pages, the minimum value is set to 20 pages.</para>
        /// <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-setprocessworkingsetsizeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMaximumWorkingSetSize">
        /// <para>The maximum working set size for the process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active and available memory is low.</para>
        /// <para>This parameter must be greater than or equal to 13 pages (for example, 53,248 on systems with a 4K page size), and less than the system-wide maximum (number of available pages minus 512 pages). The default size is 345 pages (for example, this is 1,413,120 bytes on systems with a 4K page size).</para>
        /// <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process. For details, see Remarks.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-setprocessworkingsetsizeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags">
        /// <para>The flags that control the enforcement of the minimum and maximum working set sizes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-setprocessworkingsetsizeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function is succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the function fails, the return value is zero. To get extended error information, call <b>GetLastError</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-setprocessworkingsetsizeex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetProcessWorkingSetSizeEx(win32.System.SystemServices.HANDLE hProcess, nuint dwMinimumWorkingSetSize, nuint dwMaximumWorkingSetSize, uint Flags);
        /// <summary>Locks the specified region of the process's virtual address space into physical memory, ensuring that subsequent access to the region will not incur a page fault.</summary>
        /// <param name = "lpAddress">A pointer to the base address of the region of pages to be locked.</param>
        /// <param name = "dwSize">The size of the region to be locked, in bytes. The region of affected pages includes all pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to <c>(lpAddress+dwSize)</c>. This means that a 2-byte range straddling a page boundary causes both pages to be locked.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtuallock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool VirtualLock(void *lpAddress, nuint dwSize);
        /// <summary>Unlocks a specified range of pages in the virtual address space of a process, enabling the system to swap the pages out to the paging file if necessary.</summary>
        /// <param name = "lpAddress">A pointer to the base address of the region of pages to be unlocked.</param>
        /// <param name = "dwSize">The size of the region being unlocked, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the <i>lpAddress</i> parameter to <c>(lpAddress+dwSize)</c>. This means that a 2-byte range straddling a page boundary causes both pages to be unlocked.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualunlock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool VirtualUnlock(void *lpAddress, nuint dwSize);
        /// <summary>Retrieves the addresses of the pages that are written to in a region of virtual memory.</summary>
        /// <param name = "dwFlags">
        /// <para>Indicates whether the function resets the write-tracking state.</para>
        /// <para>To reset the write-tracking state, set this parameter to <b>WRITE_WATCH_FLAG_RESET</b>. If this parameter is 0 (zero), <b>GetWriteWatch</b> does not reset the write-tracking state. For more information, see the Remarks section of this topic.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getwritewatch#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBaseAddress">
        /// <para>The base address of the memory region for which to retrieve write-tracking information.</para>
        /// <para>This address must be in a memory region that is allocated by the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> function using <b>MEM_WRITE_WATCH</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getwritewatch#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwRegionSize">The size of the memory region for which to retrieve write-tracking information, in bytes.</param>
        /// <param name = "lpAddresses">
        /// <para>A pointer to a buffer that receives an array of page addresses in the memory region.</para>
        /// <para>The addresses indicate the pages that have been written to since the region has been allocated or the write-tracking state has been reset.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getwritewatch#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpdwCount">
        /// <para>On input, this variable indicates the size of the <i>lpAddresses</i> array, in array elements.</para>
        /// <para>On output, the variable receives the number of page addresses that are returned in the array.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getwritewatch#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpdwGranularity">A pointer to a variable that receives the page size, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is 0 (zero).</para>
        /// <para>If the function fails, the return value is a nonzero value.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getwritewatch">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint GetWriteWatch(uint dwFlags, void *lpBaseAddress, nuint dwRegionSize, [Optional] void **lpAddresses, [Optional] nuint*lpdwCount, [Optional] uint *lpdwGranularity);
        /// <summary>Resets the write-tracking state for a region of virtual memory. Subsequent calls to the GetWriteWatch function only report pages that are written to since the reset operation.</summary>
        /// <param name = "lpBaseAddress">
        /// <para>A pointer to the base address of the memory region for which to reset the write-tracking state.</para>
        /// <para>This address must be in a memory region that is allocated by the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> function with <b>MEM_WRITE_WATCH</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-resetwritewatch#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwRegionSize">The size of the memory region for which to reset the write-tracking information, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is 0 (zero).</para>
        /// <para>If the function fails, the return value is a nonzero value.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-resetwritewatch">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint ResetWriteWatch(void *lpBaseAddress, nuint dwRegionSize);
        /// <inheritdoc cref = "CreateMemoryResourceNotification(win32.System.Memory.MEMORY_RESOURCE_NOTIFICATION_TYPE)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateMemoryResourceNotification_SafeHandle(win32.System.Memory.MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
        {
            win32.System.SystemServices.HANDLE __result = Kernel32.CreateMemoryResourceNotification(NotificationType);
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        /// <summary>Creates a memory resource notification object.</summary>
        /// <param name = "NotificationType">
        /// <para>The memory condition under which the object is to be signaled. This parameter can be one of the following values from the <b>MEMORY_RESOURCE_NOTIFICATION_TYPE</b> enumeration.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-creatememoryresourcenotification#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to a memory resource notification object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended  information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-creatememoryresourcenotification">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE CreateMemoryResourceNotification(win32.System.Memory.MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType);
        /// <inheritdoc cref = "QueryMemoryResourceNotification(win32.System.SystemServices.HANDLE, bool *)"/>
        internal static unsafe bool QueryMemoryResourceNotification(SafeHandle ResourceNotificationHandle, out bool ResourceState)
        {
            bool ResourceNotificationHandleAddRef = false;
            try
            {
                fixed (bool *ResourceStateLocal = &ResourceState)
                {
                    win32.System.SystemServices.HANDLE ResourceNotificationHandleLocal;
                    if (ResourceNotificationHandle is object)
                    {
                        ResourceNotificationHandle.DangerousAddRef(ref ResourceNotificationHandleAddRef);
                        ResourceNotificationHandleLocal = (win32.System.SystemServices.HANDLE)ResourceNotificationHandle.DangerousGetHandle();
                    }
                    else
                        ResourceNotificationHandleLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.QueryMemoryResourceNotification(ResourceNotificationHandleLocal, ResourceStateLocal);
                    return __result;
                }
            }
            finally
            {
                if (ResourceNotificationHandleAddRef)
                    ResourceNotificationHandle.DangerousRelease();
            }
        }

        /// <summary>Retrieves the state of the specified memory resource object.</summary>
        /// <param name = "ResourceNotificationHandle">
        /// <para>A handle to a memory resource notification object. The <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-creatememoryresourcenotification">CreateMemoryResourceNotification</a> function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-querymemoryresourcenotification#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ResourceState">The memory pointed to by this parameter receives the state of the memory resource notification object. The value of this parameter is set to <b>TRUE</b> if the specified memory condition exists, and  <b>FALSE</b> if the specified memory condition does not exist.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. For more error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-querymemoryresourcenotification">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool QueryMemoryResourceNotification(win32.System.SystemServices.HANDLE ResourceNotificationHandle, bool *ResourceState);
        /// <inheritdoc cref = "GetSystemFileCacheSize(nuint*, nuint*, uint *)"/>
        internal static unsafe bool GetSystemFileCacheSize(out nuint lpMinimumFileCacheSize, out nuint lpMaximumFileCacheSize, out uint lpFlags)
        {
            fixed (uint *lpFlagsLocal = &lpFlags)
            {
                fixed (nuint*lpMaximumFileCacheSizeLocal = &lpMaximumFileCacheSize)
                {
                    fixed (nuint*lpMinimumFileCacheSizeLocal = &lpMinimumFileCacheSize)
                    {
                        bool __result = Kernel32.GetSystemFileCacheSize(lpMinimumFileCacheSizeLocal, lpMaximumFileCacheSizeLocal, lpFlagsLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Retrieves the current size limits for the working set of the system cache.</summary>
        /// <param name = "lpMinimumFileCacheSize">A pointer to a variable that receives the minimum size of the file cache, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the system file cache, if there is a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-setsystemfilecachesize">SetSystemFileCacheSize</a> function with the <b>FILE_CACHE_MIN_HARD_ENABLE</b> flag.</param>
        /// <param name = "lpMaximumFileCacheSize">A pointer to a variable that receives the maximum size of the file cache, in bytes. The virtual memory manager enforces this limit only if there is a previous call to <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-setsystemfilecachesize">SetSystemFileCacheSize</a> with the <b>FILE_CACHE_MAX_HARD_ENABLE</b> flag.</param>
        /// <param name = "lpFlags">
        /// <para>The flags that indicate which of the file cache limits are enabled.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getsystemfilecachesize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getsystemfilecachesize">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetSystemFileCacheSize(nuint*lpMinimumFileCacheSize, nuint*lpMaximumFileCacheSize, uint *lpFlags);
        /// <summary>Limits the size of the working set for the file system cache.</summary>
        /// <param name = "MinimumFileCacheSize">
        /// <para>The minimum size of the file cache, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the system file cache.</para>
        /// <para>To flush the cache, specify <c>(SIZE_T) -1</c>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-setsystemfilecachesize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "MaximumFileCacheSize">
        /// <para>The maximum size of the file cache, in bytes. The virtual memory manager enforces this limit only if this call or a previous call to <b>SetSystemFileCacheSize</b> specifies <b>FILE_CACHE_MAX_HARD_ENABLE</b>.</para>
        /// <para>To flush the cache, specify <c>(SIZE_T) -1</c>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-setsystemfilecachesize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags">
        /// <para>The flags that enable or disable the file cache limits. If this parameter is 0 (zero), the size limits retain the current setting, which is either disabled or enabled.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-setsystemfilecachesize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-setsystemfilecachesize">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetSystemFileCacheSize(nuint MinimumFileCacheSize, nuint MaximumFileCacheSize, uint Flags);
        /// <inheritdoc cref = "CreateFileMappingNuma(win32.System.SystemServices.HANDLE, win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.System.SystemServices.PAGE_TYPE, uint, uint, win32.System.SystemServices.PCWSTR, uint)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateFileMappingNuma(SafeHandle hFile, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpFileMappingAttributes, win32.System.SystemServices.PAGE_TYPE flProtect, uint dwMaximumSizeHigh, uint dwMaximumSizeLow, string lpName, uint nndPreferred)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (char *lpNameLocal = lpName)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.SECURITY_ATTRIBUTES lpFileMappingAttributesLocal = lpFileMappingAttributes.HasValue ? lpFileMappingAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                    win32.System.SystemServices.HANDLE __result = Kernel32.CreateFileMappingNuma(hFileLocal, lpFileMappingAttributes.HasValue ? &lpFileMappingAttributesLocal : null, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpNameLocal, nndPreferred);
                    return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Creates or opens a named or unnamed file mapping object for a specified file and specifies the NUMA node for the physical memory.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file from which to create a file mapping object.</para>
        /// <para>The file must be opened with access rights that are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and <i>dwMaximumSizeLow</i> parameters. In this scenario, <b>CreateFileMappingNuma</b> creates a file mapping object of a specified size  that is backed by the system paging file instead of by a file in the file system.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingnumaw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileMappingAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether a returned handle can be inherited by child processes. The <b>lpSecurityDescriptor</b> member of the <b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
        /// <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingnumaw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flProtect">
        /// <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingnumaw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
        /// <param name = "dwMaximumSizeLow">
        /// <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
        /// <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that the <i>hFile</i> parameter identifies.</para>
        /// <para>An attempt to map a file with a length of 0 (zero) fails with an error code of <b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingnumaw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>The name of the file mapping object.</para>
        /// <para>If this parameter matches the name of an existing file mapping object, the function requests access to the object with the protection that the <i>flProtect</i> parameter specifies.</para>
        /// <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
        /// <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
        /// <para>The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). Creating a file mapping object in the global namespace requires the <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
        /// <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines so that applications can support multiple users.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingnumaw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nndPreferred">
        /// <para>The NUMA node where the physical memory should reside.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingnumaw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
        /// <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size) and the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingnumaw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateFileMappingNumaW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateFileMappingNuma(win32.System.SystemServices.HANDLE hFile, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpFileMappingAttributes, win32.System.SystemServices.PAGE_TYPE flProtect, uint dwMaximumSizeHigh, uint dwMaximumSizeLow, win32.System.SystemServices.PCWSTR lpName, uint nndPreferred);
        /// <inheritdoc cref = "PrefetchVirtualMemory(win32.System.SystemServices.HANDLE, nuint, win32.System.Memory.WIN32_MEMORY_RANGE_ENTRY*, uint)"/>
        internal static unsafe bool PrefetchVirtualMemory(SafeHandle hProcess, Span<win32.System.Memory.WIN32_MEMORY_RANGE_ENTRY> VirtualAddresses, uint Flags)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (win32.System.Memory.WIN32_MEMORY_RANGE_ENTRY*VirtualAddressesLocal = VirtualAddresses)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.PrefetchVirtualMemory(hProcessLocal, (nuint)VirtualAddresses.Length, VirtualAddressesLocal, Flags);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Provides an efficient mechanism to bring into memory potentially discontiguous virtual address ranges in a process address space.</summary>
        /// <param name = "hProcess">
        /// <para>Handle to the process whose virtual address ranges are to be prefetched. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess">GetCurrentProcess</a> function to use the current process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-prefetchvirtualmemory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "NumberOfEntries">
        /// <para>Number of entries in the array pointed to by the <i>VirtualAddresses</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-prefetchvirtualmemory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "VirtualAddresses">
        /// <para>Pointer to an array of <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/ns-memoryapi-win32_memory_range_entry">WIN32_MEMORY_RANGE_ENTRY</a> structures which each specify a virtual address range to be prefetched. The virtual address ranges may cover any part of the process address space accessible by the target process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-prefetchvirtualmemory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Flags">Reserved. Must be 0.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-prefetchvirtualmemory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool PrefetchVirtualMemory(win32.System.SystemServices.HANDLE hProcess, nuint NumberOfEntries, win32.System.Memory.WIN32_MEMORY_RANGE_ENTRY*VirtualAddresses, uint Flags);
        /// <inheritdoc cref = "CreateFileMappingFromApp(win32.System.SystemServices.HANDLE, win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.System.SystemServices.PAGE_TYPE, ulong, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateFileMappingFromApp(SafeHandle hFile, win32.System.SystemServices.SECURITY_ATTRIBUTES? SecurityAttributes, win32.System.SystemServices.PAGE_TYPE PageProtection, ulong MaximumSize, string Name)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (char *NameLocal = Name)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.SECURITY_ATTRIBUTES SecurityAttributesLocal = SecurityAttributes.HasValue ? SecurityAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                    win32.System.SystemServices.HANDLE __result = Kernel32.CreateFileMappingFromApp(hFileLocal, SecurityAttributes.HasValue ? &SecurityAttributesLocal : null, PageProtection, MaximumSize, NameLocal);
                    return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Creates or opens a named or unnamed file mapping object for a specified file from a Windows Store app.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file from which to create a file mapping object.</para>
        /// <para>The file must be opened with access rights that are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and <i>dwMaximumSizeLow</i> parameters. In this scenario, <b>CreateFileMappingFromApp</b> creates a file mapping object of a specified size  that is backed by the system paging file instead of by a file in the file system.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingfromapp#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "SecurityAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether a returned handle can be inherited by child processes. The <b>lpSecurityDescriptor</b> member of the <b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
        /// <para>If <i>SecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingfromapp#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "PageProtection">
        /// <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingfromapp#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "MaximumSize">
        /// <para>The maximum size of the file mapping object.</para>
        /// <para>An attempt to map a file with a length of 0 (zero) fails with an error code of <b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingfromapp#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Name">
        /// <para>The name of the file mapping object.</para>
        /// <para>If this parameter matches the name of an existing mapping object, the function requests access to the object with the protection that <i>flProtect</i> specifies.</para>
        /// <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
        /// <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails, and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
        /// <para>The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). Creating a file mapping object in the global namespace from a session other than session zero requires the <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
        /// <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingfromapp#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
        /// <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-createfilemappingfromapp">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateFileMappingFromApp(win32.System.SystemServices.HANDLE hFile, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*SecurityAttributes, win32.System.SystemServices.PAGE_TYPE PageProtection, ulong MaximumSize, win32.System.SystemServices.PCWSTR Name);
        /// <inheritdoc cref = "MapViewOfFileFromApp(win32.System.SystemServices.HANDLE, win32.System.SystemServices.FILE_MAP, ulong, nuint)"/>
        internal static unsafe void *MapViewOfFileFromApp(SafeHandle hFileMappingObject, win32.System.SystemServices.FILE_MAP DesiredAccess, ulong FileOffset, nuint NumberOfBytesToMap)
        {
            bool hFileMappingObjectAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileMappingObjectLocal;
                if (hFileMappingObject is object)
                {
                    hFileMappingObject.DangerousAddRef(ref hFileMappingObjectAddRef);
                    hFileMappingObjectLocal = (win32.System.SystemServices.HANDLE)hFileMappingObject.DangerousGetHandle();
                }
                else
                    hFileMappingObjectLocal = default(win32.System.SystemServices.HANDLE);
                void *__result = Kernel32.MapViewOfFileFromApp(hFileMappingObjectLocal, DesiredAccess, FileOffset, NumberOfBytesToMap);
                return __result;
            }
            finally
            {
                if (hFileMappingObjectAddRef)
                    hFileMappingObject.DangerousRelease();
            }
        }

        /// <summary>Maps a view of a file mapping into the address space of a calling Windows Store app.</summary>
        /// <param name = "hFileMappingObject">
        /// <para>A handle to a file mapping object. The <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-createfilemappingfromapp">CreateFileMappingFromApp</a>  function returns this handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffilefromapp#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "DesiredAccess">The type of access to a file mapping object, which determines the page protection of the pages. This</param>
        /// <param name = "FileOffset">
        /// <para>The file offset where the view is to begin. The offset must specify an offset within the file mapping. They must also match the  memory allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To obtain the memory allocation granularity of the system, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function, which fills in the members of a <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/ns-sysinfoapi-system_info">SYSTEM_INFO</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffilefromapp#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "NumberOfBytesToMap">
        /// <para>The number of bytes of a file mapping to map to the view. All bytes must be within the maximum size specified by <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-createfilemappingfromapp">CreateFileMappingFromApp</a>. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the file mapping.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffilefromapp#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapviewoffilefromapp">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *MapViewOfFileFromApp(win32.System.SystemServices.HANDLE hFileMappingObject, win32.System.SystemServices.FILE_MAP DesiredAccess, ulong FileOffset, nuint NumberOfBytesToMap);
        /// <summary>This is an extended version of UnmapViewOfFile that takes an additional flags parameter.</summary>
        /// <param name = "BaseAddress">
        /// <para>A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be identical to the value returned by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffileex">MapViewOfFileEx</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-unmapviewoffileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "UnmapFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-unmapviewoffileex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool UnmapViewOfFileEx(void *BaseAddress, win32.System.Memory.UNMAP_VIEW_OF_FILE_FLAGS UnmapFlags);
        /// <inheritdoc cref = "AllocateUserPhysicalPages(win32.System.SystemServices.HANDLE, nuint*, nuint*)"/>
        internal static unsafe bool AllocateUserPhysicalPages(SafeHandle hProcess, ref nuint NumberOfPages, nuint*PageArray)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (nuint*NumberOfPagesLocal = &NumberOfPages)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.AllocateUserPhysicalPages(hProcessLocal, NumberOfPagesLocal, PageArray);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Allocates physical memory pages to be mapped and unmapped within any Address Windowing Extensions (AWE) region of a specified process.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to a process.</para>
        /// <para>The function allocates memory that can later be mapped within the virtual address space of this process. The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-allocateuserphysicalpages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "NumberOfPages">
        /// <para>The size of the physical memory to allocate, in pages.</para>
        /// <para>To determine the page size of the computer, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function. On output, this parameter receives the number of pages that are actually allocated, which might be less than the number requested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-allocateuserphysicalpages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "PageArray">
        /// <para>A pointer to an array to store the page frame numbers of the allocated memory. The size of the array that is allocated should be at least the <i>NumberOfPages</i> times the size of the <b>ULONG_PTR</b> data type.</para>
        /// <para>Do not attempt to modify this buffer. It contains operating system data, and corruption could be catastrophic. The information in the buffer is not useful to an application.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-allocateuserphysicalpages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is <b>TRUE</b>. Fewer pages than requested can be allocated. The caller must check the value of the <i>NumberOfPages</i> parameter on return to see how many pages are allocated. All allocated page frame numbers are sequentially placed in the memory pointed to by the <i>UserPfnArray</i> parameter.</para>
        /// <para>If the function fails, the return value is <b>FALSE</b>, and no frames are allocated. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-allocateuserphysicalpages">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool AllocateUserPhysicalPages(win32.System.SystemServices.HANDLE hProcess, nuint*NumberOfPages, nuint*PageArray);
        /// <inheritdoc cref = "FreeUserPhysicalPages(win32.System.SystemServices.HANDLE, nuint*, nuint*)"/>
        internal static unsafe bool FreeUserPhysicalPages(SafeHandle hProcess, ref nuint NumberOfPages, nuint*PageArray)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (nuint*NumberOfPagesLocal = &NumberOfPages)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.FreeUserPhysicalPages(hProcessLocal, NumberOfPagesLocal, PageArray);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Frees physical memory pages that are allocated previously by using AllocateUserPhysicalPages or AllocateUserPhysicalPagesNuma.</summary>
        /// <param name = "hProcess">
        /// <para>The handle to a process.</para>
        /// <para>The function frees memory within the virtual address space of this process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-freeuserphysicalpages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "NumberOfPages">
        /// <para>The size of the physical memory to free, in pages.</para>
        /// <para>On return, if the function fails, this parameter indicates the number of pages that are freed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-freeuserphysicalpages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "PageArray">A pointer to an array of page frame numbers of the allocated memory to be freed.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
        /// <para>If the function fails, the return value is <b>FALSE</b>. In this case, the <i>NumberOfPages</i> parameter reflect how many pages have actually been released. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-freeuserphysicalpages">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool FreeUserPhysicalPages(win32.System.SystemServices.HANDLE hProcess, nuint*NumberOfPages, nuint*PageArray);
        /// <inheritdoc cref = "MapUserPhysicalPages(void *, nuint, nuint*)"/>
        internal static unsafe bool MapUserPhysicalPages(void *VirtualAddress, Span<nuint> PageArray)
        {
            fixed (nuint*PageArrayLocal = PageArray)
            {
                bool __result = Kernel32.MapUserPhysicalPages(VirtualAddress, (nuint)PageArray.Length, PageArrayLocal);
                return __result;
            }
        }

        /// <summary>Maps previously allocated physical memory pages at a specified address in an Address Windowing Extensions (AWE) region.</summary>
        /// <param name = "VirtualAddress">
        /// <para>A pointer to the starting address of the region of memory to remap.</para>
        /// <para>The value of <i>lpAddress</i> must be within the address range that the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> function returns when the <a href = "https://docs.microsoft.com/windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region is allocated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapuserphysicalpages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "NumberOfPages">
        /// <para>The size of the physical memory and virtual address space for which to establish translations, in pages.</para>
        /// <para>The virtual address range is contiguous starting at <i>lpAddress</i>. The physical frames are specified by the <i>UserPfnArray</i>.</para>
        /// <para>The total number of pages cannot extend from the starting address beyond the end of the range that is specified in <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-allocateuserphysicalpages">AllocateUserPhysicalPages</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapuserphysicalpages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "PageArray">
        /// <para>A pointer to an array of physical page frame numbers. These frames are mapped by the argument <i>lpAddress</i> on return from this function. The size of the memory that is allocated should be at least the <i>NumberOfPages</i> times the size of the data type <b>ULONG_PTR</b>.</para>
        /// <para>Do not attempt to modify this buffer. It contains operating system data, and corruption could be catastrophic. The information in the buffer is not useful to an application. If this parameter is <b>NULL</b>, the specified address range is unmapped.  Also, the specified physical pages are not freed, and you must call <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-freeuserphysicalpages">FreeUserPhysicalPages</a> to free them.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapuserphysicalpages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
        /// <para>If the function fails, the return value is <b>FALSE</b> and no mapping is done—partial or otherwise. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-mapuserphysicalpages">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool MapUserPhysicalPages(void *VirtualAddress, nuint NumberOfPages, [Optional] nuint*PageArray);
        /// <inheritdoc cref = "AllocateUserPhysicalPagesNuma(win32.System.SystemServices.HANDLE, nuint*, nuint*, uint)"/>
        internal static unsafe bool AllocateUserPhysicalPagesNuma(SafeHandle hProcess, ref nuint NumberOfPages, nuint*PageArray, uint nndPreferred)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (nuint*NumberOfPagesLocal = &NumberOfPages)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.AllocateUserPhysicalPagesNuma(hProcessLocal, NumberOfPagesLocal, PageArray, nndPreferred);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Allocates physical memory pages to be mapped and unmapped within any Address Windowing Extensions (AWE) region of a specified process and specifies the NUMA node for the physical memory.</summary>
        /// <param name = "hProcess">
        /// <para>A handle to a process.</para>
        /// <para>The function allocates memory that can later be mapped within the virtual address space of this process. The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-allocateuserphysicalpagesnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "NumberOfPages">
        /// <para>The size of the physical memory to allocate, in pages.</para>
        /// <para>To determine the page size of the computer, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function. On output, this parameter receives the number of pages that are actually allocated, which might be less than the number requested.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-allocateuserphysicalpagesnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "PageArray">
        /// <para>A pointer to an array to store the page frame numbers of the allocated memory.</para>
        /// <para>The size of the array that is allocated should be at least the <i>NumberOfPages</i> times the size of the <b>ULONG_PTR</b> data type.</para>
        /// <para><div class = "alert"><b>Caution</b>  Do not attempt to modify this buffer. It contains operating system data, and corruption could be catastrophic. The information in the buffer is not useful to an application.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-allocateuserphysicalpagesnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nndPreferred">The NUMA node where the physical memory should reside.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
        /// <para>Fewer pages than requested can be allocated. The caller must check the value of the <i>NumberOfPages</i> parameter on return to see how many pages are allocated. All allocated page frame numbers are sequentially placed in the memory pointed to by the <i>PageArray</i> parameter.</para>
        /// <para>If the function fails, the return value is <b>FALSE</b> and no frames are allocated. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-allocateuserphysicalpagesnuma">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool AllocateUserPhysicalPagesNuma(win32.System.SystemServices.HANDLE hProcess, nuint*NumberOfPages, nuint*PageArray, uint nndPreferred);
        /// <inheritdoc cref = "VirtualAllocExNuma(win32.System.SystemServices.HANDLE, void *, nuint, win32.System.Memory.VIRTUAL_ALLOCATION_TYPE, uint, uint)"/>
        internal static unsafe void *VirtualAllocExNuma(SafeHandle hProcess, void *lpAddress, nuint dwSize, win32.System.Memory.VIRTUAL_ALLOCATION_TYPE flAllocationType, uint flProtect, uint nndPreferred)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                void *__result = Kernel32.VirtualAllocExNuma(hProcessLocal, lpAddress, dwSize, flAllocationType, flProtect, nndPreferred);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Reserves, commits, or changes the state of a region of memory within the virtual address space of the specified process, and specifies the NUMA node for the physical memory.</summary>
        /// <param name = "hProcess">
        /// <para>The handle to a process. The function allocates memory within the virtual address space of this process.</para>
        /// <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualallocexnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpAddress">
        /// <para>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</para>
        /// <para>If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity.</para>
        /// <para>If you are committing memory that is already reserved, the function rounds this address down to the nearest page boundary. To determine the size of a page and the allocation granularity on the host computer, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function.</para>
        /// <para>If <i>lpAddress</i> is <b>NULL</b>, the function determines where to allocate the region.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualallocexnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwSize">
        /// <para>The size of the region of memory to be allocated, in bytes.</para>
        /// <para>If <i>lpAddress</i> is <b>NULL</b>, the function rounds <i>dwSize</i> up to the next page boundary.</para>
        /// <para>If <i>lpAddress</i> is not <b>NULL</b>, the function allocates all pages that contain one or more bytes in the range from <i>lpAddress</i> to <c>(lpAddress+dwSize)</c>. This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualallocexnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flAllocationType"></param>
        /// <param name = "flProtect">
        /// <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the <a href = "https://docs.microsoft.com/windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
        /// <para>Protection attributes specified when protecting a page cannot conflict with those specified when allocating a page.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualallocexnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nndPreferred">
        /// <para>The NUMA node where the physical memory should reside.</para>
        /// <para>Used only when allocating a new VA region (either committed or reserved). Otherwise this parameter is ignored when the API is used to commit pages in a region that already exists</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualallocexnuma#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualallocexnuma">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *VirtualAllocExNuma(win32.System.SystemServices.HANDLE hProcess, [Optional] void *lpAddress, nuint dwSize, win32.System.Memory.VIRTUAL_ALLOCATION_TYPE flAllocationType, uint flProtect, uint nndPreferred);
        /// <inheritdoc cref = "GetMemoryErrorHandlingCapabilities(uint *)"/>
        internal static unsafe bool GetMemoryErrorHandlingCapabilities(out uint Capabilities)
        {
            fixed (uint *CapabilitiesLocal = &Capabilities)
            {
                bool __result = Kernel32.GetMemoryErrorHandlingCapabilities(CapabilitiesLocal);
                return __result;
            }
        }

        /// <summary>Gets the memory error handling capabilities of the system.</summary>
        /// <param name = "Capabilities">
        /// <para>A <b>PULONG</b> that receives one or more of the following flags.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getmemoryerrorhandlingcapabilities#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-getmemoryerrorhandlingcapabilities">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetMemoryErrorHandlingCapabilities(uint *Capabilities);
        /// <summary>Registers a bad memory notification that is called when one or more bad memory pages are detected.</summary>
        /// <param name = "Callback">
        /// <para>A pointer to the application-defined <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/hh691011(v=vs.85)">BadMemoryCallbackRoutine</a> function to register.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-registerbadmemorynotification#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Registration handle that represents the callback notification. Can be passed to the <a href = "/windows/desktop/api/memoryapi/nf-memoryapi-unregisterbadmemorynotification">UnregisterBadMemoryNotification</a> function when no longer needed.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-registerbadmemorynotification">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe void *RegisterBadMemoryNotification(delegate *unmanaged[Stdcall]<void>Callback);
        /// <summary>Closes the specified bad memory notification handle.</summary>
        /// <param name = "RegistrationHandle">
        /// <para>Registration handle returned from the <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-registerbadmemorynotification">RegisterBadMemoryNotification</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-unregisterbadmemorynotification#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-unregisterbadmemorynotification">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool UnregisterBadMemoryNotification(void *RegistrationHandle);
        /// <summary>Indicates that the data contained in a range of memory pages is no longer needed by the application and can be discarded by the system if necessary.</summary>
        /// <param name = "VirtualAddress">Page-aligned starting address of the memory to offer.</param>
        /// <param name = "Size">Size, in bytes, of the memory region to offer.  <i>Size</i> must be an integer multiple of the system page size.</param>
        /// <param name = "Priority">
        /// <para><i>Priority</i> indicates how important the offered memory is to the application. A higher priority increases the probability that the offered memory can be reclaimed intact when calling <a href = "https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-reclaimvirtualmemory">ReclaimVirtualMemory</a>. The system typically discards lower priority memory before discarding higher priority memory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-offervirtualmemory#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>ERROR_SUCCESS if successful; a <a href = "/windows/desktop/Debug/system-error-codes">System Error Code</a> otherwise.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-offervirtualmemory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint OfferVirtualMemory(void *VirtualAddress, nuint Size, win32.System.Memory.OFFER_PRIORITY Priority);
        /// <summary>Reclaims a range of memory pages that were offered to the system with OfferVirtualMemory.</summary>
        /// <param name = "VirtualAddress">Page-aligned starting address of the memory to reclaim.</param>
        /// <param name = "Size">Size, in bytes, of the memory region to reclaim.  <i>Size</i> must be an integer multiple of the system page size.</param>
        /// <returns>
        /// <para>Returns ERROR_SUCCESS if successful and the memory was reclaimed intact.</para>
        /// <para>Returns ERROR_BUSY if successful but the memory was discarded and must be rewritten by the application.  In this case, the contents of the memory region is undefined.</para>
        /// <para>Returns a <a href = "/windows/desktop/Debug/system-error-codes">System Error Code</a> otherwise.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-reclaimvirtualmemory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint ReclaimVirtualMemory(void *VirtualAddress, nuint Size);
        /// <summary>Discards the memory contents of a range of memory pages, without decommitting the memory. The contents of discarded memory is undefined and must be rewritten by the application.</summary>
        /// <param name = "VirtualAddress">Page-aligned starting address of the memory to discard.</param>
        /// <param name = "Size">Size, in bytes, of the memory region to discard.  <i>Size</i> must be an integer multiple of the system page size.</param>
        /// <returns>ERROR_SUCCESS if successful; a <a href = "/windows/desktop/Debug/system-error-codes">System Error Code</a> otherwise.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-discardvirtualmemory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint DiscardVirtualMemory(void *VirtualAddress, nuint Size);
        /// <summary>Allocates the specified number of bytes from the heap.</summary>
        /// <param name = "uFlags"></param>
        /// <param name = "dwBytes">The number of bytes to allocate. If this parameter is zero and the <i>uFlags</i> parameter specifies <b>GMEM_MOVEABLE</b>, the function returns a handle to a memory object that is marked as discarded.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the newly allocated memory object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalalloc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nint GlobalAlloc(win32.System.Memory.GLOBAL_ALLOC_FLAGS uFlags, nuint dwBytes);
        /// <summary>Changes the size or attributes of a specified global memory object. The size can increase or decrease.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the global memory object to be reallocated. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a> or <b>GlobalReAlloc</b> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalrealloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwBytes">The new size of the memory block, in bytes. If <i>uFlags</i> specifies <b>GMEM_MODIFY</b>, this parameter is ignored.</param>
        /// <param name = "uFlags">
        /// <para>The reallocation options. If <b>GMEM_MODIFY</b> is specified, the function modifies the attributes of the memory object only (the <i>dwBytes</i> parameter is ignored.) Otherwise, the function reallocates the memory object.</para>
        /// <para>You can optionally combine <b>GMEM_MODIFY</b> with the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalrealloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the reallocated memory object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalrealloc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nint GlobalReAlloc(nint hMem, nuint dwBytes, uint uFlags);
        /// <summary>Retrieves the current size of the specified global memory object, in bytes.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the global memory object. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalsize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the size of the specified global memory object, in bytes.</para>
        /// <para>If the specified handle is not valid or if the object has been discarded, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalsize">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nuint GlobalSize(nint hMem);
        /// <summary>Decrements the lock count associated with a memory object that was allocated with GMEM_MOVEABLE.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the global memory object. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalunlock#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the memory object is still locked after decrementing the lock count, the return value is a nonzero value. If the memory object is unlocked after decrementing the lock count, the function returns zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>NO_ERROR</b>.</para>
        /// <para>If the function fails, the return value is zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns a value other than <b>NO_ERROR</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalunlock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool GlobalUnlock(nint hMem);
        /// <summary>Locks a global memory object and returns a pointer to the first byte of the object's memory block.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the global memory object. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globallock#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a pointer to the first byte of the memory block.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globallock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *GlobalLock(nint hMem);
        /// <summary>Retrieves information about the specified global memory object.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the global memory object. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalflags#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value specifies the allocation values and the lock count for the memory object.</para>
        /// <para>If the function fails, the return value is <b>GMEM_INVALID_HANDLE</b>, indicating that the global handle is not valid. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalflags">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GlobalFlags(nint hMem);
        /// <summary>Retrieves the handle associated with the specified pointer to a global memory block.</summary>
        /// <param name = "pMem">
        /// <para>A pointer to the first byte of the global memory block. This pointer is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globallock">GlobalLock</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the specified global memory object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalhandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe nint GlobalHandle(void *pMem);
        /// <summary>Frees the specified global memory object and invalidates its handle.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the global memory object. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a> function. It is not safe to free memory allocated with <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalfree#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is <b>NULL</b>.</para>
        /// <para>If the function fails, the return value is equal to a handle to the global memory object. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-globalfree">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nint GlobalFree(nint hMem);
        /// <summary>Allocates the specified number of bytes from the heap.</summary>
        /// <param name = "uFlags"></param>
        /// <param name = "uBytes">The number of bytes to allocate. If this parameter is zero and the <i>uFlags</i> parameter specifies <b>LMEM_MOVEABLE</b>, the function returns a handle to a memory object that is marked as discarded.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the newly allocated memory object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localalloc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nint LocalAlloc(win32.System.Memory.LOCAL_ALLOC_FLAGS uFlags, nuint uBytes);
        /// <summary>Changes the size or the attributes of a specified local memory object. The size can increase or decrease.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the local memory object to be reallocated. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> or <b>LocalReAlloc</b> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localrealloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uBytes">The new size of the memory block, in bytes. If <i>uFlags</i> specifies <b>LMEM_MODIFY</b>, this parameter is ignored.</param>
        /// <param name = "uFlags">
        /// <para>The reallocation options. If <b>LMEM_MODIFY</b> is specified, the function modifies the attributes of the memory object only (the <i>uBytes</i> parameter is ignored.) Otherwise, the function reallocates the memory object.</para>
        /// <para>You can optionally combine <b>LMEM_MODIFY</b> with the following value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localrealloc#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the reallocated memory object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localrealloc">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nint LocalReAlloc(nint hMem, nuint uBytes, uint uFlags);
        /// <summary>Locks a local memory object and returns a pointer to the first byte of the object's memory block.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the local memory object. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localrealloc">LocalReAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-locallock#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a pointer to the first byte of the memory block.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-locallock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe void *LocalLock(nint hMem);
        /// <summary>Retrieves the handle associated with the specified pointer to a local memory object.</summary>
        /// <param name = "pMem">
        /// <para>A pointer to the first byte of the local memory object. This pointer is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-locallock">LocalLock</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the specified local memory object.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localhandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe nint LocalHandle(void *pMem);
        /// <summary>Decrements the lock count associated with a memory object that was allocated with LMEM_MOVEABLE.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the local memory object. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localrealloc">LocalReAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localunlock#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the memory object is still locked after decrementing the lock count, the return value is nonzero. If the memory object is unlocked after decrementing the lock count, the function returns zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>NO_ERROR</b>.</para>
        /// <para>If the function fails, the return value is zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns a value other than <b>NO_ERROR</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localunlock">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool LocalUnlock(nint hMem);
        /// <summary>Retrieves the current size of the specified local memory object, in bytes.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the local memory object. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localrealloc">LocalReAlloc</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localhandle">LocalHandle</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localsize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the size of the specified local memory object, in bytes. If the specified handle is not valid or if the object has been discarded, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localsize">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nuint LocalSize(nint hMem);
        /// <summary>Retrieves information about the specified local memory object.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the local memory object. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localrealloc">LocalReAlloc</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localflags#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value specifies the allocation values and the lock count for the memory object.</para>
        /// <para>If the function fails, the return value is <b>LMEM_INVALID_HANDLE</b>, indicating that the local handle is not valid. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localflags">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint LocalFlags(nint hMem);
        /// <summary>Frees the specified local memory object and invalidates its handle.</summary>
        /// <param name = "hMem">
        /// <para>A handle to the local memory object. This handle is returned by either the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localrealloc">LocalReAlloc</a> function. It is not safe to free memory allocated with <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localfree#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is <b>NULL</b>.</para>
        /// <para>If the function fails, the return value is equal to a handle to the local memory object. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-localfree">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern nint LocalFree(nint hMem);
        /// <inheritdoc cref = "EnableThreadProfiling(win32.System.SystemServices.HANDLE, uint, ulong, win32.System.SystemServices.HANDLE*)"/>
        internal static unsafe uint EnableThreadProfiling(SafeHandle ThreadHandle, uint Flags, ulong HardwareCounters, out Microsoft.Win32.SafeHandles.SafeFileHandle PerformanceDataHandle)
        {
            bool ThreadHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE ThreadHandleLocal;
                if (ThreadHandle is object)
                {
                    ThreadHandle.DangerousAddRef(ref ThreadHandleAddRef);
                    ThreadHandleLocal = (win32.System.SystemServices.HANDLE)ThreadHandle.DangerousGetHandle();
                }
                else
                    ThreadHandleLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE PerformanceDataHandleLocal;
                uint __result = Kernel32.EnableThreadProfiling(ThreadHandleLocal, Flags, HardwareCounters, &PerformanceDataHandleLocal);
                PerformanceDataHandle = new Microsoft.Win32.SafeHandles.SafeFileHandle(PerformanceDataHandleLocal, ownsHandle: true);
                return __result;
            }
            finally
            {
                if (ThreadHandleAddRef)
                    ThreadHandle.DangerousRelease();
            }
        }

        /// <summary>Enables thread profiling on the specified thread.</summary>
        /// <param name = "ThreadHandle">The handle to the thread on which you want to enable profiling. This must be the current thread.</param>
        /// <param name = "Flags">To receive thread profiling data such as context switch count, set this parameter to THREAD_PROFILING_FLAG_DISPATCH; otherwise, set to 0.</param>
        /// <param name = "HardwareCounters">To receive hardware performance counter data, set this parameter to a bitmask that identifies the hardware counters to collect. You can specify up to 16 performance counters. Each bit relates directly to the zero-based hardware counter index for the hardware performance counters that you configured. Set to zero if you are not collecting hardware counter data. If you set a bit for a hardware counter that has not been configured, the counter value that is read for that counter is zero.</param>
        /// <param name = "PerformanceDataHandle">An opaque handle that you use when calling the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-readthreadprofilingdata">ReadThreadProfilingData</a> and <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-disablethreadprofiling">DisableThreadProfiling</a> functions.</param>
        /// <returns>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-enablethreadprofiling">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint EnableThreadProfiling(win32.System.SystemServices.HANDLE ThreadHandle, uint Flags, ulong HardwareCounters, win32.System.SystemServices.HANDLE*PerformanceDataHandle);
        /// <inheritdoc cref = "DisableThreadProfiling(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint DisableThreadProfiling(SafeHandle PerformanceDataHandle)
        {
            bool PerformanceDataHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE PerformanceDataHandleLocal;
                if (PerformanceDataHandle is object)
                {
                    PerformanceDataHandle.DangerousAddRef(ref PerformanceDataHandleAddRef);
                    PerformanceDataHandleLocal = (win32.System.SystemServices.HANDLE)PerformanceDataHandle.DangerousGetHandle();
                }
                else
                    PerformanceDataHandleLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.DisableThreadProfiling(PerformanceDataHandleLocal);
                return __result;
            }
            finally
            {
                if (PerformanceDataHandleAddRef)
                    PerformanceDataHandle.DangerousRelease();
            }
        }

        /// <summary>Disables thread profiling.</summary>
        /// <param name = "PerformanceDataHandle">The handle that the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-enablethreadprofiling">EnableThreadProfiling</a> function returned.</param>
        /// <returns>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-disablethreadprofiling">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint DisableThreadProfiling(win32.System.SystemServices.HANDLE PerformanceDataHandle);
        /// <inheritdoc cref = "QueryThreadProfiling(win32.System.SystemServices.HANDLE, byte *)"/>
        internal static unsafe uint QueryThreadProfiling(SafeHandle ThreadHandle, out byte Enabled)
        {
            bool ThreadHandleAddRef = false;
            try
            {
                fixed (byte *EnabledLocal = &Enabled)
                {
                    win32.System.SystemServices.HANDLE ThreadHandleLocal;
                    if (ThreadHandle is object)
                    {
                        ThreadHandle.DangerousAddRef(ref ThreadHandleAddRef);
                        ThreadHandleLocal = (win32.System.SystemServices.HANDLE)ThreadHandle.DangerousGetHandle();
                    }
                    else
                        ThreadHandleLocal = default(win32.System.SystemServices.HANDLE);
                    uint __result = Kernel32.QueryThreadProfiling(ThreadHandleLocal, EnabledLocal);
                    return __result;
                }
            }
            finally
            {
                if (ThreadHandleAddRef)
                    ThreadHandle.DangerousRelease();
            }
        }

        /// <summary>Determines whether thread profiling is enabled for the specified thread.</summary>
        /// <param name = "ThreadHandle">The handle to the thread of interest.</param>
        /// <param name = "Enabled">Is <b>TRUE</b> if thread profiling is enabled for the specified thread; otherwise, <b>FALSE</b>.</param>
        /// <returns>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-querythreadprofiling">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint QueryThreadProfiling(win32.System.SystemServices.HANDLE ThreadHandle, byte *Enabled);
        /// <inheritdoc cref = "ReadThreadProfilingData(win32.System.SystemServices.HANDLE, uint, win32.System.Performance.HardwareCounterProfiling.PERFORMANCE_DATA*)"/>
        internal static unsafe uint ReadThreadProfilingData(SafeHandle PerformanceDataHandle, uint Flags, out win32.System.Performance.HardwareCounterProfiling.PERFORMANCE_DATA PerformanceData)
        {
            bool PerformanceDataHandleAddRef = false;
            try
            {
                fixed (win32.System.Performance.HardwareCounterProfiling.PERFORMANCE_DATA*PerformanceDataLocal = &PerformanceData)
                {
                    win32.System.SystemServices.HANDLE PerformanceDataHandleLocal;
                    if (PerformanceDataHandle is object)
                    {
                        PerformanceDataHandle.DangerousAddRef(ref PerformanceDataHandleAddRef);
                        PerformanceDataHandleLocal = (win32.System.SystemServices.HANDLE)PerformanceDataHandle.DangerousGetHandle();
                    }
                    else
                        PerformanceDataHandleLocal = default(win32.System.SystemServices.HANDLE);
                    uint __result = Kernel32.ReadThreadProfilingData(PerformanceDataHandleLocal, Flags, PerformanceDataLocal);
                    return __result;
                }
            }
            finally
            {
                if (PerformanceDataHandleAddRef)
                    PerformanceDataHandle.DangerousRelease();
            }
        }

        /// <summary>Reads the specified profiling data associated with the thread.</summary>
        /// <param name = "PerformanceDataHandle">The handle that the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-enablethreadprofiling">EnableThreadProfiling</a> function returned.</param>
        /// <param name = "Flags">
        /// <para>One or more of the following flags that specify the counter data to read. The flags must have been set when you called the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-enablethreadprofiling">EnableThreadProfiling</a> function.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readthreadprofilingdata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "PerformanceData">A <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-performance_data">PERFORMANCE_DATA</a> structure that contains the thread profiling and hardware counter data.</param>
        /// <returns>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readthreadprofilingdata">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint ReadThreadProfilingData(win32.System.SystemServices.HANDLE PerformanceDataHandle, uint Flags, win32.System.Performance.HardwareCounterProfiling.PERFORMANCE_DATA*PerformanceData);
        /// <inheritdoc cref = "PowerCreateRequest(win32.System.SystemServices.REASON_CONTEXT*)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle PowerCreateRequest(in win32.System.SystemServices.REASON_CONTEXT Context)
        {
            fixed (win32.System.SystemServices.REASON_CONTEXT*ContextLocal = &Context)
            {
                win32.System.SystemServices.HANDLE __result = Kernel32.PowerCreateRequest(ContextLocal);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates a new power request object.</summary>
        /// <param name = "Context">Points to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-reason_context">REASON_CONTEXT</a> structure that contains information about the power request.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the power request object.</para>
        /// <para>If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-powercreaterequest">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE PowerCreateRequest(win32.System.SystemServices.REASON_CONTEXT*Context);
        /// <inheritdoc cref = "PowerSetRequest(win32.System.SystemServices.HANDLE, win32.System.SystemServices.POWER_REQUEST_TYPE)"/>
        internal static unsafe bool PowerSetRequest(SafeHandle PowerRequest, win32.System.SystemServices.POWER_REQUEST_TYPE RequestType)
        {
            bool PowerRequestAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE PowerRequestLocal;
                if (PowerRequest is object)
                {
                    PowerRequest.DangerousAddRef(ref PowerRequestAddRef);
                    PowerRequestLocal = (win32.System.SystemServices.HANDLE)PowerRequest.DangerousGetHandle();
                }
                else
                    PowerRequestLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.PowerSetRequest(PowerRequestLocal, RequestType);
                return __result;
            }
            finally
            {
                if (PowerRequestAddRef)
                    PowerRequest.DangerousRelease();
            }
        }

        /// <summary>Increments the count of power requests of the specified type for a power request object.</summary>
        /// <param name = "PowerRequest">A handle to a power request object.</param>
        /// <param name = "RequestType"></param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, it returns zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-powersetrequest">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool PowerSetRequest(win32.System.SystemServices.HANDLE PowerRequest, win32.System.SystemServices.POWER_REQUEST_TYPE RequestType);
        /// <inheritdoc cref = "PowerClearRequest(win32.System.SystemServices.HANDLE, win32.System.SystemServices.POWER_REQUEST_TYPE)"/>
        internal static unsafe bool PowerClearRequest(SafeHandle PowerRequest, win32.System.SystemServices.POWER_REQUEST_TYPE RequestType)
        {
            bool PowerRequestAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE PowerRequestLocal;
                if (PowerRequest is object)
                {
                    PowerRequest.DangerousAddRef(ref PowerRequestAddRef);
                    PowerRequestLocal = (win32.System.SystemServices.HANDLE)PowerRequest.DangerousGetHandle();
                }
                else
                    PowerRequestLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.PowerClearRequest(PowerRequestLocal, RequestType);
                return __result;
            }
            finally
            {
                if (PowerRequestAddRef)
                    PowerRequest.DangerousRelease();
            }
        }

        /// <summary>Decrements the count of power requests of the specified type for a power request object.</summary>
        /// <param name = "PowerRequest">A handle to a power request object.</param>
        /// <param name = "RequestType"></param>
        /// <returns>
        /// <para>If the function succeeds, it returns a nonzero value.</para>
        /// <para>If the function fails, it returns zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-powerclearrequest">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool PowerClearRequest(win32.System.SystemServices.HANDLE PowerRequest, win32.System.SystemServices.POWER_REQUEST_TYPE RequestType);
        /// <inheritdoc cref = "K32EnumProcesses(uint *, uint, uint *)"/>
        internal static unsafe bool K32EnumProcesses(out uint lpidProcess, uint cb, out uint lpcbNeeded)
        {
            fixed (uint *lpcbNeededLocal = &lpcbNeeded)
            {
                fixed (uint *lpidProcessLocal = &lpidProcess)
                {
                    bool __result = Kernel32.K32EnumProcesses(lpidProcessLocal, cb, lpcbNeededLocal);
                    return __result;
                }
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool K32EnumProcesses(uint *lpidProcess, uint cb, uint *lpcbNeeded);
        /// <inheritdoc cref = "K32EnumProcessModules(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HINSTANCE*, uint, uint *)"/>
        internal static unsafe bool K32EnumProcessModules(SafeHandle hProcess, out Kernel32.FreeLibrarySafeHandle lphModule, uint cb, out uint lpcbNeeded)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *lpcbNeededLocal = &lpcbNeeded)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.HINSTANCE lphModuleLocal;
                    bool __result = Kernel32.K32EnumProcessModules(hProcessLocal, &lphModuleLocal, cb, lpcbNeededLocal);
                    lphModule = new Kernel32.FreeLibrarySafeHandle(lphModuleLocal, ownsHandle: true);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool K32EnumProcessModules(win32.System.SystemServices.HANDLE hProcess, win32.System.SystemServices.HINSTANCE*lphModule, uint cb, uint *lpcbNeeded);
        /// <inheritdoc cref = "K32EnumProcessModulesEx(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HINSTANCE*, uint, uint *, uint)"/>
        internal static unsafe bool K32EnumProcessModulesEx(SafeHandle hProcess, out Kernel32.FreeLibrarySafeHandle lphModule, uint cb, out uint lpcbNeeded, uint dwFilterFlag)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *lpcbNeededLocal = &lpcbNeeded)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.HINSTANCE lphModuleLocal;
                    bool __result = Kernel32.K32EnumProcessModulesEx(hProcessLocal, &lphModuleLocal, cb, lpcbNeededLocal, dwFilterFlag);
                    lphModule = new Kernel32.FreeLibrarySafeHandle(lphModuleLocal, ownsHandle: true);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool K32EnumProcessModulesEx(win32.System.SystemServices.HANDLE hProcess, win32.System.SystemServices.HINSTANCE*lphModule, uint cb, uint *lpcbNeeded, uint dwFilterFlag);
        /// <inheritdoc cref = "K32GetModuleBaseName(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint K32GetModuleBaseName(SafeHandle hProcess, SafeHandle hModule, win32.System.SystemServices.PWSTR lpBaseName, uint nSize)
        {
            bool hProcessAddRef = false;
            bool hModuleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HINSTANCE hModuleLocal;
                if (hModule is object)
                {
                    hModule.DangerousAddRef(ref hModuleAddRef);
                    hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                }
                else
                    hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                uint __result = Kernel32.K32GetModuleBaseName(hProcessLocal, hModuleLocal, lpBaseName, nSize);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "K32GetModuleBaseNameW")]
        internal static extern uint K32GetModuleBaseName(win32.System.SystemServices.HANDLE hProcess, win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.PWSTR lpBaseName, uint nSize);
        /// <inheritdoc cref = "K32GetModuleFileNameEx(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HINSTANCE, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint K32GetModuleFileNameEx(SafeHandle hProcess, SafeHandle hModule, win32.System.SystemServices.PWSTR lpFilename, uint nSize)
        {
            bool hProcessAddRef = false;
            bool hModuleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HINSTANCE hModuleLocal;
                if (hModule is object)
                {
                    hModule.DangerousAddRef(ref hModuleAddRef);
                    hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                }
                else
                    hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                uint __result = Kernel32.K32GetModuleFileNameEx(hProcessLocal, hModuleLocal, lpFilename, nSize);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "K32GetModuleFileNameExW")]
        internal static extern uint K32GetModuleFileNameEx(win32.System.SystemServices.HANDLE hProcess, win32.System.SystemServices.HINSTANCE hModule, win32.System.SystemServices.PWSTR lpFilename, uint nSize);
        /// <inheritdoc cref = "K32GetModuleInformation(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HINSTANCE, win32.System.ProcessStatus.MODULEINFO*, uint)"/>
        internal static unsafe bool K32GetModuleInformation(SafeHandle hProcess, SafeHandle hModule, out win32.System.ProcessStatus.MODULEINFO lpmodinfo, uint cb)
        {
            bool hProcessAddRef = false;
            bool hModuleAddRef = false;
            try
            {
                fixed (win32.System.ProcessStatus.MODULEINFO*lpmodinfoLocal = &lpmodinfo)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.HINSTANCE hModuleLocal;
                    if (hModule is object)
                    {
                        hModule.DangerousAddRef(ref hModuleAddRef);
                        hModuleLocal = (win32.System.SystemServices.HINSTANCE)hModule.DangerousGetHandle();
                    }
                    else
                        hModuleLocal = default(win32.System.SystemServices.HINSTANCE);
                    bool __result = Kernel32.K32GetModuleInformation(hProcessLocal, hModuleLocal, lpmodinfoLocal, cb);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool K32GetModuleInformation(win32.System.SystemServices.HANDLE hProcess, win32.System.SystemServices.HINSTANCE hModule, win32.System.ProcessStatus.MODULEINFO*lpmodinfo, uint cb);
        /// <inheritdoc cref = "K32EmptyWorkingSet(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool K32EmptyWorkingSet(SafeHandle hProcess)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.K32EmptyWorkingSet(hProcessLocal);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool K32EmptyWorkingSet(win32.System.SystemServices.HANDLE hProcess);
        /// <inheritdoc cref = "K32QueryWorkingSet(win32.System.SystemServices.HANDLE, void *, uint)"/>
        internal static unsafe bool K32QueryWorkingSet(SafeHandle hProcess, void *pv, uint cb)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.K32QueryWorkingSet(hProcessLocal, pv, cb);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool K32QueryWorkingSet(win32.System.SystemServices.HANDLE hProcess, void *pv, uint cb);
        /// <inheritdoc cref = "K32QueryWorkingSetEx(win32.System.SystemServices.HANDLE, void *, uint)"/>
        internal static unsafe bool K32QueryWorkingSetEx(SafeHandle hProcess, void *pv, uint cb)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.K32QueryWorkingSetEx(hProcessLocal, pv, cb);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool K32QueryWorkingSetEx(win32.System.SystemServices.HANDLE hProcess, void *pv, uint cb);
        /// <inheritdoc cref = "K32InitializeProcessForWsWatch(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool K32InitializeProcessForWsWatch(SafeHandle hProcess)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.K32InitializeProcessForWsWatch(hProcessLocal);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool K32InitializeProcessForWsWatch(win32.System.SystemServices.HANDLE hProcess);
        /// <inheritdoc cref = "K32GetWsChanges(win32.System.SystemServices.HANDLE, win32.System.ProcessStatus.PSAPI_WS_WATCH_INFORMATION*, uint)"/>
        internal static unsafe bool K32GetWsChanges(SafeHandle hProcess, out win32.System.ProcessStatus.PSAPI_WS_WATCH_INFORMATION lpWatchInfo, uint cb)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (win32.System.ProcessStatus.PSAPI_WS_WATCH_INFORMATION*lpWatchInfoLocal = &lpWatchInfo)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.K32GetWsChanges(hProcessLocal, lpWatchInfoLocal, cb);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool K32GetWsChanges(win32.System.SystemServices.HANDLE hProcess, win32.System.ProcessStatus.PSAPI_WS_WATCH_INFORMATION*lpWatchInfo, uint cb);
        /// <inheritdoc cref = "K32GetWsChangesEx(win32.System.SystemServices.HANDLE, win32.System.ProcessStatus.PSAPI_WS_WATCH_INFORMATION_EX*, uint *)"/>
        internal static unsafe bool K32GetWsChangesEx(SafeHandle hProcess, out win32.System.ProcessStatus.PSAPI_WS_WATCH_INFORMATION_EX lpWatchInfoEx, ref uint cb)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *cbLocal = &cb)
                {
                    fixed (win32.System.ProcessStatus.PSAPI_WS_WATCH_INFORMATION_EX*lpWatchInfoExLocal = &lpWatchInfoEx)
                    {
                        win32.System.SystemServices.HANDLE hProcessLocal;
                        if (hProcess is object)
                        {
                            hProcess.DangerousAddRef(ref hProcessAddRef);
                            hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                        }
                        else
                            hProcessLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.K32GetWsChangesEx(hProcessLocal, lpWatchInfoExLocal, cbLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool K32GetWsChangesEx(win32.System.SystemServices.HANDLE hProcess, win32.System.ProcessStatus.PSAPI_WS_WATCH_INFORMATION_EX*lpWatchInfoEx, uint *cb);
        /// <inheritdoc cref = "K32GetMappedFileName(win32.System.SystemServices.HANDLE, void *, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint K32GetMappedFileName(SafeHandle hProcess, void *lpv, win32.System.SystemServices.PWSTR lpFilename, uint nSize)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.K32GetMappedFileName(hProcessLocal, lpv, lpFilename, nSize);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "K32GetMappedFileNameW")]
        internal static extern unsafe uint K32GetMappedFileName(win32.System.SystemServices.HANDLE hProcess, void *lpv, win32.System.SystemServices.PWSTR lpFilename, uint nSize);
        /// <inheritdoc cref = "K32EnumDeviceDrivers(void **, uint, uint *)"/>
        internal static unsafe bool K32EnumDeviceDrivers(out void *lpImageBase, uint cb, out uint lpcbNeeded)
        {
            fixed (uint *lpcbNeededLocal = &lpcbNeeded)
            {
                fixed (void **lpImageBaseLocal = &lpImageBase)
                {
                    bool __result = Kernel32.K32EnumDeviceDrivers(lpImageBaseLocal, cb, lpcbNeededLocal);
                    return __result;
                }
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool K32EnumDeviceDrivers(void **lpImageBase, uint cb, uint *lpcbNeeded);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "K32GetDeviceDriverBaseNameW")]
        internal static extern unsafe uint K32GetDeviceDriverBaseName(void *ImageBase, win32.System.SystemServices.PWSTR lpBaseName, uint nSize);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "K32GetDeviceDriverFileNameW")]
        internal static extern unsafe uint K32GetDeviceDriverFileName(void *ImageBase, win32.System.SystemServices.PWSTR lpFilename, uint nSize);
        /// <inheritdoc cref = "K32GetProcessMemoryInfo(win32.System.SystemServices.HANDLE, win32.System.ProcessStatus.PROCESS_MEMORY_COUNTERS*, uint)"/>
        internal static unsafe bool K32GetProcessMemoryInfo(SafeHandle Process, ref win32.System.ProcessStatus.PROCESS_MEMORY_COUNTERS ppsmemCounters, uint cb)
        {
            bool ProcessAddRef = false;
            try
            {
                fixed (win32.System.ProcessStatus.PROCESS_MEMORY_COUNTERS*ppsmemCountersLocal = &ppsmemCounters)
                {
                    win32.System.SystemServices.HANDLE ProcessLocal;
                    if (Process is object)
                    {
                        Process.DangerousAddRef(ref ProcessAddRef);
                        ProcessLocal = (win32.System.SystemServices.HANDLE)Process.DangerousGetHandle();
                    }
                    else
                        ProcessLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.K32GetProcessMemoryInfo(ProcessLocal, ppsmemCountersLocal, cb);
                    return __result;
                }
            }
            finally
            {
                if (ProcessAddRef)
                    Process.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool K32GetProcessMemoryInfo(win32.System.SystemServices.HANDLE Process, win32.System.ProcessStatus.PROCESS_MEMORY_COUNTERS*ppsmemCounters, uint cb);
        /// <inheritdoc cref = "K32GetPerformanceInfo(win32.System.ProcessStatus.PERFORMANCE_INFORMATION*, uint)"/>
        internal static unsafe bool K32GetPerformanceInfo(ref win32.System.ProcessStatus.PERFORMANCE_INFORMATION pPerformanceInformation, uint cb)
        {
            fixed (win32.System.ProcessStatus.PERFORMANCE_INFORMATION*pPerformanceInformationLocal = &pPerformanceInformation)
            {
                bool __result = Kernel32.K32GetPerformanceInfo(pPerformanceInformationLocal, cb);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool K32GetPerformanceInfo(win32.System.ProcessStatus.PERFORMANCE_INFORMATION*pPerformanceInformation, uint cb);
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "K32EnumPageFilesW")]
        internal static extern unsafe bool K32EnumPageFiles(delegate *unmanaged[Stdcall]<void *, win32.System.ProcessStatus.ENUM_PAGE_FILE_INFORMATION*, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.BOOL>pCallBackRoutine, void *pContext);
        /// <inheritdoc cref = "K32GetProcessImageFileName(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint K32GetProcessImageFileName(SafeHandle hProcess, win32.System.SystemServices.PWSTR lpImageFileName, uint nSize)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.K32GetProcessImageFileName(hProcessLocal, lpImageFileName, nSize);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "K32GetProcessImageFileNameW")]
        internal static extern uint K32GetProcessImageFileName(win32.System.SystemServices.HANDLE hProcess, win32.System.SystemServices.PWSTR lpImageFileName, uint nSize);
        /// <inheritdoc cref = "OOBEComplete(bool *)"/>
        internal static unsafe bool OOBEComplete(out bool isOOBEComplete)
        {
            fixed (bool *isOOBECompleteLocal = &isOOBEComplete)
            {
                bool __result = Kernel32.OOBEComplete(isOOBECompleteLocal);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool OOBEComplete(bool *isOOBEComplete);
        /// <inheritdoc cref = "RegisterWaitUntilOOBECompleted(delegate *unmanaged[Stdcall]{void *, void}, void *, void **)"/>
        internal static unsafe bool RegisterWaitUntilOOBECompleted(delegate *unmanaged[Stdcall]<void *, void>OOBECompletedCallback, void *CallbackContext, out void *WaitHandle)
        {
            fixed (void **WaitHandleLocal = &WaitHandle)
            {
                bool __result = Kernel32.RegisterWaitUntilOOBECompleted(OOBECompletedCallback, CallbackContext, WaitHandleLocal);
                return __result;
            }
        }

        /// <summary>Registers a callback to be called once OOBE (Windows Welcome) has been completed.</summary>
        /// <param name = "OOBECompletedCallback">Pointer to an application-defined callback function that will be called upon completion of OOBE. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/api/oobenotification/nc-oobenotification-oobe_completed_callback">OOBE_COMPLETED_CALLBACK</a>.</param>
        /// <param name = "CallbackContext">Pointer to the callback context. This value will be passed to the function specified by <i>OOBECompletedCallback</i>. This value can be <b>nulll</b>.</param>
        /// <param name = "WaitHandle">Pointer to a variable that will receive the handle to the wait callback registration.</param>
        /// <returns><b>TRUE</b> if the routine successfully registered the callback. Otherwise, <b>FALSE</b> is returned. If <b>FALSE</b>, <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will retrieve extended error information.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//oobenotification/nf-oobenotification-registerwaituntiloobecompleted">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool RegisterWaitUntilOOBECompleted(delegate *unmanaged[Stdcall]<void *, void>OOBECompletedCallback, [Optional] void *CallbackContext, void **WaitHandle);
        /// <summary>Unregisters the callback previously registered via RegisterWaitUntilOOBECompleted.</summary>
        /// <param name = "WaitHandle">Handle to be unregistered.</param>
        /// <returns><b>TRUE</b> if the callback was successfully unregistered. Otherwise, <b>FALSE</b> is returned. If <b>FALSE</b>, <a href = "/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will retrieve extended error information.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//oobenotification/nf-oobenotification-unregisterwaituntiloobecompleted">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool UnregisterWaitUntilOOBECompleted(void *WaitHandle);
        /// <summary>Registers the active instance of an application for recovery.</summary>
        /// <param name = "pRecoveyCallback">A pointer to the recovery callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa373202(v=vs.85)">ApplicationRecoveryCallback</a>.</param>
        /// <param name = "pvParameter">A pointer to a variable to be passed to the callback function. Can be <b>NULL</b>.</param>
        /// <param name = "dwPingInterval">
        /// <para>The recovery ping interval, in milliseconds. By default, the interval is 5 seconds (RECOVERY_DEFAULT_PING_INTERVAL). The maximum interval is 5 minutes. If you specify zero, the default interval is used.</para>
        /// <para>You must call the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-applicationrecoveryinprogress">ApplicationRecoveryInProgress</a> function within the specified interval to indicate to ARR that you are still actively recovering; otherwise, WER terminates recovery. Typically, you perform recovery in a loop with each iteration lasting no longer than the ping interval. Each iteration performs a block of recovery work followed by a call to <b>ApplicationRecoveryInProgress</b>. Since you also use <b>ApplicationRecoveryInProgress</b> to determine if the user wants to cancel recovery, you should consider a smaller interval, so you do not perform a lot of work unnecessarily.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-registerapplicationrecoverycallback#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Reserved for future use. Set to zero.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-registerapplicationrecoverycallback">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT RegisterApplicationRecoveryCallback(delegate *unmanaged[Stdcall]<void *, uint>pRecoveyCallback, [Optional] void *pvParameter, uint dwPingInterval, uint dwFlags);
        /// <summary>Removes the active instance of an application from the recovery list.</summary>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-unregisterapplicationrecoverycallback">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT UnregisterApplicationRecoveryCallback();
        /// <inheritdoc cref = "RegisterApplicationRestart(win32.System.SystemServices.PCWSTR, win32.System.Recovery.REGISTER_APPLICATION_RESTART_FLAGS)"/>
        internal static unsafe win32.System.Com.HRESULT RegisterApplicationRestart(string pwzCommandline, win32.System.Recovery.REGISTER_APPLICATION_RESTART_FLAGS dwFlags)
        {
            fixed (char *pwzCommandlineLocal = pwzCommandline)
            {
                win32.System.Com.HRESULT __result = Kernel32.RegisterApplicationRestart(pwzCommandlineLocal, dwFlags);
                return __result;
            }
        }

        /// <summary>Registers the active instance of an application for restart.</summary>
        /// <param name = "pwzCommandline">
        /// <para>A pointer to a Unicode string that specifies the command-line arguments for the application when it is restarted. The maximum size of the command line that you can specify is RESTART_MAX_CMD_LINE characters. Do not include the name of the executable in the command line; this function adds it for you.</para>
        /// <para>If this parameter is <b>NULL</b> or an empty string, the previously registered command line is removed. If the argument contains spaces, use quotes around the argument.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-registerapplicationrestart#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-registerapplicationrestart">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT RegisterApplicationRestart(win32.System.SystemServices.PCWSTR pwzCommandline, win32.System.Recovery.REGISTER_APPLICATION_RESTART_FLAGS dwFlags);
        /// <summary>Removes the active instance of an application from the restart list.</summary>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-unregisterapplicationrestart">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern win32.System.Com.HRESULT UnregisterApplicationRestart();
        /// <inheritdoc cref = "GetApplicationRecoveryCallback(win32.System.SystemServices.HANDLE, delegate *unmanaged[Stdcall]{void *, uint}*, void **, uint *, uint *)"/>
        internal static unsafe win32.System.Com.HRESULT GetApplicationRecoveryCallback(SafeHandle hProcess, out delegate *unmanaged[Stdcall]<void *, uint>pRecoveryCallback, void **ppvParameter, uint *pdwPingInterval, uint *pdwFlags)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (delegate *unmanaged[Stdcall]<void *, uint>*pRecoveryCallbackLocal = &pRecoveryCallback)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.Com.HRESULT __result = Kernel32.GetApplicationRecoveryCallback(hProcessLocal, pRecoveryCallbackLocal, ppvParameter, pdwPingInterval, pdwFlags);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves a pointer to the callback routine registered for the specified process. The address returned is in the virtual address space of the process.</summary>
        /// <param name = "hProcess">A handle to the process. This handle must have the PROCESS_VM_READ access right.</param>
        /// <param name = "pRecoveryCallback">A pointer to the recovery callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa373202(v=vs.85)">ApplicationRecoveryCallback</a>.</param>
        /// <param name = "ppvParameter">A pointer to the callback parameter.</param>
        /// <param name = "pdwPingInterval">The recovery ping interval, in 100-nanosecond intervals.</param>
        /// <param name = "pdwFlags">Reserved for future use.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getapplicationrecoverycallback">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT GetApplicationRecoveryCallback(win32.System.SystemServices.HANDLE hProcess, delegate *unmanaged[Stdcall]<void *, uint>*pRecoveryCallback, [Optional] void **ppvParameter, [Optional] uint *pdwPingInterval, [Optional] uint *pdwFlags);
        /// <inheritdoc cref = "GetApplicationRestartSettings(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PWSTR, uint *, uint *)"/>
        internal static unsafe win32.System.Com.HRESULT GetApplicationRestartSettings(SafeHandle hProcess, win32.System.SystemServices.PWSTR pwzCommandline, ref uint pcchSize, uint *pdwFlags)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *pcchSizeLocal = &pcchSize)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.Com.HRESULT __result = Kernel32.GetApplicationRestartSettings(hProcessLocal, pwzCommandline, pcchSizeLocal, pdwFlags);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves the restart information registered for the specified process.</summary>
        /// <param name = "hProcess">A handle to the process. This handle must have the PROCESS_VM_READ access right.</param>
        /// <param name = "pwzCommandline">A pointer to a buffer that receives the restart command line specified by the application when it called the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-registerapplicationrestart">RegisterApplicationRestart</a> function. The maximum size of the command line, in characters, is RESTART_MAX_CMD_LINE. Can be <b>NULL</b> if <i>pcchSize</i> is zero.</param>
        /// <param name = "pcchSize">
        /// <para>On input, specifies the size of the <i>pwzCommandLine</i> buffer, in characters.</para>
        /// <para>If the buffer is not large enough to receive the command line, the function fails with HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) and sets this parameter to the required buffer size, in characters.</para>
        /// <para>On output, specifies the size of the buffer that was used.</para>
        /// <para>To determine the required buffer size, set <i>pwzCommandLine</i> to <b>NULL</b> and this parameter to zero. The size includes one for the <b>null</b>-terminator character. Note that the function returns S_OK, not HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) in this case.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getapplicationrestartsettings#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pdwFlags">A pointer to a variable that receives the flags specified by the application when it called the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-registerapplicationrestart">RegisterApplicationRestart</a> function.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getapplicationrestartsettings">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT GetApplicationRestartSettings(win32.System.SystemServices.HANDLE hProcess, win32.System.SystemServices.PWSTR pwzCommandline, uint *pcchSize, [Optional] uint *pdwFlags);
        /// <inheritdoc cref = "ApplicationRecoveryInProgress(bool *)"/>
        internal static unsafe win32.System.Com.HRESULT ApplicationRecoveryInProgress(out bool pbCancelled)
        {
            fixed (bool *pbCancelledLocal = &pbCancelled)
            {
                win32.System.Com.HRESULT __result = Kernel32.ApplicationRecoveryInProgress(pbCancelledLocal);
                return __result;
            }
        }

        /// <summary>Indicates that the calling application is continuing to recover data.</summary>
        /// <param name = "pbCancelled">Indicates whether the user has canceled the recovery process. Set by WER if the user clicks the Cancel button.</param>
        /// <returns>
        /// <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-applicationrecoveryinprogress">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT ApplicationRecoveryInProgress(bool *pbCancelled);
        /// <summary>Indicates that the calling application has completed its data recovery.</summary>
        /// <param name = "bSuccess">Specify <b>TRUE</b> to indicate that the data was successfully recovered; otherwise, <b>FALSE</b>.</param>
        /// <remarks>
        /// <para>This should be the last call that you make in your callback because your application terminates as soon as this function is called.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-applicationrecoveryfinished#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void ApplicationRecoveryFinished(bool bSuccess);
        /// <inheritdoc cref = "CreateDirectory(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.SECURITY_ATTRIBUTES*)"/>
        internal static unsafe bool CreateDirectory(string lpPathName, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpSecurityAttributes)
        {
            fixed (char *lpPathNameLocal = lpPathName)
            {
                win32.System.SystemServices.SECURITY_ATTRIBUTES lpSecurityAttributesLocal = lpSecurityAttributes.HasValue ? lpSecurityAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                bool __result = Kernel32.CreateDirectory(lpPathNameLocal, lpSecurityAttributes.HasValue ? &lpSecurityAttributesLocal : null);
                return __result;
            }
        }

        /// <summary>Creates a new directory.</summary>
        /// <param name = "lpPathName">
        /// <para>The path of the directory to be created.</para>
        /// <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createdirectoryw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSecurityAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default security descriptor for a  directory are inherited from its parent directory.</para>
        /// <para>The target file system must support security on files and directories for this parameter to have an effect. (This is indicated when <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> returns <b>FS_PERSISTENT_ACLS</b>.)</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createdirectoryw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createdirectoryw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateDirectoryW", SetLastError = true)]
        internal static extern unsafe bool CreateDirectory(win32.System.SystemServices.PCWSTR lpPathName, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributes);
        /// <inheritdoc cref = "CreateFile(win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.FILE_ACCESS_FLAGS, win32.Storage.FileSystem.FILE_SHARE_MODE, win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.Storage.FileSystem.FILE_CREATION_DISPOSITION, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateFile(string lpFileName, win32.Storage.FileSystem.FILE_ACCESS_FLAGS dwDesiredAccess, win32.Storage.FileSystem.FILE_SHARE_MODE dwShareMode, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpSecurityAttributes, win32.Storage.FileSystem.FILE_CREATION_DISPOSITION dwCreationDisposition, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, SafeHandle hTemplateFile)
        {
            bool hTemplateFileAddRef = false;
            try
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    win32.System.SystemServices.SECURITY_ATTRIBUTES lpSecurityAttributesLocal = lpSecurityAttributes.HasValue ? lpSecurityAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                    win32.System.SystemServices.HANDLE hTemplateFileLocal;
                    if (hTemplateFile is object)
                    {
                        hTemplateFile.DangerousAddRef(ref hTemplateFileAddRef);
                        hTemplateFileLocal = (win32.System.SystemServices.HANDLE)hTemplateFile.DangerousGetHandle();
                    }
                    else
                        hTemplateFileLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.HANDLE __result = Kernel32.CreateFile(lpFileNameLocal, dwDesiredAccess, dwShareMode, lpSecurityAttributes.HasValue ? &lpSecurityAttributesLocal : null, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFileLocal);
                    return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hTemplateFileAddRef)
                    hTemplateFile.DangerousRelease();
            }
        }

        /// <summary>Creates or opens a file or I/O device. The most commonly used I/O devices are as follows:\_file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\\) in this name.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, use this Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
        /// <para>For information on special device names, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.</para>
        /// <para>To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">
        /// <para>The requested access to the file or device, which can be summarized as read, write, both or neither zero).</para>
        /// <para>The most commonly used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both (<c>GENERIC_READ | GENERIC_WRITE</c>). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>, <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>, <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.</para>
        /// <para>If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would have been denied.</para>
        /// <para>You cannot request an access mode that conflicts with the sharing mode that is specified by the <i>dwShareMode</i> parameter in an open request that already has an open handle.</para>
        /// <para>For more information, see the Remarks section of this topic and <a href = "https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwShareMode">
        /// <para>The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.</para>
        /// <para>If this parameter is zero and <b>CreateFile</b> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.</para>
        /// <para>You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <b>CreateFile</b> would fail and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function would return <b>ERROR_SHARING_VIOLATION</b>.</para>
        /// <para>To enable a process to share a file or device while another process has the file or device open, use a</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSecurityAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.</para>
        /// <para>This parameter can be <b>NULL</b>.</para>
        /// <para>If this parameter is <b>NULL</b>, the handle returned by <b>CreateFile</b> cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.</para>
        /// <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> for a file or device. If this member is <b>NULL</b>, the file or device associated with the returned handle is assigned a default security descriptor.</para>
        /// <para><b>CreateFile</b> ignores the <b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues to use the <b>bInheritHandle</b> member.</para>
        /// <para>The <b>bInheritHandle</b>member of the structure specifies whether the returned handle can be inherited.</para>
        /// <para>For more information, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwCreationDisposition">
        /// <para>An action to take on a file or device that exists or does not exist.</para>
        /// <para>For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.</para>
        /// <para>For more information, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlagsAndAttributes">
        /// <para>The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value for files. This parameter can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override <b>FILE_ATTRIBUTE_NORMAL</b>. This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any <b>FILE_ATTRIBUTE_*</b> values. This parameter can also contain Security Quality of Service (SQOS) information by specifying the <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables. <div class = "alert"><b>Note</b>  When <b>CreateFile</b> opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in <a href = "https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</div> <div> </div> Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that <b>CreateFile</b> can open. For additional information, see the Remarks section of this topic and <a href = "https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>. For more advanced access to file attributes, see <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list of all file attributes with their values and descriptions, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>. </para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTemplateFile">
        /// <para>A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file attributes and extended attributes for the file that is being created.</para>
        /// <para>This parameter can be <b>NULL</b>.</para>
        /// <para>When opening an existing file, <b>CreateFile</b> ignores this parameter.</para>
        /// <para>When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory. For additional information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.</para>
        /// <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateFileW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateFile(win32.System.SystemServices.PCWSTR lpFileName, win32.Storage.FileSystem.FILE_ACCESS_FLAGS dwDesiredAccess, win32.Storage.FileSystem.FILE_SHARE_MODE dwShareMode, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributes, win32.Storage.FileSystem.FILE_CREATION_DISPOSITION dwCreationDisposition, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, win32.System.SystemServices.HANDLE hTemplateFile);
        /// <inheritdoc cref = "DefineDosDevice(win32.Storage.FileSystem.DEFINE_DOS_DEVICE_FLAGS, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool DefineDosDevice(win32.Storage.FileSystem.DEFINE_DOS_DEVICE_FLAGS dwFlags, string lpDeviceName, string lpTargetPath)
        {
            fixed (char *lpTargetPathLocal = lpTargetPath)
            {
                fixed (char *lpDeviceNameLocal = lpDeviceName)
                {
                    bool __result = Kernel32.DefineDosDevice(dwFlags, lpDeviceNameLocal, lpTargetPathLocal);
                    return __result;
                }
            }
        }

        /// <summary>Defines, redefines, or deletes MS-DOS device names.</summary>
        /// <param name = "dwFlags">The controllable aspects of the <b>DefineDosDevice</b> function. This parameter</param>
        /// <param name = "lpDeviceName">
        /// <para>A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or deleting. The device name string must not have a colon as the last character, unless a drive letter is being defined, redefined, or deleted. For example, drive C  would be the string "C:". In no case is a trailing backslash ("\") allowed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-definedosdevicew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTargetPath">
        /// <para>A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the <b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-definedosdevicew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-definedosdevicew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "DefineDosDeviceW", SetLastError = true)]
        internal static extern bool DefineDosDevice(win32.Storage.FileSystem.DEFINE_DOS_DEVICE_FLAGS dwFlags, win32.System.SystemServices.PCWSTR lpDeviceName, win32.System.SystemServices.PCWSTR lpTargetPath);
        /// <inheritdoc cref = "DeleteFile(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool DeleteFile(string lpFileName)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                bool __result = Kernel32.DeleteFile(lpFileNameLocal);
                return __result;
            }
        }

        /// <summary>Deletes an existing file.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file to be deleted.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-deletefilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-deletefilew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "DeleteFileW", SetLastError = true)]
        internal static extern bool DeleteFile(win32.System.SystemServices.PCWSTR lpFileName);
        /// <inheritdoc cref = "DeleteVolumeMountPoint(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool DeleteVolumeMountPoint(string lpszVolumeMountPoint)
        {
            fixed (char *lpszVolumeMountPointLocal = lpszVolumeMountPoint)
            {
                bool __result = Kernel32.DeleteVolumeMountPoint(lpszVolumeMountPointLocal);
                return __result;
            }
        }

        /// <summary>Deletes a drive letter or mounted folder.</summary>
        /// <param name = "lpszVolumeMountPoint">
        /// <para>The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, "X:\" or "Y:\MountX\".</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-deletevolumemountpointw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-deletevolumemountpointw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "DeleteVolumeMountPointW", SetLastError = true)]
        internal static extern bool DeleteVolumeMountPoint(win32.System.SystemServices.PCWSTR lpszVolumeMountPoint);
        /// <summary>Closes a file search handle opened by the FindFirstFile, FindFirstFileEx, FindFirstFileNameW, FindFirstFileNameTransactedW, FindFirstFileTransacted, FindFirstStreamTransactedW, or FindFirstStreamW functions.</summary>
        /// <param name = "hFindFile">The file search handle.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findclose">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL FindClose(win32.Storage.FileSystem.FindFileHandle hFindFile);
        /// <summary>Stops change notification handle monitoring.</summary>
        /// <param name = "hChangeHandle">
        /// <para>A handle to a change notification handle created by the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstchangenotificationa">FindFirstChangeNotification</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findclosechangenotification#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findclosechangenotification">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL FindCloseChangeNotification(win32.Storage.FileSystem.FindChangeNotificationHandle hChangeHandle);
        /// <inheritdoc cref = "FindFirstChangeNotification(win32.System.SystemServices.PCWSTR, bool, win32.Storage.FileSystem.FILE_NOTIFY_CHANGE)"/>
        internal static unsafe Kernel32.FindCloseChangeNotificationSafeHandle FindFirstChangeNotification(string lpPathName, bool bWatchSubtree, win32.Storage.FileSystem.FILE_NOTIFY_CHANGE dwNotifyFilter)
        {
            fixed (char *lpPathNameLocal = lpPathName)
            {
                win32.Storage.FileSystem.FindChangeNotificationHandle __result = Kernel32.FindFirstChangeNotification(lpPathNameLocal, bWatchSubtree, dwNotifyFilter);
                return new Kernel32.FindCloseChangeNotificationSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "Kernel32.FindCloseChangeNotification"/>.
        /// </summary>
        internal class FindCloseChangeNotificationSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal FindCloseChangeNotificationSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal FindCloseChangeNotificationSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => Kernel32.FindCloseChangeNotification((win32.Storage.FileSystem.FindChangeNotificationHandle)this.handle);
        }

        /// <summary>Creates a change notification handle and sets up initial change notification filter conditions.</summary>
        /// <param name = "lpPathName">
        /// <para>The full path of the directory to be watched.</para>
        /// <para>This cannot be a relative path or an empty string.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstchangenotificationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bWatchSubtree">If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</param>
        /// <param name = "dwNotifyFilter"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
        /// <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstchangenotificationw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindFirstChangeNotificationW", SetLastError = true)]
        internal static extern win32.Storage.FileSystem.FindChangeNotificationHandle FindFirstChangeNotification(win32.System.SystemServices.PCWSTR lpPathName, bool bWatchSubtree, win32.Storage.FileSystem.FILE_NOTIFY_CHANGE dwNotifyFilter);
        /// <inheritdoc cref = "FindFirstFile(win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.WIN32_FIND_DATAW*)"/>
        internal static unsafe Kernel32.FindCloseSafeHandle FindFirstFile(string lpFileName, out win32.Storage.FileSystem.WIN32_FIND_DATAW lpFindFileData)
        {
            fixed (win32.Storage.FileSystem.WIN32_FIND_DATAW*lpFindFileDataLocal = &lpFindFileData)
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    win32.Storage.FileSystem.FindFileHandle __result = Kernel32.FindFirstFile(lpFileNameLocal, lpFindFileDataLocal);
                    return new Kernel32.FindCloseSafeHandle(__result, ownsHandle: true);
                }
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "Kernel32.FindClose"/>.
        /// </summary>
        internal class FindCloseSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal FindCloseSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal FindCloseSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => Kernel32.FindClose((win32.Storage.FileSystem.FindFileHandle)this.handle);
        }

        /// <summary>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).</summary>
        /// <param name = "lpFileName">
        /// <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk (*) or a question mark (?).</para>
        /// <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\).</para>
        /// <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to the root and all subdirectories on the path.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFindFileData">
        /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that receives information about a found file or directory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a search handle used in a subsequent call to <a href = "/windows/desktop/api/fileapi/nf-fileapi-findnextfilew">FindNextFile</a> or <a href = "/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the <i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
        /// <para>If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// <para>If the function fails because no matching files can be found, the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_FILE_NOT_FOUND</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfilew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindFirstFileW", SetLastError = true)]
        internal static extern unsafe win32.Storage.FileSystem.FindFileHandle FindFirstFile(win32.System.SystemServices.PCWSTR lpFileName, win32.Storage.FileSystem.WIN32_FIND_DATAW*lpFindFileData);
        /// <inheritdoc cref = "FindFirstFileEx(win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.FINDEX_INFO_LEVELS, void *, win32.Storage.FileSystem.FINDEX_SEARCH_OPS, void *, win32.Storage.FileSystem.FIND_FIRST_EX_FLAGS)"/>
        internal static unsafe Kernel32.FindCloseSafeHandle FindFirstFileEx(string lpFileName, win32.Storage.FileSystem.FINDEX_INFO_LEVELS fInfoLevelId, void *lpFindFileData, win32.Storage.FileSystem.FINDEX_SEARCH_OPS fSearchOp, void *lpSearchFilter, win32.Storage.FileSystem.FIND_FIRST_EX_FLAGS dwAdditionalFlags)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                win32.Storage.FileSystem.FindFileHandle __result = Kernel32.FindFirstFileEx(lpFileNameLocal, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
                return new Kernel32.FindCloseSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Searches a directory for a file or subdirectory with a name and attributes that match those specified.</summary>
        /// <param name = "lpFileName">
        /// <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk (*) or a question mark (?).</para>
        /// <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\).</para>
        /// <para>If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all subdirectories on the path.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fInfoLevelId">
        /// <para>The information level of the returned data.</para>
        /// <para>This parameter is one of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_info_levels">FINDEX_INFO_LEVELS</a> enumeration values.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFindFileData">
        /// <para>A pointer to the buffer that receives the file data.</para>
        /// <para>The pointer type is determined by the level of information that is specified in the <i>fInfoLevelId</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fSearchOp">
        /// <para>The type of filtering to perform that is different from wildcard matching.</para>
        /// <para>This parameter is one of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> enumeration values.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSearchFilter">
        /// <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information.</para>
        /// <para>At this time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer must be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwAdditionalFlags">
        /// <para>Specifies additional flags that control the search.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a search handle used in a subsequent call to <a href = "/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or <a href = "/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the <i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
        /// <para>If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfileexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindFirstFileExW", SetLastError = true)]
        internal static extern unsafe win32.Storage.FileSystem.FindFileHandle FindFirstFileEx(win32.System.SystemServices.PCWSTR lpFileName, win32.Storage.FileSystem.FINDEX_INFO_LEVELS fInfoLevelId, void *lpFindFileData, win32.Storage.FileSystem.FINDEX_SEARCH_OPS fSearchOp, void *lpSearchFilter, win32.Storage.FileSystem.FIND_FIRST_EX_FLAGS dwAdditionalFlags);
        /// <summary>Closes the specified volume search handle.</summary>
        /// <param name = "hFindVolume">
        /// <para>The volume search handle to be closed. This handle must have been previously opened by the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findvolumeclose#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findvolumeclose">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL FindVolumeClose(win32.Storage.FileSystem.FindVolumeHandle hFindVolume);
        /// <inheritdoc cref = "FindFirstVolume(win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe Kernel32.FindVolumeCloseSafeHandle FindFirstVolume_SafeHandle(win32.System.SystemServices.PWSTR lpszVolumeName, uint cchBufferLength)
        {
            win32.Storage.FileSystem.FindVolumeHandle __result = Kernel32.FindFirstVolume(lpszVolumeName, cchBufferLength);
            return new Kernel32.FindVolumeCloseSafeHandle(__result, ownsHandle: true);
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "Kernel32.FindVolumeClose"/>.
        /// </summary>
        internal class FindVolumeCloseSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal FindVolumeCloseSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal FindVolumeCloseSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => Kernel32.FindVolumeClose((win32.Storage.FileSystem.FindVolumeHandle)this.handle);
        }

        /// <summary>Retrieves the name of a volume on a computer.</summary>
        /// <param name = "lpszVolumeName">
        /// <para>A pointer to a buffer that receives a null-terminated string that specifies a volume <b>GUID</b> path for the first volume that is found.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstvolumew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchBufferLength">
        /// <para>The length of the buffer to receive the volume <b>GUID</b> path, in <b>TCHARs</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstvolumew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a search handle used in a subsequent call to the <a href = "/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> and <a href = "/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> functions.</para>
        /// <para>If the function fails to find any volumes, the return value is the <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstvolumew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindFirstVolumeW", SetLastError = true)]
        internal static extern win32.Storage.FileSystem.FindVolumeHandle FindFirstVolume(win32.System.SystemServices.PWSTR lpszVolumeName, uint cchBufferLength);
        /// <inheritdoc cref = "FindNextChangeNotification(win32.Storage.FileSystem.FindChangeNotificationHandle)"/>
        internal static unsafe bool FindNextChangeNotification(SafeHandle hChangeHandle)
        {
            bool hChangeHandleAddRef = false;
            try
            {
                win32.Storage.FileSystem.FindChangeNotificationHandle hChangeHandleLocal;
                if (hChangeHandle is object)
                {
                    hChangeHandle.DangerousAddRef(ref hChangeHandleAddRef);
                    hChangeHandleLocal = (win32.Storage.FileSystem.FindChangeNotificationHandle)hChangeHandle.DangerousGetHandle();
                }
                else
                    hChangeHandleLocal = default(win32.Storage.FileSystem.FindChangeNotificationHandle);
                bool __result = Kernel32.FindNextChangeNotification(hChangeHandleLocal);
                return __result;
            }
            finally
            {
                if (hChangeHandleAddRef)
                    hChangeHandle.DangerousRelease();
            }
        }

        /// <summary>Requests that the operating system signal a change notification handle the next time it detects an appropriate change.</summary>
        /// <param name = "hChangeHandle">
        /// <para>A handle to a change notification handle created by the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstchangenotificationa">FindFirstChangeNotification</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextchangenotification#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextchangenotification">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool FindNextChangeNotification(win32.Storage.FileSystem.FindChangeNotificationHandle hChangeHandle);
        /// <inheritdoc cref = "FindNextFile(win32.System.SystemServices.HANDLE, win32.Storage.FileSystem.WIN32_FIND_DATAW*)"/>
        internal static unsafe bool FindNextFile(SafeHandle hFindFile, out win32.Storage.FileSystem.WIN32_FIND_DATAW lpFindFileData)
        {
            bool hFindFileAddRef = false;
            try
            {
                fixed (win32.Storage.FileSystem.WIN32_FIND_DATAW*lpFindFileDataLocal = &lpFindFileData)
                {
                    win32.System.SystemServices.HANDLE hFindFileLocal;
                    if (hFindFile is object)
                    {
                        hFindFile.DangerousAddRef(ref hFindFileAddRef);
                        hFindFileLocal = (win32.System.SystemServices.HANDLE)hFindFile.DangerousGetHandle();
                    }
                    else
                        hFindFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.FindNextFile(hFindFileLocal, lpFindFileDataLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFindFileAddRef)
                    hFindFile.DangerousRelease();
            }
        }

        /// <summary>Continues a file search from a previous call to the FindFirstFile, FindFirstFileEx, or FindFirstFileTransacted functions.</summary>
        /// <param name = "hFindFile">
        /// <para>The search handle returned by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfileexa">FindFirstFileEx</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFindFileData">
        /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that receives information about the found file or subdirectory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero and  the <i>lpFindFileData</i> parameter contains information about the next file or directory found.</para>
        /// <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// <para>If the function fails because no more matching files can be found, the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_NO_MORE_FILES</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextfilew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindNextFileW", SetLastError = true)]
        internal static extern unsafe bool FindNextFile(win32.System.SystemServices.HANDLE hFindFile, win32.Storage.FileSystem.WIN32_FIND_DATAW*lpFindFileData);
        /// <summary>Continues a volume search started by a call to the FindFirstVolume function.</summary>
        /// <param name = "hFindVolume">
        /// <para>The volume search handle returned by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextvolumew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path that is found.</param>
        /// <param name = "cchBufferLength">
        /// <para>The length of the buffer that receives the volume <b>GUID</b> path, in <b>TCHARs</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextvolumew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no matching files can be found, the <b>GetLastError</b> function returns the <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the <a href = "/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextvolumew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindNextVolumeW", SetLastError = true)]
        internal static extern bool FindNextVolume(win32.Storage.FileSystem.FindVolumeHandle hFindVolume, win32.System.SystemServices.PWSTR lpszVolumeName, uint cchBufferLength);
        /// <inheritdoc cref = "FlushFileBuffers(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool FlushFileBuffers(SafeHandle hFile)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.FlushFileBuffers(hFileLocal);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Flushes the buffers of a specified file and causes all buffered data to be written to a file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the open file.</para>
        /// <para>The file handle must have the <b>GENERIC_WRITE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para>If <i>hFile</i> is a handle to a communications device, the function only flushes the transmit buffer.</para>
        /// <para>If <i>hFile</i> is a handle to the server end of a named pipe, the function does not return until the client has read all buffered data from the pipe.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-flushfilebuffers#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>The function fails if <i>hFile</i> is a handle to the console output. That is because the console output is not buffered. The function returns <b>FALSE</b>, and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_HANDLE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-flushfilebuffers">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool FlushFileBuffers(win32.System.SystemServices.HANDLE hFile);
        /// <inheritdoc cref = "GetDiskFreeSpace(win32.System.SystemServices.PCWSTR, uint *, uint *, uint *, uint *)"/>
        internal static unsafe bool GetDiskFreeSpace(string lpRootPathName, uint *lpSectorsPerCluster, uint *lpBytesPerSector, uint *lpNumberOfFreeClusters, uint *lpTotalNumberOfClusters)
        {
            fixed (char *lpRootPathNameLocal = lpRootPathName)
            {
                bool __result = Kernel32.GetDiskFreeSpace(lpRootPathNameLocal, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
                return __result;
            }
        }

        /// <summary>Retrieves information about the specified disk, including the amount of free space on the disk.</summary>
        /// <param name = "lpRootPathName">
        /// <para>The root directory of the disk for which information is to be returned. If this parameter is <b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name, it must include a trailing backslash (for example, "\\\\MyServer\\MyShare\\"). Furthermore, a drive specification must have a trailing backslash (for example, "C:\\"). The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this  directory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespacew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSectorsPerCluster">A pointer to a variable that receives the number of sectors per cluster.</param>
        /// <param name = "lpBytesPerSector">A pointer to a variable that receives the number of bytes per sector.</param>
        /// <param name = "lpNumberOfFreeClusters">
        /// <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the user who is associated with the calling thread.</para>
        /// <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the disk.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespacew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTotalNumberOfClusters">
        /// <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user who is associated with the calling thread.</para>
        /// <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespacew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespacew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetDiskFreeSpaceW", SetLastError = true)]
        internal static extern unsafe bool GetDiskFreeSpace(win32.System.SystemServices.PCWSTR lpRootPathName, [Optional] uint *lpSectorsPerCluster, [Optional] uint *lpBytesPerSector, [Optional] uint *lpNumberOfFreeClusters, [Optional] uint *lpTotalNumberOfClusters);
        /// <inheritdoc cref = "GetDiskFreeSpaceEx(win32.System.SystemServices.PCWSTR, ulong *, ulong *, ulong *)"/>
        internal static unsafe bool GetDiskFreeSpaceEx(string lpDirectoryName, ulong *lpFreeBytesAvailableToCaller, ulong *lpTotalNumberOfBytes, ulong *lpTotalNumberOfFreeBytes)
        {
            fixed (char *lpDirectoryNameLocal = lpDirectoryName)
            {
                bool __result = Kernel32.GetDiskFreeSpaceEx(lpDirectoryNameLocal, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
                return __result;
            }
        }

        /// <summary>Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free space, and the total amount of free space available to the user that is associated with the calling thread.</summary>
        /// <param name = "lpDirectoryName">
        /// <para>A directory on the disk.</para>
        /// <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
        /// <para>If this parameter is a UNC name, it must include a trailing backslash, for example, "\\\\MyServer\\MyShare\\".</para>
        /// <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a disk.</para>
        /// <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this directory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespaceexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFreeBytesAvailableToCaller">
        /// <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user who is associated with the calling thread.</para>
        /// <para>This parameter can be <b>NULL</b>.</para>
        /// <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespaceexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTotalNumberOfBytes">
        /// <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who is associated with the calling thread.</para>
        /// <para>This parameter can be <b>NULL</b>.</para>
        /// <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
        /// <para>To determine the total number of bytes on a disk or volume, use <a href = "https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespaceexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTotalNumberOfFreeBytes">
        /// <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
        /// <para>This parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespaceexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespaceexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetDiskFreeSpaceExW", SetLastError = true)]
        internal static extern unsafe bool GetDiskFreeSpaceEx(win32.System.SystemServices.PCWSTR lpDirectoryName, [Optional] ulong *lpFreeBytesAvailableToCaller, [Optional] ulong *lpTotalNumberOfBytes, [Optional] ulong *lpTotalNumberOfFreeBytes);
        /// <inheritdoc cref = "GetDiskSpaceInformation(win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.DISK_SPACE_INFORMATION*)"/>
        internal static unsafe win32.System.Com.HRESULT GetDiskSpaceInformation(string rootPath, out win32.Storage.FileSystem.DISK_SPACE_INFORMATION diskSpaceInfo)
        {
            fixed (win32.Storage.FileSystem.DISK_SPACE_INFORMATION*diskSpaceInfoLocal = &diskSpaceInfo)
            {
                fixed (char *rootPathLocal = rootPath)
                {
                    win32.System.Com.HRESULT __result = Kernel32.GetDiskSpaceInformation(rootPathLocal, diskSpaceInfoLocal);
                    return __result;
                }
            }
        }

        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetDiskSpaceInformationW")]
        internal static extern unsafe win32.System.Com.HRESULT GetDiskSpaceInformation(win32.System.SystemServices.PCWSTR rootPath, win32.Storage.FileSystem.DISK_SPACE_INFORMATION*diskSpaceInfo);
        /// <inheritdoc cref = "GetDriveType(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe uint GetDriveType(string lpRootPathName)
        {
            fixed (char *lpRootPathNameLocal = lpRootPathName)
            {
                uint __result = Kernel32.GetDriveType(lpRootPathNameLocal);
                return __result;
            }
        }

        /// <summary>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.</summary>
        /// <param name = "lpRootPathName">
        /// <para>The root directory for the drive.</para>
        /// <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the root of the current directory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdrivetypew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>The return value specifies the type of drive, which can be one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdrivetypew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetDriveTypeW")]
        internal static extern uint GetDriveType(win32.System.SystemServices.PCWSTR lpRootPathName);
        /// <inheritdoc cref = "GetFileAttributes(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe uint GetFileAttributes(string lpFileName)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                uint __result = Kernel32.GetFileAttributes(lpFileNameLocal);
                return __result;
            }
        }

        /// <summary>Retrieves file system attributes for a specified file or directory.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file or directory.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesW</b>), and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>. <div class = "alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileattributesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a list of attribute values and their descriptions, see <a href = "/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
        /// <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileattributesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetFileAttributesW", SetLastError = true)]
        internal static extern uint GetFileAttributes(win32.System.SystemServices.PCWSTR lpFileName);
        /// <inheritdoc cref = "GetFileAttributesEx(win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.GET_FILEEX_INFO_LEVELS, void *)"/>
        internal static unsafe bool GetFileAttributesEx(string lpFileName, win32.Storage.FileSystem.GET_FILEEX_INFO_LEVELS fInfoLevelId, void *lpFileInformation)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                bool __result = Kernel32.GetFileAttributesEx(lpFileNameLocal, fInfoLevelId, lpFileInformation);
                return __result;
            }
        }

        /// <summary>Retrieves attributes for a specified file or directory.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file or directory.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesExW</b>), and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileattributesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fInfoLevelId">
        /// <para>A class of attribute information to retrieve.</para>
        /// <para>This parameter can be the following value from the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> enumeration.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileattributesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileInformation">
        /// <para>A pointer to a buffer that receives the attribute information.</para>
        /// <para>The type of attribute information that is stored into this buffer is determined by the value of <i>fInfoLevelId</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileattributesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileattributesexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetFileAttributesExW", SetLastError = true)]
        internal static extern unsafe bool GetFileAttributesEx(win32.System.SystemServices.PCWSTR lpFileName, win32.Storage.FileSystem.GET_FILEEX_INFO_LEVELS fInfoLevelId, void *lpFileInformation);
        /// <inheritdoc cref = "GetFileInformationByHandle(win32.System.SystemServices.HANDLE, win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION*)"/>
        internal static unsafe bool GetFileInformationByHandle(SafeHandle hFile, out win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION lpFileInformation)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION*lpFileInformationLocal = &lpFileInformation)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetFileInformationByHandle(hFileLocal, lpFileInformationLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves file information for the specified file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file that contains the information to be retrieved.</para>
        /// <para>This handle should not be a pipe handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileinformationbyhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileInformation">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-by_handle_file_information">BY_HANDLE_FILE_INFORMATION</a> structure that receives the file information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileinformationbyhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero and file information data is contained in the buffer pointed to by the <i>lpFileInformation</i> parameter.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileinformationbyhandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetFileInformationByHandle(win32.System.SystemServices.HANDLE hFile, win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION*lpFileInformation);
        /// <inheritdoc cref = "GetFileSize(win32.System.SystemServices.HANDLE, uint *)"/>
        internal static unsafe uint GetFileSize(SafeHandle hFile, uint *lpFileSizeHigh)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.GetFileSize(hFileLocal, lpFileSizeHigh);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the size of the specified file, in bytes.</summary>
        /// <param name = "hFile">A handle to the file.</param>
        /// <param name = "lpFileSizeHigh">
        /// <para>A pointer to the variable where the high-order doubleword of the file size is returned. This parameter can be <b>NULL</b> if the application does not require the high-order doubleword.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfilesize#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the low-order doubleword of the file size, and, if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order doubleword of the file size into the variable pointed to by that parameter.</para>
        /// <para>If the function fails and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. When <i>lpFileSizeHigh</i> is <b>NULL</b>, the results returned for large files are ambiguous, and you will not be able to determine the actual size of the file. It is recommended that you use <a href = "/windows/desktop/api/fileapi/nf-fileapi-getfilesizeex">GetFileSizeEx</a> instead.</para>
        /// <para>If the function fails and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b> and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return a value other than <b>NO_ERROR</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfilesize">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint GetFileSize(win32.System.SystemServices.HANDLE hFile, [Optional] uint *lpFileSizeHigh);
        /// <inheritdoc cref = "GetFileSizeEx(win32.System.SystemServices.HANDLE, long *)"/>
        internal static unsafe bool GetFileSizeEx(SafeHandle hFile, out long lpFileSize)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (long *lpFileSizeLocal = &lpFileSize)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetFileSizeEx(hFileLocal, lpFileSizeLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the size of the specified file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file. The handle must have been created with the <b>FILE_READ_ATTRIBUTES</b> access right or equivalent, or the caller must have sufficient permission on the directory that contains the file. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfilesizeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileSize">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a> structure that receives the file size, in bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfilesizeex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfilesizeex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetFileSizeEx(win32.System.SystemServices.HANDLE hFile, long *lpFileSize);
        /// <inheritdoc cref = "GetFileType(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint GetFileType(SafeHandle hFile)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.GetFileType(hFileLocal);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the file type of the specified file.</summary>
        /// <param name = "hFile">A handle to the file.</param>
        /// <returns>
        /// <para>The function returns one of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfiletype">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetFileType(win32.System.SystemServices.HANDLE hFile);
        /// <inheritdoc cref = "GetFinalPathNameByHandle(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PWSTR, uint, win32.Storage.FileSystem.FILE_NAME)"/>
        internal static unsafe uint GetFinalPathNameByHandle(SafeHandle hFile, win32.System.SystemServices.PWSTR lpszFilePath, uint cchFilePath, win32.Storage.FileSystem.FILE_NAME dwFlags)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.GetFinalPathNameByHandle(hFileLocal, lpszFilePath, cchFilePath, dwFlags);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the final path for the specified file.</summary>
        /// <param name = "hFile">A handle to a file or directory.</param>
        /// <param name = "lpszFilePath">A pointer to a buffer that receives the path of <i>hFile</i>.</param>
        /// <param name = "cchFilePath">The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length of the string received by <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the size of the terminating null character.</para>
        /// <para><b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function, <b>GetFinalPathNameByHandleA</b>, the return value includes the size of the terminating null character.</para>
        /// <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the terminating null character, the return value is the required buffer size, in <b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
        /// <para>If the function fails for any other reason, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfinalpathnamebyhandlew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetFinalPathNameByHandleW", SetLastError = true)]
        internal static extern uint GetFinalPathNameByHandle(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.PWSTR lpszFilePath, uint cchFilePath, win32.Storage.FileSystem.FILE_NAME dwFlags);
        /// <inheritdoc cref = "GetFullPathName(win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PWSTR, win32.System.SystemServices.PWSTR*)"/>
        internal static unsafe uint GetFullPathName(string lpFileName, uint nBufferLength, win32.System.SystemServices.PWSTR lpBuffer, win32.System.SystemServices.PWSTR*lpFilePart)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                uint __result = Kernel32.GetFullPathName(lpFileNameLocal, nBufferLength, lpBuffer, lpFilePart);
                return __result;
            }
        }

        /// <summary>Retrieves the full path and file name of the specified file.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the  file.</para>
        /// <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume name.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>), and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFullPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfullpathnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBufferLength">
        /// <para>The size of the buffer to receive the null-terminated string for the drive and path, in <b>TCHARs</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfullpathnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">A pointer to a buffer that receives the null-terminated string for the  drive and path.</param>
        /// <param name = "lpFilePart">
        /// <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final file name component in the path.</para>
        /// <para>This parameter can be  <b>NULL</b>.</para>
        /// <para>If <i>lpBuffer</i> refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfullpathnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
        /// <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
        /// <para>If the function fails for any other reason, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfullpathnamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetFullPathNameW", SetLastError = true)]
        internal static extern unsafe uint GetFullPathName(win32.System.SystemServices.PCWSTR lpFileName, uint nBufferLength, win32.System.SystemServices.PWSTR lpBuffer, [Optional] win32.System.SystemServices.PWSTR*lpFilePart);
        /// <summary>Retrieves a bitmask representing the currently available disk drives.</summary>
        /// <returns>
        /// <para>If the function succeeds, the return value is a bitmask representing the currently available disk drives. Bit position 0 (the least-significant bit) is drive A, bit position 1 is drive B, bit position 2 is drive C, and so on.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlogicaldrives">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint GetLogicalDrives();
        /// <summary>Fills a buffer with strings that specify valid drives in the system.</summary>
        /// <param name = "nBufferLength">
        /// <para>The maximum size of the buffer pointed to by <i>lpBuffer</i>, in <b>TCHARs</b>. This size does not include the terminating null character. If this parameter is zero, <i>lpBuffer</i> is not used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlogicaldrivestringsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the system, plus with an additional null character. Each string is a device name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlogicaldrivestringsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</para>
        /// <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>. It is the size of the buffer required to hold the drive strings.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlogicaldrivestringsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetLogicalDriveStringsW", SetLastError = true)]
        internal static extern uint GetLogicalDriveStrings(uint nBufferLength, win32.System.SystemServices.PWSTR lpBuffer);
        /// <inheritdoc cref = "GetLongPathName(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint GetLongPathName(string lpszShortPath, win32.System.SystemServices.PWSTR lpszLongPath, uint cchBuffer)
        {
            fixed (char *lpszShortPathLocal = lpszShortPath)
            {
                uint __result = Kernel32.GetLongPathName(lpszShortPathLocal, lpszLongPath, cchBuffer);
                return __result;
            }
        }

        /// <summary>Converts the specified path to its long form.</summary>
        /// <param name = "lpszShortPath">
        /// <para>The path to be converted.</para>
        /// <para>In the ANSI version of this function, <b>GetLongPathNameA</b>, the name is limited to <b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function, <b>GetLongPathNameW</b>, and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlongpathnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszLongPath">
        /// <para>A pointer to the buffer to receive the long path.</para>
        /// <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlongpathnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchBuffer">
        /// <para>The size of the buffer <i>lpszLongPath</i> points to, in <b>TCHARs</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlongpathnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
        /// <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
        /// <para>If the function fails for any other reason, such as if the file does not exist, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlongpathnamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetLongPathNameW", SetLastError = true)]
        internal static extern uint GetLongPathName(win32.System.SystemServices.PCWSTR lpszShortPath, win32.System.SystemServices.PWSTR lpszLongPath, uint cchBuffer);
        /// <inheritdoc cref = "GetShortPathName(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint GetShortPathName(string lpszLongPath, win32.System.SystemServices.PWSTR lpszShortPath, uint cchBuffer)
        {
            fixed (char *lpszLongPathLocal = lpszLongPath)
            {
                uint __result = Kernel32.GetShortPathName(lpszLongPathLocal, lpszShortPath, cchBuffer);
                return __result;
            }
        }

        /// <summary>Retrieves the short path form of the specified path.</summary>
        /// <param name = "lpszLongPath">
        /// <para>The path string.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getshortpathnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszShortPath">
        /// <para>A pointer to a buffer to receive the null-terminated short form of the path that <i>lpszLongPath</i> specifies.</para>
        /// <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i> will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getshortpathnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchBuffer">
        /// <para>The size of the buffer  that <i>lpszShortPath</i> points to, in <b>TCHARs</b>.</para>
        /// <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getshortpathnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string that is copied to <i>lpszShortPath</i>, not including the terminating null character.</para>
        /// <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the terminating null character.</para>
        /// <para>If the function fails for any other reason, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getshortpathnamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetShortPathNameW", SetLastError = true)]
        internal static extern uint GetShortPathName(win32.System.SystemServices.PCWSTR lpszLongPath, win32.System.SystemServices.PWSTR lpszShortPath, uint cchBuffer);
        /// <inheritdoc cref = "GetTempFileName(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe uint GetTempFileName(string lpPathName, string lpPrefixString, uint uUnique, win32.System.SystemServices.PWSTR lpTempFileName)
        {
            fixed (char *lpPrefixStringLocal = lpPrefixString)
            {
                fixed (char *lpPathNameLocal = lpPathName)
                {
                    uint __result = Kernel32.GetTempFileName(lpPathNameLocal, lpPrefixStringLocal, uUnique, lpTempFileName);
                    return __result;
                }
            }
        }

        /// <summary>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.</summary>
        /// <param name = "lpPathName">
        /// <para>The directory path for the file name. Applications typically specify a period (.) for the current directory or the result of the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-gettemppatha">GetTempPath</a> function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or <b>GetTempFileName</b> will fail. If this parameter is <b>NULL</b>, the function fails.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettempfilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpPrefixString">
        /// <para>The null-terminated prefix string. The function uses up to the first three characters of this string as the prefix of the file name. This string must consist of characters in the OEM-defined character set.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettempfilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uUnique">
        /// <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
        /// <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the file already exists, the number is increased by one and the functions tests if this file already exists. This continues until a unique filename is found; the function creates a file by that name and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when <i>uUnique</i> is nonzero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettempfilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTempFileName">
        /// <para>A pointer to the buffer that receives the temporary file name. This buffer should be <b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettempfilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same number.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>The following is a possible return value.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettempfilenamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetTempFileNameW", SetLastError = true)]
        internal static extern uint GetTempFileName(win32.System.SystemServices.PCWSTR lpPathName, win32.System.SystemServices.PCWSTR lpPrefixString, uint uUnique, win32.System.SystemServices.PWSTR lpTempFileName);
        /// <inheritdoc cref = "GetVolumeInformationByHandle(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PWSTR, uint, uint *, uint *, uint *, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe bool GetVolumeInformationByHandle(SafeHandle hFile, win32.System.SystemServices.PWSTR lpVolumeNameBuffer, uint nVolumeNameSize, uint *lpVolumeSerialNumber, uint *lpMaximumComponentLength, uint *lpFileSystemFlags, win32.System.SystemServices.PWSTR lpFileSystemNameBuffer, uint nFileSystemNameSize)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.GetVolumeInformationByHandle(hFileLocal, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about the file system and volume associated with the specified file.</summary>
        /// <param name = "hFile">A handle to the file.</param>
        /// <param name = "lpVolumeNameBuffer">
        /// <para>A pointer to a buffer that receives the name of a specified volume. The maximum buffer size is <c>MAX_PATH+1</c>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationbyhandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nVolumeNameSize">
        /// <para>The length of a volume name buffer, in <b>WCHAR</b>s. The maximum buffer size is <c>MAX_PATH+1</c>.</para>
        /// <para>This parameter is ignored if the volume name buffer is not supplied.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationbyhandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpVolumeSerialNumber">
        /// <para>A pointer to a variable that receives the volume serial number.</para>
        /// <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
        /// <para>This function returns the volume serial number that the operating system assigns when a hard disk is formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the Windows Management Instrumentation (WMI) <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a> property <b>SerialNumber</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationbyhandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMaximumComponentLength">
        /// <para>A pointer to a variable that receives the maximum length, in <b>WCHAR</b>s, of a file name component  that a specified file system supports.</para>
        /// <para>A file name component is the portion of a file name between backslashes.</para>
        /// <para>The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to is used to indicate that a specified file system supports long names. For example, for a FAT file system that supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can also be supported on systems that use the NTFS file system.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationbyhandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileSystemFlags">
        /// <para>A pointer to a variable that receives flags associated with the specified file system.</para>
        /// <para>This parameter can be one or more of the following flags. However, <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually exclusive.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationbyhandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileSystemNameBuffer">
        /// <para>A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationbyhandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nFileSystemNameSize">
        /// <para>The length of the file system name buffer, in <b>WCHAR</b>s. The maximum buffer size is <c>MAX_PATH+1</c>.</para>
        /// <para>This parameter is ignored if the file system name buffer is not supplied.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationbyhandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If all the requested information is retrieved, the return value is nonzero.</para>
        /// <para>If not all the requested information is retrieved, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationbyhandlew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetVolumeInformationByHandleW", SetLastError = true)]
        internal static extern unsafe bool GetVolumeInformationByHandle(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.PWSTR lpVolumeNameBuffer, uint nVolumeNameSize, [Optional] uint *lpVolumeSerialNumber, [Optional] uint *lpMaximumComponentLength, [Optional] uint *lpFileSystemFlags, win32.System.SystemServices.PWSTR lpFileSystemNameBuffer, uint nFileSystemNameSize);
        /// <inheritdoc cref = "GetVolumeInformation(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint, uint *, uint *, uint *, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe bool GetVolumeInformation(string lpRootPathName, win32.System.SystemServices.PWSTR lpVolumeNameBuffer, uint nVolumeNameSize, uint *lpVolumeSerialNumber, uint *lpMaximumComponentLength, uint *lpFileSystemFlags, win32.System.SystemServices.PWSTR lpFileSystemNameBuffer, uint nFileSystemNameSize)
        {
            fixed (char *lpRootPathNameLocal = lpRootPathName)
            {
                bool __result = Kernel32.GetVolumeInformation(lpRootPathNameLocal, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
                return __result;
            }
        }

        /// <summary>Retrieves information about the file system and volume associated with the specified root directory.</summary>
        /// <param name = "lpRootPathName">
        /// <para>A pointer to a string that contains the root directory of the volume to be described.</para>
        /// <para>If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing backslash is required. For example, you  specify \\MyServer\MyShare as "\\MyServer\MyShare\", or the C drive as "C:\".</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpVolumeNameBuffer">
        /// <para>A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the <i>nVolumeNameSize</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nVolumeNameSize">
        /// <para>The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>+1.</para>
        /// <para>This parameter is ignored if the volume name buffer is not supplied.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpVolumeSerialNumber">
        /// <para>A pointer to a variable that receives the volume serial number.</para>
        /// <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
        /// <para>This function returns the volume serial number that the operating system assigns when a hard disk is formatted.  To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the Windows Management Instrumentation (WMI) <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a>  property <b>SerialNumber</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMaximumComponentLength">
        /// <para>A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file name component  that a specified file system supports.</para>
        /// <para>A file name component is the portion of a file name between backslashes.</para>
        /// <para>The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to is used to indicate that a specified file system supports long names. For example, for a FAT file system that supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can also be supported on systems that use the NTFS file system.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileSystemFlags">
        /// <para>A pointer to a variable that receives flags associated with the specified file system.</para>
        /// <para>This parameter can be one or more of the following flags. However, <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually exclusive.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileSystemNameBuffer">
        /// <para>A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nFileSystemNameSize">
        /// <para>The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>+1.</para>
        /// <para>This parameter is ignored if the file system name buffer is not supplied.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If all the requested information is retrieved, the return value is nonzero.</para>
        /// <para>If not all the requested information is retrieved, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetVolumeInformationW", SetLastError = true)]
        internal static extern unsafe bool GetVolumeInformation(win32.System.SystemServices.PCWSTR lpRootPathName, win32.System.SystemServices.PWSTR lpVolumeNameBuffer, uint nVolumeNameSize, [Optional] uint *lpVolumeSerialNumber, [Optional] uint *lpMaximumComponentLength, [Optional] uint *lpFileSystemFlags, win32.System.SystemServices.PWSTR lpFileSystemNameBuffer, uint nFileSystemNameSize);
        /// <inheritdoc cref = "GetVolumePathName(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe bool GetVolumePathName(string lpszFileName, win32.System.SystemServices.PWSTR lpszVolumePathName, uint cchBufferLength)
        {
            fixed (char *lpszFileNameLocal = lpszFileName)
            {
                bool __result = Kernel32.GetVolumePathName(lpszFileNameLocal, lpszVolumePathName, cchBufferLength);
                return __result;
            }
        }

        /// <summary>Retrieves the volume mount point where the specified path is mounted.</summary>
        /// <param name = "lpszFileName">
        /// <para>A pointer to the input path string. Both absolute and relative file and directory names, for example, "..", are acceptable in this path.</para>
        /// <para>If you specify a relative directory or file name without a volume qualifier, **GetVolumePathName** returns the drive letter of the boot volume.</para>
        /// <para>If this parameter is an empty string, "", the function fails but the last error is set to **ERROR_SUCCESS**.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumepathnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszVolumePathName">A pointer to a string that receives the volume mount point for the input path.</param>
        /// <param name = "cchBufferLength">The length of the output buffer, in **TCHARs**.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumepathnamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetVolumePathNameW", SetLastError = true)]
        internal static extern bool GetVolumePathName(win32.System.SystemServices.PCWSTR lpszFileName, win32.System.SystemServices.PWSTR lpszVolumePathName, uint cchBufferLength);
        /// <inheritdoc cref = "LockFile(win32.System.SystemServices.HANDLE, uint, uint, uint, uint)"/>
        internal static unsafe bool LockFile(SafeHandle hFile, uint dwFileOffsetLow, uint dwFileOffsetHigh, uint nNumberOfBytesToLockLow, uint nNumberOfBytesToLockHigh)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.LockFile(hFileLocal, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Locks the specified file for exclusive access by the calling process.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file. The file handle must have been created with the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-lockfile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFileOffsetLow">The low-order 32 bits of the starting byte offset in the file where the lock should begin.</param>
        /// <param name = "dwFileOffsetHigh">The high-order 32 bits of the starting byte offset in the file where the lock should begin.</param>
        /// <param name = "nNumberOfBytesToLockLow">The low-order 32 bits of the length of the byte range to be locked.</param>
        /// <param name = "nNumberOfBytesToLockHigh">The high-order 32 bits of the length of the byte range to be locked.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero (<b>TRUE</b>).</para>
        /// <para>If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-lockfile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool LockFile(win32.System.SystemServices.HANDLE hFile, uint dwFileOffsetLow, uint dwFileOffsetHigh, uint nNumberOfBytesToLockLow, uint nNumberOfBytesToLockHigh);
        /// <inheritdoc cref = "LockFileEx(win32.System.SystemServices.HANDLE, win32.Storage.FileSystem.LOCK_FILE_FLAGS, uint, uint, uint, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool LockFileEx(SafeHandle hFile, win32.Storage.FileSystem.LOCK_FILE_FLAGS dwFlags, uint dwReserved, uint nNumberOfBytesToLockLow, uint nNumberOfBytesToLockHigh, ref win32.System.SystemServices.OVERLAPPED lpOverlapped)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.OVERLAPPED*lpOverlappedLocal = &lpOverlapped)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.LockFileEx(hFileLocal, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlappedLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Locks the specified file for exclusive access by the calling process. This function can operate either synchronously or asynchronously and can request either an exclusive or a shared lock.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file. The handle must have been created with either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-lockfileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <param name = "dwReserved">Reserved parameter; must be set to zero.</param>
        /// <param name = "nNumberOfBytesToLockLow">The low-order 32 bits of the length of the byte range to lock.</param>
        /// <param name = "nNumberOfBytesToLockHigh">The high-order 32 bits of the length of the byte range to lock.</param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that the function uses with the locking request. This structure, which is required, contains the file offset of the beginning of the lock range. You must initialize the <b>hEvent</b> member to a valid handle or zero.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-lockfileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero (<b>TRUE</b>).</para>
        /// <para>If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-lockfileex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool LockFileEx(win32.System.SystemServices.HANDLE hFile, win32.Storage.FileSystem.LOCK_FILE_FLAGS dwFlags, uint dwReserved, uint nNumberOfBytesToLockLow, uint nNumberOfBytesToLockHigh, win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <inheritdoc cref = "QueryDosDevice(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe uint QueryDosDevice(string lpDeviceName, win32.System.SystemServices.PWSTR lpTargetPath, uint ucchMax)
        {
            fixed (char *lpDeviceNameLocal = lpDeviceName)
            {
                uint __result = Kernel32.QueryDosDevice(lpDeviceNameLocal, lpTargetPath, ucchMax);
                return __result;
            }
        }

        /// <summary>Retrieves information about MS-DOS device names.</summary>
        /// <param name = "lpDeviceName">
        /// <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing backslash; for example, use "C:", not "C:\\".</para>
        /// <para>This parameter can be <b>NULL</b>. In that case, the <b>QueryDosDevice</b> function will store a list of all existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-querydosdevicew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTargetPath">
        /// <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or more null-terminated strings. The final null-terminated string is followed by an additional <b>NULL</b>.</para>
        /// <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated strings represent undeleted prior mappings for the device.</para>
        /// <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-querydosdevicew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ucchMax">
        /// <para>The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by <i>lpTargetPath</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-querydosdevicew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into the buffer pointed to by <i>lpTargetPath</i>.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the buffer is too small, the function fails and the last error code is <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-querydosdevicew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "QueryDosDeviceW", SetLastError = true)]
        internal static extern uint QueryDosDevice(win32.System.SystemServices.PCWSTR lpDeviceName, win32.System.SystemServices.PWSTR lpTargetPath, uint ucchMax);
        /// <inheritdoc cref = "ReadFile(win32.System.SystemServices.HANDLE, void *, uint, uint *, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool ReadFile(SafeHandle hFile, void *lpBuffer, uint nNumberOfBytesToRead, uint *lpNumberOfBytesRead, win32.System.SystemServices.OVERLAPPED*lpOverlapped)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.ReadFile(hFileLocal, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file pointer if supported by the device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the device (for example, a file, file stream, physical disk, volume,  console buffer, tape drive, socket, communications resource, mailslot, or  pipe).</para>
        /// <para>The <i>hFile</i> parameter must have been created with read access. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para>For asynchronous read operations, <i>hFile</i> can be any handle that is opened with the <b>FILE_FLAG_OVERLAPPED</b> flag by the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function, or a socket handle returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to the buffer that receives the data read from a file or device.</para>
        /// <para>This buffer must remain valid for the duration of the read operation. The caller must not use this buffer until the read operation is completed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
        /// <param name = "lpNumberOfBytesRead">
        /// <para>A pointer to the variable that receives the number of bytes read when using a synchronous <i>hFile</i> parameter. <b>ReadFile</b> sets this value to zero  before doing any work or error checking. Use <b>NULL</b> for this parameter if this is an asynchronous operation to avoid potentially erroneous results.</para>
        /// <para>This parameter can be <b>NULL</b> only when the <i>lpOverlapped</i> parameter is not <b>NULL</b>.</para>
        /// <para>For more information, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is required if the <i>hFile</i> parameter was opened with <b>FILE_FLAG_OVERLAPPED</b>, otherwise it can be <b>NULL</b>.</para>
        /// <para>If <i>hFile</i> is opened with <b>FILE_FLAG_OVERLAPPED</b>, the <i>lpOverlapped</i> parameter must point to a valid and unique <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, otherwise the function can incorrectly report that the read operation is complete.</para>
        /// <para>For an <i>hFile</i> that supports byte offsets, if you use this parameter you must specify a byte offset at which to start reading from the file or device. This offset is specified by setting the <b>Offset</b> and <b>OffsetHigh</b> members of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. For an <i>hFile</i> that does not support byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are ignored.</para>
        /// <para>For more information about different combinations of <i>lpOverlapped</i> and <b>FILE_FLAG_OVERLAPPED</b>, see the Remarks section and the <a href = "https://docs.microsoft.com/">Synchronization and File Position</a> section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero (<b>TRUE</b>).</para>
        /// <para>If the function fails, or is completing asynchronously, the return value is zero (<b>FALSE</b>). To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function. <div class = "alert"><b>Note</b>  The <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> code <b>ERROR_IO_PENDING</b> is not a failure; it designates the read operation is pending completion asynchronously. For more information, see Remarks.</div> <div> </div></para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ReadFile(win32.System.SystemServices.HANDLE hFile, [Optional] void *lpBuffer, uint nNumberOfBytesToRead, [Optional] uint *lpNumberOfBytesRead, [Optional] win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <inheritdoc cref = "ReadFileEx(win32.System.SystemServices.HANDLE, void *, uint, win32.System.SystemServices.OVERLAPPED*, delegate *unmanaged[Stdcall]{uint, uint, win32.System.SystemServices.OVERLAPPED*, void})"/>
        internal static unsafe bool ReadFileEx(SafeHandle hFile, void *lpBuffer, uint nNumberOfBytesToRead, ref win32.System.SystemServices.OVERLAPPED lpOverlapped, delegate *unmanaged[Stdcall]<uint, uint, win32.System.SystemServices.OVERLAPPED*, void>lpCompletionRoutine)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.OVERLAPPED*lpOverlappedLocal = &lpOverlapped)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.ReadFileEx(hFileLocal, lpBuffer, nNumberOfBytesToRead, lpOverlappedLocal, lpCompletionRoutine);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Reads data from the specified file or input/output (I/O) device. It reports its completion status asynchronously, calling the specified completion routine when reading is completed or canceled and the calling thread is in an alertable wait state.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe).</para>
        /// <para>This parameter can be any handle opened with the <b>FILE_FLAG_OVERLAPPED</b> flag by the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function, or a socket handle returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function.</para>
        /// <para>This handle also must have the <b>GENERIC_READ</b> access right. For more information on access rights, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to a buffer that receives the data read from the file or device.</para>
        /// <para>This buffer must remain valid for the duration of the read operation. The application should not use this buffer until the read operation is completed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nNumberOfBytesToRead">The number of bytes to be read.</param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure that supplies data to be used during the asynchronous (overlapped) file read operation.</para>
        /// <para>For files that support byte offsets, you must specify a byte offset at which to start reading from the file. You specify this offset by setting the <b>Offset</b> and <b>OffsetHigh</b> members of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. For files or devices that do not support byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are ignored.</para>
        /// <para>The <b>ReadFileEx</b> function ignores the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure's <b>hEvent</b> member. An application is free to use that member for its own purposes in the context of a <b>ReadFileEx</b> call. <b>ReadFileEx</b> signals completion of its read operation by calling, or queuing a call to, the completion routine pointed to by <i>lpCompletionRoutine</i>, so it does not need an event handle.</para>
        /// <para>The <b>ReadFileEx</b> function does use the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure's <b>Internal</b> and <b>InternalHigh</b> members. An application should not set these members.</para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure must remain valid for the duration of the read operation. It should not be a variable that can go out of scope while the read operation is pending completion.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCompletionRoutine">
        /// <para>A pointer to the completion routine to be called when the read operation is complete and the calling thread is in an alertable wait state. For more information about the completion routine, see <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the function succeeds, the calling thread has an asynchronous I/O operation pending: the overlapped read operation from the file. When this I/O operation completes, and the calling thread is blocked in an alertable wait state, the system calls the function pointed to by <i>lpCompletionRoutine</i>, and the wait state completes with a return code of <b>WAIT_IO_COMPLETION</b>.</para>
        /// <para>If the function succeeds, and the file reading operation completes, but the calling thread is not in an alertable wait state, the system queues the completion routine call, holding the call until the calling thread enters an alertable wait state. For information about alertable waits and overlapped input/output operations, see <a href = "/windows/desktop/Sync/about-synchronization">About Synchronization</a>.</para>
        /// <para>If <b>ReadFileEx</b> attempts to read past the end-of-file (EOF), the call to <a href = "/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> for that operation returns <b>FALSE</b> and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_HANDLE_EOF</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfileex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ReadFileEx(win32.System.SystemServices.HANDLE hFile, [Optional] void *lpBuffer, uint nNumberOfBytesToRead, win32.System.SystemServices.OVERLAPPED*lpOverlapped, delegate *unmanaged[Stdcall]<uint, uint, win32.System.SystemServices.OVERLAPPED*, void>lpCompletionRoutine);
        /// <inheritdoc cref = "ReadFileScatter(win32.System.SystemServices.HANDLE, win32.System.SystemServices.FILE_SEGMENT_ELEMENT*, uint, uint *, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool ReadFileScatter(SafeHandle hFile, in win32.System.SystemServices.FILE_SEGMENT_ELEMENT aSegmentArray, uint nNumberOfBytesToRead, ref uint lpReserved, ref win32.System.SystemServices.OVERLAPPED lpOverlapped)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.OVERLAPPED*lpOverlappedLocal = &lpOverlapped)
                {
                    fixed (uint *lpReservedLocal = &lpReserved)
                    {
                        fixed (win32.System.SystemServices.FILE_SEGMENT_ELEMENT*aSegmentArrayLocal = &aSegmentArray)
                        {
                            win32.System.SystemServices.HANDLE hFileLocal;
                            if (hFile is object)
                            {
                                hFile.DangerousAddRef(ref hFileAddRef);
                                hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                            }
                            else
                                hFileLocal = default(win32.System.SystemServices.HANDLE);
                            bool __result = Kernel32.ReadFileScatter(hFileLocal, aSegmentArrayLocal, nNumberOfBytesToRead, lpReservedLocal, lpOverlappedLocal);
                            return __result;
                        }
                    }
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Reads data from a file and stores it in an array of buffers.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file to be read.</para>
        /// <para>The file handle must be created with the <b>GENERIC_READ</b> right, and the <b>FILE_FLAG_OVERLAPPED</b> and <b>FILE_FLAG_NO_BUFFERING</b> flags. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfilescatter#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "aSegmentArray">
        /// <para>A pointer to an array of <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_file_segment_element">FILE_SEGMENT_ELEMENT</a> buffers that receives the data. For a description of this union, see Remarks.</para>
        /// <para>Each element can receive one page of data.</para>
        /// <para><div class = "alert"><b>Note</b>  To determine the size of a system page, use <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a>.</div> <div> </div> The array must contain enough elements to store <i>nNumberOfBytesToRead</i> bytes of data, plus one element for the terminating <b>NULL</b>. For example, if there are 40 KB to be read and the page size is 4 KB, the array must have 11 elements that includes 10 for the data and one for the <b>NULL</b>.</para>
        /// <para>Each buffer must be at least the size of a system memory page and must be aligned on a system memory page size boundary. The system reads one system memory page of data into each buffer.</para>
        /// <para>The function stores the data in the buffers in sequential order. For example, it stores data into the first buffer, then into the second buffer, and so on until each buffer is filled and all the data is stored, or there are no more buffers.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfilescatter#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nNumberOfBytesToRead">
        /// <para>The total number of bytes to be read from the file. Each element of <i>aSegmentArray</i> contains a one-page chunk of this total. Because the file must be opened with <b>FILE_FLAG_NO_BUFFERING</b>, the number of bytes must be a multiple of the sector size of the file system where the file is located.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfilescatter#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpReserved">This parameter is reserved for future use and must be <b>NULL</b>.</param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure.</para>
        /// <para>The <b>ReadFileScatter</b> function requires a valid <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. The <i>lpOverlapped</i> parameter cannot be <b>NULL</b>.</para>
        /// <para>The <b>ReadFileScatter</b> function starts reading data from the file at a position that is specified by the <b>Offset</b> and <b>OffsetHigh</b> members of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.</para>
        /// <para>The <b>ReadFileScatter</b> function may return before the read operation is complete. In that scenario, the <b>ReadFileScatter</b> function returns the value 0 (zero), and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the value <b>ERROR_IO_PENDING</b>. This asynchronous operation of <b>ReadFileScatter</b> lets the calling process continue while the read operation completes. You can call the <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-hasoverlappediocompleted">HasOverlappedIoCompleted</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> functions to obtain information about the completion of the read operation. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfilescatter#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// <para>If <b>ReadFileScatter</b> attempts to read past the end-of-file (EOF), the call to <a href = "/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> for that operation returns <b>FALSE</b> and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_HANDLE_EOF</b>.</para>
        /// <para>If the function returns before the read operation is complete, the function returns zero (0), and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_IO_PENDING</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfilescatter">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool ReadFileScatter(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.FILE_SEGMENT_ELEMENT*aSegmentArray, uint nNumberOfBytesToRead, uint *lpReserved, win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <inheritdoc cref = "RemoveDirectory(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool RemoveDirectory(string lpPathName)
        {
            fixed (char *lpPathNameLocal = lpPathName)
            {
                bool __result = Kernel32.RemoveDirectory(lpPathNameLocal);
                return __result;
            }
        }

        /// <summary>Deletes an existing empty directory.</summary>
        /// <param name = "lpPathName">
        /// <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process must have delete access to the directory.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-removedirectoryw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-removedirectoryw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "RemoveDirectoryW", SetLastError = true)]
        internal static extern bool RemoveDirectory(win32.System.SystemServices.PCWSTR lpPathName);
        /// <inheritdoc cref = "SetEndOfFile(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool SetEndOfFile(SafeHandle hFile)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetEndOfFile(hFileLocal);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Sets the physical file size for the specified file to the current position of the file pointer.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file to be extended or truncated.</para>
        /// <para>The file handle must be created with the <b>GENERIC_WRITE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setendoffile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setendoffile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetEndOfFile(win32.System.SystemServices.HANDLE hFile);
        /// <inheritdoc cref = "SetFileAttributes(win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES)"/>
        internal static unsafe bool SetFileAttributes(string lpFileName, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES dwFileAttributes)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                bool __result = Kernel32.SetFileAttributes(lpFileNameLocal, dwFileAttributes);
                return __result;
            }
        }

        /// <summary>Sets the attributes for a file or directory.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file whose attributes are to be set.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>SetFileAttributesW</b>) and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>. <div class = "alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileattributesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFileAttributes">
        /// <para>The file attributes to set for the file.</para>
        /// <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
        /// <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
        /// <para>The following is a list of supported attribute values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileattributesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileattributesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetFileAttributesW", SetLastError = true)]
        internal static extern bool SetFileAttributes(win32.System.SystemServices.PCWSTR lpFileName, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES dwFileAttributes);
        /// <inheritdoc cref = "SetFileInformationByHandle(win32.System.SystemServices.HANDLE, win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS, void *, uint)"/>
        internal static unsafe bool SetFileInformationByHandle(SafeHandle hFile, win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS FileInformationClass, void *lpFileInformation, uint dwBufferSize)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetFileInformationByHandle(hFileLocal, FileInformationClass, lpFileInformation, dwBufferSize);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Sets the file information for the specified file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file for which to change information.</para>
        /// <para>This handle must be opened with the appropriate permissions for the requested change. For more information, see the Remarks and Example Code sections.</para>
        /// <para>This handle should not be a pipe handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileinformationbyhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "FileInformationClass">
        /// <para>A <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-file_info_by_handle_class">FILE_INFO_BY_HANDLE_CLASS</a> enumeration value that specifies the type of information to be changed.</para>
        /// <para>For a table of valid values, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileinformationbyhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileInformation">
        /// <para>A pointer to the buffer that contains the information to change  for the specified file information class. The structure that this parameter points to corresponds to the class that is specified by <i>FileInformationClass</i>.</para>
        /// <para>For a table of valid structure types, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileinformationbyhandle#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwBufferSize">The size of <i>lpFileInformation</i>, in bytes.</param>
        /// <returns>
        /// <para>Returns nonzero if successful or zero otherwise.</para>
        /// <para>To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileinformationbyhandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetFileInformationByHandle(win32.System.SystemServices.HANDLE hFile, win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS FileInformationClass, void *lpFileInformation, uint dwBufferSize);
        /// <inheritdoc cref = "SetFilePointer(win32.System.SystemServices.HANDLE, int, int *, win32.Storage.FileSystem.SET_FILE_POINTER_MOVE_METHOD)"/>
        internal static unsafe uint SetFilePointer(SafeHandle hFile, int lDistanceToMove, int *lpDistanceToMoveHigh, win32.Storage.FileSystem.SET_FILE_POINTER_MOVE_METHOD dwMoveMethod)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.SetFilePointer(hFileLocal, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Moves the file pointer of the specified file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file.</para>
        /// <para>The file handle must be created with the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilepointer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lDistanceToMove">
        /// <para>The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer.</para>
        /// <para>If <i>lpDistanceToMoveHigh</i> is not <b>NULL</b>, <i>lpDistanceToMoveHigh</i> and <i>lDistanceToMove</i> form a single 64-bit signed value that specifies the distance to move. If <i>lpDistanceToMoveHigh</i> is <b>NULL</b>, <i>lDistanceToMove</i> is a 32-bit signed value. A positive value for <i>lDistanceToMove</i> moves the file pointer forward in the file, and a negative value moves the file pointer back.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilepointer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDistanceToMoveHigh">
        /// <para>A pointer to the high order 32-bits of the signed 64-bit distance to move.</para>
        /// <para>If you do not need the high order 32-bits, this pointer must be set to <b>NULL</b>. When  not <b>NULL</b>, this parameter also receives the high order <b>DWORD</b> of the new value of the file pointer. For more information, see the Remarks section in this topic.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilepointer#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMoveMethod">The starting point for the file pointer move.</param>
        /// <returns>
        /// <para>If the function succeeds and <i>lpDistanceToMoveHigh</i> is <b>NULL</b>, the return value is the low-order <b>DWORD</b> of the new file pointer. <b>Note</b>  If the function returns a value other than <b>INVALID_SET_FILE_POINTER</b>, the call to <b>SetFilePointer</b> has succeeded. You do not need to call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If function succeeds and <i>lpDistanceToMoveHigh</i> is not <b>NULL</b>, the return value is the low-order <b>DWORD</b> of the new file pointer and <i>lpDistanceToMoveHigh</i> contains the high order <b>DWORD</b> of the new file pointer.</para>
        /// <para>If the function fails, the return value is <b>INVALID_SET_FILE_POINTER</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If a new file pointer is a negative value, the function fails, the file pointer is not moved, and the code returned by <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is <b>ERROR_NEGATIVE_SEEK</b>.</para>
        /// <para>If <i>lpDistanceToMoveHigh</i> is <b>NULL</b> and the new file position does not fit in a 32-bit value, the function fails and returns <b>INVALID_SET_FILE_POINTER</b>.</para>
        /// <para><div class = "alert"><b>Note</b>  Because <b>INVALID_SET_FILE_POINTER</b> is a valid value for the low-order <b>DWORD</b> of the new file pointer, you must check both the return value of the function and the error code returned by <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether or not an error has occurred. If an error has occurred, the return value of <b>SetFilePointer</b> is <b>INVALID_SET_FILE_POINTER</b> and <b>GetLastError</b> returns a value other than <b>NO_ERROR</b>. For a code example that demonstrates how to check for failure, see the Remarks section in this topic.</div> <div> </div></para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilepointer">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe uint SetFilePointer(win32.System.SystemServices.HANDLE hFile, int lDistanceToMove, [Optional] int *lpDistanceToMoveHigh, win32.Storage.FileSystem.SET_FILE_POINTER_MOVE_METHOD dwMoveMethod);
        /// <inheritdoc cref = "SetFilePointerEx(win32.System.SystemServices.HANDLE, long, long *, win32.Storage.FileSystem.SET_FILE_POINTER_MOVE_METHOD)"/>
        internal static unsafe bool SetFilePointerEx(SafeHandle hFile, long liDistanceToMove, long *lpNewFilePointer, win32.Storage.FileSystem.SET_FILE_POINTER_MOVE_METHOD dwMoveMethod)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetFilePointerEx(hFileLocal, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Moves the file pointer of the specified file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file. The file handle must have been created with the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilepointerex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "liDistanceToMove">
        /// <para>The number of bytes to move the file pointer. A positive value moves the pointer forward in the file and a negative value moves the file pointer backward.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilepointerex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewFilePointer">
        /// <para>A pointer to a variable to receive the new file pointer. If this parameter is <b>NULL</b>, the new file pointer is not returned.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilepointerex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMoveMethod"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilepointerex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetFilePointerEx(win32.System.SystemServices.HANDLE hFile, long liDistanceToMove, [Optional] long *lpNewFilePointer, win32.Storage.FileSystem.SET_FILE_POINTER_MOVE_METHOD dwMoveMethod);
        /// <inheritdoc cref = "SetFileValidData(win32.System.SystemServices.HANDLE, long)"/>
        internal static unsafe bool SetFileValidData(SafeHandle hFile, long ValidDataLength)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetFileValidData(hFileLocal, ValidDataLength);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Sets the valid data length of the specified file. This function is useful in very limited scenarios. For more information, see the Remarks section.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file. The file must have been opened with the <b>GENERIC_WRITE</b> access right, and the <b>SE_MANAGE_VOLUME_NAME</b> privilege enabled. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><div class = "alert"><b>Note</b>  The file cannot be a network file, or be compressed, sparse, or transacted.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilevaliddata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ValidDataLength">
        /// <para>The new valid data length.</para>
        /// <para>This parameter must be a positive value that is greater than the current valid data length, but less than the current file size.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilevaliddata#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is 0. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilevaliddata">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetFileValidData(win32.System.SystemServices.HANDLE hFile, long ValidDataLength);
        /// <inheritdoc cref = "UnlockFile(win32.System.SystemServices.HANDLE, uint, uint, uint, uint)"/>
        internal static unsafe bool UnlockFile(SafeHandle hFile, uint dwFileOffsetLow, uint dwFileOffsetHigh, uint nNumberOfBytesToUnlockLow, uint nNumberOfBytesToUnlockHigh)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.UnlockFile(hFileLocal, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Unlocks a region in an open file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file that contains a region locked with <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-lockfile">LockFile</a>. The file handle must have been created with either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-unlockfile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFileOffsetLow">The low-order word of the starting byte offset in the file where the locked region begins.</param>
        /// <param name = "dwFileOffsetHigh">The high-order word of the starting byte offset in the file where the locked region begins.</param>
        /// <param name = "nNumberOfBytesToUnlockLow">The low-order word of the length of the byte range to be unlocked.</param>
        /// <param name = "nNumberOfBytesToUnlockHigh">The high-order word of the length of the byte range to be unlocked.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-unlockfile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool UnlockFile(win32.System.SystemServices.HANDLE hFile, uint dwFileOffsetLow, uint dwFileOffsetHigh, uint nNumberOfBytesToUnlockLow, uint nNumberOfBytesToUnlockHigh);
        /// <inheritdoc cref = "UnlockFileEx(win32.System.SystemServices.HANDLE, uint, uint, uint, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool UnlockFileEx(SafeHandle hFile, uint dwReserved, uint nNumberOfBytesToUnlockLow, uint nNumberOfBytesToUnlockHigh, ref win32.System.SystemServices.OVERLAPPED lpOverlapped)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.OVERLAPPED*lpOverlappedLocal = &lpOverlapped)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.UnlockFileEx(hFileLocal, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlappedLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Unlocks a region in the specified file. This function can operate either synchronously or asynchronously.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file. The handle must have been created with either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-unlockfileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwReserved">Reserved parameter; must be zero.</param>
        /// <param name = "nNumberOfBytesToUnlockLow">The low-order part of the length of the byte range to unlock.</param>
        /// <param name = "nNumberOfBytesToUnlockHigh">The high-order part of the length of the byte range to unlock.</param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that the function uses with the unlocking request. This structure contains the file offset of the beginning of the unlock range. You must initialize the <b>hEvent</b> member to a valid handle or zero. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-unlockfileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero or <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-unlockfileex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool UnlockFileEx(win32.System.SystemServices.HANDLE hFile, uint dwReserved, uint nNumberOfBytesToUnlockLow, uint nNumberOfBytesToUnlockHigh, win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <inheritdoc cref = "WriteFile(win32.System.SystemServices.HANDLE, void *, uint, uint *, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool WriteFile(SafeHandle hFile, void *lpBuffer, uint nNumberOfBytesToWrite, uint *lpNumberOfBytesWritten, win32.System.SystemServices.OVERLAPPED*lpOverlapped)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.WriteFile(hFileLocal, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Writes data to the specified file or input/output (I/O) device.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file or I/O device (for example, a file, file stream, physical disk, volume,  console buffer, tape drive, socket, communications resource, mailslot, or  pipe).</para>
        /// <para>The <i>hFile</i> parameter must have been created with the write access. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para>For asynchronous write operations, <i>hFile</i> can be any handle opened with the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function using the <b>FILE_FLAG_OVERLAPPED</b> flag or a socket handle returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to the buffer containing the data to be written to the file or device.</para>
        /// <para>This buffer must remain valid for the duration of the write operation. The caller must not use this buffer until the write operation is completed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nNumberOfBytesToWrite">
        /// <para>The number of bytes to be written to the file or device.</para>
        /// <para>A value of zero specifies a null write operation. The behavior of a null write operation depends on the underlying file system or communications technology.</para>
        /// <para><b>Windows Server 2003 and Windows XP:  </b>Pipe write operations across a network are limited in size per write. The amount varies per platform. For x86 platforms it's 63.97 MB. For x64 platforms it's 31.97 MB. For Itanium it's 63.95 MB. For more information regarding pipes, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNumberOfBytesWritten">
        /// <para>A pointer to the variable that receives the number of bytes written when using a synchronous <i>hFile</i> parameter. <b>WriteFile</b> sets this value to zero before doing any work or error checking. Use <b>NULL</b> for this parameter if this is an asynchronous operation to avoid potentially erroneous results.</para>
        /// <para>This parameter can be <b>NULL</b> only when the <i>lpOverlapped</i> parameter is not <b>NULL</b>.</para>
        /// <para>For more information, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is required if the <i>hFile</i> parameter was opened with <b>FILE_FLAG_OVERLAPPED</b>, otherwise this parameter can be <b>NULL</b>.</para>
        /// <para>For an <i>hFile</i> that supports byte offsets, if you use this parameter you must specify a byte offset at which to start writing to the file or device. This offset is specified by setting the <b>Offset</b> and <b>OffsetHigh</b> members of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. For an <i>hFile</i> that does not support byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are ignored.</para>
        /// <para>To write to the end of file, specify both the <b>Offset</b> and <b>OffsetHigh</b> members of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function to open <i>hFile</i> using <b>FILE_APPEND_DATA</b> access.</para>
        /// <para>For more information about different combinations of <i>lpOverlapped</i> and <b>FILE_FLAG_OVERLAPPED</b>, see the Remarks section and the <a href = "https://docs.microsoft.com/">Synchronization and File Position</a> section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero (<b>TRUE</b>).</para>
        /// <para>If the function fails, or is completing asynchronously, the return value is zero (<b>FALSE</b>). To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// <para><div class = "alert"><b>Note</b>  The <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> code <b>ERROR_IO_PENDING</b> is not a failure; it designates the write operation is pending completion asynchronously. For more information, see Remarks.</div> <div> </div></para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool WriteFile(win32.System.SystemServices.HANDLE hFile, [Optional] void *lpBuffer, uint nNumberOfBytesToWrite, [Optional] uint *lpNumberOfBytesWritten, [Optional] win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <inheritdoc cref = "WriteFileEx(win32.System.SystemServices.HANDLE, void *, uint, win32.System.SystemServices.OVERLAPPED*, delegate *unmanaged[Stdcall]{uint, uint, win32.System.SystemServices.OVERLAPPED*, void})"/>
        internal static unsafe bool WriteFileEx(SafeHandle hFile, void *lpBuffer, uint nNumberOfBytesToWrite, ref win32.System.SystemServices.OVERLAPPED lpOverlapped, delegate *unmanaged[Stdcall]<uint, uint, win32.System.SystemServices.OVERLAPPED*, void>lpCompletionRoutine)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.OVERLAPPED*lpOverlappedLocal = &lpOverlapped)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.WriteFileEx(hFileLocal, lpBuffer, nNumberOfBytesToWrite, lpOverlappedLocal, lpCompletionRoutine);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Writes data to the specified file or input/output (I/O) device. It reports its completion status asynchronously, calling the specified completion routine when writing is completed or canceled and the calling thread is in an alertable wait state.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file or I/O device (for example, a file, file stream, physical disk, volume,  console buffer, tape drive, socket, communications resource, mailslot, or  pipe).</para>
        /// <para>This parameter can be any handle opened with the <b>FILE_FLAG_OVERLAPPED</b> flag by the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function, or a socket handle returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function. Do not associate an I/O completion port with this handle. For more information, see the Remarks section. This handle also must have the <b>GENERIC_WRITE</b> access right. For more information on access rights, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to the buffer containing the data to be written to the file or device.</para>
        /// <para>This buffer must remain valid for the duration of the write operation. The caller must not use this buffer until the write operation is completed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nNumberOfBytesToWrite">
        /// <para>The number of bytes to be written to the file or device.</para>
        /// <para>A value of zero specifies a null write operation. The behavior of a null write operation depends on the underlying file system. Pipe write operations across a network are limited to 65,535 bytes per write. For more information regarding  pipes, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure that supplies data to be used during the overlapped (asynchronous) write operation.</para>
        /// <para>For files that support byte offsets, you must specify a byte offset at which to start writing to the file. You specify this offset by setting the <b>Offset</b> and <b>OffsetHigh</b> members of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. For files or devices that do not support byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are ignored. To write to the end of file, specify both the <b>Offset</b> and <b>OffsetHigh</b> members of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function to open <i>hFile</i> using <b>FILE_APPEND_DATA</b> access. The <b>WriteFileEx</b> function ignores the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure's <b>hEvent</b> member. An application is free to use that member for its own purposes in the context of a <b>WriteFileEx</b> call. <b>WriteFileEx</b> signals completion of its writing operation by calling, or queuing a call to, the completion routine pointed to by <i>lpCompletionRoutine</i>, so it does not need an event handle. The <b>WriteFileEx</b> function does use the <b>Internal</b> and <b>InternalHigh</b> members of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. You should not change the value of these members. The <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure must remain valid for the duration of the write operation. It should not be a variable that can go out of scope while the write operation is pending completion.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCompletionRoutine">
        /// <para>A pointer to a completion routine to be called when the write operation has been completed and the calling thread is in an alertable wait state. For more information about this completion routine, see <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefileex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the <b>WriteFileEx</b> function succeeds, the calling thread has an asynchronous I/O operation pending: the overlapped write operation to the file. When this I/O operation finishes, and the calling thread is blocked in an alertable wait state, the operating system calls the function pointed to by <i>lpCompletionRoutine</i>, and the wait completes with a return code of <b>WAIT_IO_COMPLETION</b>.</para>
        /// <para>If the function succeeds and the file-writing operation finishes, but the calling thread is not in an alertable wait state, the system queues the call to *<i>lpCompletionRoutine</i>, holding the call until the calling thread enters an alertable wait state. For more information about alertable wait states and overlapped input/output operations, see <a href = "/windows/desktop/Sync/about-synchronization">About Synchronization</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefileex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool WriteFileEx(win32.System.SystemServices.HANDLE hFile, [Optional] void *lpBuffer, uint nNumberOfBytesToWrite, win32.System.SystemServices.OVERLAPPED*lpOverlapped, delegate *unmanaged[Stdcall]<uint, uint, win32.System.SystemServices.OVERLAPPED*, void>lpCompletionRoutine);
        /// <inheritdoc cref = "WriteFileGather(win32.System.SystemServices.HANDLE, win32.System.SystemServices.FILE_SEGMENT_ELEMENT*, uint, uint *, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool WriteFileGather(SafeHandle hFile, in win32.System.SystemServices.FILE_SEGMENT_ELEMENT aSegmentArray, uint nNumberOfBytesToWrite, ref uint lpReserved, ref win32.System.SystemServices.OVERLAPPED lpOverlapped)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.OVERLAPPED*lpOverlappedLocal = &lpOverlapped)
                {
                    fixed (uint *lpReservedLocal = &lpReserved)
                    {
                        fixed (win32.System.SystemServices.FILE_SEGMENT_ELEMENT*aSegmentArrayLocal = &aSegmentArray)
                        {
                            win32.System.SystemServices.HANDLE hFileLocal;
                            if (hFile is object)
                            {
                                hFile.DangerousAddRef(ref hFileAddRef);
                                hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                            }
                            else
                                hFileLocal = default(win32.System.SystemServices.HANDLE);
                            bool __result = Kernel32.WriteFileGather(hFileLocal, aSegmentArrayLocal, nNumberOfBytesToWrite, lpReservedLocal, lpOverlappedLocal);
                            return __result;
                        }
                    }
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves data from an array of buffers and writes the data to a file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file. The file handle must be created with the <b>GENERIC_WRITE</b> access right, and the <b>FILE_FLAG_OVERLAPPED</b> and <b>FILE_FLAG_NO_BUFFERING</b> flags. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefilegather#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "aSegmentArray">
        /// <para>A pointer to an array of <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_file_segment_element">FILE_SEGMENT_ELEMENT</a> buffers that contain the data. For a description of this union, see Remarks.</para>
        /// <para>Each element contains the address of one page of data. <div class = "alert"><b>Note</b>  To determine the size of a system page, use the <a href = "https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function.</div> <div> </div>The array must contain enough elements to store <i>nNumberOfBytesToWrite</i> bytes of data, and one element for the terminating <b>NULL</b>. For example, if there are 40 KB to be read and the page size is 4 KB, the array must have 11 elements that includes 10 elements for the data and one element for the <b>NULL</b>.</para>
        /// <para>Each buffer must be at least the size of a system memory page and must be aligned on a system memory page size boundary. The system writes one system memory page of data from each buffer.</para>
        /// <para>The function gathers the data from the buffers in a sequential order. For example, it writes data to the file from the first buffer, then the second buffer, and so on until there is no more data.</para>
        /// <para>Due to the asynchronous operation of this function, precautions must be taken to ensure that this parameter always references valid memory for the lifetime of the asynchronous writes. For instance, a common programming error is to use local stack storage and then allow execution to run out of scope.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefilegather#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nNumberOfBytesToWrite">
        /// <para>The total number of bytes to be written. Each element of <i>aSegmentArray</i> contains a one-page chunk of this total. Because the file must be opened with <b>FILE_FLAG_NO_BUFFERING</b>, the number of bytes must be a multiple of the sector size of the file system where the file is located.</para>
        /// <para>If <i>nNumberOfBytesToWrite</i> is zero (0), the function performs a null write operation. The behavior of a null write operation depends on the underlying file system. If <i>nNumberOfBytesToWrite</i> is not zero (0) and the offset and length of the write place data beyond the current end of the file, the <b>WriteFileGather</b> function extends the file.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefilegather#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpReserved">This parameter is reserved for future use and must be <b>NULL</b>.</param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure.</para>
        /// <para>The <b>WriteFileGather</b> function requires a valid <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. The <i>lpOverlapped</i> parameter cannot be <b>NULL</b>.</para>
        /// <para>The <b>WriteFileGather</b> function starts writing data to the file at a position that is specified by the <b>Offset</b> and <b>OffsetHigh</b> members of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.</para>
        /// <para>The <b>WriteFileGather</b> function may return before the write operation is complete. In that scenario, the <b>WriteFileGather</b> function returns the value zero (0), and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the value <b>ERROR_IO_PENDING</b>. This asynchronous operation of the <b>WriteFileGather</b> function lets the calling process continue while the write operation completes. You can call the <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a>, <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-hasoverlappediocompleted">HasOverlappedIoCompleted</a>, or <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> function to obtain information about the completion of the write operation. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefilegather#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// <para>If the function returns before the write operation is complete, the function returns zero (0), and the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_IO_PENDING</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefilegather">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool WriteFileGather(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.FILE_SEGMENT_ELEMENT*aSegmentArray, uint nNumberOfBytesToWrite, uint *lpReserved, win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <summary>Retrieves the path of the directory designated for temporary files.</summary>
        /// <param name = "nBufferLength">
        /// <para>The size of the string buffer identified by <i>lpBuffer</i>, in <b>TCHARs</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettemppathw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. The returned string ends with a backslash, for example, "C:\\TEMP\\".</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettemppathw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, the return value is the length, in <b>TCHARs</b>, of the buffer required to hold the path.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettemppathw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetTempPathW", SetLastError = true)]
        internal static extern uint GetTempPath(uint nBufferLength, win32.System.SystemServices.PWSTR lpBuffer);
        /// <inheritdoc cref = "GetVolumeNameForVolumeMountPoint(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe bool GetVolumeNameForVolumeMountPoint(string lpszVolumeMountPoint, win32.System.SystemServices.PWSTR lpszVolumeName, uint cchBufferLength)
        {
            fixed (char *lpszVolumeMountPointLocal = lpszVolumeMountPoint)
            {
                bool __result = Kernel32.GetVolumeNameForVolumeMountPoint(lpszVolumeMountPointLocal, lpszVolumeName, cchBufferLength);
                return __result;
            }
        }

        /// <summary>Retrieves a volume GUID path for the volume that is associated with the specified volume mount point ( drive letter, volume GUID path, or mounted folder).</summary>
        /// <param name = "lpszVolumeMountPoint">A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\\") or a drive letter (for example, "X:\\"). The string must end with a trailing backslash ('\\').</param>
        /// <param name = "lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\\\\?\Volume{<i>GUID</i>}\\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</param>
        /// <param name = "cchBufferLength">The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumenameforvolumemountpointw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetVolumeNameForVolumeMountPointW", SetLastError = true)]
        internal static extern bool GetVolumeNameForVolumeMountPoint(win32.System.SystemServices.PCWSTR lpszVolumeMountPoint, win32.System.SystemServices.PWSTR lpszVolumeName, uint cchBufferLength);
        /// <inheritdoc cref = "GetVolumePathNamesForVolumeName(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint, uint *)"/>
        internal static unsafe bool GetVolumePathNamesForVolumeName(string lpszVolumeName, win32.System.SystemServices.PWSTR lpszVolumePathNames, uint cchBufferLength, out uint lpcchReturnLength)
        {
            fixed (uint *lpcchReturnLengthLocal = &lpcchReturnLength)
            {
                fixed (char *lpszVolumeNameLocal = lpszVolumeName)
                {
                    bool __result = Kernel32.GetVolumePathNamesForVolumeName(lpszVolumeNameLocal, lpszVolumePathNames, cchBufferLength, lpcchReturnLengthLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves a list of drive letters and mounted folder paths for the specified volume.</summary>
        /// <param name = "lpszVolumeName">
        /// <para>A volume <b>GUID</b> path for the volume. A volume <b>GUID</b> path is of the form "\\\\?\\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\\".</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumepathnamesforvolumenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszVolumePathNames">
        /// <para>A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an array of null-terminated strings terminated by an additional <b>NULL</b> character. If the buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumepathnamesforvolumenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchBufferLength">
        /// <para>The length of the <i>lpszVolumePathNames</i> buffer, in <b>TCHARs</b>, including all <b>NULL</b> characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumepathnamesforvolumenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpcchReturnLength">
        /// <para>If the call is successful, this parameter is the number of <b>TCHARs</b> copied to the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer required to hold the complete list, in <b>TCHARs</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumepathnamesforvolumenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the buffer is not large enough to hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the <i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumepathnamesforvolumenamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetVolumePathNamesForVolumeNameW", SetLastError = true)]
        internal static extern unsafe bool GetVolumePathNamesForVolumeName(win32.System.SystemServices.PCWSTR lpszVolumeName, win32.System.SystemServices.PWSTR lpszVolumePathNames, uint cchBufferLength, uint *lpcchReturnLength);
        /// <inheritdoc cref = "CreateFile2(win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.FILE_ACCESS_FLAGS, win32.Storage.FileSystem.FILE_SHARE_MODE, win32.Storage.FileSystem.FILE_CREATION_DISPOSITION, win32.Storage.FileSystem.CREATEFILE2_EXTENDED_PARAMETERS*)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateFile2(string lpFileName, win32.Storage.FileSystem.FILE_ACCESS_FLAGS dwDesiredAccess, win32.Storage.FileSystem.FILE_SHARE_MODE dwShareMode, win32.Storage.FileSystem.FILE_CREATION_DISPOSITION dwCreationDisposition, win32.Storage.FileSystem.CREATEFILE2_EXTENDED_PARAMETERS? pCreateExParams)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                win32.Storage.FileSystem.CREATEFILE2_EXTENDED_PARAMETERS pCreateExParamsLocal = pCreateExParams.HasValue ? pCreateExParams.Value : default(win32.Storage.FileSystem.CREATEFILE2_EXTENDED_PARAMETERS);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateFile2(lpFileNameLocal, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams.HasValue ? &pCreateExParamsLocal : null);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Creates or opens a file or I/O device.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file or device to be created or opened.</para>
        /// <para>For information on special device names, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.</para>
        /// <para>To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfile2#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">
        /// <para>The requested access to the file or device, which can be summarized as read, write, both or neither zero).</para>
        /// <para>The most commonly used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both (<c>GENERIC_READ | GENERIC_WRITE</c>). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>, <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>, <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.</para>
        /// <para>If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would have been denied.</para>
        /// <para>You cannot request an access mode that conflicts with the sharing mode that is specified by the <i>dwShareMode</i> parameter in an open request that already has an open handle.</para>
        /// <para>For more information, see the Remarks section of this topic and <a href = "https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfile2#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwShareMode">
        /// <para>The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.</para>
        /// <para>If this parameter is zero and <b>CreateFile2</b> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.</para>
        /// <para>You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <b>CreateFile2</b> would fail and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function would return <b>ERROR_SHARING_VIOLATION</b>.</para>
        /// <para>To enable a process to share a file or device while another process has the file or device open, use a</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfile2#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwCreationDisposition">
        /// <para>An action to take on a file or device that exists or does not exist.</para>
        /// <para>For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.</para>
        /// <para>For more information, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfile2#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pCreateExParams">
        /// <para>Pointer to an optional <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-createfile2_extended_parameters">CREATEFILE2_EXTENDED_PARAMETERS</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfile2#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.</para>
        /// <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfile2">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateFile2(win32.System.SystemServices.PCWSTR lpFileName, win32.Storage.FileSystem.FILE_ACCESS_FLAGS dwDesiredAccess, win32.Storage.FileSystem.FILE_SHARE_MODE dwShareMode, win32.Storage.FileSystem.FILE_CREATION_DISPOSITION dwCreationDisposition, [Optional] win32.Storage.FileSystem.CREATEFILE2_EXTENDED_PARAMETERS*pCreateExParams);
        /// <inheritdoc cref = "SetFileIoOverlappedRange(win32.System.SystemServices.HANDLE, byte *, uint)"/>
        internal static unsafe bool SetFileIoOverlappedRange(SafeHandle FileHandle, in byte OverlappedRangeStart, uint Length)
        {
            bool FileHandleAddRef = false;
            try
            {
                fixed (byte *OverlappedRangeStartLocal = &OverlappedRangeStart)
                {
                    win32.System.SystemServices.HANDLE FileHandleLocal;
                    if (FileHandle is object)
                    {
                        FileHandle.DangerousAddRef(ref FileHandleAddRef);
                        FileHandleLocal = (win32.System.SystemServices.HANDLE)FileHandle.DangerousGetHandle();
                    }
                    else
                        FileHandleLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetFileIoOverlappedRange(FileHandleLocal, OverlappedRangeStartLocal, Length);
                    return __result;
                }
            }
            finally
            {
                if (FileHandleAddRef)
                    FileHandle.DangerousRelease();
            }
        }

        /// <summary>Associates a virtual address range with the specified file handle.</summary>
        /// <param name = "FileHandle">
        /// <para>A handle to the file.</para>
        /// <para>This file handle must be opened with <b>FILE_READ_ATTRIBUTES</b> access rights.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileiooverlappedrange#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "OverlappedRangeStart">The starting address for the range.</param>
        /// <param name = "Length">The length of the range, in bytes.</param>
        /// <returns>
        /// <para>Returns nonzero if successful or zero otherwise.</para>
        /// <para>To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileiooverlappedrange">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetFileIoOverlappedRange(win32.System.SystemServices.HANDLE FileHandle, byte *OverlappedRangeStart, uint Length);
        /// <inheritdoc cref = "GetCompressedFileSize(win32.System.SystemServices.PCWSTR, uint *)"/>
        internal static unsafe uint GetCompressedFileSize(string lpFileName, uint *lpFileSizeHigh)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                uint __result = Kernel32.GetCompressedFileSize(lpFileNameLocal, lpFileSizeHigh);
                return __result;
            }
        }

        /// <summary>Retrieves the actual number of bytes of disk storage used to store a specified file.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file.</para>
        /// <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
        /// <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getcompressedfilesizew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileSizeHigh">
        /// <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
        /// <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getcompressedfilesizew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
        /// <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getcompressedfilesizew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetCompressedFileSizeW", SetLastError = true)]
        internal static extern unsafe uint GetCompressedFileSize(win32.System.SystemServices.PCWSTR lpFileName, [Optional] uint *lpFileSizeHigh);
        /// <inheritdoc cref = "FindFirstStream(win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.STREAM_INFO_LEVELS, void *, uint)"/>
        internal static unsafe Kernel32.FindCloseSafeHandle FindFirstStream(string lpFileName, win32.Storage.FileSystem.STREAM_INFO_LEVELS InfoLevel, void *lpFindStreamData, uint dwFlags)
        {
            fixed (char *lpFileNameLocal = lpFileName)
            {
                win32.Storage.FileSystem.FindStreamHandle __result = Kernel32.FindFirstStream(lpFileNameLocal, InfoLevel, lpFindStreamData, dwFlags);
                return new Kernel32.FindCloseSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>Enumerates the first stream with a ::$DATA stream type in the specified file or directory.</summary>
        /// <param name = "lpFileName">The fully qualified file name.</param>
        /// <param name = "InfoLevel">
        /// <para>The information level of the returned data. This parameter is one of the values in the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/ne-fileapi-stream_info_levels">STREAM_INFO_LEVELS</a> enumeration type.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirststreamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFindStreamData">
        /// <para>A pointer to a buffer that receives the file stream data. The format of this data depends on the value of the <i>InfoLevel</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirststreamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Reserved for future use. This parameter must be zero.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a search handle that can be used in subsequent calls to the <a href = "/windows/desktop/api/fileapi/nf-fileapi-findnextstreamw">FindNextStreamW</a> function. If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no  streams can be found, the function fails and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_HANDLE_EOF</b> (38). If the filesystem does not support streams, the function fails and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_PARAMETER</b> (87).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirststreamw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindFirstStreamW", SetLastError = true)]
        internal static extern unsafe win32.Storage.FileSystem.FindStreamHandle FindFirstStream(win32.System.SystemServices.PCWSTR lpFileName, win32.Storage.FileSystem.STREAM_INFO_LEVELS InfoLevel, void *lpFindStreamData, uint dwFlags);
        /// <inheritdoc cref = "FindNextStream(win32.Storage.FileSystem.FindStreamHandle, void *)"/>
        internal static unsafe bool FindNextStream(SafeHandle hFindStream, void *lpFindStreamData)
        {
            bool hFindStreamAddRef = false;
            try
            {
                win32.Storage.FileSystem.FindStreamHandle hFindStreamLocal;
                if (hFindStream is object)
                {
                    hFindStream.DangerousAddRef(ref hFindStreamAddRef);
                    hFindStreamLocal = (win32.Storage.FileSystem.FindStreamHandle)hFindStream.DangerousGetHandle();
                }
                else
                    hFindStreamLocal = default(win32.Storage.FileSystem.FindStreamHandle);
                bool __result = Kernel32.FindNextStream(hFindStreamLocal, lpFindStreamData);
                return __result;
            }
            finally
            {
                if (hFindStreamAddRef)
                    hFindStream.DangerousRelease();
            }
        }

        /// <summary>Continues a stream search started by a previous call to the FindFirstStreamW function.</summary>
        /// <param name = "hFindStream">
        /// <para>The search handle returned by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirststreamw">FindFirstStreamW</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextstreamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFindStreamData">
        /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_find_stream_data">WIN32_FIND_STREAM_DATA</a> structure that receives information about the stream.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextstreamw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no  more streams can be found, <b>GetLastError</b> returns <b>ERROR_HANDLE_EOF</b> (38).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextstreamw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindNextStreamW", SetLastError = true)]
        internal static extern unsafe bool FindNextStream(win32.Storage.FileSystem.FindStreamHandle hFindStream, void *lpFindStreamData);
        /// <summary>Determines whether the file I/O functions are using the ANSI or OEM character set code page.</summary>
        /// <returns>
        /// <para>If the set of file I/O functions is using the ANSI code page, the return value is nonzero.</para>
        /// <para>If the set of file I/O functions is using the OEM code page, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-arefileapisansi">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool AreFileApisANSI();
        /// <inheritdoc cref = "FindFirstFileName(win32.System.SystemServices.PCWSTR, uint, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe Kernel32.FindCloseSafeHandle FindFirstFileName(string lpFileName, uint dwFlags, ref uint StringLength, win32.System.SystemServices.PWSTR LinkName)
        {
            fixed (uint *StringLengthLocal = &StringLength)
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    win32.Storage.FileSystem.FindFileNameHandle __result = Kernel32.FindFirstFileName(lpFileNameLocal, dwFlags, StringLengthLocal, LinkName);
                    return new Kernel32.FindCloseSafeHandle(__result, ownsHandle: true);
                }
            }
        }

        /// <summary>Creates an enumeration of all the hard links to the specified file. The FindFirstFileNameW function returns a handle to the enumeration that can be used on subsequent calls to the FindNextFileNameW function.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Reserved; specify zero (0).</param>
        /// <param name = "StringLength">
        /// <para>The size of the buffer pointed to by the <i>LinkName</i> parameter, in characters. If this call fails and the error returned from the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function is <b>ERROR_MORE_DATA</b> (234), the value that is returned by this parameter is the size that the buffer pointed to by <i>LinkName</i>  must be to contain all the data.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "LinkName">A pointer to a buffer to store the first link name found for <i>lpFileName</i>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a search handle that can be used with the <a href = "/windows/desktop/api/fileapi/nf-fileapi-findnextfilenamew">FindNextFileNameW</a> function or closed with the <a href = "/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
        /// <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b> (0xffffffff). To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfilenamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindFirstFileNameW", SetLastError = true)]
        internal static extern unsafe win32.Storage.FileSystem.FindFileNameHandle FindFirstFileName(win32.System.SystemServices.PCWSTR lpFileName, uint dwFlags, uint *StringLength, win32.System.SystemServices.PWSTR LinkName);
        /// <inheritdoc cref = "FindNextFileName(win32.Storage.FileSystem.FindFileNameHandle, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe bool FindNextFileName(SafeHandle hFindStream, ref uint StringLength, win32.System.SystemServices.PWSTR LinkName)
        {
            bool hFindStreamAddRef = false;
            try
            {
                fixed (uint *StringLengthLocal = &StringLength)
                {
                    win32.Storage.FileSystem.FindFileNameHandle hFindStreamLocal;
                    if (hFindStream is object)
                    {
                        hFindStream.DangerousAddRef(ref hFindStreamAddRef);
                        hFindStreamLocal = (win32.Storage.FileSystem.FindFileNameHandle)hFindStream.DangerousGetHandle();
                    }
                    else
                        hFindStreamLocal = default(win32.Storage.FileSystem.FindFileNameHandle);
                    bool __result = Kernel32.FindNextFileName(hFindStreamLocal, StringLengthLocal, LinkName);
                    return __result;
                }
            }
            finally
            {
                if (hFindStreamAddRef)
                    hFindStream.DangerousRelease();
            }
        }

        /// <summary>Continues enumerating the hard links to a file using the handle returned by a successful call to the FindFirstFileNameW function.</summary>
        /// <param name = "hFindStream">
        /// <para>A handle to the enumeration that is returned by a successful call to <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilenamew">FindFirstFileNameW</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextfilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "StringLength">
        /// <para>The size of the <i>LinkName</i> parameter, in characters. If this call fails and the error is <b>ERROR_MORE_DATA</b>, the value that is returned by this parameter is the size that <i>LinkName</i>  must be to contain all the data.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextfilenamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "LinkName">A pointer to a buffer to store the first link name found for <i>lpFileName</i>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If no matching files can be found, the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_HANDLE_EOF</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextfilenamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindNextFileNameW", SetLastError = true)]
        internal static extern unsafe bool FindNextFileName(win32.Storage.FileSystem.FindFileNameHandle hFindStream, uint *StringLength, win32.System.SystemServices.PWSTR LinkName);
        /// <summary>Causes the file I/O functions for the process to use the OEM character set code page.</summary>
        /// <remarks>
        /// <para>The file I/O functions whose code page is set by <b>SetFileApisToOEM</b> are those functions exported by KERNEL32.DLL that accept or return a file name. <b>SetFileApisToOEM</b> sets the code page per process, rather than per thread or per computer.</para>
        /// <para>The <b>SetFileApisToOEM</b> function is complemented by the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistoansi">SetFileApisToANSI</a> function, which causes the same set of file I/O functions to use the ANSI character set code page.</para>
        /// <para>The 8-bit console functions use the OEM code page by default. All other functions use the ANSI code page by default. This means that strings returned by the console functions may not be processed correctly by other functions, and vice versa. For example, if the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFileA</a> function returns a string that contains certain extended ANSI characters, and the 8-bit console functions are set to use the OEM code page, then the <a href = "https://docs.microsoft.com/windows/console/writeconsole">WriteConsoleA</a> function will not display the string properly.</para>
        /// <para>Use the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-arefileapisansi">AreFileApisANSI</a> function to determine which code page the set of file I/O functions is currently using. Use the <a href = "https://docs.microsoft.com/windows/console/setconsolecp">SetConsoleCP</a> and <a href = "https://docs.microsoft.com/windows/console/setconsoleoutputcp">SetConsoleOutputCP</a> functions to set the code page for the 8-bit console functions.</para>
        /// <para>To solve the problem of code page incompatibility, it is best to use Unicode for console applications. Console applications that use Unicode are much more versatile than those that use 8-bit console functions. Barring that solution, a console application can call the <b>SetFileApisToOEM</b> function to cause the set of file I/O functions to use OEM character set strings rather than ANSI character set strings. Use the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistoansi">SetFileApisToANSI</a> function to set those functions back to the ANSI code page.</para>
        /// <para>When dealing with command lines, a console application should obtain the command line in Unicode form and then convert it to OEM form using the relevant character-to-OEM functions. Note also that the array in the <i>argv</i> parameter of the command-line <b>main</b> function contains ANSI character set strings in this case.</para>
        /// <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileapistooem#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void SetFileApisToOEM();
        /// <summary>Causes the file I/O functions to use the ANSI character set code page for the current process.</summary>
        /// <remarks>
        /// <para>The file I/O functions whose code page is set by <b>SetFileApisToANSI</b> are those functions exported by KERNEL32.DLL that accept or return a file name. <b>SetFileApisToANSI</b> sets the code page per process, rather than per thread or per computer.</para>
        /// <para>The <b>SetFileApisToANSI</b> function complements the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistooem">SetFileApisToOEM</a> function, which causes the same set of file I/O functions to use the OEM character set code page.</para>
        /// <para>The 8-bit console functions use the OEM code page by default. All other functions use the ANSI code page by default. This means that strings returned by the console functions may not be processed correctly by other functions, and vice versa. For example, if the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFileA</a> function returns a string that contains certain extended ANSI characters, and the 8-bit console functions are set to use the OEM code page, then the <a href = "https://docs.microsoft.com/windows/console/writeconsole">WriteConsoleA</a> function does not display the string properly.</para>
        /// <para>Use the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-arefileapisansi">AreFileApisANSI</a> function to determine which code page the set of file I/O functions is currently using. Use the <a href = "https://docs.microsoft.com/windows/console/setconsolecp">SetConsoleCP</a> and <a href = "https://docs.microsoft.com/windows/console/setconsoleoutputcp">SetConsoleOutputCP</a> functions to set the code page for the 8-bit console functions.</para>
        /// <para>To solve the problem of code page incompatibility, it is best to use Unicode for console applications. Console applications that use Unicode are much more versatile than those that use 8-bit console functions. Barring that solution, a console application can call the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistooem">SetFileApisToOEM</a> function to cause the set of file I/O functions to use OEM character set strings rather than ANSI character set strings. Use the <b>SetFileApisToANSI</b> function to set those functions back to the ANSI code page.</para>
        /// <para>When dealing with command lines, a console application should obtain the command line in Unicode form and then convert it to OEM form using the relevant character-to-OEM functions. Note also that the array in the <i>argv</i> parameter of the command-line <b>main</b> function contains ANSI character set strings in this case.</para>
        /// <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileapistoansi#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void SetFileApisToANSI();
        /// <inheritdoc cref = "CreateIoCompletionPort(win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, nuint, uint)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateIoCompletionPort(SafeHandle FileHandle, SafeHandle ExistingCompletionPort, nuint CompletionKey, uint NumberOfConcurrentThreads)
        {
            bool FileHandleAddRef = false;
            bool ExistingCompletionPortAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE FileHandleLocal;
                if (FileHandle is object)
                {
                    FileHandle.DangerousAddRef(ref FileHandleAddRef);
                    FileHandleLocal = (win32.System.SystemServices.HANDLE)FileHandle.DangerousGetHandle();
                }
                else
                    FileHandleLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE ExistingCompletionPortLocal;
                if (ExistingCompletionPort is object)
                {
                    ExistingCompletionPort.DangerousAddRef(ref ExistingCompletionPortAddRef);
                    ExistingCompletionPortLocal = (win32.System.SystemServices.HANDLE)ExistingCompletionPort.DangerousGetHandle();
                }
                else
                    ExistingCompletionPortLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE __result = Kernel32.CreateIoCompletionPort(FileHandleLocal, ExistingCompletionPortLocal, CompletionKey, NumberOfConcurrentThreads);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (FileHandleAddRef)
                    FileHandle.DangerousRelease();
                if (ExistingCompletionPortAddRef)
                    ExistingCompletionPort.DangerousRelease();
            }
        }

        /// <summary>Creates an input/output (I/O) completion port and associates it with a specified file handle, or creates an I/O completion port that is not yet associated with a file handle, allowing association at a later time.</summary>
        /// <param name = "FileHandle">
        /// <para>An open file handle or <b>INVALID_HANDLE_VALUE</b>.</para>
        /// <para>The handle must be to an object that supports overlapped I/O.</para>
        /// <para>If a handle is provided, it has to have been opened for overlapped I/O completion. For example, you must specify the <b>FILE_FLAG_OVERLAPPED</b> flag when using the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function to obtain the handle.</para>
        /// <para>If <b>INVALID_HANDLE_VALUE</b> is specified, the function creates an I/O completion port without associating it with a file handle. In this case, the <i>ExistingCompletionPort</i> parameter must be <b>NULL</b> and the <i>CompletionKey</i> parameter is ignored.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-createiocompletionport#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ExistingCompletionPort">
        /// <para>A handle to an existing I/O completion port or <b>NULL</b>.</para>
        /// <para>If this parameter specifies an existing I/O completion port, the function associates it with the handle specified by the <i>FileHandle</i> parameter. The function returns the handle of the existing I/O completion port if successful; it does not create a new I/O completion port.</para>
        /// <para>If this parameter is <b>NULL</b>, the function creates a new I/O completion port and, if the <i>FileHandle</i> parameter is valid, associates it with the new I/O completion port. Otherwise no file handle association occurs. The function returns the handle to the new I/O completion port if successful.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-createiocompletionport#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "CompletionKey">The per-handle user-defined completion key that is included in every I/O completion packet for the specified file handle. For more information, see the Remarks section.</param>
        /// <param name = "NumberOfConcurrentThreads">
        /// <para>The maximum number of threads that the operating system can allow to concurrently process I/O completion packets for the I/O completion port. This parameter is ignored if the <i>ExistingCompletionPort</i> parameter is not <b>NULL</b>.</para>
        /// <para>If this parameter is zero, the system allows as many concurrently running threads as there are processors in the system.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-createiocompletionport#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the handle to an I/O completion port:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-createiocompletionport">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE CreateIoCompletionPort(win32.System.SystemServices.HANDLE FileHandle, win32.System.SystemServices.HANDLE ExistingCompletionPort, nuint CompletionKey, uint NumberOfConcurrentThreads);
        /// <inheritdoc cref = "GetQueuedCompletionStatus(win32.System.SystemServices.HANDLE, uint *, nuint*, win32.System.SystemServices.OVERLAPPED**, uint)"/>
        internal static unsafe bool GetQueuedCompletionStatus(SafeHandle CompletionPort, out uint lpNumberOfBytesTransferred, out nuint lpCompletionKey, out win32.System.SystemServices.OVERLAPPED*lpOverlapped, uint dwMilliseconds)
        {
            bool CompletionPortAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.OVERLAPPED**lpOverlappedLocal = &lpOverlapped)
                {
                    fixed (nuint*lpCompletionKeyLocal = &lpCompletionKey)
                    {
                        fixed (uint *lpNumberOfBytesTransferredLocal = &lpNumberOfBytesTransferred)
                        {
                            win32.System.SystemServices.HANDLE CompletionPortLocal;
                            if (CompletionPort is object)
                            {
                                CompletionPort.DangerousAddRef(ref CompletionPortAddRef);
                                CompletionPortLocal = (win32.System.SystemServices.HANDLE)CompletionPort.DangerousGetHandle();
                            }
                            else
                                CompletionPortLocal = default(win32.System.SystemServices.HANDLE);
                            bool __result = Kernel32.GetQueuedCompletionStatus(CompletionPortLocal, lpNumberOfBytesTransferredLocal, lpCompletionKeyLocal, lpOverlappedLocal, dwMilliseconds);
                            return __result;
                        }
                    }
                }
            }
            finally
            {
                if (CompletionPortAddRef)
                    CompletionPort.DangerousRelease();
            }
        }

        /// <summary>Attempts to dequeue an I/O completion packet from the specified I/O completion port.</summary>
        /// <param name = "CompletionPort">
        /// <para>A handle to the completion port. To create a completion port, use the <a href = "https://docs.microsoft.com/windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getqueuedcompletionstatus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNumberOfBytesTransferred">A pointer to a variable that receives the number of bytes transferred in a completed I/O operation.</param>
        /// <param name = "lpCompletionKey">
        /// <para>A pointer to a variable that receives the completion key value associated with the file handle whose I/O operation has completed. A completion key is a per-file key that is specified in a call to <a href = "https://docs.microsoft.com/windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getqueuedcompletionstatus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to a variable that receives the address of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that was specified when the completed I/O operation was started.</para>
        /// <para>Even if you have passed the function a file handle associated with a completion port and a valid <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, an application can prevent completion port notification. This is done by specifying a valid event handle for the <b>hEvent</b> member of the <b>OVERLAPPED</b> structure, and setting its low-order bit. A valid event handle whose low-order bit is set keeps I/O completion from being queued to the completion port.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getqueuedcompletionstatus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMilliseconds">
        /// <para>The number of milliseconds that the caller is willing to wait for a completion packet to appear at the completion port. If a completion packet does not appear within the specified time, the function times out, returns <b>FALSE</b>, and sets *<i>lpOverlapped</i> to <b>NULL</b>.</para>
        /// <para>If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will never time out. If <i>dwMilliseconds</i> is zero and there is no I/O operation to dequeue, the function will time out immediately.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getqueuedcompletionstatus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns nonzero (<b>TRUE</b>) if successful or zero (<b>FALSE</b>) otherwise.</para>
        /// <para>To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>For more information, see the Remarks section.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getqueuedcompletionstatus">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetQueuedCompletionStatus(win32.System.SystemServices.HANDLE CompletionPort, uint *lpNumberOfBytesTransferred, nuint*lpCompletionKey, win32.System.SystemServices.OVERLAPPED**lpOverlapped, uint dwMilliseconds);
        /// <inheritdoc cref = "GetQueuedCompletionStatusEx(win32.System.SystemServices.HANDLE, win32.Storage.FileSystem.OVERLAPPED_ENTRY*, uint, uint *, uint, bool)"/>
        internal static unsafe bool GetQueuedCompletionStatusEx(SafeHandle CompletionPort, Span<win32.Storage.FileSystem.OVERLAPPED_ENTRY> lpCompletionPortEntries, out uint ulNumEntriesRemoved, uint dwMilliseconds, bool fAlertable)
        {
            bool CompletionPortAddRef = false;
            try
            {
                fixed (uint *ulNumEntriesRemovedLocal = &ulNumEntriesRemoved)
                {
                    fixed (win32.Storage.FileSystem.OVERLAPPED_ENTRY*lpCompletionPortEntriesLocal = lpCompletionPortEntries)
                    {
                        win32.System.SystemServices.HANDLE CompletionPortLocal;
                        if (CompletionPort is object)
                        {
                            CompletionPort.DangerousAddRef(ref CompletionPortAddRef);
                            CompletionPortLocal = (win32.System.SystemServices.HANDLE)CompletionPort.DangerousGetHandle();
                        }
                        else
                            CompletionPortLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.GetQueuedCompletionStatusEx(CompletionPortLocal, lpCompletionPortEntriesLocal, (uint)lpCompletionPortEntries.Length, ulNumEntriesRemovedLocal, dwMilliseconds, fAlertable);
                        return __result;
                    }
                }
            }
            finally
            {
                if (CompletionPortAddRef)
                    CompletionPort.DangerousRelease();
            }
        }

        /// <summary>Retrieves multiple completion port entries simultaneously.</summary>
        /// <param name = "CompletionPort">
        /// <para>A handle to the completion port. To create a completion port, use the <a href = "https://docs.microsoft.com/windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getqueuedcompletionstatusex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCompletionPortEntries">
        /// <para>On input, points to a pre-allocated array of <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped_entry">OVERLAPPED_ENTRY</a> structures.</para>
        /// <para>On output, receives an array of <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped_entry">OVERLAPPED_ENTRY</a> structures that hold the entries. The number of array elements is provided by <i>ulNumEntriesRemoved</i>.</para>
        /// <para>The number of bytes transferred during each I/O, the completion key that indicates on which file each I/O occurred, and the overlapped structure address used in each original I/O are all returned in the <i>lpCompletionPortEntries</i> array.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getqueuedcompletionstatusex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ulCount">The maximum number of entries to remove.</param>
        /// <param name = "ulNumEntriesRemoved">A pointer to a variable that receives the number of entries actually removed.</param>
        /// <param name = "dwMilliseconds">
        /// <para>The number of milliseconds that the caller is willing to wait for a completion packet to appear at the completion port. If a completion packet does not appear within the specified time, the function times out and returns <b>FALSE</b>.</para>
        /// <para>If <i>dwMilliseconds</i> is <b>INFINITE</b> (0xFFFFFFFF), the function will never time out. If <i>dwMilliseconds</i> is zero and there is no I/O operation to dequeue, the function will time out immediately.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getqueuedcompletionstatusex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fAlertable">
        /// <para>If this parameter is <b>FALSE</b>, the function does not return until the time-out period has elapsed or an entry is retrieved.</para>
        /// <para>If the parameter is <b>TRUE</b> and there are no available entries, the function performs an alertable wait. The thread returns when the system queues an I/O completion routine or APC to the thread and the thread executes the function.</para>
        /// <para>A completion routine is queued when the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefileex">WriteFileEx</a> function in which it was specified has completed, and the calling thread is the thread that initiated the operation. An APC is queued when you call <a href = "https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-queueuserapc">QueueUserAPC</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getqueuedcompletionstatusex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns nonzero (<b>TRUE</b>) if successful or zero (<b>FALSE</b>) otherwise.</para>
        /// <para>To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-getqueuedcompletionstatusex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetQueuedCompletionStatusEx(win32.System.SystemServices.HANDLE CompletionPort, win32.Storage.FileSystem.OVERLAPPED_ENTRY*lpCompletionPortEntries, uint ulCount, uint *ulNumEntriesRemoved, uint dwMilliseconds, bool fAlertable);
        /// <inheritdoc cref = "PostQueuedCompletionStatus(win32.System.SystemServices.HANDLE, uint, nuint, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool PostQueuedCompletionStatus(SafeHandle CompletionPort, uint dwNumberOfBytesTransferred, nuint dwCompletionKey, win32.System.SystemServices.OVERLAPPED? lpOverlapped)
        {
            bool CompletionPortAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE CompletionPortLocal;
                if (CompletionPort is object)
                {
                    CompletionPort.DangerousAddRef(ref CompletionPortAddRef);
                    CompletionPortLocal = (win32.System.SystemServices.HANDLE)CompletionPort.DangerousGetHandle();
                }
                else
                    CompletionPortLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.OVERLAPPED lpOverlappedLocal = lpOverlapped.HasValue ? lpOverlapped.Value : default(win32.System.SystemServices.OVERLAPPED);
                bool __result = Kernel32.PostQueuedCompletionStatus(CompletionPortLocal, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped.HasValue ? &lpOverlappedLocal : null);
                return __result;
            }
            finally
            {
                if (CompletionPortAddRef)
                    CompletionPort.DangerousRelease();
            }
        }

        /// <summary>Posts an I/O completion packet to an I/O completion port.</summary>
        /// <param name = "CompletionPort">A handle to an I/O completion port to which the I/O completion packet is to be posted.</param>
        /// <param name = "dwNumberOfBytesTransferred">
        /// <para>The value to be returned through the <i>lpNumberOfBytesTransferred</i> parameter of the <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-postqueuedcompletionstatus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwCompletionKey">
        /// <para>The value to be returned through the <i>lpCompletionKey</i> parameter of the <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-postqueuedcompletionstatus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>The value to be returned through the <i>lpOverlapped</i> parameter of the <a href = "https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-postqueuedcompletionstatus#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> .</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-postqueuedcompletionstatus">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool PostQueuedCompletionStatus(win32.System.SystemServices.HANDLE CompletionPort, uint dwNumberOfBytesTransferred, nuint dwCompletionKey, [Optional] win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <inheritdoc cref = "CancelIoEx(win32.System.SystemServices.HANDLE, win32.System.SystemServices.OVERLAPPED*)"/>
        internal static unsafe bool CancelIoEx(SafeHandle hFile, win32.System.SystemServices.OVERLAPPED? lpOverlapped)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.OVERLAPPED lpOverlappedLocal = lpOverlapped.HasValue ? lpOverlapped.Value : default(win32.System.SystemServices.OVERLAPPED);
                bool __result = Kernel32.CancelIoEx(hFileLocal, lpOverlapped.HasValue ? &lpOverlappedLocal : null);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations in the current process, regardless of which thread created the I/O operation.</summary>
        /// <param name = "hFile">A handle to the file.</param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure that contains the data used for asynchronous  I/O.</para>
        /// <para>If this parameter is <b>NULL</b>, all I/O requests for the <i>hFile</i> parameter are canceled.</para>
        /// <para>If this parameter is not <b>NULL</b>, only those specific I/O requests that were issued for the file with the specified <i>lpOverlapped</i> overlapped structure are marked as canceled, meaning that you can cancel one or more requests, while the <a href = "https://docs.microsoft.com/windows/desktop/FileIO/cancelio">CancelIo</a> function cancels all outstanding requests on a file handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-cancelioex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued by the calling process for the specified file handle was successfully requested. The application must not free or reuse the <a href = "/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure associated with the canceled I/O operations until they have completed. The thread can use the <a href = "/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> function to determine when the I/O operations themselves have been completed.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// <para>If this function cannot find a request to cancel, the return value is 0 (zero), and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_NOT_FOUND</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-cancelioex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool CancelIoEx(win32.System.SystemServices.HANDLE hFile, [Optional] win32.System.SystemServices.OVERLAPPED*lpOverlapped);
        /// <inheritdoc cref = "CancelIo(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool CancelIo(SafeHandle hFile)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.CancelIo(hFileLocal);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Cancels all pending input and output (I/O) operations that are issued by the calling thread for the specified file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file.</para>
        /// <para>The function cancels all pending I/O operations for this file handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-cancelio#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued by the calling thread for the specified file handle was successfully requested. The thread can use the <a href = "/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> function to determine when the I/O operations themselves have been completed.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-cancelio">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool CancelIo(win32.System.SystemServices.HANDLE hFile);
        /// <inheritdoc cref = "CancelSynchronousIo(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool CancelSynchronousIo(SafeHandle hThread)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.CancelSynchronousIo(hThreadLocal);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Marks pending synchronous I/O operations that are issued by the specified thread as canceled.</summary>
        /// <param name = "hThread">A handle to the thread.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// <para>If this function cannot find a request to cancel, the return value is 0 (zero), and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_NOT_FOUND</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//ioapiset/nf-ioapiset-cancelsynchronousio">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool CancelSynchronousIo(win32.System.SystemServices.HANDLE hThread);
        /// <inheritdoc cref = "Wow64DisableWow64FsRedirection(void **)"/>
        internal static unsafe bool Wow64DisableWow64FsRedirection(out void *OldValue)
        {
            fixed (void **OldValueLocal = &OldValue)
            {
                bool __result = Kernel32.Wow64DisableWow64FsRedirection(OldValueLocal);
                return __result;
            }
        }

        /// <summary>Disables file system redirection for the calling thread. File system redirection is enabled by default.</summary>
        /// <param name = "OldValue">
        /// <para>The WOW64 file system redirection value. The system uses this parameter to store information necessary to revert (re-enable) file system redirection.</para>
        /// <para><div class = "alert"><b>Note</b>  This value is for system use only. To avoid unpredictable behavior, do not modify this value in any way.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Wow64DisableWow64FsRedirection(void **OldValue);
        /// <summary>Restores file system redirection for the calling thread.</summary>
        /// <param name = "OlValue">TBD</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value.</para>
        /// <para>If the function fails, the return value is <b>FALSE</b> (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool Wow64RevertWow64FsRedirection(void *OlValue);
        /// <inheritdoc cref = "Wow64SuspendThread(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint Wow64SuspendThread(SafeHandle hThread)
        {
            bool hThreadAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hThreadLocal;
                if (hThread is object)
                {
                    hThread.DangerousAddRef(ref hThreadAddRef);
                    hThreadLocal = (win32.System.SystemServices.HANDLE)hThread.DangerousGetHandle();
                }
                else
                    hThreadLocal = default(win32.System.SystemServices.HANDLE);
                uint __result = Kernel32.Wow64SuspendThread(hThreadLocal);
                return __result;
            }
            finally
            {
                if (hThreadAddRef)
                    hThread.DangerousRelease();
            }
        }

        /// <summary>Suspends the specified WOW64 thread.</summary>
        /// <param name = "hThread">
        /// <para>A handle to the thread that is to be suspended.</para>
        /// <para>The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64suspendthread#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64suspendthread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint Wow64SuspendThread(win32.System.SystemServices.HANDLE hThread);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern int LZStart();
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void LZDone();
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern int CopyLZFile(int hfSource, int hfDest);
        /// <summary>Copies a source file to a destination file.</summary>
        /// <param name = "hfSource">A handle to the source file.</param>
        /// <param name = "hfDest">A handle to the destination file.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value specifies the size, in bytes, of the destination file.</para>
        /// <para>If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that <b>LZCopy</b> calls neither <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor <a href = "/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.</para>
        /// <para>The following is a list of error codes that <b>LZCopy</b> can return upon failure.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzcopy">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int LZCopy(int hfSource, int hfDest);
        /// <summary>Allocates memory for the internal data structures required to decompress files, and then creates and initializes them.</summary>
        /// <param name = "hfSource">A handle to the file.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a new LZ file handle.</para>
        /// <para>If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that <b>LZInit</b> calls neither <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor <a href = "/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.</para>
        /// <para>The following is the list of the error codes that <b>LZInit</b> can return upon failure.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzinit">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int LZInit(int hfSource);
        /// <summary>Retrieves the original name of a compressed file, if the file was compressed by the Lempel-Ziv algorithm.</summary>
        /// <param name = "lpszSource">The name of the compressed file.</param>
        /// <param name = "lpszBuffer">A pointer to a buffer that receives the original name of the compressed file.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is 1.</para>
        /// <para>If the function fails, the return value is LZERROR_BADVALUE. There is no extended error information for this function; do not call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para><div class = "alert"><b>Note</b>  <b>GetExpandedName</b> calls neither <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor <a href = "/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.</div> <div> </div></para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-getexpandednamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetExpandedNameW", SetLastError = true)]
        internal static extern int GetExpandedName(win32.System.SystemServices.PWSTR lpszSource, win32.System.SystemServices.PWSTR lpszBuffer);
        /// <inheritdoc cref = "LZOpenFile(win32.System.SystemServices.PWSTR, win32.Storage.FileSystem.OFSTRUCT*, win32.Storage.FileSystem.LZOPENFILE_STYLE)"/>
        internal static unsafe int LZOpenFile(win32.System.SystemServices.PWSTR lpFileName, ref win32.Storage.FileSystem.OFSTRUCT lpReOpenBuf, win32.Storage.FileSystem.LZOPENFILE_STYLE wStyle)
        {
            fixed (win32.Storage.FileSystem.OFSTRUCT*lpReOpenBufLocal = &lpReOpenBuf)
            {
                int __result = Kernel32.LZOpenFile(lpFileName, lpReOpenBufLocal, wStyle);
                return __result;
            }
        }

        /// <summary>Creates, opens, reopens, or deletes the specified file.</summary>
        /// <param name = "lpFileName">The name of the file.</param>
        /// <param name = "lpReOpenBuf">
        /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure that is to receive information about the file when the file is first opened. The structure can be used in subsequent calls to the <b>LZOpenFile</b> function to see the open file.</para>
        /// <para>The <b>szPathName</b> member of this structure contains characters from the original equipment manufacturer (OEM) character set.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzopenfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wStyle"></param>
        /// <returns>
        /// <para>If the function succeeds and the value specified by the <i>wStyle</i> parameter is not <b>OF_READ</b>, the return value is a handle identifying the file. If the file is compressed and opened with <i>wStyle</i> set to <b>OF_READ</b>, the return value is a special file handle.</para>
        /// <para>If the function fails, the return value is an <b>LZERROR_*</b> code. These codes have values less than zero. There is no extended error information for this function; do not call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para><div class = "alert"><b>Note</b>  <b>LZOpenFile</b> calls neither <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor <a href = "/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.</div> <div> </div> The following is the list of the error codes that <b>LZOpenFile</b> can return upon failure.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzopenfilew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "LZOpenFileW", SetLastError = true)]
        internal static extern unsafe int LZOpenFile(win32.System.SystemServices.PWSTR lpFileName, win32.Storage.FileSystem.OFSTRUCT*lpReOpenBuf, win32.Storage.FileSystem.LZOPENFILE_STYLE wStyle);
        /// <summary>Moves a file pointer the specified number of bytes from a starting position.</summary>
        /// <param name = "hFile">A handle to the file.</param>
        /// <param name = "lOffset">The number of bytes by which to move the file pointer.</param>
        /// <param name = "iOrigin"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value specifies the offset from the beginning of the file to the new pointer position.</para>
        /// <para>If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that <b>LZSeek</b> calls neither <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor <a href = "/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.</para>
        /// <para>The following is the list of error codes that <b>LZSeek</b> can return upon failure.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzseek">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int LZSeek(int hFile, int lOffset, int iOrigin);
        /// <summary>Reads (at most) the specified number of bytes from a file and copies them into a buffer.</summary>
        /// <param name = "hFile">A handle to the file.</param>
        /// <param name = "lpBuffer">A pointer to a buffer that receives the bytes read from the file. Ensure that this buffer is larger than <i>cbRead</i>.</param>
        /// <param name = "cbRead">The count of bytes to be read.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value specifies the number of bytes read.</para>
        /// <para>If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that <b>LZRead</b> calls neither <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor <a href = "/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.</para>
        /// <para>The following is the list of error codes that <b>LZRead</b> can return upon failure.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzread">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int LZRead(int hFile, win32.System.SystemServices.PSTR lpBuffer, int cbRead);
        /// <summary>Closes a file that was opened by using the LZOpenFile function.</summary>
        /// <param name = "hFile">A handle to the file to be closed.</param>
        /// <remarks>
        /// <para>The handle identifying the file must be retrieved by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzopenfilea">LZOpenFile</a> function. If the handle is retrieved by calling the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openfile">OpenFile</a> function, an error occurs.</para>
        /// <para>If the file has been compressed by the Lempel-Ziv algorithm and opened by using <a href = "https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzopenfilea">LZOpenFile</a>, <b>LZClose</b> frees any global heap space that was allocated to expand the file.</para>
        /// <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzclose#">Read more on docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void LZClose(int hFile);
        /// <inheritdoc cref = "SearchPath(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PWSTR, win32.System.SystemServices.PWSTR*)"/>
        internal static unsafe uint SearchPath(string lpPath, string lpFileName, string lpExtension, uint nBufferLength, win32.System.SystemServices.PWSTR lpBuffer, win32.System.SystemServices.PWSTR*lpFilePart)
        {
            fixed (char *lpExtensionLocal = lpExtension)
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    fixed (char *lpPathLocal = lpPath)
                    {
                        uint __result = Kernel32.SearchPath(lpPathLocal, lpFileNameLocal, lpExtensionLocal, nBufferLength, lpBuffer, lpFilePart);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Searches for a specified file in a specified path.</summary>
        /// <param name = "lpPath">
        /// <para>The path to be searched for the file.</para>
        /// <para>If this parameter is <b>NULL</b>, the function searches for a matching file using a registry-dependent system  search path. For more information, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-searchpathw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileName">The name of the file for which to search.</param>
        /// <param name = "lpExtension">
        /// <para>The extension to be added to the file name when searching for the file. The first character of the file name extension must be a period (.). The extension is added only if the specified file name does not end with an extension.</para>
        /// <para>If a file name extension is not required or if the file name contains an extension, this parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-searchpathw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBufferLength">
        /// <para>The size of the buffer that receives the valid path and file name (including the terminating null character), in <b>TCHARs</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-searchpathw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to the buffer to receive the path and file name of the file found. The  string is a null-terminated string.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-searchpathw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFilePart">
        /// <para>A pointer to the variable to receive the address (within <i>lpBuffer</i>) of the last component of the valid path and file name, which is the address of the character immediately following the final backslash (\\) in the path.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-searchpathw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the value returned is the length, in <b>TCHARs</b>, of the string that is copied to the buffer, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, the value returned is the size of the buffer that is required to hold the path, including the terminating null character.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-searchpathw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SearchPathW", SetLastError = true)]
        internal static extern unsafe uint SearchPath(win32.System.SystemServices.PCWSTR lpPath, win32.System.SystemServices.PCWSTR lpFileName, win32.System.SystemServices.PCWSTR lpExtension, uint nBufferLength, win32.System.SystemServices.PWSTR lpBuffer, [Optional] win32.System.SystemServices.PWSTR*lpFilePart);
        /// <inheritdoc cref = "GetBinaryType(win32.System.SystemServices.PCWSTR, uint *)"/>
        internal static unsafe bool GetBinaryType(string lpApplicationName, out uint lpBinaryType)
        {
            fixed (uint *lpBinaryTypeLocal = &lpBinaryType)
            {
                fixed (char *lpApplicationNameLocal = lpApplicationName)
                {
                    bool __result = Kernel32.GetBinaryType(lpApplicationNameLocal, lpBinaryTypeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.</summary>
        /// <param name = "lpApplicationName">
        /// <para>The full path of the file whose executable type is to be determined.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getbinarytypew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBinaryType">
        /// <para>A pointer to a variable to receive information about the executable type of the file specified by <i>lpApplicationName</i>. The following constants are defined.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getbinarytypew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by <i>lpBinaryType</i> to indicate the file's executable type.</para>
        /// <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the file is a DLL, the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getbinarytypew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetBinaryTypeW", SetLastError = true)]
        internal static extern unsafe bool GetBinaryType(win32.System.SystemServices.PCWSTR lpApplicationName, uint *lpBinaryType);
        /// <inheritdoc cref = "GetLongPathNameTransacted(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint GetLongPathNameTransacted(string lpszShortPath, win32.System.SystemServices.PWSTR lpszLongPath, uint cchBuffer, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpszShortPathLocal = lpszShortPath)
                {
                    win32.System.SystemServices.HANDLE hTransactionLocal;
                    if (hTransaction is object)
                    {
                        hTransaction.DangerousAddRef(ref hTransactionAddRef);
                        hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                    }
                    else
                        hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                    uint __result = Kernel32.GetLongPathNameTransacted(lpszShortPathLocal, lpszLongPath, cchBuffer, hTransactionLocal);
                    return __result;
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Converts the specified path to its long form as a transacted operation.</summary>
        /// <param name = "lpszShortPath">
        /// <para>The path to be converted.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
        /// <para>The path must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getlongpathnametransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszLongPath">
        /// <para>A pointer to the buffer to receive the long path.</para>
        /// <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getlongpathnametransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchBuffer">
        /// <para>The size of the buffer <i>lpszLongPath</i> points to, in <b>TCHAR</b>s.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getlongpathnametransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getlongpathnametransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length, in <b>TCHAR</b>s, of the string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
        /// <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHAR</b>s, of the buffer that is required to hold the path and the terminating null character.</para>
        /// <para>If the function fails for any other reason, such as if the file does not exist, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getlongpathnametransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetLongPathNameTransactedW", SetLastError = true)]
        internal static extern uint GetLongPathNameTransacted(win32.System.SystemServices.PCWSTR lpszShortPath, win32.System.SystemServices.PWSTR lpszLongPath, uint cchBuffer, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "SetFileCompletionNotificationModes(win32.System.SystemServices.HANDLE, byte)"/>
        internal static unsafe bool SetFileCompletionNotificationModes(SafeHandle FileHandle, byte Flags)
        {
            bool FileHandleAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE FileHandleLocal;
                if (FileHandle is object)
                {
                    FileHandle.DangerousAddRef(ref FileHandleAddRef);
                    FileHandleLocal = (win32.System.SystemServices.HANDLE)FileHandle.DangerousGetHandle();
                }
                else
                    FileHandleLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.SetFileCompletionNotificationModes(FileHandleLocal, Flags);
                return __result;
            }
            finally
            {
                if (FileHandleAddRef)
                    FileHandle.DangerousRelease();
            }
        }

        /// <summary>Sets the notification modes for a file handle, allowing you to specify how completion notifications work for the specified file.</summary>
        /// <param name = "FileHandle">A handle to the file.</param>
        /// <param name = "Flags">
        /// <para>The modes to be set.  One or more modes can be set at the same time; however, after a mode has been set for a file handle, it cannot be removed.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfilecompletionnotificationmodes#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns nonzero if successful or zero otherwise.</para>
        /// <para>To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfilecompletionnotificationmodes">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetFileCompletionNotificationModes(win32.System.SystemServices.HANDLE FileHandle, byte Flags);
        /// <inheritdoc cref = "SetFileShortName(win32.System.SystemServices.HANDLE, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetFileShortName(SafeHandle hFile, string lpShortName)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (char *lpShortNameLocal = lpShortName)
                {
                    win32.System.SystemServices.HANDLE hFileLocal;
                    if (hFile is object)
                    {
                        hFile.DangerousAddRef(ref hFileAddRef);
                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                    }
                    else
                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetFileShortName(hFileLocal, lpShortNameLocal);
                    return __result;
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Sets the short name for the specified file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the <b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfileshortnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpShortName">
        /// <para>A pointer to a string that specifies the short name for the file.</para>
        /// <para>Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If  a short file name does not exist, the function will do nothing and return success.</para>
        /// <para><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfileshortnamew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <b>GetLastError</b> may return one of the following error codes that are specific to this function.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfileshortnamew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetFileShortNameW", SetLastError = true)]
        internal static extern bool SetFileShortName(win32.System.SystemServices.HANDLE hFile, win32.System.SystemServices.PCWSTR lpShortName);
        /// <inheritdoc cref = "OpenFile(win32.System.SystemServices.PCSTR, win32.Storage.FileSystem.OFSTRUCT*, win32.Storage.FileSystem.LZOPENFILE_STYLE)"/>
        internal static unsafe int OpenFile(win32.System.SystemServices.PCSTR lpFileName, ref win32.Storage.FileSystem.OFSTRUCT lpReOpenBuff, win32.Storage.FileSystem.LZOPENFILE_STYLE uStyle)
        {
            fixed (win32.Storage.FileSystem.OFSTRUCT*lpReOpenBuffLocal = &lpReOpenBuff)
            {
                int __result = Kernel32.OpenFile(lpFileName, lpReOpenBuffLocal, uStyle);
                return __result;
            }
        }

        /// <summary>Creates, opens, reopens, or deletes a file.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file.</para>
        /// <para>The string must consist of characters from the 8-bit Windows character set. The <b>OpenFile</b> function does not support Unicode file names or opening named pipes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openfile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpReOpenBuff">
        /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure that receives information about a file when it is first opened.</para>
        /// <para>The structure can be used in subsequent calls to the <b>OpenFile</b> function to see an open file.</para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure contains a path string member with a length that is limited to <b>OFS_MAXPATHNAME</b> characters, which is 128 characters. Because of this, you cannot use the <b>OpenFile</b> function to open a file with a path length that exceeds 128 characters. The <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function does not have this path length limitation.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openfile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "uStyle">The action to be taken.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value specifies a file handle to use when performing file I/O. To close the file, call the <a href = "/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function using this handle.</para>
        /// <para>If the function fails, the return value is <b>HFILE_ERROR</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openfile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int OpenFile(win32.System.SystemServices.PCSTR lpFileName, win32.Storage.FileSystem.OFSTRUCT*lpReOpenBuff, win32.Storage.FileSystem.LZOPENFILE_STYLE uStyle);
        /// <summary>Enables or disables file system redirection for the calling thread.</summary>
        /// <param name = "Wow64FsEnableRedirection">
        /// <para>Indicates the type of request for WOW64 system folder redirection. If <b>TRUE</b>, requests redirection be enabled; if <b>FALSE</b>, requests redirection be disabled.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64enablewow64fsredirection#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Boolean value indicating whether the function succeeded. If <b>TRUE</b>, the function succeeded; if <b>FALSE</b>, the function failed.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64enablewow64fsredirection">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern byte Wow64EnableWow64FsRedirection(byte Wow64FsEnableRedirection);
        /// <summary>Sets the per-process mode that the SearchPath function uses when locating files.</summary>
        /// <param name = "Flags">
        /// <para>The search mode to use.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setsearchpathmode#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the operation completes successfully, the <b>SetSearchPathMode</b> function returns a nonzero value.</para>
        /// <para>If the operation fails, the <b>SetSearchPathMode</b> function returns zero. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// <para>If the <b>SetSearchPathMode</b> function fails because a parameter value is not valid, the value returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function will be <b>ERROR_INVALID_PARAMETER</b>.</para>
        /// <para>If the <b>SetSearchPathMode</b> function fails because the combination of current state and parameter value is not valid, the value returned by the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function will be <b>ERROR_ACCESS_DENIED</b>. For more information, see the Remarks section.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setsearchpathmode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetSearchPathMode(uint Flags);
        /// <inheritdoc cref = "CreateDirectoryEx(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.SECURITY_ATTRIBUTES*)"/>
        internal static unsafe bool CreateDirectoryEx(string lpTemplateDirectory, string lpNewDirectory, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpSecurityAttributes)
        {
            fixed (char *lpNewDirectoryLocal = lpNewDirectory)
            {
                fixed (char *lpTemplateDirectoryLocal = lpTemplateDirectory)
                {
                    win32.System.SystemServices.SECURITY_ATTRIBUTES lpSecurityAttributesLocal = lpSecurityAttributes.HasValue ? lpSecurityAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                    bool __result = Kernel32.CreateDirectoryEx(lpTemplateDirectoryLocal, lpNewDirectoryLocal, lpSecurityAttributes.HasValue ? &lpSecurityAttributesLocal : null);
                    return __result;
                }
            }
        }

        /// <summary>Creates a new directory with the attributes of a specified template directory.</summary>
        /// <param name = "lpTemplateDirectory">
        /// <para>The path of the directory to use as a template when creating the new directory.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectoryexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewDirectory">
        /// <para>The path of the directory to be created.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectoryexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSecurityAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory.</para>
        /// <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a directory are inherited from its parent directory.</para>
        /// <para>The target file system must support security on files and directories for this parameter to have an effect. This is indicated when <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> returns <b>FS_PERSISTENT_ACLS</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectoryexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectoryexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateDirectoryExW", SetLastError = true)]
        internal static extern unsafe bool CreateDirectoryEx(win32.System.SystemServices.PCWSTR lpTemplateDirectory, win32.System.SystemServices.PCWSTR lpNewDirectory, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributes);
        /// <inheritdoc cref = "CreateDirectoryTransacted(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool CreateDirectoryTransacted(string lpTemplateDirectory, string lpNewDirectory, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpSecurityAttributes, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpNewDirectoryLocal = lpNewDirectory)
                {
                    fixed (char *lpTemplateDirectoryLocal = lpTemplateDirectory)
                    {
                        win32.System.SystemServices.SECURITY_ATTRIBUTES lpSecurityAttributesLocal = lpSecurityAttributes.HasValue ? lpSecurityAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                        win32.System.SystemServices.HANDLE hTransactionLocal;
                        if (hTransaction is object)
                        {
                            hTransaction.DangerousAddRef(ref hTransactionAddRef);
                            hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                        }
                        else
                            hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.CreateDirectoryTransacted(lpTemplateDirectoryLocal, lpNewDirectoryLocal, lpSecurityAttributes.HasValue ? &lpSecurityAttributesLocal : null, hTransactionLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Creates a new directory as a transacted operation, with the attributes of a specified template directory.</summary>
        /// <param name = "lpTemplateDirectory">
        /// <para>The path of the directory to use as a template when creating the new directory.  This parameter can be <b>NULL</b>.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para>The directory must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectorytransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewDirectory">
        /// <para>The path of the directory to be created.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectorytransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSecurityAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory.</para>
        /// <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a directory are inherited from its parent directory.</para>
        /// <para>The target file system must support security on files and directories for this parameter to have an effect. This is indicated when <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> returns <b>FS_PERSISTENT_ACLS</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectorytransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectorytransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectorytransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateDirectoryTransactedW", SetLastError = true)]
        internal static extern unsafe bool CreateDirectoryTransacted(win32.System.SystemServices.PCWSTR lpTemplateDirectory, win32.System.SystemServices.PCWSTR lpNewDirectory, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributes, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "RemoveDirectoryTransacted(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool RemoveDirectoryTransacted(string lpPathName, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpPathNameLocal = lpPathName)
                {
                    win32.System.SystemServices.HANDLE hTransactionLocal;
                    if (hTransaction is object)
                    {
                        hTransaction.DangerousAddRef(ref hTransactionAddRef);
                        hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                    }
                    else
                        hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.RemoveDirectoryTransacted(lpPathNameLocal, hTransactionLocal);
                    return __result;
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Deletes an existing empty directory as a transacted operation.</summary>
        /// <param name = "lpPathName">
        /// <para>The path of the directory to be removed. The path must specify an empty directory, and the calling process must have delete access to the directory.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para>The directory must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-removedirectorytransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-removedirectorytransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-removedirectorytransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "RemoveDirectoryTransactedW", SetLastError = true)]
        internal static extern bool RemoveDirectoryTransacted(win32.System.SystemServices.PCWSTR lpPathName, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "GetFullPathNameTransacted(win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PWSTR, win32.System.SystemServices.PWSTR*, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint GetFullPathNameTransacted(string lpFileName, uint nBufferLength, win32.System.SystemServices.PWSTR lpBuffer, win32.System.SystemServices.PWSTR*lpFilePart, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    win32.System.SystemServices.HANDLE hTransactionLocal;
                    if (hTransaction is object)
                    {
                        hTransaction.DangerousAddRef(ref hTransactionAddRef);
                        hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                    }
                    else
                        hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                    uint __result = Kernel32.GetFullPathNameTransacted(lpFileNameLocal, nBufferLength, lpBuffer, lpFilePart, hTransactionLocal);
                    return __result;
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Retrieves the full path and file name of the specified file as a transacted operation.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file.</para>
        /// <para>This string can use short (the 8.3 form) or long file names. This string can be a share or volume name.</para>
        /// <para>The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfullpathnametransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBufferLength">
        /// <para>The size of the buffer to receive the null-terminated string  for the drive and path,  in <b>TCHARs</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfullpathnametransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">A pointer to a buffer that receives the null-terminated string for the  drive and path.</param>
        /// <param name = "lpFilePart">
        /// <para>A pointer to a buffer that receives the address (in <i>lpBuffer</i>) of the final file name component in the path. Specify <b>NULL</b> if you do not need to receive this information.</para>
        /// <para>If <i>lpBuffer</i> points to a directory and not a file, <i>lpFilePart</i> receives 0 (zero).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfullpathnametransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfullpathnametransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
        /// <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
        /// <para>If the function fails for any other reason, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfullpathnametransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetFullPathNameTransactedW", SetLastError = true)]
        internal static extern unsafe uint GetFullPathNameTransacted(win32.System.SystemServices.PCWSTR lpFileName, uint nBufferLength, win32.System.SystemServices.PWSTR lpBuffer, [Optional] win32.System.SystemServices.PWSTR*lpFilePart, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "CreateFileTransacted(win32.System.SystemServices.PCWSTR, uint, win32.Storage.FileSystem.FILE_SHARE_MODE, win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.Storage.FileSystem.FILE_CREATION_DISPOSITION, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, win32.Storage.FileSystem.TXFS_MINIVERSION*, void *)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle CreateFileTransacted(string lpFileName, uint dwDesiredAccess, win32.Storage.FileSystem.FILE_SHARE_MODE dwShareMode, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpSecurityAttributes, win32.Storage.FileSystem.FILE_CREATION_DISPOSITION dwCreationDisposition, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, SafeHandle hTemplateFile, SafeHandle hTransaction, win32.Storage.FileSystem.TXFS_MINIVERSION? pusMiniVersion, void *lpExtendedParameter)
        {
            bool hTemplateFileAddRef = false;
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    win32.System.SystemServices.SECURITY_ATTRIBUTES lpSecurityAttributesLocal = lpSecurityAttributes.HasValue ? lpSecurityAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                    win32.System.SystemServices.HANDLE hTemplateFileLocal;
                    if (hTemplateFile is object)
                    {
                        hTemplateFile.DangerousAddRef(ref hTemplateFileAddRef);
                        hTemplateFileLocal = (win32.System.SystemServices.HANDLE)hTemplateFile.DangerousGetHandle();
                    }
                    else
                        hTemplateFileLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.HANDLE hTransactionLocal;
                    if (hTransaction is object)
                    {
                        hTransaction.DangerousAddRef(ref hTransactionAddRef);
                        hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                    }
                    else
                        hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                    win32.Storage.FileSystem.TXFS_MINIVERSION pusMiniVersionLocal = pusMiniVersion.HasValue ? pusMiniVersion.Value : default(win32.Storage.FileSystem.TXFS_MINIVERSION);
                    win32.System.SystemServices.HANDLE __result = Kernel32.CreateFileTransacted(lpFileNameLocal, dwDesiredAccess, dwShareMode, lpSecurityAttributes.HasValue ? &lpSecurityAttributesLocal : null, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFileLocal, hTransactionLocal, pusMiniVersion.HasValue ? &pusMiniVersionLocal : null, lpExtendedParameter);
                    return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hTemplateFileAddRef)
                    hTemplateFile.DangerousRelease();
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Creates or opens a file, file stream, or directory as a transacted operation.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of an object to be created or opened.</para>
        /// <para>The object must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. For information on special device names, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.</para>
        /// <para>To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the object, which can be  summarized as read, write, both or neither (zero). The most commonly used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both (<b>GENERIC_READ</b> | <b>GENERIC_WRITE</b>). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para>If this parameter is zero, the application can query  file, directory, or device attributes without accessing that file or device. For more information, see the Remarks section of this topic.</para>
        /// <para>You cannot request an access mode that conflicts with the sharing mode that is specified in an open request that has an open handle. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwShareMode">
        /// <para>The sharing mode of an object, which can be read, write, both, delete, all of these, or none (refer to the following table).</para>
        /// <para>If this parameter is zero and <b>CreateFileTransacted</b> succeeds, the object cannot be shared and cannot be opened again until the handle is closed. For more information, see the Remarks section of this topic.</para>
        /// <para>You cannot request a sharing mode that conflicts with the access mode that is specified in an open request that has an open handle, because that would result in the following sharing violation: <b>ERROR_SHARING_VIOLATION</b>. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
        /// <para>To enable a process to share an object while another process has the object open, use a combination of one or</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSecurityAttributes">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that contains an optional <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">security descriptor</a> and also determines whether or not the returned handle can be inherited by child processes. The parameter can be <b>NULL</b>.</para>
        /// <para>If the <i>lpSecurityAttributes</i> parameter is <b>NULL</b>, the handle returned by <b>CreateFileTransacted</b> cannot be inherited by any child processes your application may create and the object associated with the returned handle gets a default security descriptor.</para>
        /// <para>The <b>bInheritHandle</b> member of the structure specifies whether the returned handle can be inherited.</para>
        /// <para>The  <b>lpSecurityDescriptor</b> member of the structure specifies a <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">security descriptor</a> for an object, but may also be <b>NULL</b>.</para>
        /// <para>If <b>lpSecurityDescriptor</b> member is <b>NULL</b>, the object associated with the returned handle is assigned a default security descriptor.</para>
        /// <para><b>CreateFileTransacted</b> ignores the <b>lpSecurityDescriptor</b> member when opening an existing file, but continues to use the <b>bInheritHandle</b> member.</para>
        /// <para>For more information, see the Remarks section of this topic.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwCreationDisposition">
        /// <para>An action to take on files that exist and  do not exist.</para>
        /// <para>For more information, see the Remarks section of this topic.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlagsAndAttributes">
        /// <para>The file attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value.</para>
        /// <para>This parameter can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
        /// <para>This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of buffering behavior, access modes, and other special-purpose flags. These combine with any <b>FILE_ATTRIBUTE_*</b> values.</para>
        /// <para>This parameter can also contain Security Quality of Service (SQOS) information by specifying the <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.</para>
        /// <para><div class = "alert"><b>Note</b>  <p class = "note">When <b>CreateFileTransacted</b> opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in <a href = "https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
        /// <para></div> <div> </div> The following file attributes and flags are used only for file objects, not other types of objects that <b>CreateFileTransacted</b> opens (additional information can be found in the Remarks section of this topic). For more advanced access to file attributes, see <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list of all file attributes with their values and descriptions, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTemplateFile">
        /// <para>A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file attributes and extended attributes for the file that is being created. This parameter can be <b>NULL</b>.</para>
        /// <para>When opening an existing file, <b>CreateFileTransacted</b> ignores the template file.</para>
        /// <para>When opening a new EFS-encrypted file, the file inherits the DACL from its parent directory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pusMiniVersion">
        /// <para>The miniversion to be opened. If the transaction specified in <i>hTransaction</i> is not the transaction that is modifying the file, this parameter should be <b>NULL</b>. Otherwise, this parameter can be a miniversion identifier returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_txfs_create_miniversion">FSCTL_TXFS_CREATE_MINIVERSION</a> control</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpExtendedParameter">This parameter is reserved and must be <b>NULL</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.</para>
        /// <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateFileTransactedW", SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE CreateFileTransacted(win32.System.SystemServices.PCWSTR lpFileName, uint dwDesiredAccess, win32.Storage.FileSystem.FILE_SHARE_MODE dwShareMode, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributes, win32.Storage.FileSystem.FILE_CREATION_DISPOSITION dwCreationDisposition, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, win32.System.SystemServices.HANDLE hTemplateFile, win32.System.SystemServices.HANDLE hTransaction, [Optional] win32.Storage.FileSystem.TXFS_MINIVERSION*pusMiniVersion, void *lpExtendedParameter);
        /// <inheritdoc cref = "ReOpenFile(win32.System.SystemServices.HANDLE, win32.Storage.FileSystem.FILE_ACCESS_FLAGS, win32.Storage.FileSystem.FILE_SHARE_MODE, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle ReOpenFile(SafeHandle hOriginalFile, win32.Storage.FileSystem.FILE_ACCESS_FLAGS dwDesiredAccess, win32.Storage.FileSystem.FILE_SHARE_MODE dwShareMode, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes)
        {
            bool hOriginalFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hOriginalFileLocal;
                if (hOriginalFile is object)
                {
                    hOriginalFile.DangerousAddRef(ref hOriginalFileAddRef);
                    hOriginalFileLocal = (win32.System.SystemServices.HANDLE)hOriginalFile.DangerousGetHandle();
                }
                else
                    hOriginalFileLocal = default(win32.System.SystemServices.HANDLE);
                win32.System.SystemServices.HANDLE __result = Kernel32.ReOpenFile(hOriginalFileLocal, dwDesiredAccess, dwShareMode, dwFlagsAndAttributes);
                return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
            }
            finally
            {
                if (hOriginalFileAddRef)
                    hOriginalFile.DangerousRelease();
            }
        }

        /// <summary>Reopens the specified file system object with different access rights, sharing mode, and flags.</summary>
        /// <param name = "hOriginalFile">
        /// <para>A handle to the object to be reopened. The object must have been created by the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-reopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">
        /// <para>The required access to the object. For a list of values, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>. You cannot request an access mode that conflicts with the sharing mode specified in a previous open request whose handle is still open.</para>
        /// <para>If this parameter is zero (0), the application can query device attributes without accessing the device. This is useful if an application wants to determine the size of a floppy disk drive and the formats it supports without requiring a floppy in the drive.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-reopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwShareMode">
        /// <para>The sharing mode of the object. You cannot request a sharing mode that conflicts with the access mode specified in a previous open request whose handle is still open.</para>
        /// <para>If this parameter is zero (0) and <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> succeeds, the object cannot be shared and cannot be opened again until the handle is closed.</para>
        /// <para>To enable other processes to share the object while your process has it open, use a combination of one or</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-reopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlagsAndAttributes"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is an open handle to the specified file.</para>
        /// <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-reopenfile">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.HANDLE ReOpenFile(win32.System.SystemServices.HANDLE hOriginalFile, win32.Storage.FileSystem.FILE_ACCESS_FLAGS dwDesiredAccess, win32.Storage.FileSystem.FILE_SHARE_MODE dwShareMode, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
        /// <inheritdoc cref = "SetFileAttributesTransacted(win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool SetFileAttributesTransacted(string lpFileName, uint dwFileAttributes, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    win32.System.SystemServices.HANDLE hTransactionLocal;
                    if (hTransaction is object)
                    {
                        hTransaction.DangerousAddRef(ref hTransactionAddRef);
                        hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                    }
                    else
                        hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetFileAttributesTransacted(lpFileNameLocal, dwFileAttributes, hTransactionLocal);
                    return __result;
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Sets the attributes for a file or directory as a transacted operation.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file whose attributes are to be set.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>. The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfileattributestransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFileAttributes">
        /// <para>The file attributes to set for the file.</para>
        /// <para>For a list of file attribute value and their descriptions, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>. This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
        /// <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
        /// <para>The following is a list of supported attribute values.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfileattributestransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfileattributestransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfileattributestransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetFileAttributesTransactedW", SetLastError = true)]
        internal static extern bool SetFileAttributesTransacted(win32.System.SystemServices.PCWSTR lpFileName, uint dwFileAttributes, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "GetFileAttributesTransacted(win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.GET_FILEEX_INFO_LEVELS, void *, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool GetFileAttributesTransacted(string lpFileName, win32.Storage.FileSystem.GET_FILEEX_INFO_LEVELS fInfoLevelId, void *lpFileInformation, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    win32.System.SystemServices.HANDLE hTransactionLocal;
                    if (hTransaction is object)
                    {
                        hTransaction.DangerousAddRef(ref hTransactionAddRef);
                        hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                    }
                    else
                        hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetFileAttributesTransacted(lpFileNameLocal, fInfoLevelId, lpFileInformation, hTransactionLocal);
                    return __result;
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Retrieves file system attributes for a specified file or directory as a transacted operation.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file or directory.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. The file or directory must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfileattributestransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fInfoLevelId">
        /// <para>The level of attribute information to retrieve.</para>
        /// <para>This parameter can be the following value from the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> enumeration. </para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfileattributestransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileInformation">
        /// <para>A pointer to a buffer that receives the attribute information.</para>
        /// <para>The type of attribute information that is stored into this buffer is determined by the value of <i>fInfoLevelId</i>. If the <i>fInfoLevelId</i> parameter is <b>GetFileExInfoStandard</b> then this parameter points to a <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> structure</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfileattributestransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfileattributestransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetFileAttributesTransactedW", SetLastError = true)]
        internal static extern unsafe bool GetFileAttributesTransacted(win32.System.SystemServices.PCWSTR lpFileName, win32.Storage.FileSystem.GET_FILEEX_INFO_LEVELS fInfoLevelId, void *lpFileInformation, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "GetCompressedFileSizeTransacted(win32.System.SystemServices.PCWSTR, uint *, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe uint GetCompressedFileSizeTransacted(string lpFileName, uint *lpFileSizeHigh, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    win32.System.SystemServices.HANDLE hTransactionLocal;
                    if (hTransaction is object)
                    {
                        hTransaction.DangerousAddRef(ref hTransactionAddRef);
                        hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                    }
                    else
                        hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                    uint __result = Kernel32.GetCompressedFileSizeTransacted(lpFileNameLocal, lpFileSizeHigh, hTransactionLocal);
                    return __result;
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Retrieves the actual number of bytes of disk storage used to store a specified file as a transacted operation.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file.</para>
        /// <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
        /// <para>The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcompressedfilesizetransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileSizeHigh">
        /// <para>A pointer to a variable that receives the high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
        /// <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcompressedfilesizetransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
        /// <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcompressedfilesizetransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetCompressedFileSizeTransactedW", SetLastError = true)]
        internal static extern unsafe uint GetCompressedFileSizeTransacted(win32.System.SystemServices.PCWSTR lpFileName, [Optional] uint *lpFileSizeHigh, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "DeleteFileTransacted(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool DeleteFileTransacted(string lpFileName, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    win32.System.SystemServices.HANDLE hTransactionLocal;
                    if (hTransaction is object)
                    {
                        hTransaction.DangerousAddRef(ref hTransactionAddRef);
                        hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                    }
                    else
                        hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.DeleteFileTransacted(lpFileNameLocal, hTransactionLocal);
                    return __result;
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Deletes an existing file as a transacted operation.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file to be deleted.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para>The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deletefiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deletefiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deletefiletransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "DeleteFileTransactedW", SetLastError = true)]
        internal static extern bool DeleteFileTransacted(win32.System.SystemServices.PCWSTR lpFileName, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "CheckNameLegalDOS8Dot3A(win32.System.SystemServices.PCSTR, win32.System.SystemServices.PSTR, uint, bool *, bool *)"/>
        internal static unsafe bool CheckNameLegalDOS8Dot3A(win32.System.SystemServices.PCSTR lpName, win32.System.SystemServices.PSTR lpOemName, uint OemNameSize, bool *pbNameContainsSpaces, out bool pbNameLegal)
        {
            fixed (bool *pbNameLegalLocal = &pbNameLegal)
            {
                bool __result = Kernel32.CheckNameLegalDOS8Dot3A(lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegalLocal);
                return __result;
            }
        }

        /// <summary>Determines whether the specified name can be used to create a file on a FAT file system.</summary>
        /// <param name = "lpName">The file name, in 8.3 format.</param>
        /// <param name = "lpOemName">
        /// <para>A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3a#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "OemNameSize">
        /// <para>The size of the <i>lpOemName</i> buffer, in characters. If <i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3a#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pbNameContainsSpaces">
        /// <para>Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If the name is not a valid 8.3 FAT file system name, this parameter is undefined.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3a#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pbNameLegal">
        /// <para>If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when the current OEM code page is applied to the file name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3a#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3a">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool CheckNameLegalDOS8Dot3A(win32.System.SystemServices.PCSTR lpName, win32.System.SystemServices.PSTR lpOemName, uint OemNameSize, [Optional] bool *pbNameContainsSpaces, bool *pbNameLegal);
        /// <inheritdoc cref = "CheckNameLegalDOS8Dot3W(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PSTR, uint, bool *, bool *)"/>
        internal static unsafe bool CheckNameLegalDOS8Dot3W(string lpName, win32.System.SystemServices.PSTR lpOemName, uint OemNameSize, bool *pbNameContainsSpaces, out bool pbNameLegal)
        {
            fixed (bool *pbNameLegalLocal = &pbNameLegal)
            {
                fixed (char *lpNameLocal = lpName)
                {
                    bool __result = Kernel32.CheckNameLegalDOS8Dot3W(lpNameLocal, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegalLocal);
                    return __result;
                }
            }
        }

        /// <summary>Determines whether the specified name can be used to create a file on a FAT file system.</summary>
        /// <param name = "lpName">The file name, in 8.3 format.</param>
        /// <param name = "lpOemName">
        /// <para>A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3w#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "OemNameSize">
        /// <para>The size of the <i>lpOemName</i> buffer, in characters. If <i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3w#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pbNameContainsSpaces">
        /// <para>Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If the name is not a valid 8.3 FAT file system name, this parameter is undefined.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3w#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pbNameLegal">
        /// <para>If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when the current OEM code page is applied to the file name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3w#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is 0 (zero). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3w">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool CheckNameLegalDOS8Dot3W(win32.System.SystemServices.PCWSTR lpName, win32.System.SystemServices.PSTR lpOemName, uint OemNameSize, [Optional] bool *pbNameContainsSpaces, bool *pbNameLegal);
        /// <inheritdoc cref = "FindFirstFileTransacted(win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.FINDEX_INFO_LEVELS, void *, win32.Storage.FileSystem.FINDEX_SEARCH_OPS, void *, uint, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe Kernel32.FindCloseSafeHandle FindFirstFileTransacted(string lpFileName, win32.Storage.FileSystem.FINDEX_INFO_LEVELS fInfoLevelId, void *lpFindFileData, win32.Storage.FileSystem.FINDEX_SEARCH_OPS fSearchOp, void *lpSearchFilter, uint dwAdditionalFlags, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    win32.System.SystemServices.HANDLE hTransactionLocal;
                    if (hTransaction is object)
                    {
                        hTransaction.DangerousAddRef(ref hTransactionAddRef);
                        hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                    }
                    else
                        hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                    win32.Storage.FileSystem.FindFileHandle __result = Kernel32.FindFirstFileTransacted(lpFileNameLocal, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransactionLocal);
                    return new Kernel32.FindCloseSafeHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Searches a directory for a file or subdirectory with a name that matches a specific name as a transacted operation.</summary>
        /// <param name = "lpFileName">
        /// <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk (*) or a question mark (?).</para>
        /// <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\).</para>
        /// <para>If the string ends with a wildcard, period (.), or directory name, the user must have access to the root and all subdirectories on the path.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para>The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fInfoLevelId">
        /// <para>The information level of the returned data.</para>
        /// <para>This parameter is one of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_info_levels">FINDEX_INFO_LEVELS</a> enumeration values.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFindFileData">
        /// <para>A pointer to the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that receives information about a found file or subdirectory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fSearchOp">
        /// <para>The type of filtering to perform that is different from wildcard matching.</para>
        /// <para>This parameter is one of the <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> enumeration values.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSearchFilter">
        /// <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information.</para>
        /// <para>At this time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer must be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwAdditionalFlags">
        /// <para>Specifies additional flags that control the search.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a search handle used in a subsequent call to <a href = "/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or <a href = "/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the <i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
        /// <para>If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfiletransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindFirstFileTransactedW", SetLastError = true)]
        internal static extern unsafe win32.Storage.FileSystem.FindFileHandle FindFirstFileTransacted(win32.System.SystemServices.PCWSTR lpFileName, win32.Storage.FileSystem.FINDEX_INFO_LEVELS fInfoLevelId, void *lpFindFileData, win32.Storage.FileSystem.FINDEX_SEARCH_OPS fSearchOp, void *lpSearchFilter, uint dwAdditionalFlags, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "CopyFile(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, bool)"/>
        internal static unsafe bool CopyFile(string lpExistingFileName, string lpNewFileName, bool bFailIfExists)
        {
            fixed (char *lpNewFileNameLocal = lpNewFileName)
            {
                fixed (char *lpExistingFileNameLocal = lpExistingFileName)
                {
                    bool __result = Kernel32.CopyFile(lpExistingFileNameLocal, lpNewFileNameLocal, bFailIfExists);
                    return __result;
                }
            }
        }

        /// <summary>Copies an existing file to a new file.</summary>
        /// <param name = "lpExistingFileName">
        /// <para>The name of an existing file.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div> If <i>lpExistingFileName</i> does not exist, <b>CopyFile</b> fails, and <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_FILE_NOT_FOUND</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewFileName">
        /// <para>The name of the new file.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bFailIfExists">
        /// <para>If this parameter is <b>TRUE</b> and the new file specified by <i>lpNewFileName</i> already exists, the function fails. If this parameter is <b>FALSE</b> and the new file already exists, the function overwrites the existing file and succeeds.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfilew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CopyFileW", SetLastError = true)]
        internal static extern bool CopyFile(win32.System.SystemServices.PCWSTR lpExistingFileName, win32.System.SystemServices.PCWSTR lpNewFileName, bool bFailIfExists);
        /// <inheritdoc cref = "CopyFileEx(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, delegate *unmanaged[Stdcall]{long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint}, void *, int *, uint)"/>
        internal static unsafe bool CopyFileEx(string lpExistingFileName, string lpNewFileName, delegate *unmanaged[Stdcall]<long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint>lpProgressRoutine, void *lpData, int *pbCancel, uint dwCopyFlags)
        {
            fixed (char *lpNewFileNameLocal = lpNewFileName)
            {
                fixed (char *lpExistingFileNameLocal = lpExistingFileName)
                {
                    bool __result = Kernel32.CopyFileEx(lpExistingFileNameLocal, lpNewFileNameLocal, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
                    return __result;
                }
            }
        }

        /// <summary>Copies an existing file to a new file, notifying the application of its progress through a callback function.</summary>
        /// <param name = "lpExistingFileName">
        /// <para>The name of an existing file.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. <div class = "alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div> <div> </div> If <i>lpExistingFileName</i> does not exist, the <b>CopyFileEx</b> function fails, and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_FILE_NOT_FOUND</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewFileName">
        /// <para>The name of the new file.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. <div class = "alert"><b>Tip</b>  Starting inWindows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpProgressRoutine">
        /// <para>The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback function, see the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpData">
        /// <para>The argument to be passed to the callback function. This parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pbCancel">
        /// <para>If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy operation will continue to completion.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwCopyFlags">
        /// <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following values. </para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>CopyFileEx</b> will return zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted.</para>
        /// <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>CopyFileEx</b> will return zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left intact.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfileexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CopyFileExW", SetLastError = true)]
        internal static extern unsafe bool CopyFileEx(win32.System.SystemServices.PCWSTR lpExistingFileName, win32.System.SystemServices.PCWSTR lpNewFileName, delegate *unmanaged[Stdcall]<long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint>lpProgressRoutine, [Optional] void *lpData, [Optional] int *pbCancel, uint dwCopyFlags);
        /// <inheritdoc cref = "CopyFileTransacted(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, delegate *unmanaged[Stdcall]{long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint}, void *, int *, uint, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool CopyFileTransacted(string lpExistingFileName, string lpNewFileName, delegate *unmanaged[Stdcall]<long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint>lpProgressRoutine, void *lpData, int? pbCancel, uint dwCopyFlags, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpNewFileNameLocal = lpNewFileName)
                {
                    fixed (char *lpExistingFileNameLocal = lpExistingFileName)
                    {
                        int pbCancelLocal = pbCancel.HasValue ? pbCancel.Value : default(int);
                        win32.System.SystemServices.HANDLE hTransactionLocal;
                        if (hTransaction is object)
                        {
                            hTransaction.DangerousAddRef(ref hTransactionAddRef);
                            hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                        }
                        else
                            hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.CopyFileTransacted(lpExistingFileNameLocal, lpNewFileNameLocal, lpProgressRoutine, lpData, pbCancel.HasValue ? &pbCancelLocal : null, dwCopyFlags, hTransactionLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Copies an existing file to a new file as a transacted operation, notifying the application of its progress through a callback function.</summary>
        /// <param name = "lpExistingFileName">
        /// <para>The name of an existing file.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para>If <i>lpExistingFileName</i> does not exist, the <b>CopyFileTransacted</b> function fails, and the <a href = "https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_FILE_NOT_FOUND</b>.</para>
        /// <para>The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewFileName">
        /// <para>The name of the new file.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpProgressRoutine">
        /// <para>The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback function, see the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpData">
        /// <para>The argument to be passed to the callback function. This parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pbCancel">
        /// <para>If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy operation will continue to completion.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwCopyFlags">
        /// <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>CopyFileTransacted</b> will return zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted.</para>
        /// <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>CopyFileTransacted</b> will return zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left intact.</para>
        /// <para>If you attempt to call this function with a handle to a transaction that has already been rolled back, <b>CopyFileTransacted</b> will return either <b>ERROR_TRANSACTION_NOT_ACTIVE</b> or <b>ERROR_INVALID_TRANSACTION</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfiletransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CopyFileTransactedW", SetLastError = true)]
        internal static extern unsafe bool CopyFileTransacted(win32.System.SystemServices.PCWSTR lpExistingFileName, win32.System.SystemServices.PCWSTR lpNewFileName, delegate *unmanaged[Stdcall]<long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint>lpProgressRoutine, [Optional] void *lpData, [Optional] int *pbCancel, uint dwCopyFlags, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "CopyFile2(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.COPYFILE2_EXTENDED_PARAMETERS*)"/>
        internal static unsafe win32.System.Com.HRESULT CopyFile2(string pwszExistingFileName, string pwszNewFileName, win32.Storage.FileSystem.COPYFILE2_EXTENDED_PARAMETERS? pExtendedParameters)
        {
            fixed (char *pwszNewFileNameLocal = pwszNewFileName)
            {
                fixed (char *pwszExistingFileNameLocal = pwszExistingFileName)
                {
                    win32.Storage.FileSystem.COPYFILE2_EXTENDED_PARAMETERS pExtendedParametersLocal = pExtendedParameters.HasValue ? pExtendedParameters.Value : default(win32.Storage.FileSystem.COPYFILE2_EXTENDED_PARAMETERS);
                    win32.System.Com.HRESULT __result = Kernel32.CopyFile2(pwszExistingFileNameLocal, pwszNewFileNameLocal, pExtendedParameters.HasValue ? &pExtendedParametersLocal : null);
                    return __result;
                }
            }
        }

        /// <summary>Copies an existing file to a new file, notifying the application of its progress through a callback function.</summary>
        /// <param name = "pwszExistingFileName">
        /// <para>The name of an existing file.</para>
        /// <para>To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting in Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\".  See the "Maximum Path Limitation" section of  <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div> <div> </div> If <i>lpExistingFileName</i> does not exist, the <b>CopyFile2</b> function fails returns <c>HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)</c>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfile2#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pwszNewFileName">
        /// <para>The name of the new file.</para>
        /// <para>To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting in Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfile2#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pExtendedParameters">
        /// <para>Optional address of a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-copyfile2_extended_parameters">COPYFILE2_EXTENDED_PARAMETERS</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfile2#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value will return <b>TRUE</b> when passed to the <a href = "/windows/desktop/api/winerror/nf-winerror-succeeded">SUCCEEDED</a> macro.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfile2">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe win32.System.Com.HRESULT CopyFile2(win32.System.SystemServices.PCWSTR pwszExistingFileName, win32.System.SystemServices.PCWSTR pwszNewFileName, [Optional] win32.Storage.FileSystem.COPYFILE2_EXTENDED_PARAMETERS*pExtendedParameters);
        /// <inheritdoc cref = "MoveFile(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool MoveFile(string lpExistingFileName, string lpNewFileName)
        {
            fixed (char *lpNewFileNameLocal = lpNewFileName)
            {
                fixed (char *lpExistingFileNameLocal = lpExistingFileName)
                {
                    bool __result = Kernel32.MoveFile(lpExistingFileNameLocal, lpNewFileNameLocal);
                    return __result;
                }
            }
        }

        /// <summary>Moves an existing file or a directory, including its children.</summary>
        /// <param name = "lpExistingFileName">
        /// <para>The current name of the file or directory on the local computer.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewFileName">
        /// <para>The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "MoveFileW", SetLastError = true)]
        internal static extern bool MoveFile(win32.System.SystemServices.PCWSTR lpExistingFileName, win32.System.SystemServices.PCWSTR lpNewFileName);
        /// <inheritdoc cref = "MoveFileEx(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.MOVE_FILE_FLAGS)"/>
        internal static unsafe bool MoveFileEx(string lpExistingFileName, string lpNewFileName, win32.Storage.FileSystem.MOVE_FILE_FLAGS dwFlags)
        {
            fixed (char *lpNewFileNameLocal = lpNewFileName)
            {
                fixed (char *lpExistingFileNameLocal = lpExistingFileName)
                {
                    bool __result = Kernel32.MoveFileEx(lpExistingFileNameLocal, lpNewFileNameLocal, dwFlags);
                    return __result;
                }
            }
        }

        /// <summary>Moves an existing file or directory, including its children, with various move options.</summary>
        /// <param name = "lpExistingFileName">
        /// <para>The current name of the file or directory on the local computer.</para>
        /// <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share, because delayed operations are performed before the network is available.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewFileName">
        /// <para>The new name of the file or directory on the local computer.</para>
        /// <para>When moving a file, the destination can be on a different file system or volume. If the destination is on another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
        /// <para>When moving a directory, the destination must be on the same drive.</para>
        /// <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and <i>lpNewFileName</i> is  <b>NULL</b>, <b>MoveFileEx</b> registers the <i>lpExistingFileName</i> file to be deleted when the system restarts. If <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefileexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefileexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "MoveFileExW", SetLastError = true)]
        internal static extern bool MoveFileEx(win32.System.SystemServices.PCWSTR lpExistingFileName, win32.System.SystemServices.PCWSTR lpNewFileName, win32.Storage.FileSystem.MOVE_FILE_FLAGS dwFlags);
        /// <inheritdoc cref = "MoveFileWithProgress(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, delegate *unmanaged[Stdcall]{long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint}, void *, win32.Storage.FileSystem.MOVE_FILE_FLAGS)"/>
        internal static unsafe bool MoveFileWithProgress(string lpExistingFileName, string lpNewFileName, delegate *unmanaged[Stdcall]<long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint>lpProgressRoutine, void *lpData, win32.Storage.FileSystem.MOVE_FILE_FLAGS dwFlags)
        {
            fixed (char *lpNewFileNameLocal = lpNewFileName)
            {
                fixed (char *lpExistingFileNameLocal = lpExistingFileName)
                {
                    bool __result = Kernel32.MoveFileWithProgress(lpExistingFileNameLocal, lpNewFileNameLocal, lpProgressRoutine, lpData, dwFlags);
                    return __result;
                }
            }
        }

        /// <summary>Moves a file or directory, including its children. You can provide a callback function that receives progress notifications.</summary>
        /// <param name = "lpExistingFileName">
        /// <para>The name of the existing file or directory on the local computer.</para>
        /// <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share because delayed operations are performed before the network is available.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilewithprogressw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewFileName">
        /// <para>The new name of the file or directory  on the local computer.</para>
        /// <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If <i>lpNewFileName</i> is on another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
        /// <para>When moving a directory, <i>lpExistingFileName</i> and <i>lpNewFileName</i> must be on the same drive.</para>
        /// <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and <i>lpNewFileName</i> is <b>NULL</b>, <b>MoveFileWithProgress</b> registers <i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it cannot access the registry to store the information about the delete operation. If <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilewithprogressw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpProgressRoutine">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function that is called each time another portion of the file has been moved. The callback function can be useful if you provide a user interface that displays the progress of the operation. This parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilewithprogressw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpData">
        /// <para>An argument to be passed to the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilewithprogressw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>MoveFileWithProgress</b> will return zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
        /// <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>MoveFileWithProgress</b> will return zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilewithprogressw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "MoveFileWithProgressW", SetLastError = true)]
        internal static extern unsafe bool MoveFileWithProgress(win32.System.SystemServices.PCWSTR lpExistingFileName, win32.System.SystemServices.PCWSTR lpNewFileName, delegate *unmanaged[Stdcall]<long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint>lpProgressRoutine, [Optional] void *lpData, win32.Storage.FileSystem.MOVE_FILE_FLAGS dwFlags);
        /// <inheritdoc cref = "MoveFileTransacted(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, delegate *unmanaged[Stdcall]{long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint}, void *, win32.Storage.FileSystem.MOVE_FILE_FLAGS, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool MoveFileTransacted(string lpExistingFileName, string lpNewFileName, delegate *unmanaged[Stdcall]<long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint>lpProgressRoutine, void *lpData, win32.Storage.FileSystem.MOVE_FILE_FLAGS dwFlags, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpNewFileNameLocal = lpNewFileName)
                {
                    fixed (char *lpExistingFileNameLocal = lpExistingFileName)
                    {
                        win32.System.SystemServices.HANDLE hTransactionLocal;
                        if (hTransaction is object)
                        {
                            hTransaction.DangerousAddRef(ref hTransactionAddRef);
                            hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                        }
                        else
                            hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.MoveFileTransacted(lpExistingFileNameLocal, lpNewFileNameLocal, lpProgressRoutine, lpData, dwFlags, hTransactionLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Moves an existing file or a directory, including its children, as a transacted operation.</summary>
        /// <param name = "lpExistingFileName">
        /// <para>The current name of the existing file or directory on the local computer.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNewFileName">
        /// <para>The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpProgressRoutine">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function that is called each time another portion of the file has been moved. The callback function can be useful if you provide a user interface that displays the progress of the operation. This parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpData">
        /// <para>An argument to be passed to the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This parameter can be <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefiletransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>MoveFileTransacted</b> will return zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
        /// <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>MoveFileTransacted</b> will return zero and <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefiletransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "MoveFileTransactedW", SetLastError = true)]
        internal static extern unsafe bool MoveFileTransacted(win32.System.SystemServices.PCWSTR lpExistingFileName, win32.System.SystemServices.PCWSTR lpNewFileName, delegate *unmanaged[Stdcall]<long, long, long, long, uint, win32.Storage.FileSystem.LPPROGRESS_ROUTINE_CALLBACK_REASON, win32.System.SystemServices.HANDLE, win32.System.SystemServices.HANDLE, void *, uint>lpProgressRoutine, [Optional] void *lpData, win32.Storage.FileSystem.MOVE_FILE_FLAGS dwFlags, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "ReplaceFile(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.REPLACE_FILE_FLAGS, void *, void *)"/>
        internal static unsafe bool ReplaceFile(string lpReplacedFileName, string lpReplacementFileName, string lpBackupFileName, win32.Storage.FileSystem.REPLACE_FILE_FLAGS dwReplaceFlags, void *lpExclude, void *lpReserved)
        {
            fixed (char *lpBackupFileNameLocal = lpBackupFileName)
            {
                fixed (char *lpReplacementFileNameLocal = lpReplacementFileName)
                {
                    fixed (char *lpReplacedFileNameLocal = lpReplacedFileName)
                    {
                        bool __result = Kernel32.ReplaceFile(lpReplacedFileNameLocal, lpReplacementFileNameLocal, lpBackupFileNameLocal, dwReplaceFlags, lpExclude, lpReserved);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Replaces one file with another file, with the option of creating a backup copy of the original file.</summary>
        /// <param name = "lpReplacedFileName">
        /// <para>The name of the file to be replaced.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div> This file is opened with the <b>GENERIC_READ</b>, <b>DELETE</b>, and <b>SYNCHRONIZE</b> access rights. The sharing mode is <b>FILE_SHARE_READ</b> | <b>FILE_SHARE_WRITE</b> | <b>FILE_SHARE_DELETE</b>.</para>
        /// <para>The caller must have write access to the file to be replaced. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-replacefilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpReplacementFileName">
        /// <para>The name of the file that will replace the <i>lpReplacedFileName</i> file.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div> The function attempts to open this file with the <b>SYNCHRONIZE</b>, <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, <b>DELETE</b>, and <b>WRITE_DAC</b> access rights so that it can preserve all attributes and ACLs. If this fails, the function attempts to open the file with the <b>SYNCHRONIZE</b>, <b>GENERIC_READ</b>, <b>DELETE</b>, and <b>WRITE_DAC</b> access rights. No sharing mode is specified.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-replacefilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBackupFileName">
        /// <para>The name of the file that will serve as a backup copy of the <i>lpReplacedFileName</i> file. If this parameter is <b>NULL</b>, no backup file is created. See the Remarks section for implementation details on the backup file.</para>
        /// <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-replacefilew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwReplaceFlags"></param>
        /// <param name = "lpExclude">Reserved for future use.</param>
        /// <param name = "lpReserved">Reserved for future use.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following are possible error codes for this function.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-replacefilew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "ReplaceFileW", SetLastError = true)]
        internal static extern unsafe bool ReplaceFile(win32.System.SystemServices.PCWSTR lpReplacedFileName, win32.System.SystemServices.PCWSTR lpReplacementFileName, win32.System.SystemServices.PCWSTR lpBackupFileName, win32.Storage.FileSystem.REPLACE_FILE_FLAGS dwReplaceFlags, void *lpExclude, void *lpReserved);
        /// <inheritdoc cref = "CreateHardLink(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.SECURITY_ATTRIBUTES*)"/>
        internal static unsafe bool CreateHardLink(string lpFileName, string lpExistingFileName, ref win32.System.SystemServices.SECURITY_ATTRIBUTES lpSecurityAttributes)
        {
            fixed (win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributesLocal = &lpSecurityAttributes)
            {
                fixed (char *lpExistingFileNameLocal = lpExistingFileName)
                {
                    fixed (char *lpFileNameLocal = lpFileName)
                    {
                        bool __result = Kernel32.CreateHardLink(lpFileNameLocal, lpExistingFileNameLocal, lpSecurityAttributesLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Establishes a hard link between an existing file and a new file.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the new file.</para>
        /// <para>This parameter may include the path but cannot specify the name of a directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND. <div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinkw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpExistingFileName">
        /// <para>The name of the existing file.</para>
        /// <para>This parameter may include the path cannot specify the name of a directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND. <div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinkw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSecurityAttributes">Reserved; must be <b>NULL</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
        /// <para>If you pass a name longer than MAX_PATH characters to the *lpFileName* or *lpExistingFileName* parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinkw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateHardLinkW", SetLastError = true)]
        internal static extern unsafe bool CreateHardLink(win32.System.SystemServices.PCWSTR lpFileName, win32.System.SystemServices.PCWSTR lpExistingFileName, win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributes);
        /// <inheritdoc cref = "CreateHardLinkTransacted(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool CreateHardLinkTransacted(string lpFileName, string lpExistingFileName, ref win32.System.SystemServices.SECURITY_ATTRIBUTES lpSecurityAttributes, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributesLocal = &lpSecurityAttributes)
                {
                    fixed (char *lpExistingFileNameLocal = lpExistingFileName)
                    {
                        fixed (char *lpFileNameLocal = lpFileName)
                        {
                            win32.System.SystemServices.HANDLE hTransactionLocal;
                            if (hTransaction is object)
                            {
                                hTransaction.DangerousAddRef(ref hTransactionAddRef);
                                hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                            }
                            else
                                hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                            bool __result = Kernel32.CreateHardLinkTransacted(lpFileNameLocal, lpExistingFileNameLocal, lpSecurityAttributesLocal, hTransactionLocal);
                            return __result;
                        }
                    }
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Establishes a hard link between an existing file and a new file as a transacted operation.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the new file.</para>
        /// <para>This parameter cannot specify the name of a directory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinktransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpExistingFileName">
        /// <para>The name of the existing file.</para>
        /// <para>This parameter cannot specify the name of a directory.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinktransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSecurityAttributes">Reserved; must be <b>NULL</b>.</param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinktransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero (0). To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
        /// <para>The files must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinktransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateHardLinkTransactedW", SetLastError = true)]
        internal static extern unsafe bool CreateHardLinkTransacted(win32.System.SystemServices.PCWSTR lpFileName, win32.System.SystemServices.PCWSTR lpExistingFileName, win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributes, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "FindFirstStreamTransacted(win32.System.SystemServices.PCWSTR, win32.Storage.FileSystem.STREAM_INFO_LEVELS, void *, uint, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe Kernel32.FindCloseSafeHandle FindFirstStreamTransacted(string lpFileName, win32.Storage.FileSystem.STREAM_INFO_LEVELS InfoLevel, void *lpFindStreamData, uint dwFlags, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpFileNameLocal = lpFileName)
                {
                    win32.System.SystemServices.HANDLE hTransactionLocal;
                    if (hTransaction is object)
                    {
                        hTransaction.DangerousAddRef(ref hTransactionAddRef);
                        hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                    }
                    else
                        hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                    win32.Storage.FileSystem.FindStreamHandle __result = Kernel32.FindFirstStreamTransacted(lpFileNameLocal, InfoLevel, lpFindStreamData, dwFlags, hTransactionLocal);
                    return new Kernel32.FindCloseSafeHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Enumerates the first stream in the specified file or directory as a transacted operation.</summary>
        /// <param name = "lpFileName">
        /// <para>The fully qualified file name.</para>
        /// <para>The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b> (6805).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirststreamtransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "InfoLevel">
        /// <para>The information level of the returned data. This parameter is one of the values in the <a href = "https://docs.microsoft.com/windows/desktop/api/fileapi/ne-fileapi-stream_info_levels">STREAM_INFO_LEVELS</a> enumeration type.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirststreamtransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFindStreamData">
        /// <para>A pointer to a buffer that receives the file data. The format of this data depends on the value of the <i>InfoLevel</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirststreamtransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Reserved for future use. This parameter must be zero.</param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirststreamtransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a search handle that can be used in subsequent calls to the <a href = "/windows/desktop/api/fileapi/nf-fileapi-findnextstreamw">FindNextStreamW</a>function.</para>
        /// <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirststreamtransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindFirstStreamTransactedW", SetLastError = true)]
        internal static extern unsafe win32.Storage.FileSystem.FindStreamHandle FindFirstStreamTransacted(win32.System.SystemServices.PCWSTR lpFileName, win32.Storage.FileSystem.STREAM_INFO_LEVELS InfoLevel, void *lpFindStreamData, uint dwFlags, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "FindFirstFileNameTransacted(win32.System.SystemServices.PCWSTR, uint, uint *, win32.System.SystemServices.PWSTR, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe Kernel32.FindCloseSafeHandle FindFirstFileNameTransacted(string lpFileName, uint dwFlags, ref uint StringLength, win32.System.SystemServices.PWSTR LinkName, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (uint *StringLengthLocal = &StringLength)
                {
                    fixed (char *lpFileNameLocal = lpFileName)
                    {
                        win32.System.SystemServices.HANDLE hTransactionLocal;
                        if (hTransaction is object)
                        {
                            hTransaction.DangerousAddRef(ref hTransactionAddRef);
                            hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                        }
                        else
                            hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                        win32.Storage.FileSystem.FindFileNameHandle __result = Kernel32.FindFirstFileNameTransacted(lpFileNameLocal, dwFlags, StringLengthLocal, LinkName, hTransactionLocal);
                        return new Kernel32.FindCloseSafeHandle(__result, ownsHandle: true);
                    }
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Creates an enumeration of all the hard links to the specified file as a transacted operation. The function returns a handle to the enumeration that can be used on subsequent calls to the FindNextFileNameW function.</summary>
        /// <param name = "lpFileName">
        /// <para>The name of the file.</para>
        /// <para>The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b> (6805).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfilenametransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Reserved; specify zero (0).</param>
        /// <param name = "StringLength">
        /// <para>The size of the buffer pointed to by the <i>LinkName</i> parameter, in characters. If this call fails and the error is <b>ERROR_MORE_DATA</b> (234), the value that is returned by this parameter is the size that the buffer pointed to by <i>LinkName</i> must be to contain all the data.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfilenametransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "LinkName">A pointer to a buffer to store the first link name found for <i>lpFileName</i>.</param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfilenametransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a search handle that can be used with the <a href = "/windows/desktop/api/fileapi/nf-fileapi-findnextfilenamew">FindNextFileNameW</a> function or closed with the <a href = "/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
        /// <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b> (0xffffffff). To get extended error information, call the <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfilenametransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindFirstFileNameTransactedW", SetLastError = true)]
        internal static extern unsafe win32.Storage.FileSystem.FindFileNameHandle FindFirstFileNameTransacted(win32.System.SystemServices.PCWSTR lpFileName, uint dwFlags, uint *StringLength, win32.System.SystemServices.PWSTR LinkName, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "SetVolumeLabel(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetVolumeLabel(string lpRootPathName, string lpVolumeName)
        {
            fixed (char *lpVolumeNameLocal = lpVolumeName)
            {
                fixed (char *lpRootPathNameLocal = lpRootPathName)
                {
                    bool __result = Kernel32.SetVolumeLabel(lpRootPathNameLocal, lpVolumeNameLocal);
                    return __result;
                }
            }
        }

        /// <summary>Sets the label of a file system volume.</summary>
        /// <param name = "lpRootPathName">
        /// <para>A pointer to a string that contains the volume's drive letter (for example, X:\) or the path of a mounted folder that is associated with the volume (for example, Y:\MountX\). The string must end with a trailing backslash ('\'). If this parameter is <b>NULL</b>, the root of the current directory is used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setvolumelabelw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpVolumeName">
        /// <para>A pointer to a string that contains the new label for the volume. If this parameter is <b>NULL</b>, the function deletes any existing label from the specified volume and does not assign a new label.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setvolumelabelw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setvolumelabelw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetVolumeLabelW", SetLastError = true)]
        internal static extern bool SetVolumeLabel(win32.System.SystemServices.PCWSTR lpRootPathName, win32.System.SystemServices.PCWSTR lpVolumeName);
        /// <inheritdoc cref = "SetFileBandwidthReservation(win32.System.SystemServices.HANDLE, uint, uint, bool, uint *, uint *)"/>
        internal static unsafe bool SetFileBandwidthReservation(SafeHandle hFile, uint nPeriodMilliseconds, uint nBytesPerPeriod, bool bDiscardable, out uint lpTransferSize, out uint lpNumOutstandingRequests)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (uint *lpNumOutstandingRequestsLocal = &lpNumOutstandingRequests)
                {
                    fixed (uint *lpTransferSizeLocal = &lpTransferSize)
                    {
                        win32.System.SystemServices.HANDLE hFileLocal;
                        if (hFile is object)
                        {
                            hFile.DangerousAddRef(ref hFileAddRef);
                            hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                        }
                        else
                            hFileLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.SetFileBandwidthReservation(hFileLocal, nPeriodMilliseconds, nBytesPerPeriod, bDiscardable, lpTransferSizeLocal, lpNumOutstandingRequestsLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Requests that bandwidth for the specified file stream be reserved. The reservation is specified as a number of bytes in a period of milliseconds for I/O requests on the specified file handle.</summary>
        /// <param name = "hFile">A handle to the file.</param>
        /// <param name = "nPeriodMilliseconds">
        /// <para>The period of the reservation, in milliseconds. The period is the time from which the I/O is issued to the kernel until the time the I/O should be completed. The minimum supported value for the file stream can be determined by looking at the value returned through the <i>lpPeriodMilliseconds</i> parameter to the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilebandwidthreservation">GetFileBandwidthReservation</a> function, on a handle that has not had a bandwidth reservation set.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfilebandwidthreservation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBytesPerPeriod">
        /// <para>The bandwidth to reserve, in bytes per period. The maximum supported value for the file stream can be determined by looking at the value returned through the <i>lpBytesPerPeriod</i> parameter to the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilebandwidthreservation">GetFileBandwidthReservation</a> function, on a handle that has not had a bandwidth reservation set.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfilebandwidthreservation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bDiscardable">
        /// <para>Indicates whether I/O should be completed with an error if a driver is unable to satisfy an I/O operation before the period expires. If one of the drivers for the specified file stream does not support this functionality, this function may return success and ignore the flag. To verify whether the setting will be honored, call the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilebandwidthreservation">GetFileBandwidthReservation</a> function using the same <i>hFile</i> handle and examine the <i>*pDiscardable</i> return value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfilebandwidthreservation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTransferSize">
        /// <para>A pointer to a variable that receives the minimum size of any individual I/O request that may be issued by the application. All I/O requests should be multiples of <i>TransferSize</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfilebandwidthreservation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNumOutstandingRequests">
        /// <para>A pointer to a variable that receives the number of <i>TransferSize</i> chunks the application should allow to be outstanding with the operating system. This allows the storage stack to keep the device busy and allows maximum throughput.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfilebandwidthreservation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns nonzero if successful or zero otherwise.</para>
        /// <para>A reservation can fail if there is not enough bandwidth available on the volume because of existing reservations; in this case <b>ERROR_NO_SYSTEM_RESOURCES</b> is returned.</para>
        /// <para>To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfilebandwidthreservation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetFileBandwidthReservation(win32.System.SystemServices.HANDLE hFile, uint nPeriodMilliseconds, uint nBytesPerPeriod, bool bDiscardable, uint *lpTransferSize, uint *lpNumOutstandingRequests);
        /// <inheritdoc cref = "GetFileBandwidthReservation(win32.System.SystemServices.HANDLE, uint *, uint *, int *, uint *, uint *)"/>
        internal static unsafe bool GetFileBandwidthReservation(SafeHandle hFile, out uint lpPeriodMilliseconds, out uint lpBytesPerPeriod, out int pDiscardable, out uint lpTransferSize, out uint lpNumOutstandingRequests)
        {
            bool hFileAddRef = false;
            try
            {
                fixed (uint *lpNumOutstandingRequestsLocal = &lpNumOutstandingRequests)
                {
                    fixed (uint *lpTransferSizeLocal = &lpTransferSize)
                    {
                        fixed (int *pDiscardableLocal = &pDiscardable)
                        {
                            fixed (uint *lpBytesPerPeriodLocal = &lpBytesPerPeriod)
                            {
                                fixed (uint *lpPeriodMillisecondsLocal = &lpPeriodMilliseconds)
                                {
                                    win32.System.SystemServices.HANDLE hFileLocal;
                                    if (hFile is object)
                                    {
                                        hFile.DangerousAddRef(ref hFileAddRef);
                                        hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                                    }
                                    else
                                        hFileLocal = default(win32.System.SystemServices.HANDLE);
                                    bool __result = Kernel32.GetFileBandwidthReservation(hFileLocal, lpPeriodMillisecondsLocal, lpBytesPerPeriodLocal, pDiscardableLocal, lpTransferSizeLocal, lpNumOutstandingRequestsLocal);
                                    return __result;
                                }
                            }
                        }
                    }
                }
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves the bandwidth reservation properties of the volume on which the specified file resides.</summary>
        /// <param name = "hFile">A handle to the file.</param>
        /// <param name = "lpPeriodMilliseconds">
        /// <para>A pointer to a variable that receives the period of the reservation, in milliseconds. The period is the time from which the I/O is issued to the kernel until the time the I/O should be completed. If no bandwidth has been reserved for this handle, then the value returned is the minimum reservation period supported for this volume.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfilebandwidthreservation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBytesPerPeriod">
        /// <para>A pointer to a variable that receives the maximum number of bytes per period that can be reserved on the volume. If no bandwidth has been reserved for this handle, then the value returned is the maximum number of bytes per period supported for the volume.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfilebandwidthreservation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pDiscardable">
        /// <para><b>TRUE</b> if I/O should be completed with an error if a driver is unable to satisfy an I/O operation before the period expires. <b>FALSE</b> if the underlying subsystem does not support failing in this manner.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfilebandwidthreservation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTransferSize">
        /// <para>The minimum size of any individual I/O request that may be issued by the application. All I/O requests should be multiples of <i>TransferSize</i>. If no bandwidth has been reserved for this handle, then the value returned is the minimum transfer size supported for this volume.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfilebandwidthreservation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpNumOutstandingRequests">
        /// <para>The number of <i>TransferSize</i> chunks  allowed to be outstanding with the operating system.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfilebandwidthreservation#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns nonzero if successful or zero otherwise.</para>
        /// <para>To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfilebandwidthreservation">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetFileBandwidthReservation(win32.System.SystemServices.HANDLE hFile, uint *lpPeriodMilliseconds, uint *lpBytesPerPeriod, int *pDiscardable, uint *lpTransferSize, uint *lpNumOutstandingRequests);
        /// <inheritdoc cref = "ReadDirectoryChanges(win32.System.SystemServices.HANDLE, void *, uint, bool, win32.Storage.FileSystem.FILE_NOTIFY_CHANGE, uint *, win32.System.SystemServices.OVERLAPPED*, delegate *unmanaged[Stdcall]{uint, uint, win32.System.SystemServices.OVERLAPPED*, void})"/>
        internal static unsafe bool ReadDirectoryChanges(SafeHandle hDirectory, void *lpBuffer, uint nBufferLength, bool bWatchSubtree, win32.Storage.FileSystem.FILE_NOTIFY_CHANGE dwNotifyFilter, uint *lpBytesReturned, win32.System.SystemServices.OVERLAPPED*lpOverlapped, delegate *unmanaged[Stdcall]<uint, uint, win32.System.SystemServices.OVERLAPPED*, void>lpCompletionRoutine)
        {
            bool hDirectoryAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDirectoryLocal;
                if (hDirectory is object)
                {
                    hDirectory.DangerousAddRef(ref hDirectoryAddRef);
                    hDirectoryLocal = (win32.System.SystemServices.HANDLE)hDirectory.DangerousGetHandle();
                }
                else
                    hDirectoryLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.ReadDirectoryChanges(hDirectoryLocal, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine);
                return __result;
            }
            finally
            {
                if (hDirectoryAddRef)
                    hDirectory.DangerousRelease();
            }
        }

        /// <summary>Retrieves information that describes the changes within the specified directory.</summary>
        /// <param name = "hDirectory">
        /// <para>A handle to the directory to be monitored. This directory must be opened with the <b>FILE_LIST_DIRECTORY</b> access right, or an access right such as <b>GENERIC_READ</b> that includes the <b>FILE_LIST_DIRECTORY</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to the <b>DWORD</b>-aligned formatted buffer in which the read results are to be returned. The structure of this buffer is defined by the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_information">FILE_NOTIFY_INFORMATION</a> structure. This buffer is filled either synchronously or asynchronously, depending on how the directory is opened and what value is given to the <i>lpOverlapped</i> parameter. For more information, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBufferLength">
        /// <para>The size of the buffer that is pointed to by the <i>lpBuffer</i> parameter, in bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bWatchSubtree">
        /// <para>If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory. If this parameter is <b>FALSE</b>, the function monitors only the directory specified by the <i>hDirectory</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwNotifyFilter">The filter criteria that the function checks to determine if the wait operation has completed. This</param>
        /// <param name = "lpBytesReturned">
        /// <para>For synchronous calls, this parameter receives the number of bytes transferred into the <i>lpBuffer</i> parameter. For asynchronous calls, this parameter is undefined. You must use an asynchronous notification technique to retrieve the number of bytes transferred.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that supplies data to be used during asynchronous operation. Otherwise, this value is <b>NULL</b>. The <b>Offset</b> and <b>OffsetHigh</b> members of this structure are not used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCompletionRoutine">
        /// <para>A pointer to a completion routine to be called when the operation has been completed or canceled and the calling thread is in an alertable wait state. For more information about this completion routine, see <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. For synchronous calls, this means that the operation succeeded. For asynchronous calls, this indicates that the operation was successfully queued.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the network redirector or the target file system does not support this operation, the function fails with <b>ERROR_INVALID_FUNCTION</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "ReadDirectoryChangesW", SetLastError = true)]
        internal static extern unsafe bool ReadDirectoryChanges(win32.System.SystemServices.HANDLE hDirectory, void *lpBuffer, uint nBufferLength, bool bWatchSubtree, win32.Storage.FileSystem.FILE_NOTIFY_CHANGE dwNotifyFilter, [Optional] uint *lpBytesReturned, [Optional] win32.System.SystemServices.OVERLAPPED*lpOverlapped, delegate *unmanaged[Stdcall]<uint, uint, win32.System.SystemServices.OVERLAPPED*, void>lpCompletionRoutine);
        /// <inheritdoc cref = "ReadDirectoryChangesEx(win32.System.SystemServices.HANDLE, void *, uint, bool, win32.Storage.FileSystem.FILE_NOTIFY_CHANGE, uint *, win32.System.SystemServices.OVERLAPPED*, delegate *unmanaged[Stdcall]{uint, uint, win32.System.SystemServices.OVERLAPPED*, void}, win32.Storage.FileSystem.READ_DIRECTORY_NOTIFY_INFORMATION_CLASS)"/>
        internal static unsafe bool ReadDirectoryChangesEx(SafeHandle hDirectory, void *lpBuffer, uint nBufferLength, bool bWatchSubtree, win32.Storage.FileSystem.FILE_NOTIFY_CHANGE dwNotifyFilter, uint *lpBytesReturned, win32.System.SystemServices.OVERLAPPED*lpOverlapped, delegate *unmanaged[Stdcall]<uint, uint, win32.System.SystemServices.OVERLAPPED*, void>lpCompletionRoutine, win32.Storage.FileSystem.READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
        {
            bool hDirectoryAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hDirectoryLocal;
                if (hDirectory is object)
                {
                    hDirectory.DangerousAddRef(ref hDirectoryAddRef);
                    hDirectoryLocal = (win32.System.SystemServices.HANDLE)hDirectory.DangerousGetHandle();
                }
                else
                    hDirectoryLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.ReadDirectoryChangesEx(hDirectoryLocal, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine, ReadDirectoryNotifyInformationClass);
                return __result;
            }
            finally
            {
                if (hDirectoryAddRef)
                    hDirectory.DangerousRelease();
            }
        }

        /// <summary>Retrieves information that describes the changes within the specified directory, which can include extended information if that information type is specified.</summary>
        /// <param name = "hDirectory">
        /// <para>A handle to the directory to be monitored. This directory must be opened with the <b>FILE_LIST_DIRECTORY</b> access right, or an access right such as <b>GENERIC_READ</b> that includes the <b>FILE_LIST_DIRECTORY</b> access right.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpBuffer">
        /// <para>A pointer to the <b>DWORD</b>-aligned formatted buffer in which <b>ReadDirectoryChangesExW</b> should return the read results. The structure of this buffer is defined by the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_extended_information">FILE_NOTIFY_EXTENDED_INFORMATION</a> structure if the value of the <i>ReadDirectoryNotifyInformationClass</i> parameter is <b>ReadDirectoryNotifyExtendedInformation</b>, or by the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_information">FILE_NOTIFY_INFORMATION</a> structure if <i>ReadDirectoryNotifyInformationClass</i> is <b>ReadDirectoryNotifyInformation</b>.</para>
        /// <para>This buffer is filled either synchronously or asynchronously, depending on how the directory is opened and what value is given to the <i>lpOverlapped</i> parameter. For more information, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nBufferLength">
        /// <para>The size of the buffer to which the <i>lpBuffer</i> parameter points, in bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bWatchSubtree">
        /// <para>If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory. If this parameter is <b>FALSE</b>, the function monitors only the directory specified by the <i>hDirectory</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwNotifyFilter">The filter criteria that the function checks to determine if the wait operation has completed. This</param>
        /// <param name = "lpBytesReturned">
        /// <para>For synchronous calls, this parameter receives the number of bytes transferred into the <i>lpBuffer</i> parameter. For asynchronous calls, this parameter is undefined. You must use an asynchronous notification technique to retrieve the number of bytes transferred.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpOverlapped">
        /// <para>A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that supplies data to be used during asynchronous operation. Otherwise, this value is <b>NULL</b>. The <b>Offset</b> and <b>OffsetHigh</b> members of this structure are not used.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCompletionRoutine">
        /// <para>A pointer to a completion routine to be called when the operation has been completed or canceled and the calling thread is in an alertable wait state. For more information about this completion routine, see <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "ReadDirectoryNotifyInformationClass">
        /// <para>The type of   information that <b>ReadDirectoryChangesExW</b> should write to the buffer to which the <i>lpBuffer</i> parameter points. Specify <b>ReadDirectoryNotifyInformation</b> to indicate that the information should consist of <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_information">FILE_NOTIFY_INFORMATION</a> structures, or <b>ReadDirectoryNotifyExtendedInformation</b>to indicate that the information should consist of <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_extended_information">FILE_NOTIFY_EXTENDED_INFORMATION</a> structures.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. For synchronous calls, this means that the operation succeeded. For asynchronous calls, this indicates that the operation was successfully queued.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the network redirector or the target file system does not support this operation, the function fails with <b>ERROR_INVALID_FUNCTION</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "ReadDirectoryChangesExW", SetLastError = true)]
        internal static extern unsafe bool ReadDirectoryChangesEx(win32.System.SystemServices.HANDLE hDirectory, void *lpBuffer, uint nBufferLength, bool bWatchSubtree, win32.Storage.FileSystem.FILE_NOTIFY_CHANGE dwNotifyFilter, [Optional] uint *lpBytesReturned, [Optional] win32.System.SystemServices.OVERLAPPED*lpOverlapped, delegate *unmanaged[Stdcall]<uint, uint, win32.System.SystemServices.OVERLAPPED*, void>lpCompletionRoutine, win32.Storage.FileSystem.READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass);
        /// <summary>Closes the specified mounted folder search handle.</summary>
        /// <param name = "hFindVolumeMountPoint">
        /// <para>The mounted folder search handle to be closed. This handle must have been previously opened by the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findvolumemountpointclose#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findvolumemountpointclose">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern win32.System.SystemServices.BOOL FindVolumeMountPointClose(win32.Storage.FileSystem.FindVolumeMointPointHandle hFindVolumeMountPoint);
        /// <inheritdoc cref = "FindFirstVolumeMountPoint(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe Kernel32.FindVolumeMountPointCloseSafeHandle FindFirstVolumeMountPoint(string lpszRootPathName, win32.System.SystemServices.PWSTR lpszVolumeMountPoint, uint cchBufferLength)
        {
            fixed (char *lpszRootPathNameLocal = lpszRootPathName)
            {
                win32.Storage.FileSystem.FindVolumeMointPointHandle __result = Kernel32.FindFirstVolumeMountPoint(lpszRootPathNameLocal, lpszVolumeMountPoint, cchBufferLength);
                return new Kernel32.FindVolumeMountPointCloseSafeHandle(__result, ownsHandle: true);
            }
        }

        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref = "Kernel32.FindVolumeMountPointClose"/>.
        /// </summary>
        internal class FindVolumeMountPointCloseSafeHandle : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            internal FindVolumeMountPointCloseSafeHandle(): base(INVALID_HANDLE_VALUE, true)
            {
            }

            internal FindVolumeMountPointCloseSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true): base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;
            protected override bool ReleaseHandle() => Kernel32.FindVolumeMountPointClose((win32.Storage.FileSystem.FindVolumeMointPointHandle)this.handle);
        }

        /// <summary>Retrieves the name of a mounted folder on the specified volume.</summary>
        /// <param name = "lpszRootPathName">A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</param>
        /// <param name = "lpszVolumeMountPoint">A pointer to a buffer that receives the name of the first mounted folder that is found.</param>
        /// <param name = "cchBufferLength">
        /// <para>The length of the buffer that receives the path to the mounted folder, in <b>TCHAR</b>s.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstvolumemountpointw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a search handle used in a subsequent call to the <a href = "/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> and <a href = "/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> functions.</para>
        /// <para>If the function fails to find a mounted folder on the volume, the return value is the <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstvolumemountpointw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindFirstVolumeMountPointW", SetLastError = true)]
        internal static extern win32.Storage.FileSystem.FindVolumeMointPointHandle FindFirstVolumeMountPoint(win32.System.SystemServices.PCWSTR lpszRootPathName, win32.System.SystemServices.PWSTR lpszVolumeMountPoint, uint cchBufferLength);
        /// <inheritdoc cref = "FindNextVolumeMountPoint(win32.Storage.FileSystem.FindVolumeMointPointHandle, win32.System.SystemServices.PWSTR, uint)"/>
        internal static unsafe bool FindNextVolumeMountPoint(SafeHandle hFindVolumeMountPoint, win32.System.SystemServices.PWSTR lpszVolumeMountPoint, uint cchBufferLength)
        {
            bool hFindVolumeMountPointAddRef = false;
            try
            {
                win32.Storage.FileSystem.FindVolumeMointPointHandle hFindVolumeMountPointLocal;
                if (hFindVolumeMountPoint is object)
                {
                    hFindVolumeMountPoint.DangerousAddRef(ref hFindVolumeMountPointAddRef);
                    hFindVolumeMountPointLocal = (win32.Storage.FileSystem.FindVolumeMointPointHandle)hFindVolumeMountPoint.DangerousGetHandle();
                }
                else
                    hFindVolumeMountPointLocal = default(win32.Storage.FileSystem.FindVolumeMointPointHandle);
                bool __result = Kernel32.FindNextVolumeMountPoint(hFindVolumeMountPointLocal, lpszVolumeMountPoint, cchBufferLength);
                return __result;
            }
            finally
            {
                if (hFindVolumeMountPointAddRef)
                    hFindVolumeMountPoint.DangerousRelease();
            }
        }

        /// <summary>Continues a mounted folder search started by a call to the FindFirstVolumeMountPoint function.</summary>
        /// <param name = "hFindVolumeMountPoint">
        /// <para>A mounted folder search handle returned by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findnextvolumemountpointw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszVolumeMountPoint">A pointer to a buffer that receives the name of the mounted folder that is found.</param>
        /// <param name = "cchBufferLength">
        /// <para>The length of the buffer that receives the mounted folder name, in <b>TCHARs</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findnextvolumemountpointw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no more mounted folders can be found, the <b>GetLastError</b> function returns the <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the <a href = "/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findnextvolumemountpointw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FindNextVolumeMountPointW", SetLastError = true)]
        internal static extern bool FindNextVolumeMountPoint(win32.Storage.FileSystem.FindVolumeMointPointHandle hFindVolumeMountPoint, win32.System.SystemServices.PWSTR lpszVolumeMountPoint, uint cchBufferLength);
        /// <inheritdoc cref = "SetVolumeMountPoint(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetVolumeMountPoint(string lpszVolumeMountPoint, string lpszVolumeName)
        {
            fixed (char *lpszVolumeNameLocal = lpszVolumeName)
            {
                fixed (char *lpszVolumeMountPointLocal = lpszVolumeMountPoint)
                {
                    bool __result = Kernel32.SetVolumeMountPoint(lpszVolumeMountPointLocal, lpszVolumeNameLocal);
                    return __result;
                }
            }
        }

        /// <summary>Associates a volume with a drive letter or a directory on another volume.</summary>
        /// <param name = "lpszVolumeMountPoint">
        /// <para>The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\") or a directory on another volume (for example, "Y:\MountX\"). The string must end with a trailing backslash ('\').</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setvolumemountpointw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpszVolumeName">
        /// <para>A volume <b>GUID</b> path for the volume. This string must be of the form "\\\\?\\Volume{<i>GUID</i>}\\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. The "\\\\?\\" turns off path parsing and is ignored as part of the path, as discussed in <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setvolumemountpointw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setvolumemountpointw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetVolumeMountPointW", SetLastError = true)]
        internal static extern bool SetVolumeMountPoint(win32.System.SystemServices.PCWSTR lpszVolumeMountPoint, win32.System.SystemServices.PCWSTR lpszVolumeName);
        /// <inheritdoc cref = "GetFileInformationByHandleEx(win32.System.SystemServices.HANDLE, win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS, void *, uint)"/>
        internal static unsafe bool GetFileInformationByHandleEx(SafeHandle hFile, win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS FileInformationClass, void *lpFileInformation, uint dwBufferSize)
        {
            bool hFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE hFileLocal;
                if (hFile is object)
                {
                    hFile.DangerousAddRef(ref hFileAddRef);
                    hFileLocal = (win32.System.SystemServices.HANDLE)hFile.DangerousGetHandle();
                }
                else
                    hFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.GetFileInformationByHandleEx(hFileLocal, FileInformationClass, lpFileInformation, dwBufferSize);
                return __result;
            }
            finally
            {
                if (hFileAddRef)
                    hFile.DangerousRelease();
            }
        }

        /// <summary>Retrieves file information for the specified file.</summary>
        /// <param name = "hFile">
        /// <para>A handle to the file that contains the information to be retrieved.</para>
        /// <para>This handle should not be a pipe handle.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfileinformationbyhandleex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "FileInformationClass">
        /// <para>A <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-file_info_by_handle_class">FILE_INFO_BY_HANDLE_CLASS</a> enumeration value that specifies the type of information to be retrieved.</para>
        /// <para>For a table of valid values, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfileinformationbyhandleex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFileInformation">
        /// <para>A pointer to the buffer that receives the requested file information. The structure that is returned corresponds to the class that is specified by <i>FileInformationClass</i>. For a table of valid structure types, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfileinformationbyhandleex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwBufferSize">The size of the <i>lpFileInformation</i> buffer, in bytes.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero and file information data is contained in the buffer pointed to by the <i>lpFileInformation</i> parameter.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfileinformationbyhandleex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetFileInformationByHandleEx(win32.System.SystemServices.HANDLE hFile, win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS FileInformationClass, void *lpFileInformation, uint dwBufferSize);
        /// <inheritdoc cref = "OpenFileById(win32.System.SystemServices.HANDLE, win32.Storage.FileSystem.FILE_ID_DESCRIPTOR*, win32.Storage.FileSystem.FILE_ACCESS_FLAGS, win32.Storage.FileSystem.FILE_SHARE_MODE, win32.System.SystemServices.SECURITY_ATTRIBUTES*, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES)"/>
        internal static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle OpenFileById(SafeHandle hVolumeHint, in win32.Storage.FileSystem.FILE_ID_DESCRIPTOR lpFileId, win32.Storage.FileSystem.FILE_ACCESS_FLAGS dwDesiredAccess, win32.Storage.FileSystem.FILE_SHARE_MODE dwShareMode, win32.System.SystemServices.SECURITY_ATTRIBUTES? lpSecurityAttributes, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes)
        {
            bool hVolumeHintAddRef = false;
            try
            {
                fixed (win32.Storage.FileSystem.FILE_ID_DESCRIPTOR*lpFileIdLocal = &lpFileId)
                {
                    win32.System.SystemServices.HANDLE hVolumeHintLocal;
                    if (hVolumeHint is object)
                    {
                        hVolumeHint.DangerousAddRef(ref hVolumeHintAddRef);
                        hVolumeHintLocal = (win32.System.SystemServices.HANDLE)hVolumeHint.DangerousGetHandle();
                    }
                    else
                        hVolumeHintLocal = default(win32.System.SystemServices.HANDLE);
                    win32.System.SystemServices.SECURITY_ATTRIBUTES lpSecurityAttributesLocal = lpSecurityAttributes.HasValue ? lpSecurityAttributes.Value : default(win32.System.SystemServices.SECURITY_ATTRIBUTES);
                    win32.System.SystemServices.HANDLE __result = Kernel32.OpenFileById(hVolumeHintLocal, lpFileIdLocal, dwDesiredAccess, dwShareMode, lpSecurityAttributes.HasValue ? &lpSecurityAttributesLocal : null, dwFlagsAndAttributes);
                    return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
                }
            }
            finally
            {
                if (hVolumeHintAddRef)
                    hVolumeHint.DangerousRelease();
            }
        }

        /// <summary>Opens the file that matches the specified identifier.</summary>
        /// <param name = "hVolumeHint">A handle to any file on a volume or share on which the file to be opened is stored.</param>
        /// <param name = "lpFileId">
        /// <para>A pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_descriptor">FILE_ID_DESCRIPTOR</a> that identifies the file to open.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openfilebyid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwDesiredAccess">
        /// <para>The access to the object. Access can be read, write, or both.</para>
        /// <para>For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>. You cannot request an access mode that conflicts with the sharing mode that is specified in an open request that has an open handle.</para>
        /// <para>If this parameter is zero (0), the application can query file and device attributes without accessing a device. This is useful for an application to determine the size of a floppy disk drive and the formats it supports without requiring a floppy in a drive. It can also be used to test for the existence of a file or directory without opening them for read or write access.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openfilebyid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwShareMode">
        /// <para>The sharing mode of an object, which can be read, write, both, or none.</para>
        /// <para>You cannot request a sharing mode that conflicts with the access mode that is specified in an open request that has an open handle, because that would result in the following sharing violation: (<b>ERROR_SHARING_VIOLATION</b>). For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
        /// <para>If this parameter is zero (0) and <b>OpenFileById</b> succeeds, the object cannot be shared and cannot be opened again until the handle is closed. For more information, see the Remarks section of this topic.</para>
        /// <para>The sharing options remain in effect until you close the handle to an object.</para>
        /// <para>To enable a processes to share an object while another process has the object open, use a combination of one</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openfilebyid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSecurityAttributes">Reserved.</param>
        /// <param name = "dwFlagsAndAttributes">
        /// <para>The file flags.</para>
        /// <para>When <b>OpenFileById</b> opens a file, it combines the file flags with existing file attributes, and ignores any supplied file attributes. This parameter can include any combination of the following flags.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openfilebyid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is an open handle to a specified file.</para>
        /// <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openfilebyid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe win32.System.SystemServices.HANDLE OpenFileById(win32.System.SystemServices.HANDLE hVolumeHint, win32.Storage.FileSystem.FILE_ID_DESCRIPTOR*lpFileId, win32.Storage.FileSystem.FILE_ACCESS_FLAGS dwDesiredAccess, win32.Storage.FileSystem.FILE_SHARE_MODE dwShareMode, [Optional] win32.System.SystemServices.SECURITY_ATTRIBUTES*lpSecurityAttributes, win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
        /// <inheritdoc cref = "CreateSymbolicLink(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, uint)"/>
        internal static unsafe byte CreateSymbolicLink(string lpSymlinkFileName, string lpTargetFileName, uint dwFlags)
        {
            fixed (char *lpTargetFileNameLocal = lpTargetFileName)
            {
                fixed (char *lpSymlinkFileNameLocal = lpSymlinkFileName)
                {
                    byte __result = Kernel32.CreateSymbolicLink(lpSymlinkFileNameLocal, lpTargetFileNameLocal, dwFlags);
                    return __result;
                }
            }
        }

        /// <summary>Creates a symbolic link.</summary>
        /// <param name = "lpSymlinkFileName">
        /// <para>The symbolic link to be created.</para>
        /// <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinkw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpTargetFileName">
        /// <para>The name of the target for the symbolic link to be created.</para>
        /// <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.</para>
        /// <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
        /// <para><div class = "alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href = "https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinkw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinkw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinkw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateSymbolicLinkW", SetLastError = true)]
        internal static extern byte CreateSymbolicLink(win32.System.SystemServices.PCWSTR lpSymlinkFileName, win32.System.SystemServices.PCWSTR lpTargetFileName, uint dwFlags);
        /// <inheritdoc cref = "CreateSymbolicLinkTransacted(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe byte CreateSymbolicLinkTransacted(string lpSymlinkFileName, string lpTargetFileName, uint dwFlags, SafeHandle hTransaction)
        {
            bool hTransactionAddRef = false;
            try
            {
                fixed (char *lpTargetFileNameLocal = lpTargetFileName)
                {
                    fixed (char *lpSymlinkFileNameLocal = lpSymlinkFileName)
                    {
                        win32.System.SystemServices.HANDLE hTransactionLocal;
                        if (hTransaction is object)
                        {
                            hTransaction.DangerousAddRef(ref hTransactionAddRef);
                            hTransactionLocal = (win32.System.SystemServices.HANDLE)hTransaction.DangerousGetHandle();
                        }
                        else
                            hTransactionLocal = default(win32.System.SystemServices.HANDLE);
                        byte __result = Kernel32.CreateSymbolicLinkTransacted(lpSymlinkFileNameLocal, lpTargetFileNameLocal, dwFlags, hTransactionLocal);
                        return __result;
                    }
                }
            }
            finally
            {
                if (hTransactionAddRef)
                    hTransaction.DangerousRelease();
            }
        }

        /// <summary>Creates a symbolic link as a transacted operation.</summary>
        /// <param name = "lpSymlinkFileName">The symbolic link to be created.</param>
        /// <param name = "lpTargetFileName">
        /// <para>The name of the target for the symbolic link to be created.</para>
        /// <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinktransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinktransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "hTransaction">
        /// <para>A handle to the transaction. This handle is returned by the <a href = "https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinktransactedw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinktransactedw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CreateSymbolicLinkTransactedW", SetLastError = true)]
        internal static extern byte CreateSymbolicLinkTransacted(win32.System.SystemServices.PCWSTR lpSymlinkFileName, win32.System.SystemServices.PCWSTR lpTargetFileName, uint dwFlags, win32.System.SystemServices.HANDLE hTransaction);
        /// <inheritdoc cref = "GetCurrentPackageId(uint *, byte *)"/>
        internal static unsafe int GetCurrentPackageId(ref uint bufferLength, byte *buffer)
        {
            fixed (uint *bufferLengthLocal = &bufferLength)
            {
                int __result = Kernel32.GetCurrentPackageId(bufferLengthLocal, buffer);
                return __result;
            }
        }

        /// <summary>Gets the package identifier (ID) for the calling process.</summary>
        /// <param name = "bufferLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of <i>buffer</i>, in bytes. On output, the size of the structure returned, in bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackageid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "buffer">
        /// <para>Type: <b>BYTE*</b></para>
        /// <para>The package ID, represented as a <a href = "https://docs.microsoft.com/windows/desktop/api/appmodel/ns-appmodel-package_id">PACKAGE_ID</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackageid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackageid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetCurrentPackageId(uint *bufferLength, [Optional] byte *buffer);
        /// <inheritdoc cref = "GetCurrentPackageFullName(uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int GetCurrentPackageFullName(ref uint packageFullNameLength, win32.System.SystemServices.PWSTR packageFullName)
        {
            fixed (uint *packageFullNameLengthLocal = &packageFullNameLength)
            {
                int __result = Kernel32.GetCurrentPackageFullName(packageFullNameLengthLocal, packageFullName);
                return __result;
            }
        }

        /// <summary>Gets the package full name for the calling process.</summary>
        /// <param name = "packageFullNameLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of the <i>packageFullName</i> buffer, in characters. On output, the size of the package full name returned, in characters, including the null terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackagefullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFullName">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>The package full name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackagefullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackagefullname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetCurrentPackageFullName(uint *packageFullNameLength, win32.System.SystemServices.PWSTR packageFullName);
        /// <inheritdoc cref = "GetCurrentPackageFamilyName(uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int GetCurrentPackageFamilyName(ref uint packageFamilyNameLength, win32.System.SystemServices.PWSTR packageFamilyName)
        {
            fixed (uint *packageFamilyNameLengthLocal = &packageFamilyNameLength)
            {
                int __result = Kernel32.GetCurrentPackageFamilyName(packageFamilyNameLengthLocal, packageFamilyName);
                return __result;
            }
        }

        /// <summary>Gets the package family name for the calling process.</summary>
        /// <param name = "packageFamilyNameLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of the <i>packageFamilyName</i> buffer, in characters, including the null terminator. On output, the size of the package family name returned, in characters, including the null terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackagefamilyname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFamilyName">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>The package family name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackagefamilyname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackagefamilyname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetCurrentPackageFamilyName(uint *packageFamilyNameLength, win32.System.SystemServices.PWSTR packageFamilyName);
        /// <inheritdoc cref = "GetCurrentPackagePath(uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int GetCurrentPackagePath(ref uint pathLength, win32.System.SystemServices.PWSTR path)
        {
            fixed (uint *pathLengthLocal = &pathLength)
            {
                int __result = Kernel32.GetCurrentPackagePath(pathLengthLocal, path);
                return __result;
            }
        }

        /// <summary>Gets the package path for the calling process.</summary>
        /// <param name = "pathLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of the <i>path</i> buffer, in characters. On output, the size of the package path returned, in characters, including the null terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackagepath#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "path">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>The package path.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackagepath#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackagepath">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetCurrentPackagePath(uint *pathLength, win32.System.SystemServices.PWSTR path);
        /// <inheritdoc cref = "GetPackageId(win32.System.SystemServices.HANDLE, uint *, byte *)"/>
        internal static unsafe int GetPackageId(SafeHandle hProcess, ref uint bufferLength, byte *buffer)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *bufferLengthLocal = &bufferLength)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.GetPackageId(hProcessLocal, bufferLengthLocal, buffer);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Gets the package identifier (ID) for the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>A handle to the process that has the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bufferLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of <i>buffer</i>, in bytes. On output, the size of the structure returned, in bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "buffer">
        /// <para>Type: <b>BYTE*</b></para>
        /// <para>The package ID, represented as a <a href = "https://docs.microsoft.com/windows/desktop/api/appmodel/ns-appmodel-package_id">PACKAGE_ID</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetPackageId(win32.System.SystemServices.HANDLE hProcess, uint *bufferLength, [Optional] byte *buffer);
        /// <inheritdoc cref = "GetPackageFullName(win32.System.SystemServices.HANDLE, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int GetPackageFullName(SafeHandle hProcess, ref uint packageFullNameLength, win32.System.SystemServices.PWSTR packageFullName)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *packageFullNameLengthLocal = &packageFullNameLength)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.GetPackageFullName(hProcessLocal, packageFullNameLengthLocal, packageFullName);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Gets the package full name for the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>A handle to the process that has the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagefullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFullNameLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of the <i>packageFullName</i> buffer, in characters. On output, the size of the package full name returned, in characters, including the null terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagefullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFullName">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>The package full name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagefullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagefullname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetPackageFullName(win32.System.SystemServices.HANDLE hProcess, uint *packageFullNameLength, win32.System.SystemServices.PWSTR packageFullName);
        /// <inheritdoc cref = "GetPackageFamilyName(win32.System.SystemServices.HANDLE, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int GetPackageFamilyName(SafeHandle hProcess, ref uint packageFamilyNameLength, win32.System.SystemServices.PWSTR packageFamilyName)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *packageFamilyNameLengthLocal = &packageFamilyNameLength)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.GetPackageFamilyName(hProcessLocal, packageFamilyNameLengthLocal, packageFamilyName);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Gets the package family name for the specified process.</summary>
        /// <param name = "hProcess">
        /// <para>Type: <b>HANDLE</b></para>
        /// <para>A handle to the process that has the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagefamilyname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFamilyNameLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of the <i>packageFamilyName</i> buffer, in characters. On output, the size of the package family name returned, in characters, including the null-terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagefamilyname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFamilyName">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>The package family name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagefamilyname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagefamilyname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetPackageFamilyName(win32.System.SystemServices.HANDLE hProcess, uint *packageFamilyNameLength, win32.System.SystemServices.PWSTR packageFamilyName);
        /// <inheritdoc cref = "GetPackagePathByFullName(win32.System.SystemServices.PCWSTR, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int GetPackagePathByFullName(string packageFullName, ref uint pathLength, win32.System.SystemServices.PWSTR path)
        {
            fixed (uint *pathLengthLocal = &pathLength)
            {
                fixed (char *packageFullNameLocal = packageFullName)
                {
                    int __result = Kernel32.GetPackagePathByFullName(packageFullNameLocal, pathLengthLocal, path);
                    return __result;
                }
            }
        }

        /// <summary>Gets the path of the specified package.</summary>
        /// <param name = "packageFullName">
        /// <para>Type: <b>PCWSTR</b></para>
        /// <para>The full name of the package.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagepathbyfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pathLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to a variable that holds the number of characters (<b>WCHAR</b>s) in the package path string, which includes the null-terminator.</para>
        /// <para>First you pass <b>NULL</b> to <i>path</i> to get the number of characters. You use this number to allocate memory space for <i>path</i>. Then you pass the address of this memory space to fill <i>path</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagepathbyfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "path">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>A pointer to memory space that receives  the package path string, which includes the null-terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagepathbyfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagepathbyfullname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetPackagePathByFullName(win32.System.SystemServices.PCWSTR packageFullName, uint *pathLength, win32.System.SystemServices.PWSTR path);
        /// <inheritdoc cref = "GetStagedPackagePathByFullName(win32.System.SystemServices.PCWSTR, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int GetStagedPackagePathByFullName(string packageFullName, ref uint pathLength, win32.System.SystemServices.PWSTR path)
        {
            fixed (uint *pathLengthLocal = &pathLength)
            {
                fixed (char *packageFullNameLocal = packageFullName)
                {
                    int __result = Kernel32.GetStagedPackagePathByFullName(packageFullNameLocal, pathLengthLocal, path);
                    return __result;
                }
            }
        }

        /// <summary>Gets the path of the specified staged package.</summary>
        /// <param name = "packageFullName">
        /// <para>Type: <b>PCWSTR</b></para>
        /// <para>The full name of the staged package.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getstagedpackagepathbyfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pathLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to a variable that holds the number of characters (<b>WCHAR</b>s) in the package path string, which includes the null-terminator.</para>
        /// <para>First you pass <b>NULL</b> to <i>path</i> to get the number of characters. You use this number to allocate memory space for <i>path</i>. Then you pass the address of this memory space to fill <i>path</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getstagedpackagepathbyfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "path">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>A pointer to memory space that receives  the package path string, which includes the null-terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getstagedpackagepathbyfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getstagedpackagepathbyfullname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetStagedPackagePathByFullName(win32.System.SystemServices.PCWSTR packageFullName, uint *pathLength, win32.System.SystemServices.PWSTR path);
        /// <inheritdoc cref = "GetCurrentApplicationUserModelId(uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int GetCurrentApplicationUserModelId(ref uint applicationUserModelIdLength, win32.System.SystemServices.PWSTR applicationUserModelId)
        {
            fixed (uint *applicationUserModelIdLengthLocal = &applicationUserModelIdLength)
            {
                int __result = Kernel32.GetCurrentApplicationUserModelId(applicationUserModelIdLengthLocal, applicationUserModelId);
                return __result;
            }
        }

        /// <summary>Gets the application user model ID for the current process.</summary>
        /// <param name = "applicationUserModelIdLength">On input, the size of the  <i>applicationUserModelId</i> buffer, in wide characters. On success, the size of the buffer used, including the null terminator.</param>
        /// <param name = "applicationUserModelId">A pointer to a buffer that receives the application user model ID.</param>
        /// <returns>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentapplicationusermodelid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetCurrentApplicationUserModelId(uint *applicationUserModelIdLength, win32.System.SystemServices.PWSTR applicationUserModelId);
        /// <inheritdoc cref = "GetApplicationUserModelId(win32.System.SystemServices.HANDLE, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int GetApplicationUserModelId(SafeHandle hProcess, ref uint applicationUserModelIdLength, win32.System.SystemServices.PWSTR applicationUserModelId)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (uint *applicationUserModelIdLengthLocal = &applicationUserModelIdLength)
                {
                    win32.System.SystemServices.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.System.SystemServices.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.GetApplicationUserModelId(hProcessLocal, applicationUserModelIdLengthLocal, applicationUserModelId);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Gets the application user model ID for the specified process.</summary>
        /// <param name = "hProcess">A handle to the process. This handle must have the <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more info, see <a href = "https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
        /// <param name = "applicationUserModelIdLength">On input, the size of the  <i>applicationUserModelId</i> buffer, in wide characters. On success, the size of the buffer used, including the null terminator.</param>
        /// <param name = "applicationUserModelId">A pointer to a buffer that receives the application user model ID.</param>
        /// <returns>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getapplicationusermodelid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetApplicationUserModelId(win32.System.SystemServices.HANDLE hProcess, uint *applicationUserModelIdLength, win32.System.SystemServices.PWSTR applicationUserModelId);
        /// <inheritdoc cref = "PackageIdFromFullName(win32.System.SystemServices.PCWSTR, uint, uint *, byte *)"/>
        internal static unsafe int PackageIdFromFullName(string packageFullName, uint flags, ref uint bufferLength, byte *buffer)
        {
            fixed (uint *bufferLengthLocal = &bufferLength)
            {
                fixed (char *packageFullNameLocal = packageFullName)
                {
                    int __result = Kernel32.PackageIdFromFullName(packageFullNameLocal, flags, bufferLengthLocal, buffer);
                    return __result;
                }
            }
        }

        /// <summary>Gets the package identifier (ID) for the specified package full name.</summary>
        /// <param name = "packageFullName">
        /// <para>Type: <b>PCWSTR</b></para>
        /// <para>The full name of a package.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packageidfromfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flags">
        /// <para>Type: <b>const UINT32</b></para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/appxpkg/package-constants">package constants</a> that specify how package information is retrieved. The <b>PACKAGE_INFORMATION_*</b> flags are supported.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packageidfromfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bufferLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of <i>buffer</i>, in bytes. On output, the size of the data returned, in bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packageidfromfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "buffer">
        /// <para>Type: <b>BYTE*</b></para>
        /// <para>The package ID, represented as a <a href = "https://docs.microsoft.com/windows/desktop/api/appmodel/ns-appmodel-package_id">PACKAGE_ID</a> structure.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packageidfromfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packageidfromfullname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int PackageIdFromFullName(win32.System.SystemServices.PCWSTR packageFullName, uint flags, uint *bufferLength, [Optional] byte *buffer);
        /// <inheritdoc cref = "PackageFamilyNameFromFullName(win32.System.SystemServices.PCWSTR, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int PackageFamilyNameFromFullName(string packageFullName, ref uint packageFamilyNameLength, win32.System.SystemServices.PWSTR packageFamilyName)
        {
            fixed (uint *packageFamilyNameLengthLocal = &packageFamilyNameLength)
            {
                fixed (char *packageFullNameLocal = packageFullName)
                {
                    int __result = Kernel32.PackageFamilyNameFromFullName(packageFullNameLocal, packageFamilyNameLengthLocal, packageFamilyName);
                    return __result;
                }
            }
        }

        /// <summary>Gets the package family name for the specified package full name.</summary>
        /// <param name = "packageFullName">
        /// <para>Type: <b>PCWSTR</b></para>
        /// <para>The full name of a package.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packagefamilynamefromfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFamilyNameLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of the <i>packageFamilyName</i> buffer, in characters. On output, the size of the package family name returned, in characters, including the null terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packagefamilynamefromfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFamilyName">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>The package family name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packagefamilynamefromfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packagefamilynamefromfullname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int PackageFamilyNameFromFullName(win32.System.SystemServices.PCWSTR packageFullName, uint *packageFamilyNameLength, win32.System.SystemServices.PWSTR packageFamilyName);
        /// <inheritdoc cref = "PackageNameAndPublisherIdFromFamilyName(win32.System.SystemServices.PCWSTR, uint *, win32.System.SystemServices.PWSTR, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int PackageNameAndPublisherIdFromFamilyName(string packageFamilyName, ref uint packageNameLength, win32.System.SystemServices.PWSTR packageName, ref uint packagePublisherIdLength, win32.System.SystemServices.PWSTR packagePublisherId)
        {
            fixed (uint *packagePublisherIdLengthLocal = &packagePublisherIdLength)
            {
                fixed (uint *packageNameLengthLocal = &packageNameLength)
                {
                    fixed (char *packageFamilyNameLocal = packageFamilyName)
                    {
                        int __result = Kernel32.PackageNameAndPublisherIdFromFamilyName(packageFamilyNameLocal, packageNameLengthLocal, packageName, packagePublisherIdLengthLocal, packagePublisherId);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Gets the package name and publisher identifier (ID) for the specified package family name.</summary>
        /// <param name = "packageFamilyName">
        /// <para>Type: <b>PCWSTR</b></para>
        /// <para>The family name of a package.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packagenameandpublisheridfromfamilyname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageNameLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of the <i>packageName</i> buffer, in characters. On output, the size of the package name returned, in characters, including the null-terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packagenameandpublisheridfromfamilyname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageName">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>The package name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packagenameandpublisheridfromfamilyname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packagePublisherIdLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of the <i>packagePublishId</i> buffer, in characters. On output, the size of the publisher ID returned, in characters, including the null-terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packagenameandpublisheridfromfamilyname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packagePublisherId">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>The package publisher ID.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packagenameandpublisheridfromfamilyname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-packagenameandpublisheridfromfamilyname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int PackageNameAndPublisherIdFromFamilyName(win32.System.SystemServices.PCWSTR packageFamilyName, uint *packageNameLength, win32.System.SystemServices.PWSTR packageName, uint *packagePublisherIdLength, win32.System.SystemServices.PWSTR packagePublisherId);
        /// <inheritdoc cref = "FormatApplicationUserModelId(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int FormatApplicationUserModelId(string packageFamilyName, string packageRelativeApplicationId, ref uint applicationUserModelIdLength, win32.System.SystemServices.PWSTR applicationUserModelId)
        {
            fixed (uint *applicationUserModelIdLengthLocal = &applicationUserModelIdLength)
            {
                fixed (char *packageRelativeApplicationIdLocal = packageRelativeApplicationId)
                {
                    fixed (char *packageFamilyNameLocal = packageFamilyName)
                    {
                        int __result = Kernel32.FormatApplicationUserModelId(packageFamilyNameLocal, packageRelativeApplicationIdLocal, applicationUserModelIdLengthLocal, applicationUserModelId);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Constructs an application user model ID from the package family name and the package relative application ID (PRAID).</summary>
        /// <param name = "packageFamilyName">
        /// <para>Type: <b>PCWSTR</b></para>
        /// <para>The package family name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-formatapplicationusermodelid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageRelativeApplicationId">
        /// <para>Type: <b>PCWSTR</b></para>
        /// <para>The package-relative app ID (PRAID).</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-formatapplicationusermodelid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "applicationUserModelIdLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to a variable that holds the number of characters (<b>WCHAR</b>s) in the app user model ID string, which includes the null-terminator.</para>
        /// <para>First you pass <b>NULL</b> to <i>applicationUserModelId</i> to get the number of characters. You use this number to allocate memory space for <i>applicationUserModelId</i>. Then you pass the address of this memory space to fill <i>applicationUserModelId</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-formatapplicationusermodelid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "applicationUserModelId">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>A pointer to memory space that receives  the app user model ID string, which includes the null-terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-formatapplicationusermodelid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-formatapplicationusermodelid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int FormatApplicationUserModelId(win32.System.SystemServices.PCWSTR packageFamilyName, win32.System.SystemServices.PCWSTR packageRelativeApplicationId, uint *applicationUserModelIdLength, win32.System.SystemServices.PWSTR applicationUserModelId);
        /// <inheritdoc cref = "ParseApplicationUserModelId(win32.System.SystemServices.PCWSTR, uint *, win32.System.SystemServices.PWSTR, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int ParseApplicationUserModelId(string applicationUserModelId, ref uint packageFamilyNameLength, win32.System.SystemServices.PWSTR packageFamilyName, ref uint packageRelativeApplicationIdLength, win32.System.SystemServices.PWSTR packageRelativeApplicationId)
        {
            fixed (uint *packageRelativeApplicationIdLengthLocal = &packageRelativeApplicationIdLength)
            {
                fixed (uint *packageFamilyNameLengthLocal = &packageFamilyNameLength)
                {
                    fixed (char *applicationUserModelIdLocal = applicationUserModelId)
                    {
                        int __result = Kernel32.ParseApplicationUserModelId(applicationUserModelIdLocal, packageFamilyNameLengthLocal, packageFamilyName, packageRelativeApplicationIdLengthLocal, packageRelativeApplicationId);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Deconstructs an application user model ID to its package family name and package relative application ID (PRAID).</summary>
        /// <param name = "applicationUserModelId">
        /// <para>Type: <b>PCWSTR</b></para>
        /// <para>The app user model ID.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-parseapplicationusermodelid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFamilyNameLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to a variable that holds the number of characters (<b>WCHAR</b>s) in the package family name string, which includes the null-terminator.</para>
        /// <para>First you pass <b>NULL</b> to <i>packageFamilyName</i> to get the number of characters. You use this number to allocate memory space for <i>packageFamilyName</i>. Then you pass the address of this memory space to fill <i>packageFamilyName</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-parseapplicationusermodelid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFamilyName">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>A pointer to memory space that receives  the package family name string, which includes the null-terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-parseapplicationusermodelid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageRelativeApplicationIdLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to a variable that holds the number of characters (<b>WCHAR</b>s) in the package-relative app ID string, which includes the null-terminator.</para>
        /// <para>First you pass <b>NULL</b> to <i>packageRelativeApplicationId</i> to get the number of characters. You use this number to allocate memory space for <i>packageRelativeApplicationId</i>. Then you pass the address of this memory space to fill <i>packageRelativeApplicationId</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-parseapplicationusermodelid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageRelativeApplicationId">
        /// <para>Type: <b>PWSTR</b></para>
        /// <para>A pointer to memory space that receives  the package-relative app ID (PRAID) string, which includes the null-terminator.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-parseapplicationusermodelid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-parseapplicationusermodelid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int ParseApplicationUserModelId(win32.System.SystemServices.PCWSTR applicationUserModelId, uint *packageFamilyNameLength, win32.System.SystemServices.PWSTR packageFamilyName, uint *packageRelativeApplicationIdLength, win32.System.SystemServices.PWSTR packageRelativeApplicationId);
        /// <inheritdoc cref = "GetPackagesByPackageFamily(win32.System.SystemServices.PCWSTR, uint *, win32.System.SystemServices.PWSTR*, uint *, win32.System.SystemServices.PWSTR)"/>
        internal static unsafe int GetPackagesByPackageFamily(string packageFamilyName, ref uint count, win32.System.SystemServices.PWSTR*packageFullNames, ref uint bufferLength, win32.System.SystemServices.PWSTR buffer)
        {
            fixed (uint *bufferLengthLocal = &bufferLength)
            {
                fixed (uint *countLocal = &count)
                {
                    fixed (char *packageFamilyNameLocal = packageFamilyName)
                    {
                        int __result = Kernel32.GetPackagesByPackageFamily(packageFamilyNameLocal, countLocal, packageFullNames, bufferLengthLocal, buffer);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Gets the packages with the specified family name for the current user.</summary>
        /// <param name = "packageFamilyName">
        /// <para>Type: <b>PCWSTR</b></para>
        /// <para>The package family name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "count">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to a variable that holds the number of package full names.</para>
        /// <para>First you pass <b>NULL</b> to <i>packageFullNames</i> to get the number of package full names. You use this number to allocate memory space for <i>packageFullNames</i>. Then you pass the address of this number to fill <i>packageFullNames</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFullNames">
        /// <para>Type: <b>PWSTR*</b></para>
        /// <para>A pointer to the strings of package full names.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bufferLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to a variable that holds the number of characters in the string of package full names.</para>
        /// <para>First you pass <b>NULL</b> to <i>buffer</i> to get the number of characters. You use this number to allocate memory space for <i>buffer</i>. Then you pass the address of this number to fill <i>buffer</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "buffer">
        /// <para>Type: <b>WCHAR*</b></para>
        /// <para>The string of characters for all of the package full names.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackagesbypackagefamily">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetPackagesByPackageFamily(win32.System.SystemServices.PCWSTR packageFamilyName, uint *count, [Optional] win32.System.SystemServices.PWSTR*packageFullNames, uint *bufferLength, win32.System.SystemServices.PWSTR buffer);
        /// <inheritdoc cref = "FindPackagesByPackageFamily(win32.System.SystemServices.PCWSTR, uint, uint *, win32.System.SystemServices.PWSTR*, uint *, win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe int FindPackagesByPackageFamily(string packageFamilyName, uint packageFilters, ref uint count, win32.System.SystemServices.PWSTR*packageFullNames, ref uint bufferLength, win32.System.SystemServices.PWSTR buffer, uint *packageProperties)
        {
            fixed (uint *bufferLengthLocal = &bufferLength)
            {
                fixed (uint *countLocal = &count)
                {
                    fixed (char *packageFamilyNameLocal = packageFamilyName)
                    {
                        int __result = Kernel32.FindPackagesByPackageFamily(packageFamilyNameLocal, packageFilters, countLocal, packageFullNames, bufferLengthLocal, buffer, packageProperties);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Finds the packages with the specified family name for the current user.</summary>
        /// <param name = "packageFamilyName">
        /// <para>Type: <b>PCWSTR</b></para>
        /// <para>The package family name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-findpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFilters">
        /// <para>Type: <b>UINT32</b></para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/appxpkg/package-constants">package constants</a> that specify how package information is retrieved. All package constants except <b>PACKAGE_FILTER_ALL_LOADED</b> are supported.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-findpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "count">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to a variable that holds the number of package full names that were found.</para>
        /// <para>First you pass <b>NULL</b> to <i>packageFullNames</i> to get the number of package full names that were found. You use this number to allocate memory space for <i>packageFullNames</i>. Then you pass the address of this memory space to fill <i>packageFullNames</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-findpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageFullNames">
        /// <para>Type: <b>PWSTR*</b></para>
        /// <para>A pointer to memory space that receives  the strings of package full names that were found.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-findpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bufferLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to a variable that holds the number of characters in the string of package full names.</para>
        /// <para>First you pass <b>NULL</b> to <i>buffer</i> to get the number of characters. You use this number to allocate memory space for <i>buffer</i>. Then you pass the address of this memory space to fill <i>buffer</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-findpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "buffer">
        /// <para>Type: <b>WCHAR*</b></para>
        /// <para>A pointer to memory space that receives  the string of characters for all of the package full names.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-findpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageProperties">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to memory space that receives  the <a href = "https://docs.microsoft.com/windows/desktop/appxpkg/package-constants">package properties</a> for all of the packages that were found.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-findpackagesbypackagefamily#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-findpackagesbypackagefamily">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int FindPackagesByPackageFamily(win32.System.SystemServices.PCWSTR packageFamilyName, uint packageFilters, uint *count, [Optional] win32.System.SystemServices.PWSTR*packageFullNames, uint *bufferLength, win32.System.SystemServices.PWSTR buffer, [Optional] uint *packageProperties);
        /// <inheritdoc cref = "GetCurrentPackageInfo(uint, uint *, byte *, uint *)"/>
        internal static unsafe int GetCurrentPackageInfo(uint flags, ref uint bufferLength, byte *buffer, uint *count)
        {
            fixed (uint *bufferLengthLocal = &bufferLength)
            {
                int __result = Kernel32.GetCurrentPackageInfo(flags, bufferLengthLocal, buffer, count);
                return __result;
            }
        }

        /// <summary>Gets the package information for the calling process.</summary>
        /// <param name = "flags">
        /// <para>Type: <b>const UINT32</b></para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/appxpkg/package-constants">package constants</a> that specify how package information is retrieved. The <b>PACKAGE_FILTER_*</b> flags are supported.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bufferLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of <i>buffer</i>, in bytes. On output, the size of the array of structures returned, in bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "buffer">
        /// <para>Type: <b>BYTE*</b></para>
        /// <para>The package information, represented as an array of <a href = "https://docs.microsoft.com/windows/desktop/api/appmodel/ns-appmodel-package_info">PACKAGE_INFO</a> structures.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "count">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>The number of structures in the buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getcurrentpackageinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetCurrentPackageInfo(uint flags, uint *bufferLength, [Optional] byte *buffer, [Optional] uint *count);
        /// <inheritdoc cref = "OpenPackageInfoByFullName(win32.System.SystemServices.PCWSTR, uint, win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE**)"/>
        internal static unsafe int OpenPackageInfoByFullName(string packageFullName, uint reserved, out win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE*packageInfoReference)
        {
            fixed (win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE**packageInfoReferenceLocal = &packageInfoReference)
            {
                fixed (char *packageFullNameLocal = packageFullName)
                {
                    int __result = Kernel32.OpenPackageInfoByFullName(packageFullNameLocal, reserved, packageInfoReferenceLocal);
                    return __result;
                }
            }
        }

        /// <summary>Opens the package information of the specified package.</summary>
        /// <param name = "packageFullName">
        /// <para>Type: <b>PCWSTR</b></para>
        /// <para>The full name of the package.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-openpackageinfobyfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "reserved">
        /// <para>Type: <b>const UINT32</b></para>
        /// <para>Reserved; must be 0.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-openpackageinfobyfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "packageInfoReference">
        /// <para>Type: <b>PACKAGE_INFO_REFERENCE*</b></para>
        /// <para>A reference to package information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-openpackageinfobyfullname#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-openpackageinfobyfullname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int OpenPackageInfoByFullName(win32.System.SystemServices.PCWSTR packageFullName, uint reserved, win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE**packageInfoReference);
        /// <inheritdoc cref = "ClosePackageInfo(win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE*)"/>
        internal static unsafe int ClosePackageInfo(in win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE packageInfoReference)
        {
            fixed (win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE*packageInfoReferenceLocal = &packageInfoReference)
            {
                int __result = Kernel32.ClosePackageInfo(packageInfoReferenceLocal);
                return __result;
            }
        }

        /// <summary>Closes a reference to the specified package information.</summary>
        /// <param name = "packageInfoReference">
        /// <para>Type: <b>PACKAGE_INFO_REFERENCE</b></para>
        /// <para>A reference to package information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-closepackageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-closepackageinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int ClosePackageInfo(win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE*packageInfoReference);
        /// <inheritdoc cref = "GetPackageInfo(win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE*, uint, uint *, byte *, uint *)"/>
        internal static unsafe int GetPackageInfo(in win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE packageInfoReference, uint flags, ref uint bufferLength, byte *buffer, uint *count)
        {
            fixed (uint *bufferLengthLocal = &bufferLength)
            {
                fixed (win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE*packageInfoReferenceLocal = &packageInfoReference)
                {
                    int __result = Kernel32.GetPackageInfo(packageInfoReferenceLocal, flags, bufferLengthLocal, buffer, count);
                    return __result;
                }
            }
        }

        /// <summary>Gets the package information for the specified package.</summary>
        /// <param name = "packageInfoReference">
        /// <para>Type: <b>PACKAGE_INFO_REFERENCE</b></para>
        /// <para>A reference to package information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "flags">
        /// <para>Type: <b>const UINT32</b></para>
        /// <para>The <a href = "https://docs.microsoft.com/windows/desktop/appxpkg/package-constants">package constants</a> that specify how package information is retrieved.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bufferLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>On input, the size of <i>buffer</i>, in bytes. On output, the size of the package information returned, in bytes.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "buffer">
        /// <para>Type: <b>BYTE*</b></para>
        /// <para>The package information, represented as an array of <a href = "https://docs.microsoft.com/windows/desktop/api/appmodel/ns-appmodel-package_info">PACKAGE_INFO</a> structures.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "count">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>The number of packages in the buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetPackageInfo(win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE*packageInfoReference, uint flags, uint *bufferLength, [Optional] byte *buffer, [Optional] uint *count);
        /// <inheritdoc cref = "GetPackageApplicationIds(win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE*, uint *, byte *, uint *)"/>
        internal static unsafe int GetPackageApplicationIds(in win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE packageInfoReference, ref uint bufferLength, byte *buffer, uint *count)
        {
            fixed (uint *bufferLengthLocal = &bufferLength)
            {
                fixed (win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE*packageInfoReferenceLocal = &packageInfoReference)
                {
                    int __result = Kernel32.GetPackageApplicationIds(packageInfoReferenceLocal, bufferLengthLocal, buffer, count);
                    return __result;
                }
            }
        }

        /// <summary>Gets the IDs of apps in the specified package.</summary>
        /// <param name = "packageInfoReference">
        /// <para>Type: <b>PACKAGE_INFO_REFERENCE</b></para>
        /// <para>A reference to package information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageapplicationids#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "bufferLength">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to a variable that holds the size of <i>buffer</i>, in bytes.</para>
        /// <para>First you pass <b>NULL</b> to <i>buffer</i> to get the required size of <i>buffer</i>. You use this number to allocate memory space for <i>buffer</i>. Then you pass the address of this memory space to fill <i>buffer</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageapplicationids#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "buffer">
        /// <para>Type: <b>BYTE*</b></para>
        /// <para>A pointer to memory space that receives  the app IDs.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageapplicationids#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "count">
        /// <para>Type: <b>UINT32*</b></para>
        /// <para>A pointer to a variable that receives the number of app IDs in <i>buffer</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageapplicationids#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LONG</b></para>
        /// <para>If the function succeeds it returns <b>ERROR_SUCCESS</b>. Otherwise, the function returns an error code. The possible error codes include the following.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-getpackageapplicationids">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int GetPackageApplicationIds(win32.Storage.Packaging.Appx._PACKAGE_INFO_REFERENCE*packageInfoReference, uint *bufferLength, [Optional] byte *buffer, [Optional] uint *count);
        /// <inheritdoc cref = "AppPolicyGetLifecycleManagement(win32.System.SystemServices.HANDLE, win32.Storage.Packaging.Appx.AppPolicyLifecycleManagement*)"/>
        internal static unsafe int AppPolicyGetLifecycleManagement(SafeHandle processToken, out win32.Storage.Packaging.Appx.AppPolicyLifecycleManagement policy)
        {
            bool processTokenAddRef = false;
            try
            {
                fixed (win32.Storage.Packaging.Appx.AppPolicyLifecycleManagement*policyLocal = &policy)
                {
                    win32.System.SystemServices.HANDLE processTokenLocal;
                    if (processToken is object)
                    {
                        processToken.DangerousAddRef(ref processTokenAddRef);
                        processTokenLocal = (win32.System.SystemServices.HANDLE)processToken.DangerousGetHandle();
                    }
                    else
                        processTokenLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.AppPolicyGetLifecycleManagement(processTokenLocal, policyLocal);
                    return __result;
                }
            }
            finally
            {
                if (processTokenAddRef)
                    processToken.DangerousRelease();
            }
        }

        /// <summary>Retrieves a value indicating whether a process can be suspended/resumed by the Process Lifecycle Manager (PLM).</summary>
        /// <param name = "processToken">A handle that identifies the access token for a process.</param>
        /// <param name = "policy">A pointer to a variable of the <a href = "../appmodel/ne-appmodel-apppolicylifecyclemanagement.md">AppPolicyLifecycleManagement</a> enumerated type. When the function returns successfully, the variable contains an enumerated constant value indicating whether the identified process is lifecycle-managed or not.</param>
        /// <returns>
        /// <para>If the function succeeds, the function returns ERROR_SUCCESS.</para>
        /// <para>If no known lifecycle management policy was found for the process token, the function raises a STATUS_ASSERTION_FAILURE exception and returns ERROR_NOT_FOUND.</para>
        /// <para>If either processToken or policy are null, the function returns ERROR_INVALID_PARAMETER.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-apppolicygetlifecyclemanagement">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int AppPolicyGetLifecycleManagement(win32.System.SystemServices.HANDLE processToken, win32.Storage.Packaging.Appx.AppPolicyLifecycleManagement*policy);
        /// <inheritdoc cref = "AppPolicyGetWindowingModel(win32.System.SystemServices.HANDLE, win32.Storage.Packaging.Appx.AppPolicyWindowingModel*)"/>
        internal static unsafe int AppPolicyGetWindowingModel(SafeHandle processToken, out win32.Storage.Packaging.Appx.AppPolicyWindowingModel policy)
        {
            bool processTokenAddRef = false;
            try
            {
                fixed (win32.Storage.Packaging.Appx.AppPolicyWindowingModel*policyLocal = &policy)
                {
                    win32.System.SystemServices.HANDLE processTokenLocal;
                    if (processToken is object)
                    {
                        processToken.DangerousAddRef(ref processTokenAddRef);
                        processTokenLocal = (win32.System.SystemServices.HANDLE)processToken.DangerousGetHandle();
                    }
                    else
                        processTokenLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.AppPolicyGetWindowingModel(processTokenLocal, policyLocal);
                    return __result;
                }
            }
            finally
            {
                if (processTokenAddRef)
                    processToken.DangerousRelease();
            }
        }

        /// <summary>Retrieves a value indicating whether a process uses a CoreWindow-based, or a HWND-based, windowing model. You can use the value to decide how to register for window state change notifications (size changed, visibility changed, etc.).</summary>
        /// <param name = "processToken">A handle that identifies the access token for a process.</param>
        /// <param name = "policy">A pointer to a variable of the <a href = "https://docs.microsoft.com/windows/win32/api/appmodel/ne-appmodel-apppolicywindowingmodel">AppPolicyWindowingModel</a> enumerated type. When the function returns successfully, the variable contains an enumerated constant value indicating the windowing model of the identified process.</param>
        /// <returns>
        /// <para>If the function succeeds, the function returns ERROR_SUCCESS.</para>
        /// <para>If no known windowing model policy was found for the process token, the function raises a STATUS_ASSERTION_FAILURE exception and returns ERROR_NOT_FOUND.</para>
        /// <para>If either processToken or policy are null, the function returns ERROR_INVALID_PARAMETER.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-apppolicygetwindowingmodel">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int AppPolicyGetWindowingModel(win32.System.SystemServices.HANDLE processToken, win32.Storage.Packaging.Appx.AppPolicyWindowingModel*policy);
        /// <inheritdoc cref = "AppPolicyGetMediaFoundationCodecLoading(win32.System.SystemServices.HANDLE, win32.Storage.Packaging.Appx.AppPolicyMediaFoundationCodecLoading*)"/>
        internal static unsafe int AppPolicyGetMediaFoundationCodecLoading(SafeHandle processToken, out win32.Storage.Packaging.Appx.AppPolicyMediaFoundationCodecLoading policy)
        {
            bool processTokenAddRef = false;
            try
            {
                fixed (win32.Storage.Packaging.Appx.AppPolicyMediaFoundationCodecLoading*policyLocal = &policy)
                {
                    win32.System.SystemServices.HANDLE processTokenLocal;
                    if (processToken is object)
                    {
                        processToken.DangerousAddRef(ref processTokenAddRef);
                        processTokenLocal = (win32.System.SystemServices.HANDLE)processToken.DangerousGetHandle();
                    }
                    else
                        processTokenLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.AppPolicyGetMediaFoundationCodecLoading(processTokenLocal, policyLocal);
                    return __result;
                }
            }
            finally
            {
                if (processTokenAddRef)
                    processToken.DangerousRelease();
            }
        }

        /// <summary>Retrieves a value indicating whether a process’s policy allows it to load non-Windows (third-party) plugins. You can use the value to decide whether or not to allow non-Windows (third-party) plugins.</summary>
        /// <param name = "processToken">A handle that identifies the access token for a process.</param>
        /// <param name = "policy">A pointer to a variable of the <a href = "../appmodel/ne-appmodel-apppolicymediafoundationcodecloading.md">AppPolicyMediaFoundationCodecLoading</a> enumerated type. When the function returns successfully, the variable contains an enumerated constant value indicating the codec-loading policy of the identified process.</param>
        /// <returns>
        /// <para>If the function succeeds, the function returns ERROR_SUCCESS.</para>
        /// <para>If no known codec-loading policy was found for the process token, the function raises a STATUS_ASSERTION_FAILURE exception and returns ERROR_NOT_FOUND.</para>
        /// <para>If either processToken or policy are null, the function returns ERROR_INVALID_PARAMETER.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-apppolicygetmediafoundationcodecloading">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int AppPolicyGetMediaFoundationCodecLoading(win32.System.SystemServices.HANDLE processToken, win32.Storage.Packaging.Appx.AppPolicyMediaFoundationCodecLoading*policy);
        /// <inheritdoc cref = "AppPolicyGetClrCompat(win32.System.SystemServices.HANDLE, win32.Storage.Packaging.Appx.AppPolicyClrCompat*)"/>
        internal static unsafe int AppPolicyGetClrCompat(SafeHandle processToken, out win32.Storage.Packaging.Appx.AppPolicyClrCompat policy)
        {
            bool processTokenAddRef = false;
            try
            {
                fixed (win32.Storage.Packaging.Appx.AppPolicyClrCompat*policyLocal = &policy)
                {
                    win32.System.SystemServices.HANDLE processTokenLocal;
                    if (processToken is object)
                    {
                        processToken.DangerousAddRef(ref processTokenAddRef);
                        processTokenLocal = (win32.System.SystemServices.HANDLE)processToken.DangerousGetHandle();
                    }
                    else
                        processTokenLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.AppPolicyGetClrCompat(processTokenLocal, policyLocal);
                    return __result;
                }
            }
            finally
            {
                if (processTokenAddRef)
                    processToken.DangerousRelease();
            }
        }

        /// <summary>Retrieves a value indicating the application type of a process so that you can determine whether to enable private reflection and/or make managed objects agile.</summary>
        /// <param name = "processToken">A handle that identifies the access token for a process.</param>
        /// <param name = "policy">A pointer to a variable of the <a href = "../appmodel/ne-appmodel-apppolicyclrcompat.md">AppPolicyClrCompat</a> enumerated type. When the function returns successfully, the variable contains an enumerated constant value indicating the application type of the identified process.</param>
        /// <returns>
        /// <para>If the function succeeds, the function returns ERROR_SUCCESS.</para>
        /// <para>If no known application type was found for the process token, the function raises a STATUS_ASSERTION_FAILURE exception and returns ERROR_NOT_FOUND.</para>
        /// <para>If either processToken or policy are null, the function returns ERROR_INVALID_PARAMETER.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-apppolicygetclrcompat">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int AppPolicyGetClrCompat(win32.System.SystemServices.HANDLE processToken, win32.Storage.Packaging.Appx.AppPolicyClrCompat*policy);
        /// <inheritdoc cref = "AppPolicyGetThreadInitializationType(win32.System.SystemServices.HANDLE, win32.Storage.Packaging.Appx.AppPolicyThreadInitializationType*)"/>
        internal static unsafe int AppPolicyGetThreadInitializationType(SafeHandle processToken, out win32.Storage.Packaging.Appx.AppPolicyThreadInitializationType policy)
        {
            bool processTokenAddRef = false;
            try
            {
                fixed (win32.Storage.Packaging.Appx.AppPolicyThreadInitializationType*policyLocal = &policy)
                {
                    win32.System.SystemServices.HANDLE processTokenLocal;
                    if (processToken is object)
                    {
                        processToken.DangerousAddRef(ref processTokenAddRef);
                        processTokenLocal = (win32.System.SystemServices.HANDLE)processToken.DangerousGetHandle();
                    }
                    else
                        processTokenLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.AppPolicyGetThreadInitializationType(processTokenLocal, policyLocal);
                    return __result;
                }
            }
            finally
            {
                if (processTokenAddRef)
                    processToken.DangerousRelease();
            }
        }

        /// <summary>Retrieves the kind of initialization that should be automatically performed for a process when beginthread[ex] creates a thread.</summary>
        /// <param name = "processToken">A handle that identifies the access token for a process.</param>
        /// <param name = "policy">A pointer to a variable of the <a href = "https://docs.microsoft.com/windows/desktop/api/appmodel/ne-appmodel-apppolicythreadinitializationtype">AppPolicyThreadInitializationType</a> enumerated type. When the function returns successfully, the variable contains a value indicating the kind of initialization that should be automatically performed for the process when beginthread[ex] creates a thread.</param>
        /// <returns>
        /// <para>If the function succeeds, the function returns ERROR_SUCCESS.</para>
        /// <para>If no known thread initialization policy was found for the process token, the function raises a STATUS_ASSERTION_FAILURE exception and returns ERROR_NOT_FOUND.</para>
        /// <para>If either processToken or policy are null, the function returns ERROR_INVALID_PARAMETER.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-apppolicygetthreadinitializationtype">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int AppPolicyGetThreadInitializationType(win32.System.SystemServices.HANDLE processToken, win32.Storage.Packaging.Appx.AppPolicyThreadInitializationType*policy);
        /// <inheritdoc cref = "AppPolicyGetShowDeveloperDiagnostic(win32.System.SystemServices.HANDLE, win32.Storage.Packaging.Appx.AppPolicyShowDeveloperDiagnostic*)"/>
        internal static unsafe int AppPolicyGetShowDeveloperDiagnostic(SafeHandle processToken, out win32.Storage.Packaging.Appx.AppPolicyShowDeveloperDiagnostic policy)
        {
            bool processTokenAddRef = false;
            try
            {
                fixed (win32.Storage.Packaging.Appx.AppPolicyShowDeveloperDiagnostic*policyLocal = &policy)
                {
                    win32.System.SystemServices.HANDLE processTokenLocal;
                    if (processToken is object)
                    {
                        processToken.DangerousAddRef(ref processTokenAddRef);
                        processTokenLocal = (win32.System.SystemServices.HANDLE)processToken.DangerousGetHandle();
                    }
                    else
                        processTokenLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.AppPolicyGetShowDeveloperDiagnostic(processTokenLocal, policyLocal);
                    return __result;
                }
            }
            finally
            {
                if (processTokenAddRef)
                    processToken.DangerousRelease();
            }
        }

        /// <summary>Retrieves the method used for a process to surface developer information, such as asserts, to the user.</summary>
        /// <param name = "processToken">A handle that identifies the access token for a process.</param>
        /// <param name = "policy">A pointer to a variable of the <a href = "https://docs.microsoft.com/windows/desktop/api/appmodel/ne-appmodel-apppolicyshowdeveloperdiagnostic">AppPolicyShowDeveloperDiagnostic</a> enumerated type. When the function returns successfully, the variable contains a value indicating the method used for the process to surface developer information, such as asserts, to the user.</param>
        /// <returns>
        /// <para>If the function succeeds, the function returns ERROR_SUCCESS.</para>
        /// <para>If no known developer information  policy was found for the process token, the function raises a STATUS_ASSERTION_FAILURE exception and returns ERROR_NOT_FOUND.</para>
        /// <para>If either processToken or policy are null, the function returns ERROR_INVALID_PARAMETER.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-apppolicygetshowdeveloperdiagnostic">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int AppPolicyGetShowDeveloperDiagnostic(win32.System.SystemServices.HANDLE processToken, win32.Storage.Packaging.Appx.AppPolicyShowDeveloperDiagnostic*policy);
        /// <inheritdoc cref = "AppPolicyGetProcessTerminationMethod(win32.System.SystemServices.HANDLE, win32.Storage.Packaging.Appx.AppPolicyProcessTerminationMethod*)"/>
        internal static unsafe int AppPolicyGetProcessTerminationMethod(SafeHandle processToken, out win32.Storage.Packaging.Appx.AppPolicyProcessTerminationMethod policy)
        {
            bool processTokenAddRef = false;
            try
            {
                fixed (win32.Storage.Packaging.Appx.AppPolicyProcessTerminationMethod*policyLocal = &policy)
                {
                    win32.System.SystemServices.HANDLE processTokenLocal;
                    if (processToken is object)
                    {
                        processToken.DangerousAddRef(ref processTokenAddRef);
                        processTokenLocal = (win32.System.SystemServices.HANDLE)processToken.DangerousGetHandle();
                    }
                    else
                        processTokenLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.AppPolicyGetProcessTerminationMethod(processTokenLocal, policyLocal);
                    return __result;
                }
            }
            finally
            {
                if (processTokenAddRef)
                    processToken.DangerousRelease();
            }
        }

        /// <summary>Retrieves the method used to end a process.</summary>
        /// <param name = "processToken">A handle that identifies the access token for a process.</param>
        /// <param name = "policy">A pointer to a variable of the <a href = "https://docs.microsoft.com/windows/desktop/api/appmodel/ne-appmodel-apppolicyprocessterminationmethod">AppPolicyProcessTerminationMethod</a> enumerated type. When the function returns successfully, the variable contains a value indicating the method used to end the process.</param>
        /// <returns>
        /// <para>If the function succeeds, the function returns ERROR_SUCCESS.</para>
        /// <para>If no known process termination policy was found for the process token, the function raises a STATUS_ASSERTION_FAILURE exception and returns ERROR_NOT_FOUND.</para>
        /// <para>If either processToken or policy are null, the function returns ERROR_INVALID_PARAMETER.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-apppolicygetprocessterminationmethod">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int AppPolicyGetProcessTerminationMethod(win32.System.SystemServices.HANDLE processToken, win32.Storage.Packaging.Appx.AppPolicyProcessTerminationMethod*policy);
        /// <inheritdoc cref = "AppPolicyGetCreateFileAccess(win32.System.SystemServices.HANDLE, win32.Storage.Packaging.Appx.AppPolicyCreateFileAccess*)"/>
        internal static unsafe int AppPolicyGetCreateFileAccess(SafeHandle processToken, out win32.Storage.Packaging.Appx.AppPolicyCreateFileAccess policy)
        {
            bool processTokenAddRef = false;
            try
            {
                fixed (win32.Storage.Packaging.Appx.AppPolicyCreateFileAccess*policyLocal = &policy)
                {
                    win32.System.SystemServices.HANDLE processTokenLocal;
                    if (processToken is object)
                    {
                        processToken.DangerousAddRef(ref processTokenAddRef);
                        processTokenLocal = (win32.System.SystemServices.HANDLE)processToken.DangerousGetHandle();
                    }
                    else
                        processTokenLocal = default(win32.System.SystemServices.HANDLE);
                    int __result = Kernel32.AppPolicyGetCreateFileAccess(processTokenLocal, policyLocal);
                    return __result;
                }
            }
            finally
            {
                if (processTokenAddRef)
                    processToken.DangerousRelease();
            }
        }

        /// <summary>Retrieves a value indicating whether a process has full or restricted access to the IO devices (file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe).</summary>
        /// <param name = "processToken">A handle that identifies the access token for a process.</param>
        /// <param name = "policy">A pointer to a variable of the <a href = "https://docs.microsoft.com/windows/desktop/api/appmodel/ne-appmodel-apppolicycreatefileaccess">AppPolicyCreateFileAccess</a> enumerated type. When the function returns successfully, the variable contains an enumerated constant value indicating whether the process has full or restricted access to the IO devices.</param>
        /// <returns>
        /// <para>If the function succeeds, the function returns ERROR_SUCCESS.</para>
        /// <para>If no known create file access policy was found for the process token, the function raises a STATUS_ASSERTION_FAILURE exception and returns ERROR_NOT_FOUND.</para>
        /// <para>If either processToken or policy are null, the function returns ERROR_INVALID_PARAMETER.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//appmodel/nf-appmodel-apppolicygetcreatefileaccess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe int AppPolicyGetCreateFileAccess(win32.System.SystemServices.HANDLE processToken, win32.Storage.Packaging.Appx.AppPolicyCreateFileAccess*policy);
        /// <summary>The RtlCaptureStackBackTrace routine captures a stack back trace by walking up the stack and recording the information for each frame.</summary>
        /// <param name = "FramesToSkip">The number of frames to skip from the start of the back trace.</param>
        /// <param name = "FramesToCapture">The number of frames to be captured.</param>
        /// <param name = "BackTrace">An array of pointers captured from the current stack trace.</param>
        /// <param name = "BackTraceHash">
        /// <para>An optional value that can be used to organize hash tables. If this parameter is <b>NULL</b>, no hash value is computed.</para>
        /// <para>This value is calculated based on the values of the pointers returned in the <i>BackTrace</i> array. Two identical stack traces will generate identical hash values.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnt/nf-winnt-rtlcapturestackbacktrace#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>The number of captured frames.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnt/nf-winnt-rtlcapturestackbacktrace">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe ushort RtlCaptureStackBackTrace(uint FramesToSkip, uint FramesToCapture, void **BackTrace, [Optional] uint *BackTraceHash);
        /// <inheritdoc cref = "InstallELAMCertificateInfo(win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool InstallELAMCertificateInfo(SafeHandle ELAMFile)
        {
            bool ELAMFileAddRef = false;
            try
            {
                win32.System.SystemServices.HANDLE ELAMFileLocal;
                if (ELAMFile is object)
                {
                    ELAMFile.DangerousAddRef(ref ELAMFileAddRef);
                    ELAMFileLocal = (win32.System.SystemServices.HANDLE)ELAMFile.DangerousGetHandle();
                }
                else
                    ELAMFileLocal = default(win32.System.SystemServices.HANDLE);
                bool __result = Kernel32.InstallELAMCertificateInfo(ELAMFileLocal);
                return __result;
            }
            finally
            {
                if (ELAMFileAddRef)
                    ELAMFile.DangerousRelease();
            }
        }

        /// <summary>Installs the certificate information specified in the resource file, which is linked into the ELAM driver at build time.</summary>
        /// <param name = "ELAMFile">
        /// <para>A handle to an ELAM driver file which contains the resource file with the certificate information. The handle to the ELAM driver file must be opened for read access only and must not be shared for write access.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-installelamcertificateinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is TRUE.</para>
        /// <para>If the function fails, the return value is FALSE. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-installelamcertificateinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool InstallELAMCertificateInfo(win32.System.SystemServices.HANDLE ELAMFile);
        /// <inheritdoc cref = "AddResourceAttributeAce(win32.Security.ACL*, uint, win32.Security.ACE_FLAGS, uint, win32.Security.PSID, win32.Security.CLAIM_SECURITY_ATTRIBUTES_INFORMATION*, uint *)"/>
        internal static unsafe bool AddResourceAttributeAce(ref win32.Security.ACL pAcl, uint dwAceRevision, win32.Security.ACE_FLAGS AceFlags, uint AccessMask, win32.Security.PSID pSid, in win32.Security.CLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, out uint pReturnLength)
        {
            fixed (uint *pReturnLengthLocal = &pReturnLength)
            {
                fixed (win32.Security.CLAIM_SECURITY_ATTRIBUTES_INFORMATION*pAttributeInfoLocal = &pAttributeInfo)
                {
                    fixed (win32.Security.ACL*pAclLocal = &pAcl)
                    {
                        bool __result = Kernel32.AddResourceAttributeAce(pAclLocal, dwAceRevision, AceFlags, AccessMask, pSid, pAttributeInfoLocal, pReturnLengthLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Adds a SYSTEM_RESOURCE_ATTRIBUTE_ACEaccess control entry (ACE) to the end of a system access control list (SACL).</summary>
        /// <param name = "pAcl">A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">access control list</a> (ACL). This function adds an ACE to this ACL. The value of this parameter cannot be <b>NULL</b>. The ACE is in the form of a  <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-system_resource_attribute_ace">SYSTEM_RESOURCE_ATTRIBUTE_ACE</a> structure.</param>
        /// <param name = "dwAceRevision">Specifies the revision level of the ACL being modified. This value can be ACL_REVISION or ACL_REVISION_DS. Use ACL_REVISION_DS if the ACL contains object-specific ACEs.</param>
        /// <param name = "AceFlags">
        /// <para>A set of bit flags that control ACE inheritance. The function sets these flags in the <b>AceFlags</b> member of the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-ace_header">ACE_HEADER</a> structure of the new ACE.</para>
        /// <para>For consistency with the Windows 8 Advanced File Permissions UI, applications should specify the CONTAINER_INHERIT_ACE and OBJECT_INHERIT_ACE flags in the <i>AceFlags</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//securitybaseapi/nf-securitybaseapi-addresourceattributeace#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "AccessMask">Must be zero for Windows 8 and Windows Server 2012.</param>
        /// <param name = "pSid">Must be the Everyone SID (S-1-1-0) for Windows 8 and Windows Server 2012.</param>
        /// <param name = "pAttributeInfo">Specifies the attribute information that will be appended after the SID in the ACE.</param>
        /// <param name = "pReturnLength">The size, in bytes, of the actual ACL buffer used. If the buffer specified by the <i>pAcl</i> parameter is not big enough, the value of this parameter is the total size required for the ACL buffer.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>.</para>
        /// <para>If the function fails, it returns <b>FALSE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//securitybaseapi/nf-securitybaseapi-addresourceattributeace">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool AddResourceAttributeAce(win32.Security.ACL*pAcl, uint dwAceRevision, win32.Security.ACE_FLAGS AceFlags, uint AccessMask, win32.Security.PSID pSid, win32.Security.CLAIM_SECURITY_ATTRIBUTES_INFORMATION*pAttributeInfo, uint *pReturnLength);
        /// <inheritdoc cref = "AddScopedPolicyIDAce(win32.Security.ACL*, uint, win32.Security.ACE_FLAGS, uint, win32.Security.PSID)"/>
        internal static unsafe bool AddScopedPolicyIDAce(ref win32.Security.ACL pAcl, uint dwAceRevision, win32.Security.ACE_FLAGS AceFlags, uint AccessMask, win32.Security.PSID pSid)
        {
            fixed (win32.Security.ACL*pAclLocal = &pAcl)
            {
                bool __result = Kernel32.AddScopedPolicyIDAce(pAclLocal, dwAceRevision, AceFlags, AccessMask, pSid);
                return __result;
            }
        }

        /// <summary>Adds a SYSTEM_SCOPED_POLICY_ID_ACEaccess control entry (ACE) to the end of a system access control list (SACL).</summary>
        /// <param name = "pAcl">A pointer to an <a href = "https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">access control list</a> (ACL). This function adds an ACE to this ACL. The value of this parameter cannot be <b>NULL</b>.</param>
        /// <param name = "dwAceRevision">Specifies the revision level of the ACL being modified. This value can be ACL_REVISION or ACL_REVISION_DS. Use ACL_REVISION_DS if the ACL contains object-specific ACEs.</param>
        /// <param name = "AceFlags">
        /// <para>A set of bit flags that control ACE inheritance. The function sets these flags in the <b>AceFlags</b> member of the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-ace_header">ACE_HEADER</a> structure of the new ACE.</para>
        /// <para>For consistency with the Windows 8 Advanced File Permissions UI, applications should specify the CONTAINER_INHERIT_ACE and OBJECT_INHERIT_ACE flags in the <i>AceFlags</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//securitybaseapi/nf-securitybaseapi-addscopedpolicyidace#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "AccessMask">Must be zero for Windows 8 and Windows Server 2012.</param>
        /// <param name = "pSid">A pointer to the SID (S-1-17-*) that identifies the Central Access Policy to be associated with the resource.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>.</para>
        /// <para>If the function fails, it returns <b>FALSE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//securitybaseapi/nf-securitybaseapi-addscopedpolicyidace">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool AddScopedPolicyIDAce(win32.Security.ACL*pAcl, uint dwAceRevision, win32.Security.ACE_FLAGS AceFlags, uint AccessMask, win32.Security.PSID pSid);
        /// <inheritdoc cref = "CheckTokenCapability(win32.System.SystemServices.HANDLE, win32.Security.PSID, bool *)"/>
        internal static unsafe bool CheckTokenCapability(SafeHandle TokenHandle, win32.Security.PSID CapabilitySidToCheck, out bool HasCapability)
        {
            bool TokenHandleAddRef = false;
            try
            {
                fixed (bool *HasCapabilityLocal = &HasCapability)
                {
                    win32.System.SystemServices.HANDLE TokenHandleLocal;
                    if (TokenHandle is object)
                    {
                        TokenHandle.DangerousAddRef(ref TokenHandleAddRef);
                        TokenHandleLocal = (win32.System.SystemServices.HANDLE)TokenHandle.DangerousGetHandle();
                    }
                    else
                        TokenHandleLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.CheckTokenCapability(TokenHandleLocal, CapabilitySidToCheck, HasCapabilityLocal);
                    return __result;
                }
            }
            finally
            {
                if (TokenHandleAddRef)
                    TokenHandle.DangerousRelease();
            }
        }

        /// <summary>Checks the capabilities of a given token.</summary>
        /// <param name = "TokenHandle">
        /// <para>A handle to an access token. The handle must have TOKEN_QUERY access to the token. The token must be an <a href = "https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">impersonation token</a>.</para>
        /// <para>If <i>TokenHandle</i> is <b>NULL</b>, <b>CheckTokenCapability</b> uses the impersonation token of the calling thread. If the thread is not impersonating, the function duplicates the thread's <a href = "https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">primary token</a> to create an <a href = "https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">impersonation token</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//securitybaseapi/nf-securitybaseapi-checktokencapability#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "CapabilitySidToCheck">A pointer to a capability <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-sid">SID</a> structure. The <b>CheckTokenCapability</b> function checks the capabilities of this access token.</param>
        /// <param name = "HasCapability">Receives the results of the check. If the access token has the capability, it returns <b>TRUE</b>, otherwise, it returns <b>FALSE</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a></para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//securitybaseapi/nf-securitybaseapi-checktokencapability">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool CheckTokenCapability(win32.System.SystemServices.HANDLE TokenHandle, win32.Security.PSID CapabilitySidToCheck, bool *HasCapability);
        /// <inheritdoc cref = "GetAppContainerAce(win32.Security.ACL*, uint, void **, uint *)"/>
        internal static unsafe bool GetAppContainerAce(in win32.Security.ACL Acl, uint StartingAceIndex, out void *AppContainerAce, uint *AppContainerAceIndex)
        {
            fixed (void **AppContainerAceLocal = &AppContainerAce)
            {
                fixed (win32.Security.ACL*AclLocal = &Acl)
                {
                    bool __result = Kernel32.GetAppContainerAce(AclLocal, StartingAceIndex, AppContainerAceLocal, AppContainerAceIndex);
                    return __result;
                }
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetAppContainerAce(win32.Security.ACL*Acl, uint StartingAceIndex, void **AppContainerAce, [Optional] uint *AppContainerAceIndex);
        /// <inheritdoc cref = "CheckTokenMembershipEx(win32.System.SystemServices.HANDLE, win32.Security.PSID, uint, bool *)"/>
        internal static unsafe bool CheckTokenMembershipEx(SafeHandle TokenHandle, win32.Security.PSID SidToCheck, uint Flags, out bool IsMember)
        {
            bool TokenHandleAddRef = false;
            try
            {
                fixed (bool *IsMemberLocal = &IsMember)
                {
                    win32.System.SystemServices.HANDLE TokenHandleLocal;
                    if (TokenHandle is object)
                    {
                        TokenHandle.DangerousAddRef(ref TokenHandleAddRef);
                        TokenHandleLocal = (win32.System.SystemServices.HANDLE)TokenHandle.DangerousGetHandle();
                    }
                    else
                        TokenHandleLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.CheckTokenMembershipEx(TokenHandleLocal, SidToCheck, Flags, IsMemberLocal);
                    return __result;
                }
            }
            finally
            {
                if (TokenHandleAddRef)
                    TokenHandle.DangerousRelease();
            }
        }

        /// <summary>Determines whether the specified SID is enabled in the specified token.</summary>
        /// <param name = "TokenHandle">A handle to an access token. If present, this token is checked for the SID. If not present, then the current effective token is used. This must be an impersonation token.</param>
        /// <param name = "SidToCheck">A pointer to a SID structure. The function checks for the presence of this SID in the presence of the token.</param>
        /// <param name = "Flags">Flags that affect the behavior of the function. Currently the only valid flag is CTMF_INCLUDE_APPCONTAINER which allows app containers to pass the call as long as the other requirements of the token are met, such as the group specified is present and enabled.</param>
        /// <param name = "IsMember"><b>TRUE</b> if the SID is enabled in the token; otherwise, <b>FALSE</b>.</param>
        /// <returns>
        /// <para>If the function succeeds, it returns <b>TRUE</b>.</para>
        /// <para>If the function fails, it returns zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//securitybaseapi/nf-securitybaseapi-checktokenmembershipex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool CheckTokenMembershipEx(win32.System.SystemServices.HANDLE TokenHandle, win32.Security.PSID SidToCheck, uint Flags, bool *IsMember);
        /// <inheritdoc cref = "SetCachedSigningLevel(win32.System.SystemServices.HANDLE*, uint, uint, win32.System.SystemServices.HANDLE)"/>
        internal static unsafe bool SetCachedSigningLevel(Span<win32.System.SystemServices.HANDLE> SourceFiles, uint Flags, SafeHandle TargetFile)
        {
            bool TargetFileAddRef = false;
            try
            {
                fixed (win32.System.SystemServices.HANDLE*SourceFilesLocal = SourceFiles)
                {
                    win32.System.SystemServices.HANDLE TargetFileLocal;
                    if (TargetFile is object)
                    {
                        TargetFile.DangerousAddRef(ref TargetFileAddRef);
                        TargetFileLocal = (win32.System.SystemServices.HANDLE)TargetFile.DangerousGetHandle();
                    }
                    else
                        TargetFileLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.SetCachedSigningLevel(SourceFilesLocal, (uint)SourceFiles.Length, Flags, TargetFileLocal);
                    return __result;
                }
            }
            finally
            {
                if (TargetFileAddRef)
                    TargetFile.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetCachedSigningLevel(win32.System.SystemServices.HANDLE*SourceFiles, uint SourceFileCount, uint Flags, win32.System.SystemServices.HANDLE TargetFile);
        /// <inheritdoc cref = "GetCachedSigningLevel(win32.System.SystemServices.HANDLE, uint *, uint *, byte *, uint *, uint *)"/>
        internal static unsafe bool GetCachedSigningLevel(SafeHandle File, out uint Flags, out uint SigningLevel, byte *Thumbprint, uint *ThumbprintSize, uint *ThumbprintAlgorithm)
        {
            bool FileAddRef = false;
            try
            {
                fixed (uint *SigningLevelLocal = &SigningLevel)
                {
                    fixed (uint *FlagsLocal = &Flags)
                    {
                        win32.System.SystemServices.HANDLE FileLocal;
                        if (File is object)
                        {
                            File.DangerousAddRef(ref FileAddRef);
                            FileLocal = (win32.System.SystemServices.HANDLE)File.DangerousGetHandle();
                        }
                        else
                            FileLocal = default(win32.System.SystemServices.HANDLE);
                        bool __result = Kernel32.GetCachedSigningLevel(FileLocal, FlagsLocal, SigningLevelLocal, Thumbprint, ThumbprintSize, ThumbprintAlgorithm);
                        return __result;
                    }
                }
            }
            finally
            {
                if (FileAddRef)
                    File.DangerousRelease();
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool GetCachedSigningLevel(win32.System.SystemServices.HANDLE File, uint *Flags, uint *SigningLevel, [Optional] byte *Thumbprint, [Optional] uint *ThumbprintSize, [Optional] uint *ThumbprintAlgorithm);
        /// <inheritdoc cref = "GetAppContainerNamedObjectPath(win32.System.SystemServices.HANDLE, win32.Security.PSID, uint, win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe bool GetAppContainerNamedObjectPath(SafeHandle Token, win32.Security.PSID AppContainerSid, uint ObjectPathLength, win32.System.SystemServices.PWSTR ObjectPath, out uint ReturnLength)
        {
            bool TokenAddRef = false;
            try
            {
                fixed (uint *ReturnLengthLocal = &ReturnLength)
                {
                    win32.System.SystemServices.HANDLE TokenLocal;
                    if (Token is object)
                    {
                        Token.DangerousAddRef(ref TokenAddRef);
                        TokenLocal = (win32.System.SystemServices.HANDLE)Token.DangerousGetHandle();
                    }
                    else
                        TokenLocal = default(win32.System.SystemServices.HANDLE);
                    bool __result = Kernel32.GetAppContainerNamedObjectPath(TokenLocal, AppContainerSid, ObjectPathLength, ObjectPath, ReturnLengthLocal);
                    return __result;
                }
            }
            finally
            {
                if (TokenAddRef)
                    Token.DangerousRelease();
            }
        }

        /// <summary>Retrieves the named object path for the app container.</summary>
        /// <param name = "Token">A handle pertaining to the token. If <b>NULL</b> is passed in and no <i>AppContainerSid</i> parameter is passed in, the caller's current process token is used, or the thread token if impersonating.</param>
        /// <param name = "AppContainerSid">The SID of the app container.</param>
        /// <param name = "ObjectPathLength">The length of the buffer.</param>
        /// <param name = "ObjectPath">Buffer that is filled with the named object path.</param>
        /// <param name = "ReturnLength">Returns the length required to accommodate the length of the named object path.</param>
        /// <returns>
        /// <para>If the function succeeds, the function returns a value of <b>TRUE</b>.</para>
        /// <para>If the function fails, it returns a value of <b>FALSE</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//securityappcontainer/nf-securityappcontainer-getappcontainernamedobjectpath">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetAppContainerNamedObjectPath(win32.System.SystemServices.HANDLE Token, win32.Security.PSID AppContainerSid, uint ObjectPathLength, win32.System.SystemServices.PWSTR ObjectPath, uint *ReturnLength);
        /// <inheritdoc cref = "FindStringOrdinal(uint, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PCWSTR, int, bool)"/>
        internal static unsafe int FindStringOrdinal(uint dwFindStringOrdinalFlags, string lpStringSource, int cchSource, string lpStringValue, int cchValue, bool bIgnoreCase)
        {
            fixed (char *lpStringValueLocal = lpStringValue)
            {
                fixed (char *lpStringSourceLocal = lpStringSource)
                {
                    int __result = Kernel32.FindStringOrdinal(dwFindStringOrdinalFlags, lpStringSourceLocal, cchSource, lpStringValueLocal, cchValue, bIgnoreCase);
                    return __result;
                }
            }
        }

        /// <summary>Locates a Unicode string (wide characters) in another Unicode string for a non-linguistic comparison.</summary>
        /// <param name = "dwFindStringOrdinalFlags">
        /// <para>Flags specifying details of the find operation. These flags are mutually exclusive, with FIND_FROMSTART being the default. The application can specify just one of the find flags.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findstringordinal#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpStringSource">Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.</param>
        /// <param name = "cchSource">Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application must normally specify a positive number, or 0. The application can specify -1 if the source string is null-terminated and the function should calculate the size automatically.</param>
        /// <param name = "lpStringValue">Pointer to the search string for which the function searches in the source string.</param>
        /// <param name = "cchValue">Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application must normally specify a positive number, or 0. The application can specify -1 if the string is null-terminated and the function should calculate the size automatically.</param>
        /// <param name = "bIgnoreCase"><b>TRUE</b> if the function is to perform a case-insensitive comparison, and <b>FALSE</b> otherwise. The comparison is not a linguistic operation and is not appropriate for all locales and languages. Its behavior is similar to that for English.</param>
        /// <returns>
        /// <para>Returns a 0-based index into the source string indicated by <i>lpStringSource</i> if successful. If the function succeeds, the found string is the same size as the value of <i>lpStringValue</i>. A return value of 0 indicates that the function found a match at the beginning of the source string.</para>
        /// <para>The function returns -1 if it does not succeed or if it does not find the search string. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findstringordinal">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int FindStringOrdinal(uint dwFindStringOrdinalFlags, win32.System.SystemServices.PCWSTR lpStringSource, int cchSource, win32.System.SystemServices.PCWSTR lpStringValue, int cchValue, bool bIgnoreCase);
        /// <inheritdoc cref = "GetDateFormat(uint, uint, win32.System.WindowsProgramming.SYSTEMTIME*, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int GetDateFormat(uint Locale, uint dwFlags, win32.System.WindowsProgramming.SYSTEMTIME? lpDate, string lpFormat, win32.System.SystemServices.PWSTR lpDateStr, int cchDate)
        {
            fixed (char *lpFormatLocal = lpFormat)
            {
                win32.System.WindowsProgramming.SYSTEMTIME lpDateLocal = lpDate.HasValue ? lpDate.Value : default(win32.System.WindowsProgramming.SYSTEMTIME);
                int __result = Kernel32.GetDateFormat(Locale, dwFlags, lpDate.HasValue ? &lpDateLocal : null, lpFormatLocal, lpDateStr, cchDate);
                return __result;
            }
        }

        /// <summary>Formats a date as a date string for a locale specified by the locale identifier.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale this function formats the date string for. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-getdateformatw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Flags specifying date format options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-getdateformatex">GetDateFormatEx</a>.</param>
        /// <param name = "lpDate">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the date information to format. The application sets this parameter to <b>NULL</b> if the function is to use the current local system date.</param>
        /// <param name = "lpFormat">
        /// <para>Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in <a href = "https://docs.microsoft.com/windows/desktop/Intl/day--month--year--and-era-format-pictures">Day, Month, Year, and Era Format Pictures</a>.</para>
        /// <para>The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to <b>NULL</b> to format the string according to the date format for the specified locale.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-getdateformatw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDateStr">Pointer to a buffer in which this function retrieves the formatted date string.</param>
        /// <param name = "cchDate">Size, in characters, of the <i>lpDateStr</i> buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by <i>lpDateStr</i> is not used.</param>
        /// <returns>
        /// <para>Returns the number of characters written to the <i>lpDateStr</i> buffer if successful. If the <i>cchDate</i> parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-getdateformatw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetDateFormatW", SetLastError = true)]
        internal static extern unsafe int GetDateFormat(uint Locale, uint dwFlags, [Optional] win32.System.WindowsProgramming.SYSTEMTIME*lpDate, win32.System.SystemServices.PCWSTR lpFormat, win32.System.SystemServices.PWSTR lpDateStr, int cchDate);
        /// <inheritdoc cref = "GetTimeFormat(uint, uint, win32.System.WindowsProgramming.SYSTEMTIME*, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int GetTimeFormat(uint Locale, uint dwFlags, win32.System.WindowsProgramming.SYSTEMTIME? lpTime, string lpFormat, win32.System.SystemServices.PWSTR lpTimeStr, int cchTime)
        {
            fixed (char *lpFormatLocal = lpFormat)
            {
                win32.System.WindowsProgramming.SYSTEMTIME lpTimeLocal = lpTime.HasValue ? lpTime.Value : default(win32.System.WindowsProgramming.SYSTEMTIME);
                int __result = Kernel32.GetTimeFormat(Locale, dwFlags, lpTime.HasValue ? &lpTimeLocal : null, lpFormatLocal, lpTimeStr, cchTime);
                return __result;
            }
        }

        /// <summary>Formats time as a time string for a locale specified by identifier. The function formats either a specified time or the local system time.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-gettimeformatw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Flags specifying time format options. For detailed definitions see the <i>dwFlags</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.</param>
        /// <param name = "lpTime">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system time.</param>
        /// <param name = "lpFormat">Pointer to a format picture to use to format the time string. If the application sets this parameter to <b>NULL</b>, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section.</param>
        /// <param name = "lpTimeStr">Pointer to a buffer in which this function retrieves the formatted time string.</param>
        /// <param name = "cchTime">Size, in TCHAR values, for the time string buffer indicated by <i>lpTimeStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the <i>lpTimeStr</i> parameter.</param>
        /// <returns>
        /// <para>Returns the number of TCHAR values retrieved in the buffer indicated by <i>lpTimeStr</i>. If the <i>cchTime</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted time string, including a terminating null character.</para>
        /// <para>This function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-gettimeformatw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetTimeFormatW", SetLastError = true)]
        internal static extern unsafe int GetTimeFormat(uint Locale, uint dwFlags, [Optional] win32.System.WindowsProgramming.SYSTEMTIME*lpTime, win32.System.SystemServices.PCWSTR lpFormat, win32.System.SystemServices.PWSTR lpTimeStr, int cchTime);
        /// <inheritdoc cref = "GetTimeFormatEx(win32.System.SystemServices.PCWSTR, win32.Globalization.TIME_FORMAT_FLAGS, win32.System.WindowsProgramming.SYSTEMTIME*, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int GetTimeFormatEx(string lpLocaleName, win32.Globalization.TIME_FORMAT_FLAGS dwFlags, win32.System.WindowsProgramming.SYSTEMTIME? lpTime, string lpFormat, win32.System.SystemServices.PWSTR lpTimeStr, int cchTime)
        {
            fixed (char *lpFormatLocal = lpFormat)
            {
                fixed (char *lpLocaleNameLocal = lpLocaleName)
                {
                    win32.System.WindowsProgramming.SYSTEMTIME lpTimeLocal = lpTime.HasValue ? lpTime.Value : default(win32.System.WindowsProgramming.SYSTEMTIME);
                    int __result = Kernel32.GetTimeFormatEx(lpLocaleNameLocal, dwFlags, lpTime.HasValue ? &lpTimeLocal : null, lpFormatLocal, lpTimeStr, cchTime);
                    return __result;
                }
            }
        }

        /// <summary>Formats time as a time string for a locale specified by name.</summary>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-gettimeformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <param name = "lpTime">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system time.</param>
        /// <param name = "lpFormat">Pointer to a format picture to use to format the time string. If the application sets this parameter to <b>NULL</b>, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section.</param>
        /// <param name = "lpTimeStr">Pointer to a buffer in which this function retrieves the formatted time string.</param>
        /// <param name = "cchTime">Size, in characters, for the time string buffer indicated by <i>lpTimeStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the <i>lpTimeStr</i> parameter.</param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in the buffer indicated by <i>lpTimeStr</i>. If the <i>cchTime</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted time string, including a terminating null character.</para>
        /// <para>This function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-gettimeformatex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int GetTimeFormatEx(win32.System.SystemServices.PCWSTR lpLocaleName, win32.Globalization.TIME_FORMAT_FLAGS dwFlags, [Optional] win32.System.WindowsProgramming.SYSTEMTIME*lpTime, win32.System.SystemServices.PCWSTR lpFormat, win32.System.SystemServices.PWSTR lpTimeStr, int cchTime);
        /// <inheritdoc cref = "GetDateFormatEx(win32.System.SystemServices.PCWSTR, win32.Globalization.ENUM_DATE_FORMATS_FLAGS, win32.System.WindowsProgramming.SYSTEMTIME*, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, int, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe int GetDateFormatEx(string lpLocaleName, win32.Globalization.ENUM_DATE_FORMATS_FLAGS dwFlags, win32.System.WindowsProgramming.SYSTEMTIME? lpDate, string lpFormat, win32.System.SystemServices.PWSTR lpDateStr, int cchDate, string lpCalendar)
        {
            fixed (char *lpCalendarLocal = lpCalendar)
            {
                fixed (char *lpFormatLocal = lpFormat)
                {
                    fixed (char *lpLocaleNameLocal = lpLocaleName)
                    {
                        win32.System.WindowsProgramming.SYSTEMTIME lpDateLocal = lpDate.HasValue ? lpDate.Value : default(win32.System.WindowsProgramming.SYSTEMTIME);
                        int __result = Kernel32.GetDateFormatEx(lpLocaleNameLocal, dwFlags, lpDate.HasValue ? &lpDateLocal : null, lpFormatLocal, lpDateStr, cchDate, lpCalendarLocal);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Formats a date as a date string for a locale specified by name.</summary>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-getdateformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <param name = "lpDate">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the date information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system date.</param>
        /// <param name = "lpFormat">
        /// <para>Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in <a href = "https://docs.microsoft.com/windows/desktop/Intl/day--month--year--and-era-format-pictures">Day, Month, Year, and Era Format Pictures</a>.</para>
        /// <para>For example, to get the date string "Wed, Aug 31 94", the application uses the picture string "ddd',' MMM dd yy".</para>
        /// <para>The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to <b>NULL</b> to format the string according to the date format for the specified locale.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-getdateformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDateStr">Pointer to a buffer in which this function retrieves the formatted date string.</param>
        /// <param name = "cchDate">Size, in characters, of the <i>lpDateStr</i> buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by <i>lpDateStr</i> is not used.</param>
        /// <param name = "lpCalendar">Reserved; must set to <b>NULL</b>.</param>
        /// <returns>
        /// <para>Returns the number of characters written to the <i>lpDateStr</i> buffer if successful. If the <i>cchDate</i> parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character.</para>
        /// <para>This function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-getdateformatex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int GetDateFormatEx(win32.System.SystemServices.PCWSTR lpLocaleName, win32.Globalization.ENUM_DATE_FORMATS_FLAGS dwFlags, [Optional] win32.System.WindowsProgramming.SYSTEMTIME*lpDate, win32.System.SystemServices.PCWSTR lpFormat, win32.System.SystemServices.PWSTR lpDateStr, int cchDate, win32.System.SystemServices.PCWSTR lpCalendar);
        /// <inheritdoc cref = "GetDurationFormatEx(win32.System.SystemServices.PCWSTR, uint, win32.System.WindowsProgramming.SYSTEMTIME*, ulong, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int GetDurationFormatEx(string lpLocaleName, uint dwFlags, win32.System.WindowsProgramming.SYSTEMTIME? lpDuration, ulong ullDuration, string lpFormat, win32.System.SystemServices.PWSTR lpDurationStr, int cchDuration)
        {
            fixed (char *lpFormatLocal = lpFormat)
            {
                fixed (char *lpLocaleNameLocal = lpLocaleName)
                {
                    win32.System.WindowsProgramming.SYSTEMTIME lpDurationLocal = lpDuration.HasValue ? lpDuration.Value : default(win32.System.WindowsProgramming.SYSTEMTIME);
                    int __result = Kernel32.GetDurationFormatEx(lpLocaleNameLocal, dwFlags, lpDuration.HasValue ? &lpDurationLocal : null, ullDuration, lpFormatLocal, lpDurationStr, cchDuration);
                    return __result;
                }
            }
        }

        /// <summary>Formats a duration of time as a time string for a locale specified by name.</summary>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Flags specifying function options. If <i>lpFormat</i> is not set to <b>NULL</b>, this parameter must be set to 0. If <i>lpFormat</i> is set to <b>NULL</b>, your application can specify <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default duration format for the specified locale.</para>
        /// <para><div class = "alert"><b>Caution</b>  Use of <b>LOCALE_NOUSEROVERRIDE</b> is strongly discouraged as it disables user preferences.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDuration">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time duration information to format. The application sets this parameter to <b>NULL</b> if the function is to ignore it and use <i>ullDuration</i>.</param>
        /// <param name = "ullDuration">64-bit unsigned integer that represents the number of 100-nanosecond intervals in the duration. If both <i>lpDuration</i> and <i>ullDuration</i> are set, the <i>lpDuration</i> parameter takes precedence. If <i>lpDuration</i> is set to <b>NULL</b> and <i>ullDuration</i> is set to 0, the duration is 0.</param>
        /// <param name = "lpFormat">
        /// <para>Pointer to the format string with characters as shown below. The application can set this parameter to <b>NULL</b> if the function is to format the string according to the duration format for the specified locale. If <i>lpFormat</i> is not set to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDurationStr">
        /// <para>Pointer to the buffer in which the function retrieves the duration string.</para>
        /// <para>Alternatively, this parameter retrieves <b>NULL</b> if <i>cchDuration</i> is set to 0. In this case, the function returns the required size for the duration string buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchDuration">
        /// <para>Size, in characters, of the buffer indicated by <i>lpDurationStr</i>.</para>
        /// <para>Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpDurationStr</i> and returns the required size for the duration string buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in the buffer indicated by <i>lpDurationStr</i> if successful. If <i>lpDurationStr</i> is set to <b>NULL</b> and <i>cchDuration</i> is set to 0, the function returns the required size for the duration string buffer, including the terminating null character. For example, if 10 characters are written to the buffer, the function returns 11 to include the terminating null character.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformatex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int GetDurationFormatEx(win32.System.SystemServices.PCWSTR lpLocaleName, uint dwFlags, [Optional] win32.System.WindowsProgramming.SYSTEMTIME*lpDuration, ulong ullDuration, win32.System.SystemServices.PCWSTR lpFormat, win32.System.SystemServices.PWSTR lpDurationStr, int cchDuration);
        /// <inheritdoc cref = "CompareStringEx(win32.System.SystemServices.PCWSTR, win32.Globalization.COMPARE_STRING_FLAGS, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PCWSTR, int, win32.Globalization.NLSVERSIONINFO*, void *, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe int CompareStringEx(string lpLocaleName, win32.Globalization.COMPARE_STRING_FLAGS dwCmpFlags, string lpString1, int cchCount1, string lpString2, int cchCount2, ref win32.Globalization.NLSVERSIONINFO lpVersionInformation, void *lpReserved, win32.UI.WindowsAndMessaging.LPARAM lParam)
        {
            fixed (win32.Globalization.NLSVERSIONINFO*lpVersionInformationLocal = &lpVersionInformation)
            {
                fixed (char *lpString2Local = lpString2)
                {
                    fixed (char *lpString1Local = lpString1)
                    {
                        fixed (char *lpLocaleNameLocal = lpLocaleName)
                        {
                            int __result = Kernel32.CompareStringEx(lpLocaleNameLocal, dwCmpFlags, lpString1Local, cchCount1, lpString2Local, cchCount2, lpVersionInformationLocal, lpReserved, lParam);
                            return __result;
                        }
                    }
                }
            }
        }

        /// <summary>Compares two Unicode (wide character) strings, for a locale specified by name.Caution  Using CompareStringEx incorrectly can compromise the security of your application.</summary>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-comparestringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwCmpFlags"></param>
        /// <param name = "lpString1">Pointer to the first string to compare.</param>
        /// <param name = "cchCount1">Length of the string indicated by <i>lpString1</i>, excluding the terminating null character. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.</param>
        /// <param name = "lpString2">Pointer to the second string to compare.</param>
        /// <param name = "cchCount2">Length of the string indicated by <i>lpString2</i>, excluding the terminating null character. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.</param>
        /// <param name = "lpVersionInformation">
        /// <para>Pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure that contains the version information about the relevant NLS capability; usually retrieved from <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversionex">GetNLSVersionEx</a>.</para>
        /// <para><b>Windows Vista, Windows 7:</b> Reserved; must set to <b>NULL</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-comparestringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpReserved">Reserved; must set to <b>NULL</b>.</param>
        /// <param name = "lParam">Reserved; must be set to 0.</param>
        /// <returns>
        /// <para>Returns one of the following values if successful. To maintain the C runtime convention of comparing strings, the value 2 can be subtracted from a nonzero return value. Then, the meaning of &lt;0, ==0, and &gt;0 is consistent with the C runtime.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-comparestringex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int CompareStringEx(win32.System.SystemServices.PCWSTR lpLocaleName, win32.Globalization.COMPARE_STRING_FLAGS dwCmpFlags, win32.System.SystemServices.PCWSTR lpString1, int cchCount1, win32.System.SystemServices.PCWSTR lpString2, int cchCount2, win32.Globalization.NLSVERSIONINFO*lpVersionInformation, void *lpReserved, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <inheritdoc cref = "CompareStringOrdinal(win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PCWSTR, int, bool)"/>
        internal static unsafe int CompareStringOrdinal(string lpString1, int cchCount1, string lpString2, int cchCount2, bool bIgnoreCase)
        {
            fixed (char *lpString2Local = lpString2)
            {
                fixed (char *lpString1Local = lpString1)
                {
                    int __result = Kernel32.CompareStringOrdinal(lpString1Local, cchCount1, lpString2Local, cchCount2, bIgnoreCase);
                    return __result;
                }
            }
        }

        /// <summary>Compares two Unicode strings to test binary equivalence.</summary>
        /// <param name = "lpString1">Pointer to the first string to compare.</param>
        /// <param name = "cchCount1">Length of the string indicated by <i>lpString1</i>. The application supplies -1 if the string is null-terminated. In this case, the function determines the length automatically.</param>
        /// <param name = "lpString2">Pointer to the second string to compare.</param>
        /// <param name = "cchCount2">Length of the string indicated by <i>lpString2</i>. The application supplies -1 if the string is null-terminated. In this case, the function determines the length automatically.</param>
        /// <param name = "bIgnoreCase"><b>TRUE</b> if the function is to perform a case-insensitive comparison, using the operating system uppercase table information. The application sets this parameter to <b>FALSE</b> if the function is to compare the strings exactly as they are passed in. Note that 1 is the only numeric value that can be used to specify a true value for this boolean parameter that does not result an invalid parameter error. Boolean values for this parameter work as expected.</param>
        /// <returns>
        /// <para>Returns one of the following values if successful. To maintain the C runtime convention of comparing strings, the value 2 can be subtracted from a nonzero return value. Then, the meaning of &lt;0, ==0, and &gt;0 is consistent with the C runtime.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-comparestringordinal">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int CompareStringOrdinal(win32.System.SystemServices.PCWSTR lpString1, int cchCount1, win32.System.SystemServices.PCWSTR lpString2, int cchCount2, bool bIgnoreCase);
        /// <inheritdoc cref = "CompareString(uint, uint, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PCWSTR, int)"/>
        internal static unsafe int CompareString(uint Locale, uint dwCmpFlags, string lpString1, int cchCount1, string lpString2, int cchCount2)
        {
            fixed (char *lpString2Local = lpString2)
            {
                fixed (char *lpString1Local = lpString1)
                {
                    int __result = Kernel32.CompareString(Locale, dwCmpFlags, lpString1Local, cchCount1, lpString2Local, cchCount2);
                    return __result;
                }
            }
        }

        /// <summary>Compares two character strings, for a locale specified by identifier.Caution  Using CompareString incorrectly can compromise the security of your application.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale used for the comparison. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-comparestringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwCmpFlags">Flags that indicate how the function compares the two strings. For detailed definitions, see the <i>dwCmpFlags</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.</param>
        /// <param name = "lpString1">Pointer to the first string to compare.</param>
        /// <param name = "cchCount1">Length of the string indicated by <i>lpString1</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.</param>
        /// <param name = "lpString2">Pointer to the second string to compare.</param>
        /// <param name = "cchCount2">Length of the string indicated by <i>lpString2</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.</param>
        /// <returns>Returns the values described for <a href = "/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-comparestringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "CompareStringW")]
        internal static extern int CompareString(uint Locale, uint dwCmpFlags, win32.System.SystemServices.PCWSTR lpString1, int cchCount1, win32.System.SystemServices.PCWSTR lpString2, int cchCount2);
        /// <inheritdoc cref = "FoldString(win32.Globalization.FOLD_STRING_MAP_FLAGS, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int FoldString(win32.Globalization.FOLD_STRING_MAP_FLAGS dwMapFlags, string lpSrcStr, int cchSrc, win32.System.SystemServices.PWSTR lpDestStr, int cchDest)
        {
            fixed (char *lpSrcStrLocal = lpSrcStr)
            {
                int __result = Kernel32.FoldString(dwMapFlags, lpSrcStrLocal, cchSrc, lpDestStr, cchDest);
                return __result;
            }
        }

        /// <summary>Maps one Unicode string to another, performing the specified transformation.</summary>
        /// <param name = "dwMapFlags"></param>
        /// <param name = "lpSrcStr">Pointer to a source string that the function maps.</param>
        /// <param name = "cchSrc">Size, in characters, of the source string indicated by <i>lpSrcStr</i>, excluding the terminating null character. The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, the function calculates the string length automatically, and null-terminates the mapped string indicated by <i>lpDestStr</i>.</param>
        /// <param name = "lpDestStr">Pointer to a buffer in which this function retrieves the mapped string.</param>
        /// <param name = "cchDest">
        /// <para>Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.</para>
        /// <para>The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string. If the MAP_FOLDDIGITS flag is specified, the return value is the maximum size required, even if the actual number of characters needed is smaller than the maximum size. If the maximum size is not passed, the function fails with ERROR_INSUFFICIENT_BUFFER.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-foldstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns the number of characters in the translated string, including a terminating null character, if successful. If the function succeeds and the value of <i>cchDest</i> is 0, the return value is the size of the buffer required to hold the translated string, including a terminating null character.</para>
        /// <para>This function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-foldstringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "FoldStringW", SetLastError = true)]
        internal static extern int FoldString(win32.Globalization.FOLD_STRING_MAP_FLAGS dwMapFlags, win32.System.SystemServices.PCWSTR lpSrcStr, int cchSrc, win32.System.SystemServices.PWSTR lpDestStr, int cchDest);
        /// <inheritdoc cref = "GetStringTypeEx(uint, uint, win32.System.SystemServices.PCWSTR, int, ushort *)"/>
        internal static unsafe bool GetStringTypeEx(uint Locale, uint dwInfoType, string lpSrcStr, Span<ushort> lpCharType)
        {
            fixed (ushort *lpCharTypeLocal = lpCharType)
            {
                fixed (char *lpSrcStrLocal = lpSrcStr)
                {
                    bool __result = Kernel32.GetStringTypeEx(Locale, dwInfoType, lpSrcStrLocal, lpCharType.Length, lpCharTypeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves character type information for the characters in the specified source string.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. This value uniquely defines the ANSI code page. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-getstringtypeexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwInfoType">Flags specifying the character type information to retrieve. For possible flag values, see the <i>dwInfoType</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. For detailed information about the character type bits, see Remarks for <a href = "https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>.</param>
        /// <param name = "lpSrcStr">Pointer to the string for which to retrieve the character types. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.</param>
        /// <param name = "cchSrc">Size, in characters, of the string indicated by <i>lpSrcStr</i>. The size refers to bytes for the ANSI version of the function or wide characters for the Unicode version. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.</param>
        /// <param name = "lpCharType">Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-getstringtypeexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetStringTypeExW", SetLastError = true)]
        internal static extern unsafe bool GetStringTypeEx(uint Locale, uint dwInfoType, win32.System.SystemServices.PCWSTR lpSrcStr, int cchSrc, ushort *lpCharType);
        /// <inheritdoc cref = "GetStringType(uint, win32.System.SystemServices.PCWSTR, int, ushort *)"/>
        internal static unsafe bool GetStringType(uint dwInfoType, string lpSrcStr, int cchSrc, out ushort lpCharType)
        {
            fixed (ushort *lpCharTypeLocal = &lpCharType)
            {
                fixed (char *lpSrcStrLocal = lpSrcStr)
                {
                    bool __result = Kernel32.GetStringType(dwInfoType, lpSrcStrLocal, cchSrc, lpCharTypeLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves character type information for the characters in the specified Unicode source string.</summary>
        /// <param name = "dwInfoType">
        /// <para>Flags specifying the character type information to retrieve. This parameter can have the following values. The character types are divided into different levels as described in the Remarks section.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-getstringtypew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSrcStr">Pointer to the Unicode string for which to retrieve the character types. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.</param>
        /// <param name = "cchSrc">Size, in characters, of the string indicated by <i>lpSrcStr</i>. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.</param>
        /// <param name = "lpCharType">Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-getstringtypew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetStringTypeW", SetLastError = true)]
        internal static extern unsafe bool GetStringType(uint dwInfoType, win32.System.SystemServices.PCWSTR lpSrcStr, int cchSrc, ushort *lpCharType);
        /// <summary>Maps a character string to a UTF-16 (wide character) string.</summary>
        /// <param name = "CodePage">
        /// <para>Code page to use in performing the conversion. This parameter can be set to the value of any code page that is installed or available in the operating system. For a list of code pages, see <a href = "https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>. Your application can also specify one of the values shown in the following table.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-multibytetowidechar#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <param name = "lpMultiByteStr">Pointer to the character string to convert.</param>
        /// <param name = "cbMultiByte">
        /// <para>Size, in bytes, of the string indicated by the <i>lpMultiByteStr</i> parameter. Alternatively, this parameter can be set to -1 if the string is null-terminated. Note that, if <i>cbMultiByte</i> is 0, the function fails.</para>
        /// <para>If this parameter is -1, the function processes the entire input string, including the terminating null character. Therefore, the resulting Unicode string has a terminating null character, and the length returned by the function includes this character.</para>
        /// <para>If this parameter is set to a positive integer, the function processes exactly the specified number of bytes. If the provided size does not include a terminating null character, the resulting Unicode string is not null-terminated, and the returned length does not include this character.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-multibytetowidechar#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpWideCharStr">Pointer to a buffer that receives the converted string.</param>
        /// <param name = "cchWideChar">Size, in characters, of the buffer indicated by <i>lpWideCharStr</i>. If this value is 0, the function returns the required buffer size, in characters, including any terminating null character, and makes no use of the <i>lpWideCharStr</i> buffer.</param>
        /// <returns>
        /// <para>Returns the number of characters written to the buffer indicated by <i>lpWideCharStr</i> if successful. If the function succeeds and <i>cchWideChar</i> is 0, the return value is the required size, in characters, for the buffer indicated by <i>lpWideCharStr</i>. Also see <i>dwFlags</i> for info about how the MB_ERR_INVALID_CHARS flag affects the return value when invalid sequences are input.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-multibytetowidechar">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int MultiByteToWideChar(uint CodePage, win32.Globalization.MULTI_BYTE_TO_WIDE_CHAR_FLAGS dwFlags, win32.System.SystemServices.PCSTR lpMultiByteStr, int cbMultiByte, win32.System.SystemServices.PWSTR lpWideCharStr, int cchWideChar);
        /// <inheritdoc cref = "WideCharToMultiByte(uint, uint, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PSTR, int, win32.System.SystemServices.PCSTR, int *)"/>
        internal static unsafe int WideCharToMultiByte(uint CodePage, uint dwFlags, string lpWideCharStr, int cchWideChar, win32.System.SystemServices.PSTR lpMultiByteStr, int cbMultiByte, win32.System.SystemServices.PCSTR lpDefaultChar, int *lpUsedDefaultChar)
        {
            fixed (char *lpWideCharStrLocal = lpWideCharStr)
            {
                int __result = Kernel32.WideCharToMultiByte(CodePage, dwFlags, lpWideCharStrLocal, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
                return __result;
            }
        }

        /// <summary>Maps a UTF-16 (wide character) string to a new character string.</summary>
        /// <param name = "CodePage">
        /// <para>Code page to use in performing the conversion. This parameter can be set to the value of any code page that is installed or available in the operating system. For a list of code pages, see <a href = "https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>. Your application can also specify one of the values shown in the following table.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-widechartomultibyte#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <param name = "lpWideCharStr">Pointer to the Unicode string to convert.</param>
        /// <param name = "cchWideChar">
        /// <para>Size, in characters, of the string indicated by <i>lpWideCharStr</i>. Alternatively, this parameter can be set to -1 if the string is null-terminated. If <i>cchWideChar</i> is set to 0, the function fails.</para>
        /// <para>If this parameter is -1, the function processes the entire input string, including the terminating null character. Therefore, the resulting character string has a terminating null character, and the length returned by the function includes this character.</para>
        /// <para>If this parameter is set to a positive integer, the function processes exactly the specified number of characters. If the provided size does not include a terminating null character, the resulting character string is not null-terminated, and the returned length does not include this character.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-widechartomultibyte#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpMultiByteStr">Pointer to a buffer that receives the converted string.</param>
        /// <param name = "cbMultiByte">Size, in bytes, of the buffer indicated by <i>lpMultiByteStr</i>. If this parameter is set to 0, the function returns the required buffer size for <i>lpMultiByteStr</i> and makes no use of the output parameter itself.</param>
        /// <param name = "lpDefaultChar">
        /// <para>Pointer to the character to use if a character cannot be represented in the specified code page. The application sets this parameter to <b>NULL</b> if the function is to use a system default value. To obtain the system default character, the application can call the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfo">GetCPInfo</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfoexa">GetCPInfoEx</a> function.</para>
        /// <para>For the CP_UTF7 and CP_UTF8 settings for <i>CodePage</i>, this parameter must be set to <b>NULL</b>. Otherwise, the function fails with ERROR_INVALID_PARAMETER.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-widechartomultibyte#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpUsedDefaultChar">
        /// <para>Pointer to a flag that indicates if the function has used a default character in the conversion. The flag is set to <b>TRUE</b> if one or more characters in the source string cannot be represented in the specified code page. Otherwise, the flag is set to <b>FALSE</b>. This parameter can be set to <b>NULL</b>.</para>
        /// <para>For the CP_UTF7 and CP_UTF8 settings for <i>CodePage</i>, this parameter must be set to <b>NULL</b>. Otherwise, the function fails with ERROR_INVALID_PARAMETER.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-widechartomultibyte#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If successful, returns the number of bytes written to the buffer pointed to by <i>lpMultiByteStr</i>. If the function succeeds and <i>cbMultiByte</i> is 0, the return value is the required size, in bytes, for the buffer indicated by <i>lpMultiByteStr</i>. Also see <i>dwFlags</i> for info about how the WC_ERR_INVALID_CHARS flag affects the return value when invalid sequences are input.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-widechartomultibyte">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int WideCharToMultiByte(uint CodePage, uint dwFlags, win32.System.SystemServices.PCWSTR lpWideCharStr, int cchWideChar, win32.System.SystemServices.PSTR lpMultiByteStr, int cbMultiByte, win32.System.SystemServices.PCSTR lpDefaultChar, [Optional] int *lpUsedDefaultChar);
        /// <summary>Determines if a specified code page is valid.</summary>
        /// <param name = "CodePage"><a href = "https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code page identifier</a> for the code page to check.</param>
        /// <returns>Returns a nonzero value if the code page is valid, or 0 if the code page is invalid.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidcodepage">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool IsValidCodePage(uint CodePage);
        /// <summary>Retrieves the current Windows ANSI code page identifier for the operating system.Caution  The ANSI API functions, for example, the ANSI version of TextOut, implicitly use GetACP to translate text to or from Unicode.</summary>
        /// <returns>Returns the current Windows ANSI code page (ACP) identifier for the operating system. See <a href = "/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of identifiers for Windows ANSI code pages and other code pages.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getacp">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetACP();
        /// <summary>Returns the current original equipment manufacturer (OEM) code page identifier for the operating system.</summary>
        /// <returns>Returns the current OEM code page identifier for the operating system.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getoemcp">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetOEMCP();
        /// <inheritdoc cref = "GetCPInfo(uint, win32.Globalization.CPINFO*)"/>
        internal static unsafe bool GetCPInfo(uint CodePage, out win32.Globalization.CPINFO lpCPInfo)
        {
            fixed (win32.Globalization.CPINFO*lpCPInfoLocal = &lpCPInfo)
            {
                bool __result = Kernel32.GetCPInfo(CodePage, lpCPInfoLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about any valid installed or available code page.</summary>
        /// <param name = "CodePage">Identifier for the code page for which to retrieve information. For details, see the <i>CodePage</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfoexa">GetCPInfoEx</a>.</param>
        /// <param name = "lpCPInfo">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfo">CPINFO</a> structure that receives information about the code page. See the Remarks section.</param>
        /// <returns>
        /// <para>Returns 1 if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcpinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetCPInfo(uint CodePage, win32.Globalization.CPINFO*lpCPInfo);
        /// <inheritdoc cref = "GetCPInfoEx(uint, uint, win32.Globalization.CPINFOEXW*)"/>
        internal static unsafe bool GetCPInfoEx(uint CodePage, uint dwFlags, out win32.Globalization.CPINFOEXW lpCPInfoEx)
        {
            fixed (win32.Globalization.CPINFOEXW*lpCPInfoExLocal = &lpCPInfoEx)
            {
                bool __result = Kernel32.GetCPInfoEx(CodePage, dwFlags, lpCPInfoExLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about any valid installed or available code page.</summary>
        /// <param name = "CodePage">
        /// <para>Identifier for the code page for which to retrieve information. The application can specify the code page identifier for any installed or available code page, or one of the following predefined values. See <a href = "https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of identifiers for ANSI and other code pages.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcpinfoexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Reserved; must be 0.</param>
        /// <param name = "lpCPInfoEx">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfoexa">CPINFOEX</a> structure that receives information about the code page.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcpinfoexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetCPInfoExW", SetLastError = true)]
        internal static extern unsafe bool GetCPInfoEx(uint CodePage, uint dwFlags, win32.Globalization.CPINFOEXW*lpCPInfoEx);
        /// <inheritdoc cref = "FindNLSString(uint, uint, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PCWSTR, int, int *)"/>
        internal static unsafe int FindNLSString(uint Locale, uint dwFindNLSStringFlags, string lpStringSource, int cchSource, string lpStringValue, int cchValue, int *pcchFound)
        {
            fixed (char *lpStringValueLocal = lpStringValue)
            {
                fixed (char *lpStringSourceLocal = lpStringSource)
                {
                    int __result = Kernel32.FindNLSString(Locale, dwFindNLSStringFlags, lpStringSourceLocal, cchSource, lpStringValueLocal, cchValue, pcchFound);
                    return __result;
                }
            }
        }

        /// <summary>Locates a Unicode string (wide characters) or its equivalent in another Unicode string for a locale specified by identifier.Caution  Because strings with very different binary representations can compare as identical, this function can raise certain security concerns. For more information, see the discussion of comparison functions in Security Considerations:\_International Features. Note  For interoperability reasons, the application should prefer the FindNLSStringEx function because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Although FindNLSString supports custom locales, most applications should use FindNLSStringEx for this type of support.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-findnlsstring#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFindNLSStringFlags">Flags specifying details of the find operation. For detailed definitions, see the <i>dwFindNLSStringFlags</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-findnlsstringex">FindNLSStringEx</a>.</param>
        /// <param name = "lpStringSource">Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.</param>
        /// <param name = "cchSource">Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the source string is null-terminated and the function should calculate the size automatically.</param>
        /// <param name = "lpStringValue">Pointer to the search string, for which the function searches in the source string.</param>
        /// <param name = "cchValue">Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the search string is null-terminated and the function should calculate the size automatically.</param>
        /// <param name = "pcchFound">Pointer to a buffer containing the length of the string that the function finds. For details, see the <i>pcchFound</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-findnlsstringex">FindNLSStringEx</a>.</param>
        /// <returns>
        /// <para>Returns a 0-based index into the source string indicated by <i>lpStringSource</i> if successful. In combination with the value in <i>pcchFound</i>, this index provides the exact location of the entire found string in the source string. A return value of 0 is an error-free index into the source string, and the matching string is in the source string at offset 0.</para>
        /// <para>The function returns -1 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-findnlsstring">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int FindNLSString(uint Locale, uint dwFindNLSStringFlags, win32.System.SystemServices.PCWSTR lpStringSource, int cchSource, win32.System.SystemServices.PCWSTR lpStringValue, int cchValue, [Optional] int *pcchFound);
        /// <inheritdoc cref = "LCMapString(uint, uint, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int LCMapString(uint Locale, uint dwMapFlags, string lpSrcStr, int cchSrc, win32.System.SystemServices.PWSTR lpDestStr, int cchDest)
        {
            fixed (char *lpSrcStrLocal = lpSrcStr)
            {
                int __result = Kernel32.LCMapString(Locale, dwMapFlags, lpSrcStrLocal, cchSrc, lpDestStr, cchDest);
                return __result;
            }
        }

        /// <summary>For a locale specified by identifier, maps one input character string to another using a specified transformation, or generates a sort key for the input string.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMapFlags">Flags specifying the type of transformation to use during string mapping or the type of sort key to generate. For detailed definitions, see the <i>dwMapFlags</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringex">LCMapStringEx</a>.</param>
        /// <param name = "lpSrcStr">Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0.</param>
        /// <param name = "cchSrc">
        /// <para>Size, in characters, of the source string indicated by <i>lpSrcStr</i>. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself.</para>
        /// <para>The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, if <b>LCMapString</b> is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by <i>lpDestStr</i>.</para>
        /// <para>The application cannot set this parameter to 0.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDestStr">
        /// <para>Pointer to a buffer in which this function retrieves the mapped string or a sort key.</para>
        /// <para>If the application is using the function to generate a sort key (LCMAP_SORTKEY):</para>
        /// <para>- The sort key is stored in the buffer and treated as an opaque array of bytes. The stored values can include embedded 0 bytes at any position. - The destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed.</para>
        /// <para>If the caller explicitly requests a subset of the string, the destination string does not include a terminating null character unless the caller specified it in *cchDest*.</para>
        /// <para>If this function fails, the destination buffer might contain either partial results or no results at all. In this case, all results should be considered invalid.</para>
        /// <para>> [!NOTE] > When setting LCMAP_UPPERCASE or LCMAP_LOWERCASE, the destination string can use the same buffer as the source string. However, this is strongly discouraged, as some conditions may cause the returned cased string to be a different length.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchDest">
        /// <para>Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.</para>
        /// <para>If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator.</para>
        /// <para>The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string or sort key.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds when used for string mapping, it returns the number of characters in the translated string (see *cchSrc* and *cchDest* for more details).</para>
        /// <para>If the function succeeds when used for string mapping it returns the number of bytes in the sort key.</para>
        /// <para>This function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "LCMapStringW", SetLastError = true)]
        internal static extern int LCMapString(uint Locale, uint dwMapFlags, win32.System.SystemServices.PCWSTR lpSrcStr, int cchSrc, win32.System.SystemServices.PWSTR lpDestStr, int cchDest);
        /// <summary>Retrieves information about a locale specified by identifier.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> for which to retrieve information. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getlocaleinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "LCType">
        /// <para>The locale information to retrieve. For detailed definitions, see the <i>LCType</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a>.</para>
        /// <para><div class = "alert"><b>Note</b>  For <b>GetLocaleInfo</b>, the value LOCALE_USE_CP_ACP is relevant only for the ANSI version.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getlocaleinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpLCData">Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if <i>cchData</i> is set to 0. For more information, see the Remarks section.</param>
        /// <param name = "cchData">Size, in TCHAR values, of the data buffer indicated by <i>lpLCData</i>. Alternatively, the application can set this parameter to 0. In this case, the function does not use the <i>lpLCData</i> parameter and returns the required buffer size, including the terminating null character.</param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in the locale data buffer if successful and <i>cchData</i> is a nonzero value. If the function succeeds, <i>cchData</i> is nonzero, and <a href = "/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> is specified, the return value is the size of the integer retrieved in the data buffer; that is, 2 for the Unicode version of the function or 4 for the ANSI version. If the function succeeds and the value of <i>cchData</i> is 0, the return value is the required size, in characters including a null character, for the locale data buffer.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getlocaleinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetLocaleInfoW", SetLastError = true)]
        internal static extern int GetLocaleInfo(uint Locale, uint LCType, win32.System.SystemServices.PWSTR lpLCData, int cchData);
        /// <inheritdoc cref = "SetLocaleInfo(uint, uint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetLocaleInfo(uint Locale, uint LCType, string lpLCData)
        {
            fixed (char *lpLCDataLocal = lpLCData)
            {
                bool __result = Kernel32.SetLocaleInfo(Locale, LCType, lpLCDataLocal);
                return __result;
            }
        }

        /// <summary>Sets an item of information in the user override portion of the current locale. This function does not set the system defaults.</summary>
        /// <param name = "Locale">
        /// <para>For the ANSI version of the function, the <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale with the code page used when interpreting the <i>lpLCData</i> information. For the Unicode version, this parameter is ignored.</para>
        /// <para>You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setlocaleinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "LCType">Type of locale information to set. For valid constants see "Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo" section of <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-information-constants">Locale Information Constants</a>. The application can specify only one value per call, but it can use the binary OR operator to combine <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> with any other constant.</param>
        /// <param name = "lpLCData">Pointer to a null-terminated string containing the locale information to set. The information must be in the format specific to the specified constant. The application uses a Unicode string for the Unicode version of the function, and an ANSI string for the ANSI version.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setlocaleinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetLocaleInfoW", SetLastError = true)]
        internal static extern bool SetLocaleInfo(uint Locale, uint LCType, win32.System.SystemServices.PCWSTR lpLCData);
        /// <summary>Retrieves information about a calendar for a locale specified by identifier.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcalendarinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Calendar"><a href = "https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a>.</param>
        /// <param name = "CalType">
        /// <para>Type of information to retrieve. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>.</para>
        /// <para><div class = "alert"><b>Note</b>  <b>GetCalendarInfo</b> returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.</div> <div> </div> CAL_USE_CP_ACP is relevant only for the ANSI version of this function.</para>
        /// <para>For CAL_NOUSEROVERRIDE, the function ignores any value set by <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setcalendarinfoa">SetCalendarInfo</a> and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by <b>SetCalendarInfo</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcalendarinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCalData">Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, this parameter must retrieve <b>NULL</b>.</param>
        /// <param name = "cchData">Size, in characters, of the <i>lpCalData</i> buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the <i>lpCalData</i> parameter is not used. If CAL_RETURN_NUMBER is specified for <i>CalType</i>, the value of <i>cchData</i> must be 0.</param>
        /// <param name = "lpValue">Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, then <i>lpValue</i> must not be <b>NULL</b>. If CAL_RETURN_NUMBER is not specified in <i>CalType</i>, then <i>lpValue</i> must be <b>NULL</b>.</param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in the <i>lpCalData</i> buffer, with <i>cchData</i> set to a nonzero value, if successful. If the function succeeds, <i>cchData</i> is set to 0, and CAL_RETURN_NUMBER is not specified, the return value is the size of the buffer required to hold the calendar information. If the function succeeds, <i>cchData</i> is set 0, and CAL_RETURN_NUMBER is specified, the return value is the size of the value retrieved in <i>lpValue</i>, that is, 2 for the Unicode version of the function or 4 for the ANSI version.</para>
        /// <para>This function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcalendarinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetCalendarInfoW", SetLastError = true)]
        internal static extern unsafe int GetCalendarInfo(uint Locale, uint Calendar, uint CalType, win32.System.SystemServices.PWSTR lpCalData, int cchData, [Optional] uint *lpValue);
        /// <inheritdoc cref = "SetCalendarInfo(uint, uint, uint, win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool SetCalendarInfo(uint Locale, uint Calendar, uint CalType, string lpCalData)
        {
            fixed (char *lpCalDataLocal = lpCalData)
            {
                bool __result = Kernel32.SetCalendarInfo(Locale, Calendar, CalType, lpCalDataLocal);
                return __result;
            }
        }

        /// <summary>Sets an item of locale information for a calendar. For more information, see Date and Calendar.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setcalendarinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Calendar"><a href = "https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> for the calendar for which to set information.</param>
        /// <param name = "CalType">
        /// <para>Type of calendar information to set. Only the following CALTYPE values are valid for this function. The CAL_USE_CP_ACP constant is only meaningful for the ANSI version of the function.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setcalendarinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCalData">Pointer to a null-terminated calendar information string. The information must be in the format of the specified calendar type.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setcalendarinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "SetCalendarInfoW", SetLastError = true)]
        internal static extern bool SetCalendarInfo(uint Locale, uint Calendar, uint CalType, win32.System.SystemServices.PCWSTR lpCalData);
        /// <summary>Determines if a specified character is a lead byte for the system default Windows ANSI code page (CP_ACP). A lead byte is the first byte of a two-byte character in a double-byte character set (DBCS) for the code page.</summary>
        /// <param name = "TestChar">The character to test.</param>
        /// <returns>
        /// <para>Returns a nonzero value if the test character is potentially a lead byte. The function returns 0 if the test character is not a lead byte or if it is a single-byte character. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isdbcsleadbyte">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool IsDBCSLeadByte(byte TestChar);
        /// <summary>Determines if a specified character is potentially a lead byte. A lead byte is the first byte of a two-byte character in a double-byte character set (DBCS) for the code page.</summary>
        /// <param name = "CodePage">
        /// <para>Identifier of the code page used to check lead byte ranges. This parameter can be one of the code page identifiers defined in <a href = "https://docs.microsoft.com/windows/desktop/Intl/unicode-and-character-set-constants">Unicode and Character Set Constants</a> or one of the following predefined values. This function validates lead byte values only in code pages 932, 936, 949, 950, and 1361.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isdbcsleadbyteex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "TestChar">The character to test.</param>
        /// <returns>Returns a nonzero value if the byte is a lead byte. The function returns 0 if the byte is not a lead byte or if the character is a single-byte character. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isdbcsleadbyteex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool IsDBCSLeadByteEx(uint CodePage, byte TestChar);
        /// <inheritdoc cref = "LocaleNameToLCID(win32.System.SystemServices.PCWSTR, uint)"/>
        internal static unsafe uint LocaleNameToLCID(string lpName, uint dwFlags)
        {
            fixed (char *lpNameLocal = lpName)
            {
                uint __result = Kernel32.LocaleNameToLCID(lpNameLocal, dwFlags);
                return __result;
            }
        }

        /// <summary>Converts a locale name to a locale identifier.</summary>
        /// <param name = "lpName">
        /// <para>Pointer to a null-terminated string representing a locale name, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-localenametolcid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para><b>Prior to Windows 7:</b>Reserved; should always be 0.</para>
        /// <para><b>Beginning in Windows 7:</b> Can be set to <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-allow-neutral-names">LOCALE_ALLOW_NEUTRAL_NAMES</a> to allow the return of a neutral LCID.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-localenametolcid#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns the locale identifier corresponding to the locale name if successful. If the supplied locale name corresponds to a custom locale that is the user default, this function returns <a href = "/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>. If the locale name corresponds to a custom locale that is not the user default, the function returns <a href = "/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>.</para>
        /// <para>If the locale provided is a transient locale or a CLDR (Unicode Common Locale Data Repository) locale, then the LCID returned is 0x1000.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes: </para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-localenametolcid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern uint LocaleNameToLCID(win32.System.SystemServices.PCWSTR lpName, uint dwFlags);
        /// <summary>Converts a locale identifier to a locale name.</summary>
        /// <param name = "Locale">
        /// <para>Locale identifier to translate. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcidtolocalename#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpName">
        /// <para>Pointer to a buffer in which this function retrieves the locale name, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcidtolocalename#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchName">
        /// <para>Size, in characters, of the locale name buffer. The maximum possible length of a locale name, including a terminating null character, is <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply for this parameter.</para>
        /// <para>Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the locale name buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcidtolocalename#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para><b>Before Windows 7:</b> Reserved; should always be 0.</para>
        /// <para><b>Starting with Windows 7:</b> Can be set to <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-allow-neutral-names">LOCALE_ALLOW_NEUTRAL_NAMES</a> to allow the return of a neutral name.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcidtolocalename#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns the count of characters, including the terminating null character, in the locale name if successful. If the function succeeds and the value of <i>cchName</i> is 0, the return value is the required size, in characters (including nulls), for the locale name buffer.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcidtolocalename">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int LCIDToLocaleName(uint Locale, win32.System.SystemServices.PWSTR lpName, int cchName, uint dwFlags);
        /// <inheritdoc cref = "GetDurationFormat(uint, uint, win32.System.WindowsProgramming.SYSTEMTIME*, ulong, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int GetDurationFormat(uint Locale, uint dwFlags, win32.System.WindowsProgramming.SYSTEMTIME? lpDuration, ulong ullDuration, string lpFormat, win32.System.SystemServices.PWSTR lpDurationStr, int cchDuration)
        {
            fixed (char *lpFormatLocal = lpFormat)
            {
                win32.System.WindowsProgramming.SYSTEMTIME lpDurationLocal = lpDuration.HasValue ? lpDuration.Value : default(win32.System.WindowsProgramming.SYSTEMTIME);
                int __result = Kernel32.GetDurationFormat(Locale, dwFlags, lpDuration.HasValue ? &lpDurationLocal : null, ullDuration, lpFormatLocal, lpDurationStr, cchDuration);
                return __result;
            }
        }

        /// <summary>Formats a duration of time as a time string for a locale specified by identifier.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which this function formats the duration. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformat#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Flags specifying function options. If <i>lpFormat</i> is not set to <b>NULL</b>, this parameter must be set to 0. If <i>lpFormat</i> is set to <b>NULL</b>, your application can specify <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default duration format for the specified locale.</para>
        /// <para><div class = "alert"><b>Caution</b>  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformat#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDuration">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time duration information to format. If this pointer is <b>NULL</b>, the function ignores this parameter and uses <i>ullDuration</i>.</param>
        /// <param name = "ullDuration">64-bit unsigned integer that represents the number of 100-nanosecond intervals in the duration. If both <i>lpDuration</i> and <i>ullDuration</i> are present, <i>lpDuration</i> takes precedence. If <i>lpDuration</i> is set to <b>NULL</b> and <i>ullDuration</i> is set to 0, the duration is zero.</param>
        /// <param name = "lpFormat">Pointer to the format string. For details, see the <i>lpFormat</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getdurationformatex">GetDurationFormatEx</a>.</param>
        /// <param name = "lpDurationStr">
        /// <para>Pointer to the buffer in which the function retrieves the duration string.</para>
        /// <para>Alternatively, this parameter can contain <b>NULL</b> if <i>cchDuration</i> is set to 0. In this case, the function returns the required size for the duration string buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformat#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchDuration">
        /// <para>Size, in characters, of the buffer indicated by <i>lpDurationStr</i>.</para>
        /// <para>Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpDurationStr</i> and returns the required size for the duration string buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformat#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in the buffer indicated by <i>lpDurationStr</i> if successful. If <i>lpDurationStr</i> is set to <b>NULL</b> and <i>cchDuration</i> is set to 0, the function returns the required size for the duration string buffer, including the null terminating character. For example, if 10 characters are written to the buffer, the function returns 11 to include the terminating null character.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformat">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int GetDurationFormat(uint Locale, uint dwFlags, [Optional] win32.System.WindowsProgramming.SYSTEMTIME*lpDuration, ulong ullDuration, win32.System.SystemServices.PCWSTR lpFormat, win32.System.SystemServices.PWSTR lpDurationStr, int cchDuration);
        /// <inheritdoc cref = "GetNumberFormat(uint, uint, win32.System.SystemServices.PCWSTR, win32.Globalization.NUMBERFMTW*, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int GetNumberFormat(uint Locale, uint dwFlags, string lpValue, win32.Globalization.NUMBERFMTW? lpFormat, win32.System.SystemServices.PWSTR lpNumberStr, int cchNumber)
        {
            fixed (char *lpValueLocal = lpValue)
            {
                win32.Globalization.NUMBERFMTW lpFormatLocal = lpFormat.HasValue ? lpFormat.Value : default(win32.Globalization.NUMBERFMTW);
                int __result = Kernel32.GetNumberFormat(Locale, dwFlags, lpValueLocal, lpFormat.HasValue ? &lpFormatLocal : null, lpNumberStr, cchNumber);
                return __result;
            }
        }

        /// <summary>Formats a number string as a number string customized for a locale specified by identifier.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnumberformatw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default number format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default number format for the specified locale.</para>
        /// <para><div class = "alert"><b>Caution</b>  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnumberformatw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpValue">
        /// <para>Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by <i>lpValue</i> deviates from these rules.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnumberformatw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFormat">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-numberfmta">NUMBERFMT</a> structure that contains number formatting information, with all members set to appropriate values. If this parameter does is not set to <b>NULL</b>, the function uses the locale only for formatting information not specified in the structure, for example, the locale-specific string value for the negative sign.</param>
        /// <param name = "lpNumberStr">Pointer to a buffer in which this function retrieves the formatted number string.</param>
        /// <param name = "cchNumber">Size, in TCHAR values, for the number string buffer indicated by <i>lpNumberStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer, and does not use the <i>lpNumberStr</i> parameter.</param>
        /// <returns>
        /// <para>Returns the number of TCHAR values retrieved in the buffer indicated by <i>lpNumberStr</i> if successful. If the <i>cchNumber</i> parameter is set to 0, the function returns the number of characters required to hold the formatted number string, including a terminating null character.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnumberformatw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetNumberFormatW", SetLastError = true)]
        internal static extern unsafe int GetNumberFormat(uint Locale, uint dwFlags, win32.System.SystemServices.PCWSTR lpValue, [Optional] win32.Globalization.NUMBERFMTW*lpFormat, win32.System.SystemServices.PWSTR lpNumberStr, int cchNumber);
        /// <inheritdoc cref = "GetCurrencyFormat(uint, uint, win32.System.SystemServices.PCWSTR, win32.Globalization.CURRENCYFMTW*, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int GetCurrencyFormat(uint Locale, uint dwFlags, string lpValue, win32.Globalization.CURRENCYFMTW? lpFormat, win32.System.SystemServices.PWSTR lpCurrencyStr, int cchCurrency)
        {
            fixed (char *lpValueLocal = lpValue)
            {
                win32.Globalization.CURRENCYFMTW lpFormatLocal = lpFormat.HasValue ? lpFormat.Value : default(win32.Globalization.CURRENCYFMTW);
                int __result = Kernel32.GetCurrencyFormat(Locale, dwFlags, lpValueLocal, lpFormat.HasValue ? &lpFormatLocal : null, lpCurrencyStr, cchCurrency);
                return __result;
            }
        }

        /// <summary>Formats a number string as a currency string for a locale specified by identifier.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which this function formats the currency string. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcurrencyformatw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Flags controlling currency format. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default currency format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default currency format for the specified locale.</para>
        /// <para><div class = "alert"><b>Caution</b>  Use of <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> is strongly discouraged as it disables user preferences.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcurrencyformatw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpValue">For details, see the <i>lpValue</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcurrencyformatex">GetCurrencyFormatEx</a>.</param>
        /// <param name = "lpFormat">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to <b>NULL</b> if function is to use the currency format of the specified locale. If this parameter is not set to <b>NULL</b>, the function uses the specified locale only for formatting information not specified in the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure, for example, the string value for the negative sign used by the locale.</param>
        /// <param name = "lpCurrencyStr">Pointer to a buffer in which this function retrieves the formatted currency string.</param>
        /// <param name = "cchCurrency">Size, in characters, of the <i>lpCurrencyStr</i> buffer. The application sets this parameter to 0 if the function is to return the size of the buffer required to hold the formatted currency string. In this case, the <i>lpCurrencyStr</i> parameter is not used.</param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in the buffer indicated by <i>lpCurrencyStr</i> if successful. If the <i>cchCurrency</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted currency string, including a terminating null character.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcurrencyformatw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetCurrencyFormatW", SetLastError = true)]
        internal static extern unsafe int GetCurrencyFormat(uint Locale, uint dwFlags, win32.System.SystemServices.PCWSTR lpValue, [Optional] win32.Globalization.CURRENCYFMTW*lpFormat, win32.System.SystemServices.PWSTR lpCurrencyStr, int cchCurrency);
        /// <summary>Enumerates calendar information for a specified locale.Note  To receive a calendar identifier in addition to calendar information, the application should use the EnumCalendarInfoEx function.</summary>
        /// <param name = "lpCalInfoEnumProc">Pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317806(v=vs.85)">EnumCalendarInfoProc</a>.</param>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumcalendarinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Calendar"><a href = "https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.</param>
        /// <param name = "CalType">Type of calendar information. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumcalendarinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumCalendarInfoW", SetLastError = true)]
        internal static extern unsafe bool EnumCalendarInfo(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, win32.System.SystemServices.BOOL>lpCalInfoEnumProc, uint Locale, uint Calendar, uint CalType);
        /// <summary>Enumerates calendar information for a locale specified by identifier.Note  Any application that runs only on Windows Vista and later should use EnumCalendarInfoExEx in preference to this function.</summary>
        /// <param name = "lpCalInfoEnumProcEx">Pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317807(v=vs.85)">EnumCalendarInfoProcEx</a>.</param>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumcalendarinfoexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Calendar"><a href = "https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.</param>
        /// <param name = "CalType">Type of calendar information. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumcalendarinfoexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumCalendarInfoExW", SetLastError = true)]
        internal static extern unsafe bool EnumCalendarInfoEx(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, uint, win32.System.SystemServices.BOOL>lpCalInfoEnumProcEx, uint Locale, uint Calendar, uint CalType);
        /// <summary>Enumerates the time formats that are available for a locale specified by identifier.Note  For interoperability reasons, the application should prefer the EnumTimeFormatsEx function to EnumTimeFormats because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that runs only on Windows Vista and later should use EnumTimeFormatsEx.</summary>
        /// <param name = "lpTimeFmtEnumProc">Pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317832(v=vs.85)">EnumTimeFormatsProc</a>.</param>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve time format information. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumtimeformatsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumtimeformatsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumTimeFormatsW", SetLastError = true)]
        internal static extern unsafe bool EnumTimeFormats(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, win32.System.SystemServices.BOOL>lpTimeFmtEnumProc, uint Locale, win32.Globalization.TIME_FORMAT_FLAGS dwFlags);
        /// <summary>Enumerates the long date, short date, or year/month formats that are available for a specified locale.</summary>
        /// <param name = "lpDateFmtEnumProc">Pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317813(v=vs.85)">EnumDateFormatsProc</a>.</param>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumdateformatsw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumdateformatsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumDateFormatsW", SetLastError = true)]
        internal static extern unsafe bool EnumDateFormats(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, win32.System.SystemServices.BOOL>lpDateFmtEnumProc, uint Locale, uint dwFlags);
        /// <summary>Enumerates the long date, short date, or year/month formats that are available for a specified locale.Note  Any application that runs only on Windows Vista and later should use EnumDateFormatsExEx in preference to this function.</summary>
        /// <param name = "lpDateFmtEnumProcEx">Pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317814(v=vs.85)">EnumDateFormatsProcEx</a>.</param>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumdateformatsexw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumdateformatsexw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumDateFormatsExW", SetLastError = true)]
        internal static extern unsafe bool EnumDateFormatsEx(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, uint, win32.System.SystemServices.BOOL>lpDateFmtEnumProcEx, uint Locale, uint dwFlags);
        /// <summary>Determines if a language group is installed or supported on the operating system. For more information, see NLS Terminology.</summary>
        /// <param name = "LanguageGroup"></param>
        /// <param name = "dwFlags"></param>
        /// <returns>Returns <b>TRUE</b> if the language group identifier passes the specified validity test, or <b>FALSE</b> otherwise.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidlanguagegroup">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool IsValidLanguageGroup(uint LanguageGroup, win32.Globalization.ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS dwFlags);
        /// <inheritdoc cref = "GetNLSVersion(uint, uint, win32.Globalization.NLSVERSIONINFO*)"/>
        internal static unsafe bool GetNLSVersion(uint Function, uint Locale, ref win32.Globalization.NLSVERSIONINFO lpVersionInformation)
        {
            fixed (win32.Globalization.NLSVERSIONINFO*lpVersionInformationLocal = &lpVersionInformation)
            {
                bool __result = Kernel32.GetNLSVersion(Function, Locale, lpVersionInformationLocal);
                return __result;
            }
        }

        /// <summary>Retrieves information about the current version of a specified NLS capability for a locale specified by identifier.Note  For interoperability reasons, the application should prefer the GetNLSVersionEx function to GetNLSVersion because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. This recommendation applies especially to custom locales, for which GetNLSVersionEx retrieves enough information to determine if sort behavior has changed. Any application that runs only on Windows Vista and later should use GetNLSVersionEx or at least pass the NLSVERSIONINFOEX structure when calling GetNLSVersion to obtain additional sorting versioning data.</summary>
        /// <param name = "Function">The NLS capability to query. This value must be COMPARE_STRING. See the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.</param>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnlsversion#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpVersionInformation">
        /// <para>Pointer to an <a href = "https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c>sizeof(NLSVERSIONINFO)</c>.</para>
        /// <para><div class = "alert"><b>Note</b>  On Windows Vista and later, the function can alternatively provide version information in an <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnlsversion#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if and only if the application has supplied valid values in <i>lpVersionInformation</i>, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnlsversion">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNLSVersion(uint Function, uint Locale, win32.Globalization.NLSVERSIONINFO*lpVersionInformation);
        /// <summary>Determines if the specified locale is installed or supported on the operating system. For more information, see Locales and Languages.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale to validate. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidlocale#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <returns>Returns a nonzero value if the locale identifier passes the specified validity test. The function returns 0 if it does not succeed.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidlocale">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool IsValidLocale(uint Locale, win32.Globalization.IS_VALID_LOCALE_FLAGS dwFlags);
        /// <summary>Retrieves information about a specified geographical location.</summary>
        /// <param name = "Location">Identifier for the geographical location for which to get information. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Intl/table-of-geographical-locations">Table of Geographical Locations</a>. You can obtain the available values by calling <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeoid">EnumSystemGeoID</a>.</param>
        /// <param name = "GeoType">
        /// <para>Type of information to retrieve. Possible values are defined by the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeotype">SYSGEOTYPE</a> enumeration. If the value of <i>GeoType</i> is GEO_LCID, the function retrieves a locale identifier. If the value of <i>GeoType</i> is GEO_RFC1766, the function retrieves a string name that is compliant with RFC 4646 (Windows Vista). For more information, see the Remarks section.</para>
        /// <para><b>Windows XP:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is an 8-digit hexadecimal value.</para>
        /// <para><b>Windows Me:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is a decimal value.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getgeoinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpGeoData">Pointer to the buffer in which this function retrieves the information.</param>
        /// <param name = "cchData">Size of the buffer indicated by <i>lpGeoData</i>. The size is the number of bytes for the ANSI version of the function, or the number of words for the Unicode version. The application can set this parameter to 0 if the function is to return the required size of the buffer.</param>
        /// <param name = "LangId">
        /// <para>Identifier for the language, used with the value of <i>Location</i>. The application can set this parameter to 0, with GEO_RFC1766 or GEO_LCID specified for <i>GeoType</i>. This setting causes the function to retrieve the language identifier by calling <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserdefaultlangid">GetUserDefaultLangID</a>.</para>
        /// <para><div class = "alert"><b>Note</b>   The application must set this parameter to 0 if <i>GeoType</i> has any value other than GEO_RFC1766 or GEO_LCID.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getgeoinfow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns the number of bytes (ANSI) or words (Unicode) of geographical location information retrieved in the output buffer. If <i>cchData</i> is set to 0, the function returns the required size for the buffer.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getgeoinfow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "GetGeoInfoW", SetLastError = true)]
        internal static extern int GetGeoInfo(int Location, uint GeoType, win32.System.SystemServices.PWSTR lpGeoData, int cchData, ushort LangId);
        /// <summary>Retrieves information about a geographic location that you specify by using a two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code.</summary>
        /// <param name = "location">The two-letter ISO 3166-1 or numeric UN M.49 code for the geographic location for which to get information.  To get the codes that are available on the operating system, call <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeonames">EnumSystemGeoNames</a>.</param>
        /// <param name = "geoType">
        /// <para>The type of information you want to retrieve. Possible values are defined by the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeotype">SYSGEOTYPE</a> enumeration. The following values of the <b>SYSGEOTYPE</b> enumeration should not be used with <b>GetGeoInfoEx</b>:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getgeoinfoex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "geoData">A pointer to the buffer in which <b>GetGeoInfoEx</b> should write the  requested information.</param>
        /// <param name = "geoDataCount">The size of the buffer to which the <i>GeoData</i> parameter points, in characters. Set this parameter to 0 to specify that the function should only return the size of the buffer required to store the requested information without writing the requested information to the buffer.</param>
        /// <returns>
        /// <para>The number of bytes of geographical location information that the function wrote the output buffer. If <i>geoDataCount</i> is  0, the function returns the size of the buffer required to hold the information without writing the information to the buffer.</para>
        /// <para>0 indicates that the function did not succeed. To get extended error information,  call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getgeoinfoex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetGeoInfoEx(win32.System.SystemServices.PWSTR location, uint geoType, win32.System.SystemServices.PWSTR geoData, int geoDataCount);
        /// <summary>Enumerates the geographical location identifiers (type GEOID) that are available on the operating system.</summary>
        /// <param name = "GeoClass">Geographical location class for which to enumerate the identifiers. At present, only GEOCLASS_NATION is supported. This type causes the function to enumerate all geographical identifiers for nations on the operating system.</param>
        /// <param name = "ParentGeoId">Reserved. This parameter must be 0.</param>
        /// <param name = "lpGeoEnumProc">Pointer to the application-defined callback function <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317817(v=vs.85)">EnumGeoInfoProc</a>. The <b>EnumSystemGeoID</b> function makes repeated calls to this callback function until it returns <b>FALSE</b>.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemgeoid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool EnumSystemGeoID(uint GeoClass, int ParentGeoId, delegate *unmanaged[Stdcall]<int, win32.System.SystemServices.BOOL>lpGeoEnumProc);
        /// <summary>Enumerates the two-letter International Organization for Standardization (ISO) 3166-1 codes or numeric United Nations (UN) Series M, Number 49 (M.49) codes for geographical locations that are available on the operating system.</summary>
        /// <param name = "geoClass">The geographical location class for which to enumerate the available two-letter ISO 3166-1 or numeric UN M.49 codes.</param>
        /// <param name = "geoEnumProc">Pointer to the application-defined callback function <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-geo_enumnameproc">Geo_EnumNameProc</a>. The <b>EnumSystemGeoNames</b> function calls this callback function for each of the two-letter ISO 3166-1 or numeric UN M.49 codes for geographical locations that are available on the operating system until callback function returns <b>FALSE</b>.</param>
        /// <param name = "data">Application-specific information to pass to the callback function that the <i>genEnumProc</i> parameter specifies.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemgeonames">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool EnumSystemGeoNames(uint geoClass, delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>geoEnumProc, win32.UI.WindowsAndMessaging.LPARAM data);
        /// <summary>Retrieves information about the geographical location of the user. For more information, see Table of Geographical Locations.</summary>
        /// <param name = "GeoClass">Geographical location class to return. Possible values are defined by the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeoclass">SYSGEOCLASS</a> enumeration.</param>
        /// <returns>
        /// <para>Returns the geographical location identifier of the user if <a href = "/windows/desktop/api/winnls/nf-winnls-setusergeoid">SetUserGeoID</a> has been called before to set the identifier.</para>
        /// <para>If no geographical location identifier has been set for the user, the function returns GEOID_NOT_AVAILABLE.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getusergeoid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern int GetUserGeoID(uint GeoClass);
        /// <summary>Retrieves the two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code for the default geographical location of the user.</summary>
        /// <param name = "geoName">Pointer to a buffer in which this function should write the null-terminated two-letter ISO 3166-1 or numeric UN M.49 code for the default geographic location of the user.</param>
        /// <param name = "geoNameCount">The size of the buffer that the <i>geoName</i> parameter specifies. If this value is zero, the function only returns the number of characters that function would copy to the output buffer, but does not write the name of the default geographic location of the user to the buffer.</param>
        /// <returns>
        /// <para>The number of characters the function  would copy to the output buffer, if the value of the <i>geoNameCount</i> parameter is zero. Otherwise, the  number of characters that the function copied to the buffer that the <i>geoName</i> parameter specifies.</para>
        /// <para>Zero indicates that the function failed. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserdefaultgeoname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetUserDefaultGeoName(win32.System.SystemServices.PWSTR geoName, int geoNameCount);
        /// <summary>Sets the geographical location identifier for the user. This identifier should have one of the values described in Table of Geographical Locations.</summary>
        /// <param name = "GeoId">Identifier for the geographical location of the user.</param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise.</para>
        /// <para><b>Windows XP, Windows Server 2003</b>: This function does not supply extended error information. Thus it is not appropriate for an application to call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> after this function. If the application does call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, it can return a value set by some previously called function.</para>
        /// <para>If this function does not succeed, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setusergeoid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetUserGeoID(int GeoId);
        /// <summary>Sets the geographic location for the current user to the specified two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code.</summary>
        /// <param name = "geoName">The two-letter ISO 3166-1 or numeric UN M.49 code for the geographic location to set for the current user. To get the codes that are available on the operating system, call <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeonames">EnumSystemGeoNames</a>.</param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise.</para>
        /// <para>If this function does not succeed, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setusergeoname">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool SetUserGeoName(win32.System.SystemServices.PWSTR geoName);
        /// <summary>Converts a default locale value to an actual locale identifier.</summary>
        /// <param name = "Locale">
        /// <para>Default locale identifier value to convert. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-convertdefaultlocale#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns the appropriate locale identifier if successful.</para>
        /// <para>This function returns the value of the <i>Locale</i> parameter if it does not succeed. The function fails when the <i>Locale</i> value is not one of the default values listed above.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-convertdefaultlocale">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint ConvertDefaultLocale(uint Locale);
        /// <summary>Retrieves the language identifier for the system default UI language of the operating system, also known as the &quot;install language&quot; on Windows Vista and later. For more information, see User Interface Language Management.</summary>
        /// <returns>Returns the language identifier for the system default UI language of the operating system. For more information, see the Remarks section.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystemdefaultuilanguage">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern ushort GetSystemDefaultUILanguage();
        /// <summary>Returns the locale identifier of the current locale for the calling thread.Note  This function can retrieve data that changes between releases, for example, due to a custom locale.</summary>
        /// <returns>
        /// <para>Returns the <a href = "/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale associated with the current thread.</para>
        /// <para><b>Windows Vista</b>: This function can return the identifier of a <a href = "/windows/desktop/Intl/custom-locales">custom locale</a>. If the current thread locale is a custom locale, the function returns <a href = "/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>. If the current thread locale is a supplemental custom locale, the function can return <a href = "/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>. All supplemental locales share this locale identifier.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getthreadlocale">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetThreadLocale();
        /// <summary>Sets the current locale of the calling thread.</summary>
        /// <param name = "Locale">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href = "https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setthreadlocale#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>The function should return an LCID on success. This is the LCID of the previous thread locale.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setthreadlocale">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool SetThreadLocale(uint Locale);
        /// <summary>Returns the language identifier for the user UI language for the current user.</summary>
        /// <returns>Returns the <a href = "/windows/desktop/Intl/language-identifiers">language identifier</a> for the user UI language for the current user.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserdefaultuilanguage">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern ushort GetUserDefaultUILanguage();
        /// <summary>Returns the language identifier of the Region Format setting for the current user.</summary>
        /// <returns>
        /// <para>Returns the <a href = "/windows/desktop/Intl/language-identifiers">language identifier</a> for the current user as set under <b>Control Panel</b> &gt; <b>Clock, Language, and Region</b> &gt; <b>Change date, time, or number formats</b> &gt; <b>Formats</b> tab &gt; <b>Format</b> dropdown.</para>
        /// <para>For more information on language identifiers, see <a href = "/windows/desktop/Intl/language-identifier-constants-and-strings">Language Identifier Constants and Strings</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserdefaultlangid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern ushort GetUserDefaultLangID();
        /// <summary>Returns the language identifier for the system locale.</summary>
        /// <returns>
        /// <para>Returns the <a href = "/windows/desktop/Intl/language-identifiers">language identifier</a> for the system locale. This is  the language used when displaying text in programs that do not support Unicode. It is set by the Administrator under <b>Control Panel</b> &gt; <b>Clock, Language, and Region</b> &gt; <b>Change date, time, or number formats</b> &gt; <b>Administrative</b> tab.</para>
        /// <para>For more information on language identifiers, see <a href = "/windows/desktop/Intl/language-identifier-constants-and-strings">Language Identifier Constants and Strings</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystemdefaultlangid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern ushort GetSystemDefaultLangID();
        /// <summary>Returns the locale identifier for the system locale.Note  Any application that runs only on Windows Vista and later should use GetSystemDefaultLocaleName in preference to this function.</summary>
        /// <returns>Returns the locale identifier for the system default locale, identified by <a href = "/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystemdefaultlcid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetSystemDefaultLCID();
        /// <summary>Returns the locale identifier for the user default locale.Caution  If the user default locale is a custom locale, an application cannot accurately tag data with the value or exchange it.</summary>
        /// <returns>Returns the locale identifier for the user default locale, represented as <a href = "/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>. If the user default locale is a custom locale, this function always returns <a href = "/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>, regardless of the custom locale that is selected. For example, whether the user locale is Hawaiian (US), haw-US, or Fijiian (Fiji), fj-FJ, the function returns the same value.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserdefaultlcid">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern uint GetUserDefaultLCID();
        /// <summary>Sets the user interface language for the current thread.</summary>
        /// <param name = "LangId">
        /// <para><a href = "https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">Language identifier</a> for the user interface language for the thread.</para>
        /// <para><b>Windows Vista and later:</b> The application can specify a language identifier of 0 or a nonzero identifier. For more information, see the Remarks section.</para>
        /// <para><b>Windows XP:</b> The application can only set this parameter to 0. This setting causes the function to select the language that best supports the console display. For more information, see the Remarks section.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setthreaduilanguage#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns the input language identifier if successful. If the input identifier is nonzero, the function returns that value. If the language identifier is 0, the function always succeeds and returns the identifier of the language that best supports the Windows console. See the Remarks section.</para>
        /// <para>If the input language identifier is nonzero and the function fails, the return value differs from the input language identifier. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setthreaduilanguage">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern ushort SetThreadUILanguage(ushort LangId);
        /// <summary>Returns the language identifier of the first user interface language for the current thread.</summary>
        /// <returns>Returns the identifier for a language explicitly associated with the thread by <a href = "/windows/desktop/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage</a> or <a href = "/windows/desktop/api/winnls/nf-winnls-setthreadpreferreduilanguages">SetThreadPreferredUILanguages</a>. Alternatively, if no language has been explicitly associated with the current thread, the identifier can indicate a user or system user interface language.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getthreaduilanguage">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern ushort GetThreadUILanguage();
        /// <inheritdoc cref = "GetProcessPreferredUILanguages(uint, uint *, win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe bool GetProcessPreferredUILanguages(uint dwFlags, out uint pulNumLanguages, win32.System.SystemServices.PWSTR pwszLanguagesBuffer, ref uint pcchLanguagesBuffer)
        {
            fixed (uint *pcchLanguagesBufferLocal = &pcchLanguagesBuffer)
            {
                fixed (uint *pulNumLanguagesLocal = &pulNumLanguages)
                {
                    bool __result = Kernel32.GetProcessPreferredUILanguages(dwFlags, pulNumLanguagesLocal, pwszLanguagesBuffer, pcchLanguagesBufferLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves the process preferred UI languages. For more information, see User Interface Language Management.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags identifying the language format to use for the process preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getprocesspreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pulNumLanguages">Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.</param>
        /// <param name = "pwszLanguagesBuffer">
        /// <para>Optional. Pointer to a double null-terminated multi-string buffer in which the function retrieves an ordered, null-delimited list in preference order, starting with the most preferable.</para>
        /// <para>Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getprocesspreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcchLanguagesBuffer">
        /// <para>Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.</para>
        /// <para>Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getprocesspreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getprocesspreferreduilanguages">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetProcessPreferredUILanguages(uint dwFlags, uint *pulNumLanguages, win32.System.SystemServices.PWSTR pwszLanguagesBuffer, uint *pcchLanguagesBuffer);
        /// <inheritdoc cref = "SetProcessPreferredUILanguages(uint, win32.System.SystemServices.PCWSTR, uint *)"/>
        internal static unsafe bool SetProcessPreferredUILanguages(uint dwFlags, string pwszLanguagesBuffer, uint *pulNumLanguages)
        {
            fixed (char *pwszLanguagesBufferLocal = pwszLanguagesBuffer)
            {
                bool __result = Kernel32.SetProcessPreferredUILanguages(dwFlags, pwszLanguagesBufferLocal, pulNumLanguages);
                return __result;
            }
        }

        /// <summary>Sets the process preferred UI languages for the application process. For more information, see User Interface Language Management.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags identifying the language format to use for the process preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.</para>
        /// <para>We recommend that you use MUI_LANGUAGE_NAME instead of MUI_LANGUAGE_ID.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setprocesspreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pwszLanguagesBuffer">
        /// <para>Pointer to a double null-terminated multi-string buffer that contains an ordered, null-delimited list in decreasing order of preference. If there are more than five languages in the buffer, the function only sets the first five valid languages.</para>
        /// <para>Alternatively, this parameter can contain <b>NULL</b> if no language list is required. In this case, the function clears the preferred UI languages for the process.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setprocesspreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pulNumLanguages">Pointer to the number of languages that has been set in the process language list from the input buffer, up to a maximum of five.</param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error code:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setprocesspreferreduilanguages">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool SetProcessPreferredUILanguages(uint dwFlags, win32.System.SystemServices.PCWSTR pwszLanguagesBuffer, [Optional] uint *pulNumLanguages);
        /// <inheritdoc cref = "GetUserPreferredUILanguages(uint, uint *, win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe bool GetUserPreferredUILanguages(uint dwFlags, out uint pulNumLanguages, win32.System.SystemServices.PWSTR pwszLanguagesBuffer, ref uint pcchLanguagesBuffer)
        {
            fixed (uint *pcchLanguagesBufferLocal = &pcchLanguagesBuffer)
            {
                fixed (uint *pulNumLanguagesLocal = &pulNumLanguages)
                {
                    bool __result = Kernel32.GetUserPreferredUILanguages(dwFlags, pulNumLanguagesLocal, pwszLanguagesBuffer, pcchLanguagesBufferLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves information about the user preferred UI languages. For more information, see User Interface Language Management.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags identifying language format and filtering. The following flags specify the language format to use for the display language list. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.</para>
        /// <para>| Value | Meaning | | --- | --- | | **MUI_LANGUAGE_ID** | Retrieve the language strings in [language identifier](/windows/desktop/Intl/language-identifiers) | | **MUI_LANGUAGE_NAME** | Retrieve the language strings in [language name](/windows/desktop/Intl/language-names) format. |</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserpreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pulNumLanguages">Pointer to the number of languages retrieved in *pwszLanguagesBuffer*.</param>
        /// <param name = "pwszLanguagesBuffer">
        /// <para>Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited display language list, in the format specified by *dwflags*. This list ends with two null characters.</para>
        /// <para>Alternatively if this parameter is set to **NULL** and *pcchLanguagesBuffer* is set to 0, the function retrieves the required size of the language buffer in *pcchLanguagesBuffer*. The required size includes the two null characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserpreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcchLanguagesBuffer">
        /// <para>Pointer to the size, in characters, for the language buffer indicated by *pwszLanguagesBuffer*. On successful return from the function, the parameter contains the size of the retrieved language buffer.</para>
        /// <para>Alternatively if this parameter is set to 0 and *pwszLanguagesBuffer* is set to **NULL**, the function retrieves the required size of the language buffer in *pcchLanguagesBuffer*.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserpreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [GetLastError function](../errhandlingapi/nf-errhandlingapi-getlasterror.md), which can return one of the following error codes:</para>
        /// <para>- ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to **NULL**.</para>
        /// <para>If the function fails for any other reason, the values of *pulNumLanguages* and *pcchLanguagesBuffer* are undefined.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserpreferreduilanguages">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetUserPreferredUILanguages(uint dwFlags, uint *pulNumLanguages, win32.System.SystemServices.PWSTR pwszLanguagesBuffer, uint *pcchLanguagesBuffer);
        /// <inheritdoc cref = "GetSystemPreferredUILanguages(uint, uint *, win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe bool GetSystemPreferredUILanguages(uint dwFlags, out uint pulNumLanguages, win32.System.SystemServices.PWSTR pwszLanguagesBuffer, ref uint pcchLanguagesBuffer)
        {
            fixed (uint *pcchLanguagesBufferLocal = &pcchLanguagesBuffer)
            {
                fixed (uint *pulNumLanguagesLocal = &pulNumLanguages)
                {
                    bool __result = Kernel32.GetSystemPreferredUILanguages(dwFlags, pulNumLanguagesLocal, pwszLanguagesBuffer, pcchLanguagesBufferLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves the system preferred UI languages. For more information, see User Interface Language Management.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags identifying language format and filtering. The following flags specify the format to use for the system preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystempreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pulNumLanguages">Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.</param>
        /// <param name = "pwszLanguagesBuffer">
        /// <para>Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited system preferred UI languages list, in the format specified by <i>dwFlags</i>. This list ends with two null characters.</para>
        /// <para>Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystempreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcchLanguagesBuffer">
        /// <para>Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.</para>
        /// <para>Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystempreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes: </para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystempreferreduilanguages">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetSystemPreferredUILanguages(uint dwFlags, uint *pulNumLanguages, win32.System.SystemServices.PWSTR pwszLanguagesBuffer, uint *pcchLanguagesBuffer);
        /// <inheritdoc cref = "GetThreadPreferredUILanguages(uint, uint *, win32.System.SystemServices.PWSTR, uint *)"/>
        internal static unsafe bool GetThreadPreferredUILanguages(uint dwFlags, out uint pulNumLanguages, win32.System.SystemServices.PWSTR pwszLanguagesBuffer, ref uint pcchLanguagesBuffer)
        {
            fixed (uint *pcchLanguagesBufferLocal = &pcchLanguagesBuffer)
            {
                fixed (uint *pulNumLanguagesLocal = &pulNumLanguages)
                {
                    bool __result = Kernel32.GetThreadPreferredUILanguages(dwFlags, pulNumLanguagesLocal, pwszLanguagesBuffer, pcchLanguagesBufferLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves the thread preferred UI languages for the current thread. For more information, see User Interface Language Management.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags identifying language format and filtering. The following flags specify the language format to use for the thread preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getthreadpreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pulNumLanguages">Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.</param>
        /// <param name = "pwszLanguagesBuffer">
        /// <para>Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited thread preferred UI languages list, in the format specified by <i>dwFlags</i>. This list ends with two null characters.</para>
        /// <para>Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getthreadpreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcchLanguagesBuffer">
        /// <para>Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.</para>
        /// <para>Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getthreadpreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns one of the following error codes: </para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getthreadpreferreduilanguages">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetThreadPreferredUILanguages(uint dwFlags, uint *pulNumLanguages, win32.System.SystemServices.PWSTR pwszLanguagesBuffer, uint *pcchLanguagesBuffer);
        /// <inheritdoc cref = "SetThreadPreferredUILanguages(uint, win32.System.SystemServices.PCWSTR, uint *)"/>
        internal static unsafe bool SetThreadPreferredUILanguages(uint dwFlags, string pwszLanguagesBuffer, uint *pulNumLanguages)
        {
            fixed (char *pwszLanguagesBufferLocal = pwszLanguagesBuffer)
            {
                bool __result = Kernel32.SetThreadPreferredUILanguages(dwFlags, pwszLanguagesBufferLocal, pulNumLanguages);
                return __result;
            }
        }

        /// <summary>Sets the thread preferred UI languages for the current thread. For more information, see User Interface Language Management.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags identifying format and filtering for the languages to set.</para>
        /// <para>The following <i>format flags</i> specify the language format to use for the thread preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.</para>
        /// <para>We recommend that you use MUI_LANGUAGE_NAME instead of MUI_LANGUAGE_ID.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setthreadpreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pwszLanguagesBuffer">
        /// <para>Pointer to a double null-terminated multi-string buffer that contains an ordered, null-delimited list, in the format specified by <i>dwFlags</i>.</para>
        /// <para>To clear the thread preferred UI languages list, an application sets this parameter to a null string or an empty double null-terminated string. If an application clears a language list, it should specify either a format flag or 0 for the <i>dwFlags</i> parameter.</para>
        /// <para>When the application specifies one of the filtering flags, it must set this parameter to <b>NULL</b>. In this case, the function succeeds, but does not reset the thread preferred languages.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setthreadpreferreduilanguages#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pulNumLanguages">Pointer to the number of languages that the function has set in the thread preferred UI languages list. When the application specifies one of the filtering flags, the function must set this parameter to <b>NULL</b>.</param>
        /// <returns>Returns <b>TRUE</b> if the function succeeds or <b>FALSE</b> otherwise.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setthreadpreferreduilanguages">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetThreadPreferredUILanguages(uint dwFlags, win32.System.SystemServices.PCWSTR pwszLanguagesBuffer, [Optional] uint *pulNumLanguages);
        /// <inheritdoc cref = "GetFileMUIInfo(uint, win32.System.SystemServices.PCWSTR, win32.Globalization.FILEMUIINFO*, uint *)"/>
        internal static unsafe bool GetFileMUIInfo(uint dwFlags, string pcwszFilePath, win32.Globalization.FILEMUIINFO*pFileMUIInfo, ref uint pcbFileMUIInfo)
        {
            fixed (uint *pcbFileMUIInfoLocal = &pcbFileMUIInfo)
            {
                fixed (char *pcwszFilePathLocal = pcwszFilePath)
                {
                    bool __result = Kernel32.GetFileMUIInfo(dwFlags, pcwszFilePathLocal, pFileMUIInfo, pcbFileMUIInfoLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves resource-related information about a file.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags specifying the information to retrieve. Any combination of the following flags is allowed. The default value of the flags is MUI_QUERY_TYPE | MUI_QUERY_CHECKSUM.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getfilemuiinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcwszFilePath">Pointer to a null-terminated string indicating the path to the file. Typically the file is either an LN file or a language-specific resource file. If it is not one of these types, the only significant value that the function retrieves is MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL. The function only retrieves this value if the MUI_QUERY_RESOURCE_TYPES flag is set.</param>
        /// <param name = "pFileMUIInfo">
        /// <para>Pointer to a buffer containing file information in a <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure and possibly in data following that structure. The information buffer might have to be much larger than the size of the structure itself. Depending on flag settings, the function can store considerable information following the structure, at offsets retrieved in the structure. For more information, see the Remarks section.</para>
        /// <para>Alternatively, the application can set this parameter to <b>NULL</b> if <i>pcbFileMUIInfo</i> is set to 0. In this case, the function retrieves the required size for the information buffer in <i>pcbFileMUIInfo</i>.</para>
        /// <para><div class = "alert"><b>Note</b>  If the value of <i>pFileMUIInfo</i> is not <b>NULL</b>, the <b>dwSize</b> member must be set to the size of the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure (including the information buffer), and the <b>dwVersion</b> member must be set to the current version of 0x001.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getfilemuiinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcbFileMUIInfo">
        /// <para>Pointer to the buffer size, in bytes, for the file information indicated by <i>pFileMUIInfo</i>. On successful return from the function, this parameter contains the size of the retrieved file information buffer and the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure that contains it.</para>
        /// <para>Alternatively, the application can set this parameter to 0 if it sets <b>NULL</b> in <i>pFileMUIInfo</i>. In this case, the function retrieves the required file information buffer size in <i>pcbFileMUIInfo</i>. To allocate the correct amount of memory, this value should be added to the size of the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure itself.</para>
        /// <para><div class = "alert"><b>Note</b>  The value of this parameter must match the value of the <b>dwSize</b> member of <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> if the value of <i>pFileMUIInfo</i> is not <b>NULL</b>.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getfilemuiinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getfilemuiinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetFileMUIInfo(uint dwFlags, win32.System.SystemServices.PCWSTR pcwszFilePath, [Optional] win32.Globalization.FILEMUIINFO*pFileMUIInfo, uint *pcbFileMUIInfo);
        /// <inheritdoc cref = "GetFileMUIPath(uint, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint *, win32.System.SystemServices.PWSTR, uint *, ulong *)"/>
        internal static unsafe bool GetFileMUIPath(uint dwFlags, string pcwszFilePath, win32.System.SystemServices.PWSTR pwszLanguage, ref uint pcchLanguage, win32.System.SystemServices.PWSTR pwszFileMUIPath, ref uint pcchFileMUIPath, ref ulong pululEnumerator)
        {
            fixed (ulong *pululEnumeratorLocal = &pululEnumerator)
            {
                fixed (uint *pcchFileMUIPathLocal = &pcchFileMUIPath)
                {
                    fixed (uint *pcchLanguageLocal = &pcchLanguage)
                    {
                        fixed (char *pcwszFilePathLocal = pcwszFilePath)
                        {
                            bool __result = Kernel32.GetFileMUIPath(dwFlags, pcwszFilePathLocal, pwszLanguage, pcchLanguageLocal, pwszFileMUIPath, pcchFileMUIPathLocal, pululEnumeratorLocal);
                            return __result;
                        }
                    }
                }
            }
        }

        /// <summary>Retrieves the path to all language-specific resource files associated with the supplied LN file. The application must call this function repeatedly to get the path for each resource file.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags identifying language format and filtering. The following flags specify the format of the language indicated by <i>pwszLanguage</i>. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getfilemuipath#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcwszFilePath">
        /// <para>Pointer to a null-terminated string specifying a file path. The path is either for an existing LN file or for a file such as a .txt, .inf, or .msc file. If the file is an LN file, the function looks for files containing the associated language-specific resources. For all other types of files, the function seeks files that correspond exactly to the file name and path indicated. Your application can overwrite the behavior of the file type check by using the MUI_LANG_NEUTRAL_PE_FILE or MUI_NON_LANG_NEUTRAL_FILE flag. For more information, see the Remarks section.</para>
        /// <para><div class = "alert"><b>Note</b>  The supplied file path can be a network path: for example, "\\machinename\c$\windows\system32\notepad.exe".</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getfilemuipath#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pwszLanguage">
        /// <para>Pointer to a buffer containing a language string. On input, this buffer contains the language identifier or language name for which the application should find language-specific resource files, depending on the settings of <i>dwFlags</i>. On successful return from the function, this parameter contains the language of the language-specific resource file that the function has found.</para>
        /// <para>Alternatively, the application can set this parameter to <b>NULL</b>, with the value referenced by  <i>pcchLanguage</i> set to 0. In this case, the function retrieves the required buffer size in <i>pcchLanguage</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getfilemuipath#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcchLanguage">Pointer to the buffer size, in characters, for the language string indicated by <i>pwszLanguage</i>. If the application sets the value referenced by this parameter to 0 and  passes <b>NULL</b> for <i>pwszLanguage</i>, then the required buffer size will be returned in <i>pcchLanguage</i> and the returned buffer size is always <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>, because the function is typically called multiple times in succession. The function cannot determine the exact size of the language name for all successive calls, and cannot extend the buffer on subsequent calls. Thus LOCALE_NAME_MAX_LENGTH is the only safe maximum.</param>
        /// <param name = "pwszFileMUIPath">
        /// <para>Pointer to a buffer containing the path to the language-specific resource file. It is strongly recommended to allocate this buffer to be of size MAX_PATH.</para>
        /// <para>Alternatively, this parameter can retrieve <b>NULL</b> if the value referenced by <i>pcchFileMUIPath</i> is set to 0. In this case, the function retrieves the required size for the file path buffer in <i>pcchFileMUIPath</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getfilemuipath#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcchFileMUIPath">Pointer to the buffer size, in characters, for the file path indicated by <i>pwszFileMUIPath</i>. On successful return from the function, this parameter indicates the size of the retrieved file path. If the application sets the value referenced by this parameter to 0, the function retrieves <b>NULL</b> for <i>pwszFileMUIPath</i>, the required buffer size will be returned in <i>pcchFileMUIPath</i> and the returned buffer size is always MAX_PATH, because the function is typically called multiple times in succession. The function cannot determine the exact size of the path for all successive calls, and cannot extend the buffer on subsequent calls. Thus MAX_PATH is the only safe maximum.</param>
        /// <param name = "pululEnumerator">Pointer to an enumeration variable. The first time this function is called, the value of the variable should be 0. Between subsequent calls, the application should not change the value of this parameter. After the function retrieves all possible language-specific resource file paths, it returns <b>FALSE</b>.</param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. If the function fails, the output parameters do not change.</para>
        /// <para>To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getfilemuipath">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetFileMUIPath(uint dwFlags, win32.System.SystemServices.PCWSTR pcwszFilePath, win32.System.SystemServices.PWSTR pwszLanguage, uint *pcchLanguage, win32.System.SystemServices.PWSTR pwszFileMUIPath, uint *pcchFileMUIPath, ulong *pululEnumerator);
        /// <inheritdoc cref = "GetUILanguageInfo(uint, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, uint *, uint *)"/>
        internal static unsafe bool GetUILanguageInfo(uint dwFlags, string pwmszLanguage, win32.System.SystemServices.PWSTR pwszFallbackLanguages, uint *pcchFallbackLanguages, out uint pAttributes)
        {
            fixed (uint *pAttributesLocal = &pAttributes)
            {
                fixed (char *pwmszLanguageLocal = pwmszLanguage)
                {
                    bool __result = Kernel32.GetUILanguageInfo(dwFlags, pwmszLanguageLocal, pwszFallbackLanguages, pcchFallbackLanguages, pAttributesLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves a variety of information about an installed UI language</summary>
        /// <param name = "dwFlags">
        /// <para>Flags defining the format of the specified language. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuilanguageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pwmszLanguage">Pointer to languages for which the function is to retrieve information. This parameter indicates an ordered, null-delimited list of language identifiers or language names, depending on the flag setting. For information on the use of this parameter, see the Remarks section.</param>
        /// <param name = "pwszFallbackLanguages">
        /// <para>Pointer to a buffer in which this function retrieves an ordered, null-delimited list of fallback languages, formatted as defined by the setting for <i>dwFlags</i>. This list ends with two null characters.</para>
        /// <para>Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuilanguageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pcchFallbackLanguages">
        /// <para>Pointer to the size, in characters, for the language buffer indicated by <i>pwszFallbackLanguages</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.</para>
        /// <para>Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer </i>is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuilanguageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "pAttributes">
        /// <para>Pointer to flags indicating attributes of the input language list. The function always retrieves the flag characterizing the last language listed.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuilanguageinfo#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuilanguageinfo">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetUILanguageInfo(uint dwFlags, win32.System.SystemServices.PCWSTR pwmszLanguage, win32.System.SystemServices.PWSTR pwszFallbackLanguages, [Optional] uint *pcchFallbackLanguages, uint *pAttributes);
        /// <inheritdoc cref = "SetThreadPreferredUILanguages2(uint, win32.System.SystemServices.PCWSTR, uint *, win32.Globalization.HSAVEDUILANGUAGES*)"/>
        internal static unsafe bool SetThreadPreferredUILanguages2(uint flags, string languages, uint *numLanguagesSet, win32.Globalization.HSAVEDUILANGUAGES*snapshot)
        {
            fixed (char *languagesLocal = languages)
            {
                bool __result = Kernel32.SetThreadPreferredUILanguages2(flags, languagesLocal, numLanguagesSet, snapshot);
                return __result;
            }
        }

        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool SetThreadPreferredUILanguages2(uint flags, win32.System.SystemServices.PCWSTR languages, [Optional] uint *numLanguagesSet, [Optional] win32.Globalization.HSAVEDUILANGUAGES*snapshot);
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern void RestoreThreadPreferredUILanguages(win32.Globalization.HSAVEDUILANGUAGES snapshot);
        /// <inheritdoc cref = "NotifyUILanguageChange(uint, win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PCWSTR, uint, uint *)"/>
        internal static unsafe bool NotifyUILanguageChange(uint dwFlags, string pcwstrNewLanguage, string pcwstrPreviousLanguage, uint dwReserved, uint *pdwStatusRtrn)
        {
            fixed (char *pcwstrPreviousLanguageLocal = pcwstrPreviousLanguage)
            {
                fixed (char *pcwstrNewLanguageLocal = pcwstrNewLanguage)
                {
                    bool __result = Kernel32.NotifyUILanguageChange(dwFlags, pcwstrNewLanguageLocal, pcwstrPreviousLanguageLocal, dwReserved, pdwStatusRtrn);
                    return __result;
                }
            }
        }

        /// <summary>Unsupported. NotifyUILanguageChange may be altered or unavailable.</summary>
        /// <param name = "dwFlags">Reserved.</param>
        /// <param name = "pcwstrNewLanguage">The new language.</param>
        /// <param name = "pcwstrPreviousLanguage">The previous language.</param>
        /// <param name = "dwReserved">Reserved.</param>
        /// <param name = "pdwStatusRtrn">A pointer to a <b>DWORD</b> return status.</param>
        /// <returns>A <b>BOOL</b> datatype.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-notifyuilanguagechange">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe bool NotifyUILanguageChange(uint dwFlags, win32.System.SystemServices.PCWSTR pcwstrNewLanguage, win32.System.SystemServices.PCWSTR pcwstrPreviousLanguage, uint dwReserved, [Optional] uint *pdwStatusRtrn);
        /// <summary>Enumerates the locales that are either installed on or supported by an operating system.Note  For interoperability reasons, the application should prefer the EnumSystemLocalesEx function to EnumSystemLocales because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that will be run only on Windows Vista and later should use EnumSystemLocalesEx.</summary>
        /// <param name = "lpLocaleEnumProc">Pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317822(v=vs.85)">EnumLocalesProc</a>.</param>
        /// <param name = "dwFlags">
        /// <para>Flags specifying the locale identifiers to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for LCID_SUPPORTED.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemlocalesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemlocalesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumSystemLocalesW", SetLastError = true)]
        internal static extern unsafe bool EnumSystemLocales(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, win32.System.SystemServices.BOOL>lpLocaleEnumProc, uint dwFlags);
        /// <summary>Enumerates the language groups that are either installed on or supported by an operating system.</summary>
        /// <param name = "lpLanguageGroupEnumProc">Pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317821(v=vs.85)">EnumLanguageGroupsProc</a>.</param>
        /// <param name = "dwFlags"></param>
        /// <param name = "lParam">Application-defined value to pass to the callback function. This parameter can be used in error checking. It can also be used to ensure thread safety in the callback function.</param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemlanguagegroupsw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumSystemLanguageGroupsW", SetLastError = true)]
        internal static extern unsafe bool EnumSystemLanguageGroups(delegate *unmanaged[Stdcall]<uint, win32.System.SystemServices.PWSTR, win32.System.SystemServices.PWSTR, uint, nint, win32.System.SystemServices.BOOL>lpLanguageGroupEnumProc, win32.Globalization.ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS dwFlags, nint lParam);
        /// <summary>Enumerates the locales in a specified language group.</summary>
        /// <param name = "lpLangGroupLocaleEnumProc">Pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-langgrouplocale_enumproca">EnumLanguageGroupLocalesProc</a>.</param>
        /// <param name = "LanguageGroup"></param>
        /// <param name = "dwFlags">Reserved; must be 0.</param>
        /// <param name = "lParam">An application-defined value to pass to the callback function. This value can be used for error checking. It can also be used to ensure thread safety in the callback function.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumlanguagegrouplocalesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumLanguageGroupLocalesW", SetLastError = true)]
        internal static extern unsafe bool EnumLanguageGroupLocales(delegate *unmanaged[Stdcall]<uint, uint, win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL>lpLangGroupLocaleEnumProc, uint LanguageGroup, uint dwFlags, nint lParam);
        /// <summary>Enumerates the user interface languages that are available on the operating system and calls the callback function with every language in the list.</summary>
        /// <param name = "lpUILanguageEnumProc">Pointer to an application-defined <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-uilanguage_enumproca">EnumUILanguagesProc</a> callback function. <b>EnumUILanguages</b> calls this function repeatedly to enumerate the languages in the list.</param>
        /// <param name = "dwFlags">
        /// <para>Flags identifying language format and filtering. The following flags specify the format of the language to pass to the callback function. The format flags are mutually exclusive, and MUI_LANGUAGE_ID is the default.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumuilanguagesw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">Application-defined value.</param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumuilanguagesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumUILanguagesW", SetLastError = true)]
        internal static extern unsafe bool EnumUILanguages(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, nint, win32.System.SystemServices.BOOL>lpUILanguageEnumProc, uint dwFlags, nint lParam);
        /// <summary>Enumerates the code pages that are either installed on or supported by an operating system.</summary>
        /// <param name = "lpCodePageEnumProc">Pointer to an application-defined callback function. The <b>EnumSystemCodePages</b> function enumerates code pages by making repeated calls to this callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317809(v=vs.85)">EnumCodePagesProc</a>.</param>
        /// <param name = "dwFlags"></param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemcodepagesw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "EnumSystemCodePagesW", SetLastError = true)]
        internal static extern unsafe bool EnumSystemCodePages(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, win32.System.SystemServices.BOOL>lpCodePageEnumProc, win32.Globalization.ENUM_SYSTEM_CODE_PAGES_FLAGS dwFlags);
        /// <inheritdoc cref = "IdnToNameprepUnicode(uint, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int IdnToNameprepUnicode(uint dwFlags, string lpUnicodeCharStr, int cchUnicodeChar, win32.System.SystemServices.PWSTR lpNameprepCharStr, int cchNameprepChar)
        {
            fixed (char *lpUnicodeCharStrLocal = lpUnicodeCharStr)
            {
                int __result = Kernel32.IdnToNameprepUnicode(dwFlags, lpUnicodeCharStrLocal, cchUnicodeChar, lpNameprepCharStr, cchNameprepChar);
                return __result;
            }
        }

        /// <summary>Converts an internationalized domain name (IDN) or another internationalized label to the NamePrep form specified by Network Working Group RFC 3491, but does not perform the additional conversion to Punycode.</summary>
        /// <param name = "dwFlags">Flags specifying conversion options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-idntoascii">IdnToAscii</a>.</param>
        /// <param name = "lpUnicodeCharStr">Pointer to a Unicode string representing an IDN or another internationalized label.</param>
        /// <param name = "cchUnicodeChar">Count of Unicode characters in the input Unicode string indicated by <i>lpUnicodeCharStr</i>.</param>
        /// <param name = "lpNameprepCharStr">Pointer to a buffer that receives a version of the input Unicode string converted through NamePrep processing. Alternatively, the function can retrieve <b>NULL</b> for this parameter, if <i>cchNameprepChar</i> is set to 0. In this case, the function returns the size required for this buffer.</param>
        /// <param name = "cchNameprepChar">Size, in characters, of the buffer indicated by <i>lpNameprepCharStr</i>. The application can set the size to 0 to retrieve <b>NULL</b> in <i>lpNameprepCharStr</i> and have the function return the required buffer size.</param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in <i>lpNameprepCharStr</i> if successful. The retrieved string is null-terminated only if the input Unicode string is null-terminated.</para>
        /// <para>If the function succeeds and the value of <i>cchNameprepChar</i> is 0, the function returns the required size, in characters including a terminating null character if it was part of the input buffer.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-idntonameprepunicode">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int IdnToNameprepUnicode(uint dwFlags, win32.System.SystemServices.PCWSTR lpUnicodeCharStr, int cchUnicodeChar, win32.System.SystemServices.PWSTR lpNameprepCharStr, int cchNameprepChar);
        /// <inheritdoc cref = "NormalizeString(win32.Globalization.NORM_FORM, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int NormalizeString(win32.Globalization.NORM_FORM NormForm, string lpSrcString, int cwSrcLength, win32.System.SystemServices.PWSTR lpDstString, int cwDstLength)
        {
            fixed (char *lpSrcStringLocal = lpSrcString)
            {
                int __result = Kernel32.NormalizeString(NormForm, lpSrcStringLocal, cwSrcLength, lpDstString, cwDstLength);
                return __result;
            }
        }

        /// <summary>Normalizes characters of a text string according to Unicode 4.0 TR#15. For more information, see Using Unicode Normalization to Represent Strings.</summary>
        /// <param name = "NormForm">Normalization form to use. <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-norm_form">NORM_FORM</a> specifies the standard Unicode normalization forms.</param>
        /// <param name = "lpSrcString">Pointer to the non-normalized source string.</param>
        /// <param name = "cwSrcLength">Length, in characters, of the buffer containing the source string. The application can set this parameter to -1 if the function should assume the string to be null-terminated and calculate the length automatically.</param>
        /// <param name = "lpDstString">
        /// <para>Pointer to a buffer in which the function retrieves the destination string. Alternatively, this parameter contains <b>NULL</b> if <i>cwDstLength</i> is set to 0.</para>
        /// <para><div class = "alert"><b>Note</b>  The function does not null-terminate the string if the input string length is explicitly specified without a terminating null character. To null-terminate the output string, the application should specify -1 or explicitly count the terminating null character for the input string.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-normalizestring#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cwDstLength">Length, in characters, of the buffer containing the destination string. Alternatively, the application can set this parameter to 0 to request the function to return the required size for the destination buffer.</param>
        /// <returns>
        /// <para>Returns the length of the normalized string in the destination buffer. If <i>cwDstLength</i> is set to 0, the function returns the estimated buffer length required to do the actual conversion.</para>
        /// <para>If the string in the input buffer is null-terminated or if <i>cwSrcLength</i> is -1, the string written to the destination buffer is null-terminated and the returned string length includes the terminating null character.</para>
        /// <para>The function returns a value that is less than or equal to 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-normalizestring">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int NormalizeString(win32.Globalization.NORM_FORM NormForm, win32.System.SystemServices.PCWSTR lpSrcString, int cwSrcLength, win32.System.SystemServices.PWSTR lpDstString, int cwDstLength);
        /// <inheritdoc cref = "IsNormalizedString(win32.Globalization.NORM_FORM, win32.System.SystemServices.PCWSTR, int)"/>
        internal static unsafe bool IsNormalizedString(win32.Globalization.NORM_FORM NormForm, string lpString, int cwLength)
        {
            fixed (char *lpStringLocal = lpString)
            {
                bool __result = Kernel32.IsNormalizedString(NormForm, lpStringLocal, cwLength);
                return __result;
            }
        }

        /// <summary>Verifies that a string is normalized according to Unicode 4.0 TR#15. For more information, see Using Unicode Normalization to Represent Strings.</summary>
        /// <param name = "NormForm">Normalization form to use. <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-norm_form">NORM_FORM</a> specifies the standard Unicode normalization forms.</param>
        /// <param name = "lpString">Pointer to the string to test.</param>
        /// <param name = "cwLength">Length, in characters, of the input string, including a null terminating character. If this value is -1, the function assumes the string to be null-terminated and calculates the length automatically.</param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the input string is already normalized to the appropriate form, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isnormalizedstring">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool IsNormalizedString(win32.Globalization.NORM_FORM NormForm, win32.System.SystemServices.PCWSTR lpString, int cwLength);
        /// <inheritdoc cref = "VerifyScripts(uint, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PCWSTR, int)"/>
        internal static unsafe bool VerifyScripts(uint dwFlags, string lpLocaleScripts, int cchLocaleScripts, string lpTestScripts, int cchTestScripts)
        {
            fixed (char *lpTestScriptsLocal = lpTestScripts)
            {
                fixed (char *lpLocaleScriptsLocal = lpLocaleScripts)
                {
                    bool __result = Kernel32.VerifyScripts(dwFlags, lpLocaleScriptsLocal, cchLocaleScripts, lpTestScriptsLocal, cchTestScripts);
                    return __result;
                }
            }
        }

        /// <summary>Compares two enumerated lists of scripts.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags specifying script verification options.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-verifyscripts#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpLocaleScripts">Pointer to the locale list, the enumerated list of scripts for a given locale. This list is typically populated by calling <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a> with <i>LCType</i> set to <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-sscripts">LOCALE_SSCRIPTS</a>.</param>
        /// <param name = "cchLocaleScripts">Size, in characters, of the string indicated by <i>lpLocaleScripts</i>. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails.</param>
        /// <param name = "lpTestScripts">Pointer to the test list, a second enumerated list of scripts. This list is typically populated by calling <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getstringscripts">GetStringScripts</a>.</param>
        /// <param name = "cchTestScripts">Size, in characters, of the string indicated by <i>lpTestScripts</i>. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails.</param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if the test list is non-empty and all items in the list are also included in the locale list. The function still returns <b>TRUE</b> if the locale list contains more scripts than the test list, but all the test list scripts must be contained in the locale list. If VS_ALLOW_LATIN is specified in <i>dwFlags</i>, the function behaves as if "Latn;" is always in the locale list.</para>
        /// <para>In all other cases, the function returns <b>FALSE</b>. This return can indicate that the test list contains an item that is not in the locale list, or it can indicate an error. To distinguish between these two cases, the application should call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-verifyscripts">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern bool VerifyScripts(uint dwFlags, win32.System.SystemServices.PCWSTR lpLocaleScripts, int cchLocaleScripts, win32.System.SystemServices.PCWSTR lpTestScripts, int cchTestScripts);
        /// <inheritdoc cref = "GetStringScripts(uint, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int GetStringScripts(uint dwFlags, string lpString, int cchString, win32.System.SystemServices.PWSTR lpScripts, int cchScripts)
        {
            fixed (char *lpStringLocal = lpString)
            {
                int __result = Kernel32.GetStringScripts(dwFlags, lpStringLocal, cchString, lpScripts, cchScripts);
                return __result;
            }
        }

        /// <summary>Provides a list of scripts used in the specified Unicode string.</summary>
        /// <param name = "dwFlags">
        /// <para>Flags specifying options for script retrieval.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getstringscripts#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpString">Pointer to the Unicode string to analyze.</param>
        /// <param name = "cchString">Size, in characters, of the Unicode string indicated by <i>lpString</i>. The application sets this parameter to -1 if the Unicode string is null-terminated. If the application sets this parameter to 0, the function retrieves a null Unicode string (L"\0") in <i>lpScripts</i> and returns 1.</param>
        /// <param name = "lpScripts">
        /// <para>Pointer to a buffer in which this function retrieves a null-terminated string representing a list of scripts, using the 4-character notation used in <a href = "http://www.unicode.org/iso15924/iso15924-codes.html">ISO 15924</a>. Each script name consists of four Latin characters, and the names are retrieved in alphabetical order. Each name, including the last, is followed by a semicolon.</para>
        /// <para>Alternatively, this parameter contains <b>NULL</b> if <i>cchScripts</i> is set to 0. In this case, the function returns the required size for the script buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getstringscripts#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchScripts">
        /// <para>Size, in characters, of the script buffer indicated by <i>lpScripts</i>.</para>
        /// <para>Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpScripts</i> and returns the required size for the script buffer.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getstringscripts#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in the output buffer, including a terminating null character, if successful and <i>cchScripts</i> is set to a nonzero value. The function returns 1 to indicate that no script has been found, for example, when the input string only contains COMMON or INHERITED characters and GSS_ALLOW_INHERITED_COMMON is not set. Given that each found script adds five characters (four characters + delimiter), a simple mathematical operation provides the script count as (return_code - 1) / 5.</para>
        /// <para>If the function succeeds and the value of <i>cchScripts</i> is 0, the function returns the required size, in characters including a terminating null character, for the script buffer. The script count is as described above.</para>
        /// <para>This function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getstringscripts">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetStringScripts(uint dwFlags, win32.System.SystemServices.PCWSTR lpString, int cchString, win32.System.SystemServices.PWSTR lpScripts, int cchScripts);
        /// <inheritdoc cref = "GetLocaleInfoEx(win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int GetLocaleInfoEx(string lpLocaleName, uint LCType, win32.System.SystemServices.PWSTR lpLCData, int cchData)
        {
            fixed (char *lpLocaleNameLocal = lpLocaleName)
            {
                int __result = Kernel32.GetLocaleInfoEx(lpLocaleNameLocal, LCType, lpLCData, cchData);
                return __result;
            }
        }

        /// <summary>Retrieves information about a locale specified by name.Note  The application should call this function in preference to GetLocaleInfo if designed to run only on Windows Vista and later. Note  This function can retrieve data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.</summary>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getlocaleinfoex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "LCType">
        /// <para>The locale information to retrieve. For possible values, see the "Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo" section in <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-information-constants">Locale Information Constants</a>. Note that only one piece of locale information can be specified per call.</para>
        /// <para>The application can use the binary OR operator to combine <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> with any other allowed constant. In this case, the function retrieves the value as a number instead of a string. The buffer that receives the value must be at least the length of a DWORD value, which is 2.</para>
        /// <para><div class = "alert"><b>Caution</b>  It is also possible to combine <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> with any other constant. However, use of this constant is strongly discouraged. (Even without using the current user override, the data can differ from computer to computer, and custom locales can change the data. For example, even month or day names are subject to spelling reforms.)</div> <div> </div> If <i>LCType</i> is set to <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-ioptionalcalendar">LOCALE_IOPTIONALCALENDAR</a>, the function retrieves only the first alternate calendar.</para>
        /// <para><div class = "alert"><b>Note</b>  To get all alternate calendars, the application should use <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoexa">EnumCalendarInfoEx</a>.</div> <div> </div> Starting with Windows Vista, your applications should not use <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-ilanguage">LOCALE_ILANGUAGE</a> in the <i>LCType</i> parameter to avoid failure or retrieval of unexpected data. Instead, it is recommended for your applications to call <b>GetLocaleInfoEx</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getlocaleinfoex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpLCData">Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if <i>cchData</i> is set to 0.</param>
        /// <param name = "cchData">Size, in characters, of the data buffer indicated by <i>lpLCData</i>. Alternatively, the application can set this parameter to 0. In this case, the function does not use the <i>lpLCData</i> parameter and returns the required buffer size, including the terminating null character.</param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in the locale data buffer if successful and <i>cchData</i> is a nonzero value. If the function succeeds, <i>cchData</i> is nonzero, and <a href = "/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> is specified, the return value is the size of the integer retrieved in the data buffer, that is, 2. If the function succeeds and the value of <i>cchData</i> is 0, the return value is the required size, in characters including a null character, for the locale data buffer.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getlocaleinfoex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetLocaleInfoEx(win32.System.SystemServices.PCWSTR lpLocaleName, uint LCType, win32.System.SystemServices.PWSTR lpLCData, int cchData);
        /// <inheritdoc cref = "GetCalendarInfoEx(win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PWSTR, int, uint *)"/>
        internal static unsafe int GetCalendarInfoEx(string lpLocaleName, uint Calendar, string lpReserved, uint CalType, win32.System.SystemServices.PWSTR lpCalData, int cchData, uint *lpValue)
        {
            fixed (char *lpReservedLocal = lpReserved)
            {
                fixed (char *lpLocaleNameLocal = lpLocaleName)
                {
                    int __result = Kernel32.GetCalendarInfoEx(lpLocaleNameLocal, Calendar, lpReservedLocal, CalType, lpCalData, cchData, lpValue);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves information about a calendar for a locale specified by name.Note  The application should call this function in preference to GetCalendarInfo if designed to run only on Windows Vista and later. Note  This function can retrieve data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.</summary>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcalendarinfoex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Calendar"><a href = "https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a>.</param>
        /// <param name = "lpReserved">Reserved; must be <b>NULL</b>.</param>
        /// <param name = "CalType">
        /// <para>Type of information to retrieve. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>.</para>
        /// <para><div class = "alert"><b>Note</b>  <b>GetCalendarInfoEx</b> returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.</div> <div> </div> For CAL_NOUSEROVERRIDE, the function ignores any value set by <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setcalendarinfoa">SetCalendarInfo</a> and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by <b>SetCalendarInfo</b>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcalendarinfoex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpCalData">Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, this parameter must retrieve <b>NULL</b>.</param>
        /// <param name = "cchData">Size, in characters, of the <i>lpCalData</i> buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the <i>lpCalData</i> parameter is not used. If CAL_RETURN_NUMBER is specified for <i>CalType</i>, the value of <i>cchData</i> must be 0.</param>
        /// <param name = "lpValue">Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, then <i>lpValue</i> must not be <b>NULL</b>. If CAL_RETURN_NUMBER is not specified in <i>CalType</i>, then <i>lpValue</i> must be <b>NULL</b>.</param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in the <i>lpCalData</i> buffer if successful. If the function succeeds, <i>cchData</i> is set to 0, and CAL_RETURN_NUMBER is not specified, the return value is the size of the buffer required to hold the locale information. If the function succeeds, <i>cchData</i> is set to 0, and CAL_RETURN_NUMBER is specified, the return value is the size of the value written to the <i>lpValue</i> parameter. This size is always 2.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcalendarinfoex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int GetCalendarInfoEx(win32.System.SystemServices.PCWSTR lpLocaleName, uint Calendar, win32.System.SystemServices.PCWSTR lpReserved, uint CalType, win32.System.SystemServices.PWSTR lpCalData, int cchData, [Optional] uint *lpValue);
        /// <inheritdoc cref = "GetNumberFormatEx(win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PCWSTR, win32.Globalization.NUMBERFMTW*, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int GetNumberFormatEx(string lpLocaleName, uint dwFlags, string lpValue, win32.Globalization.NUMBERFMTW? lpFormat, win32.System.SystemServices.PWSTR lpNumberStr, int cchNumber)
        {
            fixed (char *lpValueLocal = lpValue)
            {
                fixed (char *lpLocaleNameLocal = lpLocaleName)
                {
                    win32.Globalization.NUMBERFMTW lpFormatLocal = lpFormat.HasValue ? lpFormat.Value : default(win32.Globalization.NUMBERFMTW);
                    int __result = Kernel32.GetNumberFormatEx(lpLocaleNameLocal, dwFlags, lpValueLocal, lpFormat.HasValue ? &lpFormatLocal : null, lpNumberStr, cchNumber);
                    return __result;
                }
            }
        }

        /// <summary>Formats a number string as a number string customized for a locale specified by name.Note  The application should call this function in preference to GetNumberFormat if designed to run only on Windows Vista and later. Note  This function can format data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.</summary>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnumberformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default number format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default number format for the specified locale.</para>
        /// <para><div class = "alert"><b>Caution</b>  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnumberformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpValue">
        /// <para>Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by <i>lpValue</i> deviates from these rules.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnumberformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFormat">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-numberfmta">NUMBERFMT</a> structure that contains number formatting information, with all members set to appropriate values. If the application does not set this parameter to <b>NULL</b>, the function uses the locale only for formatting information not specified in the structure, for example, the locale string value for the negative sign.</param>
        /// <param name = "lpNumberStr">Pointer to a buffer in which this function retrieves the formatted number string. Alternatively, this parameter contains <b>NULL</b> if <i>cchNumber</i> is set to 0. In this case, the function returns the required size for the number string buffer.</param>
        /// <param name = "cchNumber">Size, in characters, for the number string buffer indicated by <i>lpNumberStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer and does not use the <i>lpNumberStr</i> parameter.</param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in the buffer indicated by <i>lpNumberStr</i> if successful. If the <i>cchNumber</i> parameter is set to 0, the function returns the number of characters required to hold the formatted number string, including a terminating null character.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnumberformatex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int GetNumberFormatEx(win32.System.SystemServices.PCWSTR lpLocaleName, uint dwFlags, win32.System.SystemServices.PCWSTR lpValue, [Optional] win32.Globalization.NUMBERFMTW*lpFormat, win32.System.SystemServices.PWSTR lpNumberStr, int cchNumber);
        /// <inheritdoc cref = "GetCurrencyFormatEx(win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PCWSTR, win32.Globalization.CURRENCYFMTW*, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int GetCurrencyFormatEx(string lpLocaleName, uint dwFlags, string lpValue, win32.Globalization.CURRENCYFMTW? lpFormat, win32.System.SystemServices.PWSTR lpCurrencyStr, int cchCurrency)
        {
            fixed (char *lpValueLocal = lpValue)
            {
                fixed (char *lpLocaleNameLocal = lpLocaleName)
                {
                    win32.Globalization.CURRENCYFMTW lpFormatLocal = lpFormat.HasValue ? lpFormat.Value : default(win32.Globalization.CURRENCYFMTW);
                    int __result = Kernel32.GetCurrencyFormatEx(lpLocaleNameLocal, dwFlags, lpValueLocal, lpFormat.HasValue ? &lpFormatLocal : null, lpCurrencyStr, cchCurrency);
                    return __result;
                }
            }
        }

        /// <summary>Formats a number string as a currency string for a locale specified by name.Note  The application should call this function in preference to GetCurrencyFormat if designed to run only on Windows Vista and later. Note  This function can format data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.</summary>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a> or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcurrencyformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">
        /// <para>Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default currency format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default currency format for the specified locale.</para>
        /// <para><div class = "alert"><b>Caution</b>  Use of <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> is strongly discouraged as it disables user preferences.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcurrencyformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpValue">
        /// <para>Pointer to a null-terminated string containing the number string to format. This string can contain only the following characters. All other characters are invalid. The function returns an error if the string deviates from these rules.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcurrencyformatex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpFormat">Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to <b>NULL</b> if function is to use the currency format of the specified locale. If this parameter is not set to <b>NULL</b>, the function uses the specified locale only for formatting information not specified in the <b>CURRENCYFMT</b> structure, for example, the string value for the negative sign used by the locale.</param>
        /// <param name = "lpCurrencyStr">Pointer to a buffer in which this function retrieves the formatted currency string.</param>
        /// <param name = "cchCurrency">Size, in characters, of the <i>lpCurrencyStr</i> buffer. The application can set this parameter to 0 to return the size of the buffer required to hold the formatted currency string. In this case, the buffer indicated by <i>lpCurrencyStr</i> is not used.</param>
        /// <returns>
        /// <para>Returns the number of characters retrieved in the buffer indicated by <i>lpCurrencyStr</i> if successful. If the <i>cchCurrency</i> parameter is 0, the function returns the size of the buffer required to hold the formatted currency string, including a terminating null character.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcurrencyformatex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int GetCurrencyFormatEx(win32.System.SystemServices.PCWSTR lpLocaleName, uint dwFlags, win32.System.SystemServices.PCWSTR lpValue, [Optional] win32.Globalization.CURRENCYFMTW*lpFormat, win32.System.SystemServices.PWSTR lpCurrencyStr, int cchCurrency);
        /// <summary>Retrieves the user default locale name.Note  The application should call this function in preference to GetUserDefaultLCID if designed to run only on Windows Vista and later.</summary>
        /// <param name = "lpLocaleName">Pointer to a buffer in which this function retrieves the locale name.</param>
        /// <param name = "cchLocaleName">Size, in characters, of the buffer indicated by <i>lpLocaleName</i>. The maximum possible length of a locale name, including a terminating null character, is <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply in this parameter.</param>
        /// <returns>
        /// <para>Returns the size of the buffer containing the locale name, including the terminating null character, if successful.<div class = "alert"><b>Note</b>  On single-user systems, the return value is the same as that returned by <a href = "/windows/desktop/api/winnls/nf-winnls-getsystemdefaultlocalename">GetSystemDefaultLocaleName</a>.</div> <div> </div></para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserdefaultlocalename">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetUserDefaultLocaleName(win32.System.SystemServices.PWSTR lpLocaleName, int cchLocaleName);
        /// <summary>Retrieves the system default locale name.Note  It is recommended that applications call GetUserDefaultLocaleName in preference over this function.</summary>
        /// <param name = "lpLocaleName">Pointer to a buffer in which this function retrieves the locale name.</param>
        /// <param name = "cchLocaleName">Size, in characters, of the output buffer indicated by <i>lpLocaleName</i>. The maximum possible character length of a locale name (including a terminating null character) is the value of <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size.</param>
        /// <returns>
        /// <para>Returns a value greater than 0 that indicates the length of the locale name, including the terminating null character, if successful.</para>
        /// <para>This function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystemdefaultlocalename">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int GetSystemDefaultLocaleName(win32.System.SystemServices.PWSTR lpLocaleName, int cchLocaleName);
        /// <inheritdoc cref = "IsNLSDefinedString(uint, uint, win32.Globalization.NLSVERSIONINFO*, win32.System.SystemServices.PCWSTR, int)"/>
        internal static unsafe bool IsNLSDefinedString(uint Function, uint dwFlags, in win32.Globalization.NLSVERSIONINFO lpVersionInformation, string lpString, int cchStr)
        {
            fixed (char *lpStringLocal = lpString)
            {
                fixed (win32.Globalization.NLSVERSIONINFO*lpVersionInformationLocal = &lpVersionInformation)
                {
                    bool __result = Kernel32.IsNLSDefinedString(Function, dwFlags, lpVersionInformationLocal, lpStringLocal, cchStr);
                    return __result;
                }
            }
        }

        /// <summary>Determines if each character in a string has a defined result for a specified NLS capability.</summary>
        /// <param name = "Function">NLS capability to query. This value must be COMPARE_STRING. See the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.</param>
        /// <param name = "dwFlags">Flags defining the function. Must be 0.</param>
        /// <param name = "lpVersionInformation">Pointer to an <a href = "https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure containing version information. Typically, the information is obtained by calling <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversion">GetNLSVersion</a>. The application sets this parameter to <b>NULL</b> if the function is to use the current version.</param>
        /// <param name = "lpString">Pointer to the UTF-16 string to examine.</param>
        /// <param name = "cchStr">
        /// <para>Number of UTF-16 characters in the string indicated by <i>lpString</i>. This count can include a terminating null character. If the terminating null character is included in the character count, it does not affect the checking behavior because the terminating null character is always defined.</para>
        /// <para>The application should supply -1 to indicate that the string is null-terminated. In this case, the function itself calculates the string length.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isnlsdefinedstring#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if successful, only if the input string is valid, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isnlsdefinedstring">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool IsNLSDefinedString(uint Function, uint dwFlags, win32.Globalization.NLSVERSIONINFO*lpVersionInformation, win32.System.SystemServices.PCWSTR lpString, int cchStr);
        /// <inheritdoc cref = "GetNLSVersionEx(uint, win32.System.SystemServices.PCWSTR, win32.Globalization.NLSVERSIONINFOEX*)"/>
        internal static unsafe bool GetNLSVersionEx(uint function, string lpLocaleName, ref win32.Globalization.NLSVERSIONINFOEX lpVersionInformation)
        {
            fixed (win32.Globalization.NLSVERSIONINFOEX*lpVersionInformationLocal = &lpVersionInformation)
            {
                fixed (char *lpLocaleNameLocal = lpLocaleName)
                {
                    bool __result = Kernel32.GetNLSVersionEx(function, lpLocaleNameLocal, lpVersionInformationLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves information about the current version of a specified NLS capability for a locale specified by name.Note  The application should call this function in preference to GetNLSVersion if designed to run only on Windows Vista and later.</summary>
        /// <param name = "function">The NLS capability to query. This value must be COMPARE_STRING. See the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.</param>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnlsversionex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpVersionInformation">
        /// <para>Pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c> sizeof(NLSVERSIONINFOEX)</c>.</para>
        /// <para><div class = "alert"><b>Note</b>  On Windows Vista and later, the function can alternatively provide version information in an <a href = "https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnlsversionex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Returns <b>TRUE</b> if and only if the application has supplied valid values in <i>lpVersionInformation</i>, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnlsversionex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool GetNLSVersionEx(uint function, win32.System.SystemServices.PCWSTR lpLocaleName, win32.Globalization.NLSVERSIONINFOEX*lpVersionInformation);
        /// <inheritdoc cref = "IsValidNLSVersion(uint, win32.System.SystemServices.PCWSTR, win32.Globalization.NLSVERSIONINFOEX*)"/>
        internal static unsafe uint IsValidNLSVersion(uint function, string lpLocaleName, in win32.Globalization.NLSVERSIONINFOEX lpVersionInformation)
        {
            fixed (win32.Globalization.NLSVERSIONINFOEX*lpVersionInformationLocal = &lpVersionInformation)
            {
                fixed (char *lpLocaleNameLocal = lpLocaleName)
                {
                    uint __result = Kernel32.IsValidNLSVersion(function, lpLocaleNameLocal, lpVersionInformationLocal);
                    return __result;
                }
            }
        }

        /// <summary>Determines if the NLS version is valid for a given NLS function.</summary>
        /// <param name = "function">The NLS capability to query. This value must be COMPARE_STRING. See the <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.</param>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidnlsversion#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpVersionInformation">Pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c> sizeof(NLSVERSIONINFOEX)</c>.</param>
        /// <returns>Returns a nonzero value if the NLS version is valid, or zero if the version is invalid.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidnlsversion">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern unsafe uint IsValidNLSVersion(uint function, win32.System.SystemServices.PCWSTR lpLocaleName, win32.Globalization.NLSVERSIONINFOEX*lpVersionInformation);
        /// <inheritdoc cref = "FindNLSStringEx(win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PCWSTR, int, int *, win32.Globalization.NLSVERSIONINFO*, void *, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe int FindNLSStringEx(string lpLocaleName, uint dwFindNLSStringFlags, string lpStringSource, int cchSource, string lpStringValue, int cchValue, int *pcchFound, win32.Globalization.NLSVERSIONINFO? lpVersionInformation, void *lpReserved, win32.UI.WindowsAndMessaging.LPARAM sortHandle)
        {
            fixed (char *lpStringValueLocal = lpStringValue)
            {
                fixed (char *lpStringSourceLocal = lpStringSource)
                {
                    fixed (char *lpLocaleNameLocal = lpLocaleName)
                    {
                        win32.Globalization.NLSVERSIONINFO lpVersionInformationLocal = lpVersionInformation.HasValue ? lpVersionInformation.Value : default(win32.Globalization.NLSVERSIONINFO);
                        int __result = Kernel32.FindNLSStringEx(lpLocaleNameLocal, dwFindNLSStringFlags, lpStringSourceLocal, cchSource, lpStringValueLocal, cchValue, pcchFound, lpVersionInformation.HasValue ? &lpVersionInformationLocal : null, lpReserved, sortHandle);
                        return __result;
                    }
                }
            }
        }

        /// <summary>Locates a Unicode string (wide characters) or its equivalent in another Unicode string for a locale specified by name.Caution  Because strings with very different binary representations can compare as identical, this function can raise certain security concerns. For more information, see the discussion of comparison functions in Security Considerations:\_International Features.</summary>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-findnlsstringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFindNLSStringFlags">
        /// <para>Flags specifying details of the find operation. These flags are mutually exclusive, with FIND_FROMSTART being the default. The application can specify just one of the find flags with any of the filtering flags defined in the next table. If the application does not specify a flag, the function uses the default comparison for the specified locale. As discussed in <a href = "https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>, there is no binary comparison mode.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-findnlsstringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpStringSource">Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.</param>
        /// <param name = "cchSource">Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the source string is null-terminated and the function should calculate the size automatically.</param>
        /// <param name = "lpStringValue">Pointer to the search string, for which the function searches in the source string.</param>
        /// <param name = "cchValue">Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the search string is null-terminated and the function should calculate the size automatically.</param>
        /// <param name = "pcchFound">
        /// <para>Pointer to a buffer containing the length of the string that the function finds. The string can be either longer or shorter than the search string. If the function fails to find the search string, this parameter is not modified.</para>
        /// <para>The function can retrieve <b>NULL</b> in this parameter. In this case, the function makes no indication if the length of the found string differs from the length of the source string.</para>
        /// <para>Note that the value of <i>pcchFound</i> is often identical to the value provided in <i>cchValue</i>, but can differ in the following cases:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-findnlsstringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpVersionInformation">Reserved; must be <b>NULL</b>.</param>
        /// <param name = "lpReserved">Reserved; must be <b>NULL</b>.</param>
        /// <param name = "sortHandle">Reserved; must be 0.</param>
        /// <returns>
        /// <para>Returns a 0-based index into the source string indicated by <i>lpStringSource</i> if successful. In combination with the value in <i>pcchFound</i>, this index provides the exact location of the entire found string in the source string. A return value of 0 is an error-free index into the source string, and the matching string is in the source string at offset 0.</para>
        /// <para>The function returns -1 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-findnlsstringex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int FindNLSStringEx(win32.System.SystemServices.PCWSTR lpLocaleName, uint dwFindNLSStringFlags, win32.System.SystemServices.PCWSTR lpStringSource, int cchSource, win32.System.SystemServices.PCWSTR lpStringValue, int cchValue, [Optional] int *pcchFound, [Optional] win32.Globalization.NLSVERSIONINFO*lpVersionInformation, [Optional] void *lpReserved, win32.UI.WindowsAndMessaging.LPARAM sortHandle);
        /// <inheritdoc cref = "LCMapStringEx(win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PCWSTR, int, win32.System.SystemServices.PWSTR, int, win32.Globalization.NLSVERSIONINFO*, void *, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe int LCMapStringEx(string lpLocaleName, uint dwMapFlags, string lpSrcStr, int cchSrc, win32.System.SystemServices.PWSTR lpDestStr, int cchDest, win32.Globalization.NLSVERSIONINFO? lpVersionInformation, void *lpReserved, win32.UI.WindowsAndMessaging.LPARAM sortHandle)
        {
            fixed (char *lpSrcStrLocal = lpSrcStr)
            {
                fixed (char *lpLocaleNameLocal = lpLocaleName)
                {
                    win32.Globalization.NLSVERSIONINFO lpVersionInformationLocal = lpVersionInformation.HasValue ? lpVersionInformation.Value : default(win32.Globalization.NLSVERSIONINFO);
                    int __result = Kernel32.LCMapStringEx(lpLocaleNameLocal, dwMapFlags, lpSrcStrLocal, cchSrc, lpDestStr, cchDest, lpVersionInformation.HasValue ? &lpVersionInformationLocal : null, lpReserved, sortHandle);
                    return __result;
                }
            }
        }

        /// <summary>For a locale specified by name, maps an input character string to another using a specified transformation, or generates a sort key for the input string.Note  The application should call this function in preference to LCMapString if designed to run only on Windows Vista and later.</summary>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwMapFlags">
        /// <para>Flag specifying the type of transformation to use during string mapping or the type of sort key to generate. This parameter can have the following values.</para>
        /// <para>| Flag | Meaning | | --- | --- | | **LCMAP_BYTEREV**| Use byte reversal. For example, if the application passes in 0x3450 0x4822, the result is 0x5034 0x2248. | | **LCMAP_FULLWIDTH** | Use Unicode (wide) characters where applicable. This flag and LCMAP_HALFWIDTH are mutually exclusive. With this flag, the mapping may use Normalization Form C even if an input character is already full-width. For example, the string "は゛" (which is already full-width) is normalized to "ば". See [Unicode normalization forms](http://www.unicode.org/reports/tr15/). | |**LCMAP_HALFWIDTH** | Use narrow characters where applicable. This flag and LCMAP_FULLWIDTH are mutually exclusive. | | **LCMAP_HIRAGANA** | Map all katakana characters to hiragana. This flag and LCMAP_KATAKANA are mutually exclusive. | | **LCMAP_KATAKANA** | Map all hiragana characters to katakana. This flag and LCMAP_HIRAGANA are mutually exclusive. | | **LCMAP_LINGUISTIC_CASING** | Use linguistic rules for casing, instead of file system rules (default). This flag is valid with LCMAP_LOWERCASE or LCMAP_UPPERCASE only. | | **LCMAP_LOWERCASE** | For locales and scripts capable of handling uppercase and lowercase, map all characters to lowercase. | **LCMAP_HASH** | Return a hash of the raw sort weights of a string.<br> <br>Strings that appear equivalent typically return the same hash (for example, "hello" and "HELLO" with LCMAP_IGNORECASE). However, some complex cases, such as East Asian languages, can have similar strings with identical weights that compare as equal but do not return the same hash.<br> <br>LCMAP_HASH requires that the output buffer be of size sizeof(int) | | **LCMAP_SIMPLIFIED_CHINESE** | Map traditional Chinese characters to simplified Chinese characters. This flag and LCMAP_TRADITIONAL_CHINESE are mutually exclusive. | | **LCMAP_SORTHANDLE** <br> **The use of a sort handle results in minimal performance improvements and is discouraged.** | Return a token representing the resolved sort parameters for the locale (like locale name), so future calls can pass <c>NULL</c> for the sort name and pass the previously queried sort handle as the last parameter (sortHandle) in subsequent calls to [CompareStringEx](../stringapiset/nf-stringapiset-comparestringex.md) or [LCMapStringEx](nf-winnls-lcmapstringex.md).<br> <br>LCMAP_SORTHANDLE requires that the output buffer be of size sizeof(lparam) | | **LCMAP_SORTKEY** | Produce a normalized sort key. If the LCMAP_SORTKEY flag is not specified, the function performs string mapping. For details of sort key generation and string mapping, see the Remarks section. | | **LCMAP_TITLECASE** | Windows 7:</b> Map all characters to title case, in which the first letter of each major word is capitalized. | | **LCMAP_TRADITIONAL_CHINESE** | Map simplified Chinese characters to traditional Chinese characters. This flag and LCMAP_SIMPLIFIED_CHINESE are mutually exclusive. | | **LCMAP_UPPERCASE** | For locales and scripts capable of handling uppercase and lowercase, map all characters to uppercase. |</para>
        /// <para>The following flags can be used alone, with one another, or with the LCMAP_SORTKEY and/or LCMAP_BYTEREV flags. However, they cannot be combined with the other flags listed above.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpSrcStr">Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0.</param>
        /// <param name = "cchSrc">
        /// <para>Size, in characters, of the source string indicated by <i>lpSrcStr</i>. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself.</para>
        /// <para>The application can set this parameter to any negative value to specify that the source string is null-terminated. In this case, if <b>LCMapStringEx</b> is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by <i>lpDestStr</i>.</para>
        /// <para>The application cannot set this parameter to 0.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpDestStr">
        /// <para>Pointer to a buffer in which this function retrieves the mapped string or a sort key.</para>
        /// <para>If the application is using the function to generate a sort key (LCMAP_SORTKEY):</para>
        /// <para>- The sort key is stored in the buffer and treated as an opaque array of bytes. The stored values can include embedded 0 bytes at any position. - The destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed.</para>
        /// <para>If the caller explicitly requests a subset of the string, the destination string does not include a terminating null character unless the caller specified it in *cchDest*.</para>
        /// <para>If this function fails, the destination buffer might contain either partial results or no results at all. In this case, all results should be considered invalid.</para>
        /// <para>> [!NOTE] > When setting LCMAP_UPPERCASE or LCMAP_LOWERCASE, the destination string can use the same buffer as the source string. However, this is strongly discouraged, as some conditions may cause the returned cased string to be a different length.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchDest">
        /// <para>Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.</para>
        /// <para>If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator.</para>
        /// <para>The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string or sort key.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpVersionInformation">
        /// <para>Pointer to an <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure that contains the version information about the relevant NLS capability; usually retrieved from <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversionex">GetNLSVersionEx</a>.</para>
        /// <para>**Windows Vista, Windows 7:** Reserved; must set to NULL.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpReserved">Reserved; must be NULL.</param>
        /// <param name = "sortHandle">
        /// <para>Reserved; must be 0.</para>
        /// <para>> [!NOTE] > [CompareStringEx](../stringapiset/nf-stringapiset-comparestringex.md) and [LCMapStringEx](nf-winnls-lcmapstringex.md) can specify a sort handle (if the locale name is null).  This use is discouraged for most apps.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds when used for string mapping, it returns the number of characters in the translated string (see *cchSrc* and *cchDest* for more details).</para>
        /// <para>If the function succeeds when used for string mapping it returns the number of bytes in the sort key.</para>
        /// <para>This function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe int LCMapStringEx(win32.System.SystemServices.PCWSTR lpLocaleName, uint dwMapFlags, win32.System.SystemServices.PCWSTR lpSrcStr, int cchSrc, win32.System.SystemServices.PWSTR lpDestStr, int cchDest, [Optional] win32.Globalization.NLSVERSIONINFO*lpVersionInformation, [Optional] void *lpReserved, win32.UI.WindowsAndMessaging.LPARAM sortHandle);
        /// <inheritdoc cref = "IsValidLocaleName(win32.System.SystemServices.PCWSTR)"/>
        internal static unsafe bool IsValidLocaleName(string lpLocaleName)
        {
            fixed (char *lpLocaleNameLocal = lpLocaleName)
            {
                bool __result = Kernel32.IsValidLocaleName(lpLocaleNameLocal);
                return __result;
            }
        }

        /// <summary>Determines if the specified locale name is valid for a locale that is installed or supported on the operating system.Note  An application running only on Windows Vista and later should call this function in preference to IsValidLocale to determine the validity of a supplemental locale.</summary>
        /// <param name = "lpLocaleName">Pointer to the locale name to validate.</param>
        /// <returns>Returns a nonzero value if the locale name is valid, or returns 0 for an invalid name.</returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidlocalename">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true)]
        internal static extern bool IsValidLocaleName(win32.System.SystemServices.PCWSTR lpLocaleName);
        /// <inheritdoc cref = "EnumCalendarInfoExEx(delegate *unmanaged[Stdcall]{win32.System.SystemServices.PWSTR, uint, win32.System.SystemServices.PWSTR, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL}, win32.System.SystemServices.PCWSTR, uint, win32.System.SystemServices.PCWSTR, uint, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe bool EnumCalendarInfoExEx(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, uint, win32.System.SystemServices.PWSTR, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>pCalInfoEnumProcExEx, string lpLocaleName, uint Calendar, string lpReserved, uint CalType, win32.UI.WindowsAndMessaging.LPARAM lParam)
        {
            fixed (char *lpReservedLocal = lpReserved)
            {
                fixed (char *lpLocaleNameLocal = lpLocaleName)
                {
                    bool __result = Kernel32.EnumCalendarInfoExEx(pCalInfoEnumProcExEx, lpLocaleNameLocal, Calendar, lpReservedLocal, CalType, lParam);
                    return __result;
                }
            }
        }

        /// <summary>Enumerates calendar information for a locale specified by name.Note  The application should call this function in preference to EnumCalendarInfo or EnumCalendarInfoEx if designed to run only on Windows Vista and later. Note  This function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.</summary>
        /// <param name = "pCalInfoEnumProcExEx">Pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317808(v=vs.85)">EnumCalendarInfoProcExEx</a>.</param>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumcalendarinfoexex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Calendar"><a href = "https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.</param>
        /// <param name = "lpReserved">Reserved; must be <b>NULL</b>.</param>
        /// <param name = "CalType">Type of calendar information. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.</param>
        /// <param name = "lParam">Application-provided parameter to pass to the callback function. This value is especially useful for multi-threaded applications.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumcalendarinfoexex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool EnumCalendarInfoExEx(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, uint, win32.System.SystemServices.PWSTR, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>pCalInfoEnumProcExEx, win32.System.SystemServices.PCWSTR lpLocaleName, uint Calendar, win32.System.SystemServices.PCWSTR lpReserved, uint CalType, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <inheritdoc cref = "EnumDateFormatsExEx(delegate *unmanaged[Stdcall]{win32.System.SystemServices.PWSTR, uint, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL}, win32.System.SystemServices.PCWSTR, win32.Globalization.ENUM_DATE_FORMATS_FLAGS, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe bool EnumDateFormatsExEx(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, uint, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpDateFmtEnumProcExEx, string lpLocaleName, win32.Globalization.ENUM_DATE_FORMATS_FLAGS dwFlags, win32.UI.WindowsAndMessaging.LPARAM lParam)
        {
            fixed (char *lpLocaleNameLocal = lpLocaleName)
            {
                bool __result = Kernel32.EnumDateFormatsExEx(lpDateFmtEnumProcExEx, lpLocaleNameLocal, dwFlags, lParam);
                return __result;
            }
        }

        /// <summary>Enumerates the long date, short date, or year/month formats that are available for a locale specified by name.Note  The application should call this function in preference to EnumDateFormats or EnumDateFormatsEx if designed to run only on Windows Vista and later. Note  This function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.</summary>
        /// <param name = "lpDateFmtEnumProcExEx">Pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317815(v=vs.85)">EnumDateFormatsProcExEx</a>.</param>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumdateformatsexex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags"></param>
        /// <param name = "lParam">An application-provided parameter to pass to the callback function. This value is especially useful for multi-threaded applications.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumdateformatsexex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool EnumDateFormatsExEx(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, uint, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpDateFmtEnumProcExEx, win32.System.SystemServices.PCWSTR lpLocaleName, win32.Globalization.ENUM_DATE_FORMATS_FLAGS dwFlags, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <inheritdoc cref = "EnumTimeFormatsEx(delegate *unmanaged[Stdcall]{win32.System.SystemServices.PWSTR, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL}, win32.System.SystemServices.PCWSTR, uint, win32.UI.WindowsAndMessaging.LPARAM)"/>
        internal static unsafe bool EnumTimeFormatsEx(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpTimeFmtEnumProcEx, string lpLocaleName, uint dwFlags, win32.UI.WindowsAndMessaging.LPARAM lParam)
        {
            fixed (char *lpLocaleNameLocal = lpLocaleName)
            {
                bool __result = Kernel32.EnumTimeFormatsEx(lpTimeFmtEnumProcEx, lpLocaleNameLocal, dwFlags, lParam);
                return __result;
            }
        }

        /// <summary>Enumerates the time formats that are available for a locale specified by name.Note  The application should call this function in preference to EnumTimeFormats if designed to run only on Windows Vista and later. Note  This function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.</summary>
        /// <param name = "lpTimeFmtEnumProcEx">Pointer to an application-defined callback function. For more information, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317833(v=vs.85)">EnumTimeFormatsProcEx</a>.</param>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumtimeformatsex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">The time format. Set to 0 to use the current user's long time format, or TIME_NOSECONDS (starting with Windows 7) to use the short time format.</param>
        /// <param name = "lParam">An application-provided parameter to be passed to the callback function. This is especially useful for multi-threaded applications.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumtimeformatsex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool EnumTimeFormatsEx(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpTimeFmtEnumProcEx, win32.System.SystemServices.PCWSTR lpLocaleName, uint dwFlags, win32.UI.WindowsAndMessaging.LPARAM lParam);
        /// <summary>Enumerates the locales that are either installed on or supported by an operating system.Note  The application should call this function in preference to EnumSystemLocales if designed to run only on Windows Vista and later.</summary>
        /// <param name = "lpLocaleEnumProcEx">Pointer to an application-defined callback function. The <b>EnumSystemLocalesEx</b> function enumerates locales by making repeated calls to this callback function. For more information, see <a href = "https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-locale_enumprocex">EnumLocalesProcEx</a>.</param>
        /// <param name = "dwFlags">
        /// <para>Flags identifying the locales to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-all">LOCALE_ALL</a>.</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemlocalesex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">An application-provided parameter to be passed to the callback function. This is especially useful for multi-threaded applications.</param>
        /// <param name = "lpReserved">Reserved; must be <b>NULL</b>.</param>
        /// <returns>
        /// <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemlocalesex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern unsafe bool EnumSystemLocalesEx(delegate *unmanaged[Stdcall]<win32.System.SystemServices.PWSTR, uint, win32.UI.WindowsAndMessaging.LPARAM, win32.System.SystemServices.BOOL>lpLocaleEnumProcEx, uint dwFlags, win32.UI.WindowsAndMessaging.LPARAM lParam, [Optional] void *lpReserved);
        /// <inheritdoc cref = "ResolveLocaleName(win32.System.SystemServices.PCWSTR, win32.System.SystemServices.PWSTR, int)"/>
        internal static unsafe int ResolveLocaleName(string lpNameToResolve, win32.System.SystemServices.PWSTR lpLocaleName, int cchLocaleName)
        {
            fixed (char *lpNameToResolveLocal = lpNameToResolve)
            {
                int __result = Kernel32.ResolveLocaleName(lpNameToResolveLocal, lpLocaleName, cchLocaleName);
                return __result;
            }
        }

        /// <summary>Finds a possible locale name match for the supplied name.</summary>
        /// <param name = "lpNameToResolve">Pointer to a name to resolve, for example, "en-XA" for English (Private Use).</param>
        /// <param name = "lpLocaleName">
        /// <para>Pointer to a buffer in which this function retrieves the locale name that is the match for the input name. For example, the match for the name "en-XA" is "en-US" for English (United States).</para>
        /// <para><div class = "alert"><b>Note</b>  If the function fails, the state of the output buffer is not guaranteed to be accurate. In this case, the application should check the return value and error status set by the function to determine the correct course of action.</div> <div> </div></para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-resolvelocalename#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "cchLocaleName">Size, in characters, of the buffer indicated by <i>lpLocaleName</i>. The maximum possible length of a locale name, including a terminating null character, is the value of <a href = "https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply in this parameter.</param>
        /// <returns>
        /// <para>Returns the size of the buffer containing the locale name, including the terminating null character, if successful.</para>
        /// <para>The function returns 0 if it does not succeed. To get extended error information, the application can call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes: </para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-resolvelocalename">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        internal static extern int ResolveLocaleName(win32.System.SystemServices.PCWSTR lpNameToResolve, win32.System.SystemServices.PWSTR lpLocaleName, int cchLocaleName);
    }
}