// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable CS1591, CS1573, CS0465, CS0649, CS8019, CS1570, CS1584, CS1658
namespace Windows.Win32
{
    using global::System;
    using global::System.Diagnostics;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;
    using win32 = global::Windows.Win32;

    namespace System.OleAutomation
    {
        [Guid("00020400-0000-0000-C000-000000000046")]
        internal unsafe struct IDispatch
        {
            /// <inheritdoc cref = "QueryInterface(global::System.Guid*, void **)"/>
            internal unsafe win32.System.Com.HRESULT QueryInterface(in global::System.Guid riid, out void *ppvObject)
            {
                fixed (void **ppvObjectLocal = &ppvObject)
                {
                    fixed (global::System.Guid*riidLocal = &riid)
                    {
                        win32.System.Com.HRESULT __result = this.QueryInterface(riidLocal, ppvObjectLocal);
                        return __result;
                    }
                }
            }

            internal unsafe win32.System.Com.HRESULT QueryInterface(global::System.Guid*riid, void **ppvObject)
            {
                fixed (IDispatch*pThis = &this)
                    return lpVtbl->QueryInterface_1(pThis, riid, ppvObject);
            }

            internal uint AddRef()
            {
                fixed (IDispatch*pThis = &this)
                    return lpVtbl->AddRef_2(pThis);
            }

            internal uint Release()
            {
                fixed (IDispatch*pThis = &this)
                    return lpVtbl->Release_3(pThis);
            }

            /// <inheritdoc cref = "GetTypeInfoCount(uint *)"/>
            internal unsafe win32.System.Com.HRESULT GetTypeInfoCount(out uint pctinfo)
            {
                fixed (uint *pctinfoLocal = &pctinfo)
                {
                    win32.System.Com.HRESULT __result = this.GetTypeInfoCount(pctinfoLocal);
                    return __result;
                }
            }

            /// <summary>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</summary>
            /// <param name = "pctinfo">The number of type information interfaces provided by the object. If the object provides type information, this number is 1; otherwise the number is 0.</param>
            /// <returns>
            /// <para>This method can return one of these values.</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// </returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//oaidl/nf-oaidl-idispatch-gettypeinfocount">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe win32.System.Com.HRESULT GetTypeInfoCount(uint *pctinfo)
            {
                fixed (IDispatch*pThis = &this)
                    return lpVtbl->GetTypeInfoCount_4(pThis, pctinfo);
            }

            /// <summary>Retrieves the type information for an object, which can then be used to get the type information for an interface.</summary>
            /// <param name = "iTInfo">The type information to return. Pass 0 to retrieve type information for the <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch</a> implementation.</param>
            /// <param name = "lcid">The locale identifier for the type information. An object may be able to return different type information for different languages. This is important for classes that support localized member names. For classes that do not support localized member names, this parameter can be ignored.</param>
            /// <param name = "ppTInfo">The requested type information object.</param>
            /// <returns>
            /// <para>This method can return one of these values.</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// </returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//oaidl/nf-oaidl-idispatch-gettypeinfo">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe win32.System.Com.HRESULT GetTypeInfo(uint iTInfo, uint lcid, win32.System.OleAutomation.ITypeInfo**ppTInfo)
            {
                fixed (IDispatch*pThis = &this)
                    return lpVtbl->GetTypeInfo_5(pThis, iTInfo, lcid, ppTInfo);
            }

            /// <inheritdoc cref = "GetIDsOfNames(global::System.Guid*, win32.System.SystemServices.PWSTR*, uint, uint, int *)"/>
            internal unsafe win32.System.Com.HRESULT GetIDsOfNames(in global::System.Guid riid, Span<win32.System.SystemServices.PWSTR> rgszNames, uint lcid, Span<int> rgDispId)
            {
                fixed (int *rgDispIdLocal = rgDispId)
                {
                    fixed (win32.System.SystemServices.PWSTR*rgszNamesLocal = rgszNames)
                    {
                        fixed (global::System.Guid*riidLocal = &riid)
                        {
                            if (rgszNames.Length != rgDispId.Length)
                                throw new ArgumentException();
                            win32.System.Com.HRESULT __result = this.GetIDsOfNames(riidLocal, rgszNamesLocal, (uint)rgDispId.Length, lcid, rgDispIdLocal);
                            return __result;
                        }
                    }
                }
            }

            /// <summary>Maps a single member and an optional set of argument names to a corresponding set of integer DISPIDs, which can be used on subsequent calls to Invoke.</summary>
            /// <param name = "riid">Reserved for future use. Must be IID_NULL.</param>
            /// <param name = "rgszNames">The array of names to be mapped.</param>
            /// <param name = "cNames">The count of the names to be mapped.</param>
            /// <param name = "lcid">The locale context in which to interpret the names.</param>
            /// <param name = "rgDispId">Caller-allocated array, each element of which contains an identifier (ID) corresponding to one of the names passed in the rgszNames array. The first element represents the member name. The subsequent elements represent each of the member's parameters.</param>
            /// <returns>
            /// <para>This method can return one of these values.</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// </returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//oaidl/nf-oaidl-idispatch-getidsofnames">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe win32.System.Com.HRESULT GetIDsOfNames(global::System.Guid*riid, win32.System.SystemServices.PWSTR*rgszNames, uint cNames, uint lcid, int *rgDispId)
            {
                fixed (IDispatch*pThis = &this)
                    return lpVtbl->GetIDsOfNames_6(pThis, riid, rgszNames, cNames, lcid, rgDispId);
            }

            /// <inheritdoc cref = "Invoke(int, global::System.Guid*, uint, ushort, win32.System.OleAutomation.DISPPARAMS*, win32.System.OleAutomation.VARIANT*, win32.System.OleAutomation.EXCEPINFO*, uint *)"/>
            internal unsafe win32.System.Com.HRESULT Invoke(int dispIdMember, in global::System.Guid riid, uint lcid, ushort wFlags, in win32.System.OleAutomation.DISPPARAMS pDispParams, win32.System.OleAutomation.VARIANT*pVarResult, win32.System.OleAutomation.EXCEPINFO*pExcepInfo, uint *puArgErr)
            {
                fixed (win32.System.OleAutomation.DISPPARAMS*pDispParamsLocal = &pDispParams)
                {
                    fixed (global::System.Guid*riidLocal = &riid)
                    {
                        win32.System.Com.HRESULT __result = this.Invoke(dispIdMember, riidLocal, lcid, wFlags, pDispParamsLocal, pVarResult, pExcepInfo, puArgErr);
                        return __result;
                    }
                }
            }

            /// <summary>Provides access to properties and methods exposed by an object.</summary>
            /// <param name = "dispIdMember">Identifies the member. Use <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-getidsofnames">GetIDsOfNames</a> or the object's documentation to obtain the dispatch identifier.</param>
            /// <param name = "riid">Reserved for future use. Must be IID_NULL.</param>
            /// <param name = "lcid">
            /// <para>The locale context in which to interpret arguments. The <i>lcid</i> is used by the <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-getidsofnames">GetIDsOfNames</a> function, and is also passed to <b>Invoke</b> to allow the object to interpret its arguments specific to a locale.</para>
            /// <para>Applications that do not support multiple national languages can ignore this parameter. For more information, refer to <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/automat/supporting-multiple-national-languages">Supporting Multiple National Languages</a> and <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/automat/exposing-activex-objects">Exposing ActiveX Objects</a>.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//oaidl/nf-oaidl-idispatch-invoke#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "wFlags">
            /// <para>Flags describing the context of the <b>Invoke</b> call.</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//oaidl/nf-oaidl-idispatch-invoke#parameters">Read more on docs.microsoft.com</see>.</para>
            /// </param>
            /// <param name = "pDispParams">Pointer to a DISPPARAMS structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</param>
            /// <param name = "pVarResult">Pointer to the location where the result is to be stored, or NULL if the caller expects no result. This argument is ignored if DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF is specified.</param>
            /// <param name = "pExcepInfo">Pointer to a structure that contains exception information. This structure should be filled in if DISP_E_EXCEPTION is returned. Can be NULL.</param>
            /// <param name = "puArgErr">The index within rgvarg of the first argument that has an error. Arguments are stored in pDispParams-&gt;rgvarg in reverse order, so the first argument is the one with the highest index in the array. This parameter is returned only when the resulting return value is DISP_E_TYPEMISMATCH or DISP_E_PARAMNOTFOUND. This argument can be set to null. For details, see <a href = "https://docs.microsoft.com/previous-versions/windows/desktop/automat/returning-errors">Returning Errors</a>.</param>
            /// <returns>
            /// <para>This method can return one of these values.</para>
            /// <para></para>
            /// <para>This doc was truncated.</para>
            /// </returns>
            /// <remarks>
            /// <para><see href = "https://docs.microsoft.com/windows/win32/api//oaidl/nf-oaidl-idispatch-invoke">Learn more about this API from docs.microsoft.com</see>.</para>
            /// </remarks>
            internal unsafe win32.System.Com.HRESULT Invoke(int dispIdMember, global::System.Guid*riid, uint lcid, ushort wFlags, win32.System.OleAutomation.DISPPARAMS*pDispParams, [Optional] win32.System.OleAutomation.VARIANT*pVarResult, [Optional] win32.System.OleAutomation.EXCEPINFO*pExcepInfo, [Optional] uint *puArgErr)
            {
                fixed (IDispatch*pThis = &this)
                    return lpVtbl->Invoke_7(pThis, dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
            }

            private struct Vtbl
            {
                internal delegate *unmanaged[Stdcall]<IDispatch*, global::System.Guid*, void **, win32.System.Com.HRESULT>QueryInterface_1;
                internal delegate *unmanaged[Stdcall]<IDispatch*, uint>AddRef_2;
                internal delegate *unmanaged[Stdcall]<IDispatch*, uint>Release_3;
                internal delegate *unmanaged[Stdcall]<IDispatch*, uint *, win32.System.Com.HRESULT>GetTypeInfoCount_4;
                internal delegate *unmanaged[Stdcall]<IDispatch*, uint, uint, win32.System.OleAutomation.ITypeInfo**, win32.System.Com.HRESULT>GetTypeInfo_5;
                internal delegate *unmanaged[Stdcall]<IDispatch*, global::System.Guid*, win32.System.SystemServices.PWSTR*, uint, uint, int *, win32.System.Com.HRESULT>GetIDsOfNames_6;
                internal delegate *unmanaged[Stdcall]<IDispatch*, int, global::System.Guid*, uint, ushort, win32.System.OleAutomation.DISPPARAMS*, win32.System.OleAutomation.VARIANT*, win32.System.OleAutomation.EXCEPINFO*, uint *, win32.System.Com.HRESULT>Invoke_7;
            }

            private Vtbl*lpVtbl;
        }
    }
}